<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/linux性能优化实战/05.网络性能篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a aria-current="page" class="active" href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a aria-current="page" class="active" href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/linux性能优化实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/linux性能优化实战/01.开篇词/01"><span>开篇词 | 别再让Linux性能问题成为你的绊脚石</span></a></li><li><a href="/blog-base/linux性能优化实战/01.开篇词/02"><span>01 | 如何学习Linux性能优化？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇">02.CPU性能篇</a><ul><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/01"><span>02 | 基础篇：到底应该怎么理解“平均负载”？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/02"><span>03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/03"><span>04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/04"><span>05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/05"><span>06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/06"><span>07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/07"><span>08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/08"><span>09 | 基础篇：怎么理解Linux软中断？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/09"><span>10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/10"><span>11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/11"><span>12 | 套路篇：CPU 性能优化的几个思路</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/12"><span>13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/02.cpu性能篇/13"><span>14 | 答疑（二）：如何用perf工具分析Java程序？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇">03.内存性能篇</a><ul><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/01"><span>15 | 基础篇：Linux内存是怎么工作的？</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/02"><span>16 | 基础篇：怎么理解内存中的Buffer和Cache？</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/03"><span>17 | 案例篇：如何利用系统缓存优化程序的运行效率？</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/04"><span>18 | 案例篇：内存泄漏了，我该如何定位和处理？</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/05"><span>19 | 案例篇：为什么系统的Swap变高了（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/06"><span>20 | 案例篇：为什么系统的Swap变高了？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/07"><span>21 | 套路篇：如何“快准狠”找到系统内存的问题？</span></a></li><li><a href="/blog-base/linux性能优化实战/03.内存性能篇/08"><span>22 | 答疑（三）：文件系统与磁盘的区别是什么？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇">04.IO性能篇</a><ul><li><a href="/blog-base/linux性能优化实战/04.io性能篇/01"><span>23 | 基础篇：Linux 文件系统是怎么工作的？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/02"><span>24 | 基础篇：Linux 磁盘I/O是怎么工作的（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/03"><span>25 | 基础篇：Linux 磁盘I/O是怎么工作的（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/04"><span>26 | 案例篇：如何找出狂打日志的“内鬼”？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/05"><span>27 | 案例篇：为什么我的磁盘I/O延迟很高？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/06"><span>28 | 案例篇：一个SQL查询要15秒，这是怎么回事？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/07"><span>29 | 案例篇：Redis响应严重延迟，如何解决？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/08"><span>30 | 套路篇：如何迅速分析出系统I/O的瓶颈在哪里？</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/09"><span>31 | 套路篇：磁盘 I/O 性能优化的几个思路</span></a></li><li><a href="/blog-base/linux性能优化实战/04.io性能篇/10"><span>32 | 答疑（四）：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/linux性能优化实战/05.网络性能篇">05.网络性能篇</a><ul><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/01"><span>33 | 关于 Linux 网络，你必须知道这些（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/02"><span>34 | 关于 Linux 网络，你必须知道这些（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/03"><span>35 | 基础篇：C10K 和 C1000K 回顾</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/04"><span>36 | 套路篇：怎么评估系统的网络性能？</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/05"><span>37 | 案例篇：DNS 解析时快时慢，我该怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/06"><span>38 | 案例篇：怎么使用 tcpdump 和 Wireshark 分析网络流量？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/linux性能优化实战/05.网络性能篇/07"><span>39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/08"><span>40 | 案例篇：网络请求延迟变大了，我该怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/09"><span>41 | 案例篇：如何优化 NAT 性能？（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/10"><span>42 | 案例篇：如何优化 NAT 性能？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/11"><span>43 | 套路篇：网络性能优化的几个思路（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/12"><span>44 | 套路篇：网络性能优化的几个思路（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/05.网络性能篇/13"><span>45 | 答疑（五）：网络收发过程中，缓冲区位置在哪里？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇">06.综合实战篇</a><ul><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/01"><span>46 | 案例篇：为什么应用容器化后，启动慢了很多？</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/02"><span>47 | 案例篇：服务器总是时不时丢包，我该怎么办？（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/03"><span>48 | 案例篇：服务器总是时不时丢包，我该怎么办？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/04"><span>49 | 案例篇：内核线程 CPU 利用率太高，我该怎么办？</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/05"><span>50 | 案例篇：动态追踪怎么用？（上）</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/06"><span>51 | 案例篇：动态追踪怎么用？（下）</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/07"><span>52 | 案例篇：服务吞吐量下降很厉害，怎么分析？</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/08"><span>53 | 套路篇：系统监控的综合思路</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/09"><span>54 | 套路篇：应用监控的一般思路</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/10"><span>55 | 套路篇：分析性能问题的一般步骤</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/11"><span>56 | 套路篇：优化性能问题的一般方法</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/12"><span>57 | 套路篇：Linux 性能工具速查</span></a></li><li><a href="/blog-base/linux性能优化实战/06.综合实战篇/13"><span>58 | 答疑（六）：容器冷启动如何性能分析？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-base/linux性能优化实战/07.加餐篇/01"><span>加餐（一） | 书单推荐：性能优化和Linux 系统原理</span></a></li><li><a href="/blog-base/linux性能优化实战/07.加餐篇/02"><span>加餐（二） | 书单推荐：网络原理和 Linux 内核实现</span></a></li><li><a href="/blog-base/linux性能优化实战/07.加餐篇/03"><span>用户故事 | “半路出家 ”，也要顺利拿下性能优化！</span></a></li><li><a href="/blog-base/linux性能优化实战/07.加餐篇/04"><span>用户故事 | 运维和开发工程师们怎么说？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/08.结束语">08.结束语</a><ul><li><a href="/blog-base/linux性能优化实战/08.结束语/01"><span>结束语 | 愿你攻克性能难关</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/09.结课测试">09.结课测试</a><ul><li><a href="/blog-base/linux性能优化实战/09.结课测试/01"><span>结课测试｜这些Linux性能知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-base/linux性能优化实战/summary">linux性能优化实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="DDoS 简介" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#ddos-简介"><span>DDoS 简介</span></a></li><li title="案例准备" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#案例准备"><span>案例准备</span></a></li><li title="案例分析" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#案例分析"><span>案例分析</span></a></li><li title="DDoS到底该怎么防御" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#ddos到底该怎么防御"><span>DDoS到底该怎么防御</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#小结"><span>小结</span></a></li><li title="思考" data-depth="2"><a href="/blog-base/linux性能优化实战/05.网络性能篇/07#思考"><span>思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="39--案例篇怎么缓解-ddos-攻击带来的性能下降问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#39--案例篇怎么缓解-ddos-攻击带来的性能下降问题"><span class="icon icon-link"></span></a>39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？</h1><p>你好，我是倪朋飞。</p><p>上一节，我带你学习了tcpdump 和 Wireshark 的使用方法，并通过几个案例，带你用这两个工具实际分析了网络的收发过程。碰到网络性能问题，不要忘记可以用 tcpdump 和 Wireshark 这两个大杀器，抓取实际传输的网络包，排查潜在的性能问题。</p><p>今天，我们一起来看另外一个问题，怎么缓解 DDoS（Distributed Denial of Service）带来的性能下降问题。</p><h2 id="ddos-简介"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#ddos-简介"><span class="icon icon-link"></span></a>DDoS 简介</h2><p>DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常请求。</p><p>DDoS（Distributed Denial of Service） 则是在 DoS 的基础上，采用了分布式架构，利用多台主机同时攻击目标主机。这样，即使目标服务部署了网络防御设备，面对大量网络请求时，还是无力应对。</p><p>比如，目前已知的最大流量攻击，正是去年 Github 遭受的 <a target="_blank" rel="noopener noreferrer" href="https://githubengineering.com/ddos-incident-report/">DDoS 攻击<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其峰值流量已经达到了 1.35Tbps，PPS 更是超过了 1.2 亿（126.9 million）。</p><p>从攻击的原理上来看，DDoS 可以分为下面几种类型。</p><p>第一种，耗尽带宽。无论是服务器还是路由器、交换机等网络设备，带宽都有固定的上限。带宽耗尽后，就会发生网络拥堵，从而无法传输其他正常的网络报文。</p><p>第二种，耗尽操作系统的资源。网络服务的正常运行，都需要一定的系统资源，像是CPU、内存等物理资源，以及连接表等软件资源。一旦资源耗尽，系统就不能处理其他正常的网络连接。</p><p>第三种，消耗应用程序的运行资源。应用程序的运行，通常还需要跟其他的资源或系统交互。如果应用程序一直忙于处理无效请求，也会导致正常请求的处理变慢，甚至得不到响应。</p><p>比如，构造大量不同的域名来攻击 DNS 服务器，就会导致 DNS 服务器不停执行迭代查询，并更新缓存。这会极大地消耗 DNS 服务器的资源，使 DNS 的响应变慢。</p><p>无论是哪一种类型的 DDoS，危害都是巨大的。那么，如何可以发现系统遭受了 DDoS 攻击，又该如何应对这种攻击呢？接下来，我们就通过一个案例，一起来看看这些问题。</p><h2 id="案例准备"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#案例准备"><span class="icon icon-link"></span></a>案例准备</h2><p>下面的案例仍然基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境是这样的：</p><ul><li><p>机器配置：2 CPU，8GB 内存。</p></li><li><p>预先安装 docker、sar 、hping3、tcpdump、curl 等工具，比如 apt-get install docker.io hping3 tcpdump curl。</p></li></ul><p>这些工具你应该都比较熟悉了。其中，hping3 在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/72147">系统的软中断CPU使用率升高案例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中曾经介绍过，它可以构造 TCP/IP 协议数据包，对系统进行安全审计、防火墙测试、DoS 攻击测试等。</p><p>本次案例用到三台虚拟机，我画了一张图来表示它们之间的关系。</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05.%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%AF%87/resourceimaged612d64dd4603a4bd90d110f382d313d8c12.png" alt=""/></p><p>你可以看到，其中一台虚拟机运行 Nginx ，用来模拟待分析的 Web 服务器；而另外两台作为 Web 服务器的客户端，其中一台用作 DoS 攻击，而另一台则是正常的客户端。使用多台虚拟机的目的，自然还是为了相互隔离，避免“交叉感染”。</p><blockquote><p>由于案例只使用了一台机器作为攻击源，所以这里的攻击，实际上还是传统的 DoS ，而非 DDoS。</p></blockquote><p>接下来，我们打开三个终端，分别 SSH 登录到三台机器上（下面的步骤，都假设终端编号与图示VM 编号一致），并安装上面提到的这些工具。</p><p>同以前的案例一样，下面的所有命令，都默认以 root 用户运行。如果你是用普通用户身份登陆系统，请运行 sudo su root 命令切换到 root 用户。</p><p>接下来，我们就进入到案例操作环节。</p><h2 id="案例分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#案例分析"><span class="icon icon-link"></span></a>案例分析</h2><p>首先，在终端一中，执行下面的命令运行案例，也就是启动一个最基本的 Nginx 应用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 运行Nginx服务并对外开放80端口</span></div><div class="token-line"><span class="token plain">    # --network=host表示使用主机网络（这是为了方便后面排查问题）</span></div><div class="token-line"><span class="token plain">    $ docker run -itd --name=nginx --network=host nginx</span></div></pre></div><p>然后，在终端二和终端三中，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，那么运行 curl 命令后，你应该会看到下面这个输出界面：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -w表示只输出HTTP状态码及总时间，-o表示将响应重定向到/dev/null</span></div><div class="token-line"><span class="token plain">    $ curl -s -w &#x27;Http code: %{http_code}\nTotal time:%{time_total}s\n&#x27; -o /dev/null http://192.168.0.30/</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    Http code: 200</span></div><div class="token-line"><span class="token plain">    Total time:0.002s</span></div></pre></div><p>从这里可以看到，正常情况下，我们访问 Nginx 只需要 2ms（0.002s）。</p><p>接着，在终端二中，运行 hping3 命令，来模拟 DoS 攻击：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span></div><div class="token-line"><span class="token plain">    # -i u10表示每隔10微秒发送一个网络帧</span></div><div class="token-line"><span class="token plain">    $ hping3 -S -p 80 -i u10 192.168.0.30</span></div></pre></div><p>现在，再回到终端一，你就会发现，现在不管执行什么命令，都慢了很多。不过，在实践时要注意：</p><ul><li><p>如果你的现象不那么明显，那么请尝试把参数里面的 u10 调小（比如调成 u1），或者加上–flood选项；</p></li><li><p>如果你的终端一完全没有响应了，那么请适当调大 u10（比如调成 u30），否则后面就不能通过 SSH 操作 VM1。</p></li></ul><p>然后，到终端三中，执行下面的命令，模拟正常客户端的连接：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># --connect-timeout表示连接超时时间</span></div><div class="token-line"><span class="token plain">    $ curl -w &#x27;Http code: %{http_code}\nTotal time:%{time_total}s\n&#x27; -o /dev/null --connect-timeout 10 http://192.168.0.30</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    Http code: 000</span></div><div class="token-line"><span class="token plain">    Total time:10.001s</span></div><div class="token-line"><span class="token plain">    curl: (28) Connection timed out after 10000 milliseconds</span></div></pre></div><p>你可以发现，在终端三中，正常客户端的连接超时了，并没有收到 Nginx 服务的响应。</p><p>这是发生了什么问题呢？我们再回到终端一中，检查网络状况。你应该还记得我们多次用过的 sar，它既可以观察 PPS（每秒收发的报文数），还可以观察 BPS（每秒收发的字节数）。</p><p>我们可以回到终端一中，执行下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sar -n DEV 1</span></div><div class="token-line"><span class="token plain">    08:55:49        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span></div><div class="token-line"><span class="token plain">    08:55:50      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span></div><div class="token-line"><span class="token plain">    08:55:50         eth0  22274.00    629.00   1174.64     37.78      0.00      0.00      0.00      0.02</span></div><div class="token-line"><span class="token plain">    08:55:50           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span></div></pre></div><p>关于 sar 输出中的各列含义，我在前面的 Linux 网络基础中已经介绍过，你可以点击 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/81057">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 查看，或者执行 man sar 查询手册。</p><p>从这次 sar 的输出中，你可以看到，网络接收的 PPS 已经达到了 20000 多，但是 BPS 却只有 1174 kB，这样每个包的大小就只有 54B（1174*1024/22274=54）。</p><p>这明显就是个小包了，不过具体是个什么样的包呢？那我们就用 tcpdump 抓包看看吧。</p><p>在终端一中，执行下面的 tcpdump 命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></div><div class="token-line"><span class="token plain">    # tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></div><div class="token-line"><span class="token plain">    $ tcpdump -i eth0 -n tcp port 80</span></div><div class="token-line"><span class="token plain">    09:15:48.287047 IP 192.168.0.2.27095 &gt; 192.168.0.30: Flags [S], seq 1288268370, win 512, length 0</span></div><div class="token-line"><span class="token plain">    09:15:48.287050 IP 192.168.0.2.27131 &gt; 192.168.0.30: Flags [S], seq 2084255254, win 512, length 0</span></div><div class="token-line"><span class="token plain">    09:15:48.287052 IP 192.168.0.2.27116 &gt; 192.168.0.30: Flags [S], seq 677393791, win 512, length 0</span></div><div class="token-line"><span class="token plain">    09:15:48.287055 IP 192.168.0.2.27141 &gt; 192.168.0.30: Flags [S], seq 1276451587, win 512, length 0</span></div><div class="token-line"><span class="token plain">    09:15:48.287068 IP 192.168.0.2.27154 &gt; 192.168.0.30: Flags [S], seq 1851495339, win 512, length 0</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>这个输出中，Flags [S] 表示这是一个 SYN 包。大量的 SYN 包表明，这是一个 SYN Flood 攻击。如果你用上一节讲过的 Wireshark 来观察，则可以更直观地看到 SYN Flood 的过程：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05.%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%AF%87/resourceimagef313f397305c87be6ae43e065d3262ec9113.png" alt=""/></p><p>实际上，SYN Flood 正是互联网中最经典的 DDoS 攻击方式。从上面这个图，你也可以看到它的原理：</p><ul><li><p>即客户端构造大量的 SYN 包，请求建立 TCP 连接；</p></li><li><p>而服务器收到包后，会向源 IP 发送 SYN+ACK 报文，并等待三次握手的最后一次ACK报文，直到超时。</p></li></ul><p>这种等待状态的 TCP 连接，通常也称为半开连接。由于连接表的大小有限，大量的半开连接就会导致连接表迅速占满，从而无法建立新的 TCP 连接。</p><p>参考下面这张 TCP 状态图，你能看到，此时，服务器端的 TCP 连接，会处于 SYN_RECEIVED 状态：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/05.%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E7%AF%87/resourceimage86a286dabf9cc66b29133fa6a239cfee38a2.png" alt=""/></p><p>（图片来自 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/File:Tcp_state_diagram.png">Wikipedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><p>这其实提示了我们，查看 TCP 半开连接的方法，关键在于 SYN_RECEIVED 状态的连接。我们可以使用 netstat ，来查看所有连接的状态，不过要注意，SYN_REVEIVED 的状态，通常被缩写为 SYN_RECV。</p><p>我们继续在终端一中，执行下面的 netstat 命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -n表示不解析名字，-p表示显示连接所属进程</span></div><div class="token-line"><span class="token plain">    $ netstat -n -p | grep SYN_REC</span></div><div class="token-line"><span class="token plain">    tcp        0      0 192.168.0.30:80          192.168.0.2:12503      SYN_RECV    -</span></div><div class="token-line"><span class="token plain">    tcp        0      0 192.168.0.30:80          192.168.0.2:13502      SYN_RECV    -</span></div><div class="token-line"><span class="token plain">    tcp        0      0 192.168.0.30:80          192.168.0.2:15256      SYN_RECV    -</span></div><div class="token-line"><span class="token plain">    tcp        0      0 192.168.0.30:80          192.168.0.2:18117      SYN_RECV    -</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>从结果中，你可以发现大量 SYN_RECV 状态的连接，并且源IP地址为 192.168.0.2。</p><p>进一步，我们还可以通过 wc 工具，来统计所有 SYN_RECV 状态的连接数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ netstat -n -p | grep SYN_REC | wc -l</span></div><div class="token-line"><span class="token plain">    193</span></div></pre></div><p>找出源 IP 后，要解决 SYN 攻击的问题，只要丢掉相关的包就可以。这时，iptables 可以帮你完成这个任务。你可以在终端一中，执行下面的 iptables 命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ iptables -I INPUT -s 192.168.0.2 -p tcp -j REJECT</span></div></pre></div><p>然后回到终端三中，再次执行 curl 命令，查看正常用户访问 Nginx 的情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ curl -w &#x27;Http code: %{http_code}\nTotal time:%{time_total}s\n&#x27; -o /dev/null --connect-timeout 10 http://192.168.0.30</span></div><div class="token-line"><span class="token plain">    Http code: 200</span></div><div class="token-line"><span class="token plain">    Total time:1.572171s</span></div></pre></div><p>现在，你可以发现，正常用户也可以访问 Nginx 了，只是响应比较慢，从原来的 2ms 变成了现在的 1.5s。</p><p>不过，一般来说，SYN Flood 攻击中的源 IP 并不是固定的。比如，你可以在 hping3 命令中，加入 --rand-source 选项，来随机化源 IP。不过，这时，刚才的方法就不适用了。</p><p>幸好，我们还有很多其他方法，实现类似的目标。比如，你可以用以下两种方法，来限制 syn 包的速率：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 限制syn并发数为每秒1次</span></div><div class="token-line"><span class="token plain">    $ iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 限制单个IP在60秒新建立的连接数为10</span></div><div class="token-line"><span class="token plain">    $ iptables -I INPUT -p tcp --dport 80 --syn -m recent --name SYN_FLOOD --update --seconds 60 --hitcount 10 -j REJECT</span></div></pre></div><p>到这里，我们已经初步限制了 SYN Flood 攻击。不过这还不够，因为我们的案例还只是单个的攻击源。</p><p>如果是多台机器同时发送 SYN Flood，这种方法可能就直接无效了。因为你很可能无法 SSH 登录（SSH 也是基于 TCP 的）到机器上去，更别提执行上述所有的排查命令。</p><p>所以，这还需要你事先对系统做一些 TCP 优化。</p><p>比如，SYN Flood 会导致 SYN_RECV 状态的连接急剧增大。在上面的 netstat 命令中，你也可以看到 190 多个处于半开状态的连接。</p><p>不过，半开状态的连接数是有限制的，执行下面的命令，你就可以看到，默认的半连接容量只有 256：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sysctl net.ipv4.tcp_max_syn_backlog</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_max_syn_backlog = 256</span></div></pre></div><p>换句话说， SYN 包数再稍微增大一些，就不能 SSH 登录机器了。 所以，你还应该增大半连接的容量，比如，你可以用下面的命令，将其增大为 1024：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sysctl -w net.ipv4.tcp_max_syn_backlog=1024</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_max_syn_backlog = 1024</span></div></pre></div><p>另外，连接每个 SYN_RECV 时，如果失败的话，内核还会自动重试，并且默认的重试次数是5次。你可以执行下面的命令，将其减小为 1 次：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sysctl -w net.ipv4.tcp_synack_retries=1</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_synack_retries = 1</span></div></pre></div><p>除此之外，TCP SYN Cookies 也是一种专门防御 SYN Flood 攻击的方法。SYN Cookies 基于连接信息（包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。</p><p>然后，这个 cookie 就被用作序列号，来应答 SYN+ACK 包，并释放连接状态。当客户端发送完三次握手的最后一次 ACK 后，服务器就会再次计算这个哈希值，确认是上次返回的 SYN+ACK 的返回包，才会进入 TCP 的连接状态。</p><p>因而，开启 SYN Cookies 后，就不需要维护半开连接状态了，进而也就没有了半连接数的限制。</p><blockquote><p>注意，开启 TCP syncookies 后，内核选项 net.ipv4.tcp_max_syn_backlog 也就无效了。</p></blockquote><p>你可以通过下面的命令，开启 TCP SYN Cookies：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sysctl -w net.ipv4.tcp_syncookies=1</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_syncookies = 1</span></div></pre></div><p>注意，上述 sysctl 命令修改的配置都是临时的，重启后这些配置就会丢失。所以，为了保证配置持久化，你还应该把这些配置，写入 /etc/sysctl.conf 文件中。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ cat /etc/sysctl.conf</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_syncookies = 1</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_synack_retries = 1</span></div><div class="token-line"><span class="token plain">    net.ipv4.tcp_max_syn_backlog = 1024</span></div></pre></div><p>不过要记得，写入 /etc/sysctl.conf 的配置，需要执行 sysctl -p 命令后，才会动态生效。</p><p>当然案例结束后，别忘了执行 docker rm -f nginx 命令，清理案例开始时启动的 Nginx 应用。</p><h2 id="ddos到底该怎么防御"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#ddos到底该怎么防御"><span class="icon icon-link"></span></a>DDoS到底该怎么防御</h2><p>到这里，今天的案例就结束了。不过，你肯定还有疑问。你应该注意到了，今天的主题是“缓解”，而不是“解决” DDoS 问题。</p><p>为什么不是解决 DDoS ，而只是缓解呢？而且今天案例中的方法，也只是让 Nginx 服务访问不再超时，但访问延迟还是比一开始时的 2ms 大得多。</p><p>实际上，当 DDoS 报文到达服务器后，Linux 提供的机制只能缓解，而无法彻底解决。即使像是 SYN Flood 这样的小包攻击，其巨大的 PPS ，也会导致 Linux 内核消耗大量资源，进而导致其他网络报文的处理缓慢。</p><p>虽然你可以调整内核参数，缓解 DDoS 带来的性能问题，却也会像案例这样，无法彻底解决它。</p><p>在之前的 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/81268">C10K、C100K<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/81268">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中，我也提到过，Linux 内核中冗长的协议栈，在 PPS 很大时，就是一个巨大的负担。对 DDoS 攻击来说，也是一样的道理。</p><p>所以，当时提到的 C10M 的方法，用到这里同样适合。比如，你可以基于 XDP 或者 DPDK，构建 DDoS 方案，在内核网络协议栈前，或者跳过内核协议栈，来识别并丢弃 DDoS 报文，避免DDoS 对系统其他资源的消耗。</p><p>不过，对于流量型的 DDoS 来说，当服务器的带宽被耗尽后，在服务器内部处理就无能为力了。这时，只能在服务器外部的网络设备中，设法识别并阻断流量（当然前提是网络设备要能扛住流量攻击）。比如，购置专业的入侵检测和防御设备，配置流量清洗设备阻断恶意流量等。</p><p>既然 DDoS 这么难防御，这是不是说明， Linux 服务器内部压根儿就不关注这一点，而是全部交给专业的网络设备来处理呢？</p><p>当然不是，因为 DDoS 并不一定是因为大流量或者大 PPS，有时候，慢速的请求也会带来巨大的性能下降（这种情况称为慢速 DDoS）。</p><p>比如，很多针对应用程序的攻击，都会伪装成正常用户来请求资源。这种情况下，请求流量可能本身并不大，但响应流量却可能很大，并且应用程序内部也很可能要耗费大量资源处理。</p><p>这时，就需要应用程序考虑识别，并尽早拒绝掉这些恶意流量，比如合理利用缓存、增加 WAF（Web Application Firewall）、使用 CDN 等等。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天，我们学习了分布式拒绝服务（DDoS）时的缓解方法。DDoS 利用大量的伪造请求，使目标服务耗费大量资源，来处理这些无效请求，进而无法正常响应正常的用户请求。</p><p>由于 DDoS 的分布式、大流量、难追踪等特点，目前还没有方法可以完全防御 DDoS 带来的问题，只能设法缓解这个影响。</p><p>比如，你可以购买专业的流量清洗设备和网络防火墙，在网络入口处阻断恶意流量，只保留正常流量进入数据中心的服务器中。</p><p>在 Linux 服务器中，你可以通过内核调优、DPDK、XDP 等多种方法，来增大服务器的抗攻击能力，降低 DDoS 对正常服务的影响。而在应用程序中，你可以利用各级缓存、 WAF、CDN 等方式，缓解 DDoS 对应用程序的影响。</p><h2 id="思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux性能优化实战/05.网络性能篇/07#思考"><span class="icon icon-link"></span></a>思考</h2><p>最后给你留一个思考题。</p><p>看到今天的案例，你可能会觉得眼熟。实际上，它正是在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/72147">系统的软中断CPU使用率升高案例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 基础上扩展而来的。当时，我们是从软中断 CPU 使用率的角度来分析的，也就是说，DDoS 会导致软中断 CPU 使用率（softirq）升高。</p><p>回想一下当时的案例和分析思路，再结合今天的案例，你觉得还有没有更好的方法，来检测 DDoS 攻击呢？除了 tcpdump，还有哪些方法查找这些攻击的源地址？</p><p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/linux性能优化实战/05.网络性能篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:08:26</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
