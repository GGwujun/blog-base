<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>49 | 案例篇：内核线程 CPU 利用率太高，我该怎么办？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/linux性能优化实战/06.综合实战篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a aria-current="page" class="active" href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a aria-current="page" class="active" href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/linux性能优化实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog/linux性能优化实战/01.开篇词/01"><span>开篇词 | 别再让Linux性能问题成为你的绊脚石</span></a></li><li><a href="/blog/linux性能优化实战/01.开篇词/02"><span>01 | 如何学习Linux性能优化？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇">02.CPU性能篇</a><ul><li><a href="/blog/linux性能优化实战/02.cpu性能篇/01"><span>02 | 基础篇：到底应该怎么理解“平均负载”？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/02"><span>03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/03"><span>04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/04"><span>05 | 基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/05"><span>06 | 案例篇：系统的 CPU 使用率很高，但为啥却找不到高 CPU 的应用？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/06"><span>07 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/07"><span>08 | 案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/08"><span>09 | 基础篇：怎么理解Linux软中断？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/09"><span>10 | 案例篇：系统的软中断CPU使用率升高，我该怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/10"><span>11 | 套路篇：如何迅速分析出系统CPU的瓶颈在哪里？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/11"><span>12 | 套路篇：CPU 性能优化的几个思路</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/12"><span>13 | 答疑（一）：无法模拟出 RES 中断的问题，怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/02.cpu性能篇/13"><span>14 | 答疑（二）：如何用perf工具分析Java程序？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/03.内存性能篇">03.内存性能篇</a><ul><li><a href="/blog/linux性能优化实战/03.内存性能篇/01"><span>15 | 基础篇：Linux内存是怎么工作的？</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/02"><span>16 | 基础篇：怎么理解内存中的Buffer和Cache？</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/03"><span>17 | 案例篇：如何利用系统缓存优化程序的运行效率？</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/04"><span>18 | 案例篇：内存泄漏了，我该如何定位和处理？</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/05"><span>19 | 案例篇：为什么系统的Swap变高了（上）</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/06"><span>20 | 案例篇：为什么系统的Swap变高了？（下）</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/07"><span>21 | 套路篇：如何“快准狠”找到系统内存的问题？</span></a></li><li><a href="/blog/linux性能优化实战/03.内存性能篇/08"><span>22 | 答疑（三）：文件系统与磁盘的区别是什么？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/04.io性能篇">04.IO性能篇</a><ul><li><a href="/blog/linux性能优化实战/04.io性能篇/01"><span>23 | 基础篇：Linux 文件系统是怎么工作的？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/02"><span>24 | 基础篇：Linux 磁盘I/O是怎么工作的（上）</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/03"><span>25 | 基础篇：Linux 磁盘I/O是怎么工作的（下）</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/04"><span>26 | 案例篇：如何找出狂打日志的“内鬼”？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/05"><span>27 | 案例篇：为什么我的磁盘I/O延迟很高？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/06"><span>28 | 案例篇：一个SQL查询要15秒，这是怎么回事？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/07"><span>29 | 案例篇：Redis响应严重延迟，如何解决？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/08"><span>30 | 套路篇：如何迅速分析出系统I/O的瓶颈在哪里？</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/09"><span>31 | 套路篇：磁盘 I/O 性能优化的几个思路</span></a></li><li><a href="/blog/linux性能优化实战/04.io性能篇/10"><span>32 | 答疑（四）：阻塞、非阻塞 I/O 与同步、异步 I/O 的区别和联系</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/05.网络性能篇">05.网络性能篇</a><ul><li><a href="/blog/linux性能优化实战/05.网络性能篇/01"><span>33 | 关于 Linux 网络，你必须知道这些（上）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/02"><span>34 | 关于 Linux 网络，你必须知道这些（下）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/03"><span>35 | 基础篇：C10K 和 C1000K 回顾</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/04"><span>36 | 套路篇：怎么评估系统的网络性能？</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/05"><span>37 | 案例篇：DNS 解析时快时慢，我该怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/06"><span>38 | 案例篇：怎么使用 tcpdump 和 Wireshark 分析网络流量？</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/07"><span>39 | 案例篇：怎么缓解 DDoS 攻击带来的性能下降问题？</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/08"><span>40 | 案例篇：网络请求延迟变大了，我该怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/09"><span>41 | 案例篇：如何优化 NAT 性能？（上）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/10"><span>42 | 案例篇：如何优化 NAT 性能？（下）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/11"><span>43 | 套路篇：网络性能优化的几个思路（上）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/12"><span>44 | 套路篇：网络性能优化的几个思路（下）</span></a></li><li><a href="/blog/linux性能优化实战/05.网络性能篇/13"><span>45 | 答疑（五）：网络收发过程中，缓冲区位置在哪里？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/linux性能优化实战/06.综合实战篇">06.综合实战篇</a><ul><li><a href="/blog/linux性能优化实战/06.综合实战篇/01"><span>46 | 案例篇：为什么应用容器化后，启动慢了很多？</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/02"><span>47 | 案例篇：服务器总是时不时丢包，我该怎么办？（上）</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/03"><span>48 | 案例篇：服务器总是时不时丢包，我该怎么办？（下）</span></a></li><li><a aria-current="page" class="active" href="/blog/linux性能优化实战/06.综合实战篇/04"><span>49 | 案例篇：内核线程 CPU 利用率太高，我该怎么办？</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/05"><span>50 | 案例篇：动态追踪怎么用？（上）</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/06"><span>51 | 案例篇：动态追踪怎么用？（下）</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/07"><span>52 | 案例篇：服务吞吐量下降很厉害，怎么分析？</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/08"><span>53 | 套路篇：系统监控的综合思路</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/09"><span>54 | 套路篇：应用监控的一般思路</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/10"><span>55 | 套路篇：分析性能问题的一般步骤</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/11"><span>56 | 套路篇：优化性能问题的一般方法</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/12"><span>57 | 套路篇：Linux 性能工具速查</span></a></li><li><a href="/blog/linux性能优化实战/06.综合实战篇/13"><span>58 | 答疑（六）：容器冷启动如何性能分析？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog/linux性能优化实战/07.加餐篇/01"><span>加餐（一） | 书单推荐：性能优化和Linux 系统原理</span></a></li><li><a href="/blog/linux性能优化实战/07.加餐篇/02"><span>加餐（二） | 书单推荐：网络原理和 Linux 内核实现</span></a></li><li><a href="/blog/linux性能优化实战/07.加餐篇/03"><span>用户故事 | “半路出家 ”，也要顺利拿下性能优化！</span></a></li><li><a href="/blog/linux性能优化实战/07.加餐篇/04"><span>用户故事 | 运维和开发工程师们怎么说？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/08.结束语">08.结束语</a><ul><li><a href="/blog/linux性能优化实战/08.结束语/01"><span>结束语 | 愿你攻克性能难关</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/09.结课测试">09.结课测试</a><ul><li><a href="/blog/linux性能优化实战/09.结课测试/01"><span>结课测试｜这些Linux性能知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/linux性能优化实战/summary">linux性能优化实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="内核线程" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#内核线程"><span>内核线程</span></a></li><li title="案例准备" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#案例准备"><span>案例准备</span></a></li><li title="案例分析" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#案例分析"><span>案例分析</span></a></li><li title="火焰图" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#火焰图"><span>火焰图</span></a></li><li title="火焰图分析" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#火焰图分析"><span>火焰图分析</span></a></li><li title="小结" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#小结"><span>小结</span></a></li><li title="思考" data-depth="2"><a href="/blog/linux性能优化实战/06.综合实战篇/04#思考"><span>思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="49--案例篇内核线程-cpu-利用率太高我该怎么办"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#49--案例篇内核线程-cpu-利用率太高我该怎么办"><span class="icon icon-link"></span></a>49 | 案例篇：内核线程 CPU 利用率太高，我该怎么办？</h1><p>你好，我是倪朋飞。</p><p>上一期，我们一起梳理了，网络时不时丢包的分析定位和优化方法。先简单回顾一下。</p><p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而会导致网络延迟增大以及吞吐量降低。</p><p>而分析丢包问题，还是用我们的老套路，从 Linux 网络收发的流程入手，结合 TCP/IP 协议栈的原理来逐层分析。</p><p>其实，在排查网络问题时，我们还经常碰到的一个问题，就是内核线程的 CPU 使用率很高。比如，在高并发的场景中，内核线程 ksoftirqd 的 CPU 使用率通常就会比较高。回顾一下前面学过的 CPU 和网络模块，你应该知道，这是网络收发的软中断导致的。</p><p>而要分析 ksoftirqd 这类 CPU 使用率比较高的内核线程，如果用我前面介绍过的那些分析方法，你一般需要借助于其他性能工具，进行辅助分析。</p><p>比如，还是以 ksoftirqd 为例，如果你怀疑是网络问题，就可以用 sar、tcpdump 等分析网络流量，进一步确认网络问题的根源。</p><p>不过，显然，这种方法在实际操作中需要步骤比较多，可能并不算快捷。你肯定也很想知道，有没有其他更简单的方法，可以直接观察内核线程的行为，更快定位瓶颈呢？</p><p>今天，我就继续以 ksoftirqd 为例，带你一起看看，如何分析内核线程的性能问题。</p><h2 id="内核线程"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#内核线程"><span class="icon icon-link"></span></a>内核线程</h2><p>既然要讲内核线程的性能问题，在案例开始之前，我们就先来看看，有哪些常见的内核线程。</p><p>我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 systemd 来进行管理。</p><p>稍微想一下 Linux 中的各种进程，除了用户态进程外，还有大量的内核态线程。按说内核态的线程，应该先于用户态进程启动，可是 systemd 只管理用户态进程。那么，内核态线程又是谁来管理的呢？</p><p>实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。</p><ul><li><p>0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。</p></li><li><p>1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。</p></li><li><p>2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。</p></li></ul><p>所以，要查找内核线程，我们只需要从 2 号进程开始，查找它的子孙进程即可。比如，你可以使用 ps 命令，来查找 kthreadd 的子进程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ ps -f --ppid 2 -p 2</span></div><div class="token-line"><span class="token plain">    UID         PID   PPID  C STIME TTY          TIME CMD</span></div><div class="token-line"><span class="token plain">    root          2      0  0 12:02 ?        00:00:01 [kthreadd]</span></div><div class="token-line"><span class="token plain">    root          9      2  0 12:02 ?        00:00:21 [ksoftirqd/0]</span></div><div class="token-line"><span class="token plain">    root         10      2  0 12:02 ?        00:11:47 [rcu_sched]</span></div><div class="token-line"><span class="token plain">    root         11      2  0 12:02 ?        00:00:18 [migration/0]</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    root      11094      2  0 14:20 ?        00:00:00 [kworker/1:0-eve]</span></div><div class="token-line"><span class="token plain">    root      11647      2  0 14:27 ?        00:00:00 [kworker/0:2-cgr]</span></div></pre></div><p>从上面的输出，你能够看到，内核线程的名称（CMD）都在中括号里（这一点，我们前面内容也有提到过）。所以，更简单的方法，就是直接查找名称包含中括号的进程。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ ps -ef | grep &quot;\[.*\]&quot;</span></div><div class="token-line"><span class="token plain">    root         2     0  0 08:14 ?        00:00:00 [kthreadd]</span></div><div class="token-line"><span class="token plain">    root         3     2  0 08:14 ?        00:00:00 [rcu_gp]</span></div><div class="token-line"><span class="token plain">    root         4     2  0 08:14 ?        00:00:00 [rcu_par_gp]</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>了解内核线程的基本功能，对我们排查问题有非常大的帮助。比如，我们曾经在软中断案例中提到过 ksoftirqd。它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。</p><p>如果你知道了这一点，那么，以后遇到 ksoftirqd 的 CPU 使用高的情况，就会首先怀疑是软中断的问题，然后从软中断的角度来进一步分析。</p><p>其实，除了刚才看到的 kthreadd 和 ksoftirqd 外，还有很多常见的内核线程，我们在性能分析中都经常会碰到，比如下面这几个内核线程。</p><ul><li><p><strong>kswapd0</strong>：用于内存回收。在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/75797">Swap变高<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 案例中，我曾介绍过它的工作原理。</p></li><li><p><strong>kworker</strong>：用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU86330）和未绑定 CPU（名称格式为 kworker/uPOOL86330）两类。</p></li><li><p><strong>migration</strong>：在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。</p></li><li><p><strong>jbd2</strong>/sda1-8：jbd 是 Journaling Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 jbd2 内核线程。</p></li><li><p><strong>pdflush</strong>：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在 3.10 中合并入了 kworker 中）。</p></li></ul><p>了解这几个容易发生性能问题的内核线程，有助于我们更快地定位性能瓶颈。接下来，我们来看今天的案例。</p><h2 id="案例准备"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#案例准备"><span class="icon icon-link"></span></a>案例准备</h2><p>今天的案例还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p><ul><li><p>机器配置：2 CPU，8GB 内存。</p></li><li><p>预先安装 docker、perf、hping3、curl 等工具，如 apt install docker.io linux-tools-common hping3。</p></li></ul><p>本次案例用到两台虚拟机，我画了一张图来表示它们的关系。</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage7d117dd0763a14713940e7c762a62387dd11.png" alt=""/></p><p>你需要打开两个终端，分别登录这两台虚拟机中，并安装上述工具。</p><p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令，切换到 root 用户。</p><blockquote><p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p></blockquote><p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p><h2 id="案例分析"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#案例分析"><span class="icon icon-link"></span></a>案例分析</h2><p>安装完成后，我们先在第一个终端，执行下面的命令运行案例，也就是一个最基本的 Nginx 应用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 运行Nginx服务并对外开放80端口</span></div><div class="token-line"><span class="token plain">    $ docker run -itd --name=nginx -p 80:80 nginx</span></div></pre></div><p>然后，在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，运行 curl 命令后，你应该会看到下面这个输出界面：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ curl http://192.168.0.30/</span></div><div class="token-line"><span class="token plain">    &lt;!DOCTYPE html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;html&gt;</span></div><div class="token-line"><span class="token plain">    &lt;head&gt;</span></div><div class="token-line"><span class="token plain">    &lt;title&gt;Welcome to nginx!&lt;/title&gt;</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>接着，还是在第二个终端中，运行 hping3 命令，模拟 Nginx 的客户端请求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80</span></div><div class="token-line"><span class="token plain">    # -i u10表示每隔10微秒发送一个网络帧</span></div><div class="token-line"><span class="token plain">    # 注：如果你在实践过程中现象不明显，可以尝试把10调小，比如调成5甚至1</span></div><div class="token-line"><span class="token plain">    $ hping3 -S -p 80 -i u10 192.168.0.30</span></div></pre></div><p>现在，我们再回到第一个终端，你应该就会发现异常——系统的响应明显变慢了。我们不妨执行 top，观察一下系统和进程的 CPU 使用情况：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ top</span></div><div class="token-line"><span class="token plain">    top - 08:31:43 up 17 min,  1 user,  load average: 0.00, 0.00, 0.02</span></div><div class="token-line"><span class="token plain">    Tasks: 128 total,   1 running,  69 sleeping,   0 stopped,   0 zombie</span></div><div class="token-line"><span class="token plain">    %Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 66.8 id,  0.3 wa,  0.0 hi, 32.4 si,  0.0 st</span></div><div class="token-line"><span class="token plain">    %Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 65.2 id,  0.0 wa,  0.0 hi, 34.5 si,  0.0 st</span></div><div class="token-line"><span class="token plain">    KiB Mem :  8167040 total,  7234236 free,   358976 used,   573828 buff/cache</span></div><div class="token-line"><span class="token plain">    KiB Swap:        0 total,        0 free,        0 used.  7560460 avail Mem</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span></div><div class="token-line"><span class="token plain">        9 root      20   0       0      0      0 S   7.0  0.0   0:00.48 ksoftirqd/0</span></div><div class="token-line"><span class="token plain">       18 root      20   0       0      0      0 S   6.9  0.0   0:00.56 ksoftirqd/1</span></div><div class="token-line"><span class="token plain">     2489 root      20   0  876896  38408  21520 S   0.3  0.5   0:01.50 docker-containe</span></div><div class="token-line"><span class="token plain">     3008 root      20   0   44536   3936   3304 R   0.3  0.0   0:00.09 top</span></div><div class="token-line"><span class="token plain">        1 root      20   0   78116   9000   6432 S   0.0  0.1   0:11.77 systemd</span></div><div class="token-line"><span class="token plain">     ...</span></div></pre></div><p>从 top 的输出中，你可以看到，两个 CPU 的软中断使用率都超过了 30%；而 CPU 使用率最高的进程，正好是软中断内核线程 ksoftirqd/0 和 ksoftirqd/1。</p><p>虽然，我们已经知道了 ksoftirqd 的基本功能，可以猜测是因为大量网络收发，引起了 CPU 使用率升高；但它到底在执行什么逻辑，我们却并不知道。</p><p>对于普通进程，我们要观察其行为有很多方法，比如 strace、pstack、lsof 等等。但这些工具并不适合内核线程，比如，如果你用 pstack ，或者通过 /proc/pid/stack 查看 ksoftirqd/0（进程号为 9）的调用栈时，分别可以得到以下输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ pstack 9</span></div><div class="token-line"><span class="token plain">    Could not attach to target 9: Operation not permitted.</span></div><div class="token-line"><span class="token plain">    detach: No such process</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ cat /proc/9/stack</span></div><div class="token-line"><span class="token plain">    [&lt;0&gt;] smpboot_thread_fn+0x166/0x170</span></div><div class="token-line"><span class="token plain">    [&lt;0&gt;] kthread+0x121/0x140</span></div><div class="token-line"><span class="token plain">    [&lt;0&gt;] ret_from_fork+0x35/0x40</span></div><div class="token-line"><span class="token plain">    [&lt;0&gt;] 0xffffffffffffffff</span></div></pre></div><p>显然，pstack 报出的是不允许挂载进程的错误；而 /proc/9/stack 方式虽然有输出，但输出中并没有详细的调用栈情况。</p><p>那还有没有其他方法，来观察内核线程 ksoftirqd 的行为呢？</p><p>既然是内核线程，自然应该用到内核中提供的机制。回顾一下我们之前用过的 CPU 性能工具，我想你肯定还记得 perf ，这个内核自带的性能剖析工具。</p><p>perf 可以对指定的进程或者事件进行采样，并且还可以用调用栈的形式，输出整个调用链上的汇总信息。 我们不妨就用 perf ，来试着分析一下进程号为 9 的 ksoftirqd。</p><p>继续在终端一中，执行下面的 perf record 命令；并指定进程号 9 ，以便记录 ksoftirqd 的行为:</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 采样30s后退出</span></div><div class="token-line"><span class="token plain">    $ perf record -a -g -p 9 -- sleep 30</span></div></pre></div><p>稍等一会儿，在上述命令结束后，继续执行 <code>perf report</code>命令，你就可以得到 perf 的汇总报告。按上下方向键以及回车键，展开比例最高的 ksoftirqd 后，你就可以得到下面这个调用关系链图：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage730173f5e9a9e510b9f3bf634c5e94e67801.png" alt=""/></p><p>从这个图中，你可以清楚看到 ksoftirqd 执行最多的调用过程。虽然你可能不太熟悉内核源码，但通过这些函数，我们可以大致看出它的调用栈过程。</p><ul><li><p>net_rx_action 和 netif_receive_skb，表明这是接收网络包（rx 表示 receive）。</p></li><li><p>br_handle_frame ，表明网络包经过了网桥（br 表示 bridge）。</p></li><li><p>br_nf_pre_routing ，表明在网桥上执行了 netfilter 的 PREROUTING（nf 表示 netfilter）。而我们已经知道 PREROUTING 主要用来执行 DNAT，所以可以猜测这里有 DNAT 发生。</p></li><li><p>br_pass_frame_up，表明网桥处理后，再交给桥接的其他桥接网卡进一步处理。比如，在新的网卡上接收网络包、执行 netfilter 过滤规则等等。</p></li></ul><p>我们的猜测对不对呢？实际上，我们案例最开始用 Docker 启动了容器，而 Docker 会自动为容器创建虚拟网卡、桥接到 docker0 网桥并配置 NAT 规则。这一过程，如下图所示：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage727072f2f1fa7a464e4465108d4eadcc1b70.png" alt=""/></p><p>当然了，前面 perf report 界面的调用链还可以继续展开。但很不幸，我的屏幕不够大，如果展开更多的层级，最后几个层级会超出屏幕范围。这样，即使我们能看到大部分的调用过程，却也不能说明后面层级就没问题。</p><p>那么，有没有更好的方法，来查看整个调用栈的信息呢？</p><h2 id="火焰图"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#火焰图"><span class="icon icon-link"></span></a>火焰图</h2><p>针对 perf 汇总数据的展示问题，Brendan Gragg 发明了<a target="_blank" rel="noopener noreferrer" href="http://www.brendangregg.com/flamegraphs.html">火焰图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，通过矢量图的形式，更直观展示汇总结果。下图就是一个针对 mysql 的火焰图示例。</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage686168b80d299b23b0cee518001f78960f61.png" alt=""/></p><p>（图片来自 Brendan Gregg <a target="_blank" rel="noopener noreferrer" href="http://www.brendangregg.com/flamegraphs.html">博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p><p>这张图看起来像是跳动的火焰，因此也就被称为火焰图。要理解火焰图，我们最重要的是区分清楚横轴和纵轴的含义。</p><ul><li><p><strong>横轴表示采样数和采样比例</strong>。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。</p></li><li><p><strong>纵轴表示调用栈</strong>，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。</p></li></ul><p>另外，要注意图中的颜色，并没有特殊含义，只是用来区分不同的函数。</p><p>火焰图是动态的矢量图格式，所以它还支持一些动态特性。比如，鼠标悬停到某个函数上时，就会自动显示这个函数的采样数和采样比例。而当你用鼠标点击函数时，火焰图就会把该层及其上的各层放大，方便你观察这些处于火焰图顶部的调用栈的细节。</p><p>上面 mysql 火焰图的示例，就表示了 CPU 的繁忙情况，这种火焰图也被称为 on-CPU 火焰图。如果我们根据性能分析的目标来划分，火焰图可以分为下面这几种。</p><ul><li><p><strong>on-CPU 火焰图</strong>：表示 CPU 的繁忙情况，用在 CPU 使用率比较高的场景中。</p></li><li><p><strong>off-CPU 火焰图</strong>：表示 CPU 等待 I/O、锁等各种资源的阻塞情况。</p></li><li><p><strong>内存火焰图</strong>：表示内存的分配和释放情况。</p></li><li><p><strong>热/冷火焰图</strong>：表示将 on-CPU 和 off-CPU 结合在一起综合展示。</p></li><li><p><strong>差分火焰图</strong>：表示两个火焰图的差分情况，红色表示增长，蓝色表示衰减。差分火焰图常用来比较不同场景和不同时期的火焰图，以便分析系统变化前后对性能的影响情况。</p></li></ul><p>了解了火焰图的含义和查看方法后，接下来，我们再回到案例，运用火焰图来观察刚才 perf record 得到的记录。</p><h2 id="火焰图分析"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#火焰图分析"><span class="icon icon-link"></span></a>火焰图分析</h2><p>首先，我们需要生成火焰图。我们先下载几个能从 perf record 记录生成火焰图的工具，这些工具都放在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 上面。你可以执行下面的命令来下载：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ git clone https://github.com/brendangregg/FlameGraph</span></div><div class="token-line"><span class="token plain">    $ cd FlameGraph</span></div></pre></div><p>安装好工具后，要生成火焰图，其实主要需要三个步骤：</p><ol><li><p>执行 perf script ，将 perf record 的记录转换成可读的采样记录；</p></li><li><p>执行 stackcollapse-perf.pl 脚本，合并调用栈信息；</p></li><li><p>执行 flamegraph.pl 脚本，生成火焰图。</p></li></ol><p>不过，在 Linux 中，我们可以使用管道，来简化这三个步骤的执行过程。假设刚才用 perf record 生成的文件路径为 /root/perf.data，执行下面的命令，你就可以直接生成火焰图：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ perf script -i /root/perf.data | ./stackcollapse-perf.pl --all |  ./flamegraph.pl &gt; ksoftirqd.svg</span></div></pre></div><p>执行成功后，使用浏览器打开 ksoftirqd.svg ，你就可以看到生成的火焰图了。如下图所示：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage6dcd6d4f1fece12407906aacedf5078e53cd.png" alt=""/></p><p>根据刚刚讲过的火焰图原理，这个图应该从下往上看，沿着调用栈中最宽的函数来分析执行次数最多的函数。这儿看到的结果，其实跟刚才的 perf report 类似，但直观了很多，中间这一团火，很明显就是最需要我们关注的地方。</p><p>我们顺着调用栈由下往上看（顺着图中蓝色箭头），就可以得到跟刚才 perf report 中一样的结果：</p><ul><li><p>最开始，还是 net_rx_action 到 netif_receive_skb 处理网络收包；</p></li><li><p>然后， br_handle_frame 到 br_nf_pre_routing ，在网桥中接收并执行 netfilter 钩子函数；</p></li><li><p>再向上， br_pass_frame_up 到 netif_receive_skb ，从网桥转到其他网络设备又一次接收。</p></li></ul><p>不过最后，到了 ip_forward 这里，已经看不清函数名称了。所以我们需要点击 ip_forward，展开最上面这一块调用栈：</p><p><img src="/images/linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/06.%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage41a3416291ba2f9c039a0507f913572a21a3.png" alt=""/></p><p>这样，就可以进一步看到 ip_forward 后的行为，也就是把网络包发送出去。根据这个调用过程，再结合我们前面学习的网络收发和 TCP/IP 协议栈原理，这个流程中的网络接收、网桥以及 netfilter 调用等，都是导致软中断 CPU 升高的重要因素，也就是影响网络性能的潜在瓶颈。</p><p>不过，回想一下网络收发的流程，你可能会觉得它缺了好多步骤。</p><p>比如，这个堆栈中并没有 TCP 相关的调用，也没有连接跟踪 conntrack 相关的函数。实际上，这些流程都在其他更小的火焰中，你可以点击上图左上角的“Reset Zoom”，回到完整火焰图中，再去查看其他小火焰的堆栈。</p><p>所以，在理解这个调用栈时要注意。从任何一个点出发、纵向来看的整个调用栈，其实只是最顶端那一个函数的调用堆栈，而非完整的内核网络执行流程。</p><p>另外，整个火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p><p>到这里，我们就找出了内核线程 ksoftirqd 执行最频繁的函数调用堆栈，而这个堆栈中的各层级函数，就是潜在的性能瓶颈来源。这样，后面想要进一步分析、优化时，也就有了根据。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天这个案例，你可能会觉得比较熟悉。实际上，这个案例，正是我们专栏 CPU 模块中的 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/72147">软中断案例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>当时，我们从软中断 CPU 使用率的角度入手，用网络抓包的方法找出了瓶颈来源，确认是测试机器发送的大量 SYN 包导致的。而通过今天的 perf 和火焰图方法，我们进一步找出了软中断内核线程的热点函数，其实也就找出了潜在的瓶颈和优化方向。</p><p>其实，如果遇到的是内核线程的资源使用异常，很多常用的进程级性能工具并不能帮上忙。这时，你就可以用内核自带的 perf 来观察它们的行为，找出热点函数，进一步定位性能瓶。当然，perf 产生的汇总报告并不够直观，所以我也推荐你用火焰图来协助排查。</p><p>实际上，火焰图方法同样适用于普通进程。比如，在分析 Nginx、MySQL 等各种应用场景的性能问题时，火焰图也能帮你更快定位热点函数，找出潜在性能问题。</p><h2 id="思考"><a aria-hidden="true" tabindex="-1" href="/blog/linux性能优化实战/06.综合实战篇/04#思考"><span class="icon icon-link"></span></a>思考</h2><p>最后，我想邀请你一起来聊聊，你碰到过的内核线程性能问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p><p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/linux性能优化实战/06.综合实战篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
