<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？ - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/正则表达式入门/03.应用篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li><li><a href="/blog-base/正则表达式入门/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/正则表达式入门/01.开篇词/01"><span>开篇词丨学习正则，我们到底要学什么？</span></a></li><li><a href="/blog-base/正则表达式入门/01.开篇词/02"><span>导读 | 余晟：我是怎么学习和使用正则的？</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/正则表达式入门/02.基础篇/01"><span>01 | 元字符：如何巧妙记忆正则表达式的基本元件？</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/02"><span>02丨量词与贪婪：小小的正则，也可能把CPU拖垮！</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/03"><span>03 | 分组与引用：如何用正则实现更复杂的查找和替换操作？</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/04"><span>04 | 匹配模式：一次性掌握正则中常见的4种匹配模式</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门/03.应用篇">03.应用篇</a><ul><li><a href="/blog-base/正则表达式入门/03.应用篇/01"><span>05 | 断言：如何用断言更好地实现替换重复出现的单词？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/02"><span>06 | 转义：正则中转义需要注意哪些问题？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/03"><span>07 | 正则有哪些常见的流派及其特性？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/04"><span>08 | 应用1：正则如何处理 Unicode 编码的文本？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/05"><span>09 | 应用2：如何在编辑器中使用正则完成工作？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门/03.应用篇/06"><span>10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/07"><span>11 | 如何理解正则的匹配原理以及优化原则？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/08"><span>12 | 问题集锦：详解正则常见问题及解决方案</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/04.加餐">04.加餐</a><ul><li><a href="/blog-base/正则表达式入门/04.加餐/01"><span>加餐 | 从编程语言的角度来理解正则表达式</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/05.结束语">05.结束语</a><ul><li><a href="/blog-base/正则表达式入门/05.结束语/01"><span>结束语 | 使用正则提高你的人生效率</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/06.测试题">06.测试题</a><ul><li><a href="/blog-base/正则表达式入门/06.测试题/01"><span>结课测试 | 这些正则知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/summary">正则表达式入门</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="1.校验文本内容" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#1校验文本内容"><span>1.校验文本内容</span></a></li><li title="Python" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#python"><span>Python</span></a></li><li title="Go" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#go"><span>Go</span></a></li><li title="JavaScript" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#javascript"><span>JavaScript</span></a></li><li title="Java" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#java"><span>Java</span></a></li><li title="2.提取文本内容" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#2提取文本内容"><span>2.提取文本内容</span></a></li><li title="Python" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#python-1"><span>Python</span></a></li><li title="Go" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#go-1"><span>Go</span></a></li><li title="JavaScript" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#javascript-1"><span>JavaScript</span></a></li><li title="Java" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#java-1"><span>Java</span></a></li><li title="3.替换文本内容" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#3替换文本内容"><span>3.替换文本内容</span></a></li><li title="Python" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#python-2"><span>Python</span></a></li><li title="Go" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#go-2"><span>Go</span></a></li><li title="JavaScript" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#javascript-2"><span>JavaScript</span></a></li><li title="Java" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#java-2"><span>Java</span></a></li><li title="4.切割文本内容" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#4切割文本内容"><span>4.切割文本内容</span></a></li><li title="Python" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#python-3"><span>Python</span></a></li><li title="Go" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#go-3"><span>Go</span></a></li><li title="JavaScript" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#javascript-3"><span>JavaScript</span></a></li><li title="Java" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/06#java-3"><span>Java</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#总结"><span>总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/06#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--应用3如何在语言中用正则让文本处理能力上一个台阶"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#10--应用3如何在语言中用正则让文本处理能力上一个台阶"><span class="icon icon-link"></span></a>10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？</h1><p>你好，我是伟忠。今天要和你分享的内容是如何在编程语言中使用正则，让文本处理能力上一个台阶。</p><p>现代主流的编程语言几乎都内置了正则模块，很少能见到不支持正则的编程语言。学会在编程语言中使用正则，可以极大地提高文本的处理能力。</p><p>在进行文本处理时，正则解决的问题大概可以分成四类，分别是校验文本内容、提取文本内容、替换文本内容、切割文本内容。在这一节里，我会从功能分类出发，给你讲解在一些常见的编程语言中，如何正确地实现这些功能。</p><h2 id="1校验文本内容"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#1校验文本内容"><span class="icon icon-link"></span></a>1.校验文本内容</h2><p>我们先来看一下数据验证，通常我们在网页上输入的手机号、邮箱、日期等，都需要校验。校验的特点在于，整个文本的内容要符合正则，比如要求输入6位数字的时候，输入123456abc 就是不符合要求的。</p><p>下面我们以验证日期格式年月日为例子来讲解，比如2020-01-01，我们使用正则\d<!-- -->{<!-- -->4<!-- -->}<!-- -->-\d<!-- -->{<!-- -->2<!-- -->}<!-- -->-\d<!-- -->{<!-- -->2<!-- -->}<!-- --> 来验证。</p><h3 id="python"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#python"><span class="icon icon-link"></span></a>Python</h3><p>在 Python 中，正则的包名是 re，验证文本可以使用 re.match 或 re.search 的方法，这两个方法的区别在于，re.match 是从开头匹配的，re.search是从文本中找子串。下面是详细的解释：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 测试环境 Python3</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; re.match(r&#x27;\d{4}-\d{2}-\d{2}&#x27;, &#x27;2020-06-01&#x27;)</span></div><div class="token-line"><span class="token plain">    &lt;re.Match object; span=(0, 10), match=&#x27;2020-06-01&#x27;&gt;</span></div><div class="token-line"><span class="token plain">    # 这个输出是匹配到了，范围是从下标0到下标10，匹配结果是2020-06-01</span></div><div class="token-line"><span class="token plain">    # re.search 输出结果也是类似的</span></div></pre></div><p><strong>在Python中，校验文本是否匹配的正确方式<strong><strong>如下所示</strong></strong>：</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 测试环境 Python3</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;\A\d{4}-\d{2}-\d{2}\Z&#x27;)  # 建议先编译，提高效率</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.search(&#x27;2020-06-01&#x27;) is not None</span></div><div class="token-line"><span class="token plain">    True</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.match(&#x27;2020-06-01&#x27;) is not None  # 使用match时\A可省略</span></div><div class="token-line"><span class="token plain">    True</span></div></pre></div><p>如果不添加 \A 和 \Z 的话，我们就可能得到错误的结果。而造成这个错误的主要原因就是，没有完全匹配，而是部分匹配。至于为什么不推荐用<code>^</code>和<code>$</code>，因为在多行模式下，它们的匹配行为会发现变化，相关内容在前面匹配模式中讲解过，要是忘记了你可以返回去回顾一下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 错误示范</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; re.match(r&#x27;\d{4}-\d{2}-\d{2}&#x27;, &#x27;2020-06-01abc&#x27;) is not None</span></div><div class="token-line"><span class="token plain">    True</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; re.search(r&#x27;\d{4}-\d{2}-\d{2}&#x27;, &#x27;abc2020-06-01&#x27;) is not None</span></div><div class="token-line"><span class="token plain">    True</span></div></pre></div><h3 id="go"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#go"><span class="icon icon-link"></span></a>Go</h3><p>Go语言（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。在Go语言中，正则相关的包是 regexp，下面是一个完整可运行的示例。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">       &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">       &quot;regexp&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">       re := regexp.MustCompile(`\A\d{4}-\d{2}-\d{2}\z`)</span></div><div class="token-line"><span class="token plain">       // 输出 true</span></div><div class="token-line"><span class="token plain">       fmt.Println(re.MatchString(&quot;2020-06-01&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>保存成 main.go ，在配置好go环境的前提下，直接使用命令 go run main.go 运行。不方便本地搭建Go环境的同学，可以点击 <a target="_blank" rel="noopener noreferrer" href="https://play.golang.org/p/bTQJe0mT839">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a target="_blank" rel="noopener noreferrer" href="https://repl.it/@twz915/learn-regex#%E6%A0%A1%E9%AA%8C/date.go">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 进行在线运行测试。</p><p>另外，需要注意的是，和 Python 语言不同，在 Go 语言中，正则尾部断言使用的是 \z，而不是 \Z。</p><h3 id="javascript"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#javascript"><span class="icon icon-link"></span></a>JavaScript</h3><p>在JavaScript中没有 \A 和 \z，我们可以使用<code>^</code>和<code>$</code>来表示每行的开头和结尾，默认情况下它们是匹配整个文本的开头或结尾（默认不是多行匹配模式）。在 JavaScript 中校验文本的时候，不要使用多行匹配模式，因为使用多行模式会改变<code>^</code>和<code>$</code>的匹配行为。</p><p>JavaScript代码可以直接在浏览器的Console中很方便地测试。（进入方式：任意网页上点击鼠标右键，检查，Console）</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 方法1</span></div><div class="token-line"><span class="token plain">    /^\d{4}-\d{2}-\d{2}$/.test(&quot;2020-06-01&quot;)  // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 方法2</span></div><div class="token-line"><span class="token plain">    var regex = /^\d{4}-\d{2}-\d{2}$/</span></div><div class="token-line"><span class="token plain">    &quot;2020-06-01&quot;.search(regex) == 0  // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 方法3</span></div><div class="token-line"><span class="token plain">    var regex = new RegExp(/^\d{4}-\d{2}-\d{2}$/)</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01&quot;) // tru</span></div></pre></div><p>方法3本质上和方法1是一样的，方法1写起来更简洁。需要注意的是，在使用 RegExp 对象时，如果使用 g 模式，可能会有意想不到的结果，连续调用会出现第二次返回 false 的情况，就像下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var r = new RegExp(/^\d{4}-\d{2}-\d{2}$/, &quot;g&quot;)</span></div><div class="token-line"><span class="token plain">    r.test(&quot;2020-01-01&quot;) // true</span></div><div class="token-line"><span class="token plain">    r.test(&quot;2020-01-01&quot;) // false</span></div></pre></div><p>这是因为 RegExp 在全局模式下，正则会找出文本中的所有可能的匹配，找到一个匹配时会记下 lastIndex，在下次再查找时找不到，lastIndex变为0，所以才有上面现象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var regex = new RegExp(/^\d{4}-\d{2}-\d{2}$/, &quot;g&quot;)</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01&quot;) // true</span></div><div class="token-line"><span class="token plain">    regex.lastIndex // 10</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01&quot;) // false</span></div><div class="token-line"><span class="token plain">    regex.lastIndex // 0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 为了加深理解，你可以看下面这个例子</span></div><div class="token-line"><span class="token plain">    var regex = new RegExp(/\d{4}-\d{2}-\d{2}/, &quot;g&quot;)</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01 2020-02-02&quot;) // true</span></div><div class="token-line"><span class="token plain">    regex.lastIndex // 10</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01 2020-02-02&quot;) // true</span></div><div class="token-line"><span class="token plain">    regex.lastIndex // 21</span></div><div class="token-line"><span class="token plain">    regex.test(&quot;2020-01-01 2020-02-02&quot;) // false</span></div></pre></div><p>由于我们这里是文本校验，并不需要找出所有的。所以要记住，JavaScript中文本校验在使用 RegExp 时不要设置 g 模式。</p><p>另外在ES6中添加了匹配模式 u，如果要在 JavaScript 中匹配中文等多字节的 Unicode 字符，可以指定匹配模式 u，比如测试是否为一个字符，可以是任意Unicode字符，详情可以参考下面的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/^\u{1D306}$/u.test(&quot;𝌆&quot;) // true</span></div><div class="token-line"><span class="token plain">    /^\u{1D306}$/.test(&quot;𝌆&quot;) // false</span></div><div class="token-line"><span class="token plain">    /^.$/u.test(&quot;好&quot;) // true</span></div><div class="token-line"><span class="token plain">    /^.$/u.test(&quot;好人&quot;) // false</span></div><div class="token-line"><span class="token plain">    /^.$/u.test(&quot;a&quot;) // true</span></div><div class="token-line"><span class="token plain">    /^.$/u.test(&quot;ab&quot;) // false</span></div></pre></div><h3 id="java"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#java"><span class="icon icon-link"></span></a>Java</h3><p>在 Java 中，正则相关的类在 java.util.regex 中，其中最常用的是 Pattern 和 Matcher， Pattern 是正则表达式对象，Matcher是匹配到的结果对象，Pattern 和 字符串对象关联，可以得到一个 Matcher。下面是 Java 中匹配的示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.regex.Matcher;</span></div><div class="token-line"><span class="token plain">    import java.util.regex.Pattern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Main {</span></div><div class="token-line"><span class="token plain">      public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">        //方法1，可以不加 \A 和 \z</span></div><div class="token-line"><span class="token plain">        System.out.println(Pattern.matches(&quot;\\d{4}-\\d{2}-\\d{2}&quot;, &quot;2020-06-01&quot;)); // true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //方法2，可以不加 \A 和 \z</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;2020-06-01&quot;.matches(&quot;\\d{4}-\\d{2}-\\d{2}&quot;)); // true</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //方法3，必须加上 \A 和 \z</span></div><div class="token-line"><span class="token plain">        Pattern pattern = Pattern.compile(&quot;\\A\\d{4}-\\d{2}-\\d{2}\\z&quot;);</span></div><div class="token-line"><span class="token plain">        System.out.println(pattern.matcher(&quot;2020-06-01&quot;).find()); // true</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>Java 中目前还没有原生字符串，在之前转义一节讲过，正则需要经过字符串转义和正则转义两个步骤，因此在用到反斜扛的地方，比如表示数字的<code>\d</code>，就得在字符串中表示成<code>\\d</code>，转义会让书写正则变得稍微麻烦一些，在使用的时候需要留意一下。</p><p>部分常见编程语言校验文本方式，你可以参考下面的表。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagee913e97814862f1943b59cf341728f789813.aae660f5.jpg" alt=""/></p><h2 id="2提取文本内容"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#2提取文本内容"><span class="icon icon-link"></span></a>2.提取文本内容</h2><p>我们再来看一下文本内容提取，所谓内容提取，就是从大段的文本中抽取出我们关心的内容。比较常见的例子是网页爬虫，或者说从页面上提取邮箱、抓取需要的内容等。如果要抓取的是某一个网站，页面样式是一样的，要提取的内容都在同一个位置，可以使用 <a target="_blank" rel="noopener noreferrer" href="https://lxml.de/xpathxslt.html">xpath<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a target="_blank" rel="noopener noreferrer" href="https://pypi.org/project/pyquery/">jquery选择器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 等方式，否则就只能使用正则来做了。</p><p>下面我们来讲解一下具体的例子，让你了解一下正则提取文本在一些常见的编程语言中的使用。</p><h3 id="python-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#python-1"><span class="icon icon-link"></span></a>Python</h3><p>在 Python 中提取内容最简单的就是使用 re.findall 方法了，当有子组的时候，会返回子组的内容，没有子组时，返回整个正则匹配到的内容。下面我以查找日志的年月为例进行讲解，年月可以用正则 \d<!-- -->{<!-- -->4<!-- -->}<!-- -->-\d<!-- -->{<!-- -->2<!-- -->}<!-- --> 来表示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 没有子组时</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;\d{4}-\d{2}&#x27;)</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.findall(&#x27;2020-05 2020-06&#x27;)</span></div><div class="token-line"><span class="token plain">    [&#x27;2020-05&#x27;, &#x27;2020-06&#x27;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 有子组时</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;(\d{4})-(\d{2})&#x27;)</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.findall(&#x27;2020-05 2020-06&#x27;)</span></div><div class="token-line"><span class="token plain">    [(&#x27;2020&#x27;, &#x27;05&#x27;), (&#x27;2020&#x27;, &#x27;06&#x27;)]</span></div></pre></div><p>通过上面的示例你可以看到，直接使用 findall 方法时，它会把结果存储到一个列表（数组）中，一下返回所有匹配到的结果。如果想节约内存，可以采用迭代器的方式来处理，就像下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;(\d{4})-(\d{2})&#x27;)</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; for match in reg.finditer(&#x27;2020-05 2020-06&#x27;):</span></div><div class="token-line"><span class="token plain">    ...     print(&#x27;date: &#x27;, match[0])  # 整个正则匹配到的内容</span></div><div class="token-line"><span class="token plain">    ...     print(&#x27;year: &#x27;, match[1])  # 第一个子组</span></div><div class="token-line"><span class="token plain">    ...     print(&#x27;month:&#x27;, match[2])  # 第二个子组</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    date:  2020-05</span></div><div class="token-line"><span class="token plain">    year:  2020</span></div><div class="token-line"><span class="token plain">    month: 05</span></div><div class="token-line"><span class="token plain">    date:  2020-06</span></div><div class="token-line"><span class="token plain">    year:  2020</span></div><div class="token-line"><span class="token plain">    month: 06</span></div></pre></div><p>这样我们就可以实现正则找到一个，在程序中处理一个，不需要将找到的所有结果构造成一个数组（Python中的列表）。</p><h3 id="go-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#go-1"><span class="icon icon-link"></span></a>Go</h3><p>在 Go语言里面，查找也非常简洁，可以直接使用 FindAllString 方法。如果我们想捕获子组，可以使用 FindAllStringSubmatch 方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">      &quot;regexp&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      re := regexp.MustCompile(`\d{4}-\d{2}`)</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 返回一个切片(可动态扩容的数组) [2020-06 2020-07]</span></div><div class="token-line"><span class="token plain">      fmt.Println(re.FindAllString(&quot;2020-06 2020-07&quot;, -1)) </span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 捕获子组的查找示例</span></div><div class="token-line"><span class="token plain">      re2 := regexp.MustCompile(`(\d{4})-(\d{2})`)</span></div><div class="token-line"><span class="token plain">      // 返回结果和上面 Python 类似</span></div><div class="token-line"><span class="token plain">      for _, match := range re2.FindAllStringSubmatch(&quot;2020-06 2020-07&quot;, -1) {</span></div><div class="token-line"><span class="token plain">         fmt.Println(&quot;date: &quot;, match[0])</span></div><div class="token-line"><span class="token plain">         fmt.Println(&quot;year: &quot;, match[1])</span></div><div class="token-line"><span class="token plain">         fmt.Println(&quot;month:&quot;, match[2])</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="javascript-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#javascript-1"><span class="icon icon-link"></span></a>JavaScript</h3><p>在 JavaScript 中，想要提取文本中所有符合要求的内容，正则必须使用 g 模式，否则找到第一个结果后，正则就不会继续向后查找了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用g模式，查找所有符合要求的内容</span></div><div class="token-line"><span class="token plain">    &quot;2020-06 2020-07&quot;.match(/\d{4}-\d{2}/g)</span></div><div class="token-line"><span class="token plain">    // 输出：[&quot;2020-06&quot;, &quot;2020-07&quot;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 不使用g模式，找到第一个就会停下来</span></div><div class="token-line"><span class="token plain">    &quot;2020-06 2020-07&quot;.match(/\d{4}-\d{2}/)</span></div><div class="token-line"><span class="token plain">    // 输出：[&quot;2020-06&quot;, index: 0, input: &quot;2020-06 2020-07&quot;, groups: undefined]</span></div></pre></div><p>如果要查找中文等Unicode字符，可以使用 u 匹配模式，下面是具体的示例。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&#x27;𝌆&#x27;.match(/\u{1D306}/ug) // 使用匹配模式u</span></div><div class="token-line"><span class="token plain">    [&quot;𝌆&quot;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &#x27;𝌆&#x27;.match(/\u{1D306}/g) // 不使用匹配模式u</span></div><div class="token-line"><span class="token plain">    null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 如果你对这个符号感兴趣，可以参考 https://unicode-table.com/cn/1D306</span></div></pre></div><h3 id="java-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#java-1"><span class="icon icon-link"></span></a>Java</h3><p>在 Java 中，可以使用 Matcher 的 find 方法来获取查找到的内容，就像下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.regex.Matcher;</span></div><div class="token-line"><span class="token plain">    import java.util.regex.Pattern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Main {</span></div><div class="token-line"><span class="token plain">      public static void main(String[] args) {    </span></div><div class="token-line"><span class="token plain">        Pattern pattern = Pattern.compile(&quot;\\d{4}-\\d{2}&quot;);</span></div><div class="token-line"><span class="token plain">        Matcher match = pattern.matcher(&quot;2020-06 2020-07&quot;);</span></div><div class="token-line"><span class="token plain">        while (match.find()) {</span></div><div class="token-line"><span class="token plain">          System.out.println(match.group());      </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>部分常见编程语言提取文本方式，你可以参考下面的表。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb1c9b14435e91df9454f6fa361b1510ff2c9.c25411db.jpg" alt=""/></p><h2 id="3替换文本内容"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#3替换文本内容"><span class="icon icon-link"></span></a>3.替换文本内容</h2><p>我们接着来看一下文本内容替换，替换通常用于对原来的文本内容进行一些调整。之前我们也讲解过一些使用正则进行替换的例子，今天我们再来了解一下在部分常见的编程语言中，使用正则进行文本替换的方法。</p><h3 id="python-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#python-2"><span class="icon icon-link"></span></a>Python</h3><p>在 Python 中替换相关的方法有 re.sub 和 re.subn，后者会返回替换的次数。下面我以替换年月的格式为例进行讲解，假设原始的日期格式是月日年，我们要将其处理成 xxxx年xx月xx日的格式。你可以看到，在Python中正则替换操作相关的方法，使用起来非常地简单。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;(\d{2})-(\d{2})-(\d{4})&#x27;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.sub(r&#x27;\3年\1月\2日&#x27;, &#x27;02-20-2020 05-21-2020&#x27;)</span></div><div class="token-line"><span class="token plain">    &#x27;2020年02月20日 2020年05月21日&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 可以在替换中使用 \g&lt;数字&gt;，如果分组多于10个时避免歧义</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.sub(r&#x27;\g&lt;3&gt;年\g&lt;1&gt;月\g&lt;2&gt;日&#x27;, &#x27;02-20-2020 05-21-2020&#x27;)</span></div><div class="token-line"><span class="token plain">    &#x27;2020年02月20日 2020年05月21日&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 返回替换次数</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.subn(r&#x27;\3年\1月\2日&#x27;, &#x27;02-20-2020 05-21-2020&#x27;)</span></div><div class="token-line"><span class="token plain">    (&#x27;2020年02月20日 2020年05月21日&#x27;, 2)</span></div></pre></div><h3 id="go-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#go-2"><span class="icon icon-link"></span></a>Go</h3><p>在 Go语言里面，替换和Python也非常类似，只不过子组是使用 $<!-- -->{<!-- -->num<!-- -->}<!-- --> 的方式来表示的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">      &quot;regexp&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      re := regexp.MustCompile(`(\d{2})-(\d{2})-(\d{4})`)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 示例一，返回 2020年02月20日 2020年05月21日</span></div><div class="token-line"><span class="token plain">      fmt.Println(re.ReplaceAllString(&quot;02-20-2020 05-21-2020&quot;, &quot;${3}年${1}月${2}日&quot;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 示例二，返回空字符串，因为&quot;3年&quot;，&quot;1月&quot;，&quot;2日&quot; 这样的子组不存在</span></div><div class="token-line"><span class="token plain">      fmt.Println(re.ReplaceAllString(&quot;02-20-2020 05-21-2020&quot;, &quot;$3年$1月$2日&quot;))</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 示例三，返回 2020-02-20 2020-05-21</span></div><div class="token-line"><span class="token plain">      fmt.Println(re.ReplaceAllString(&quot;02-20-2020 05-21-2020&quot;, &quot;$3-$1-$2&quot;))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>需要你注意的是，不建议把 <code>$</code>{<!-- -->num<!-- -->}<!-- --> 写成不带花括号的 <code>$</code>num，比如示例二中的错误，会让人很困惑，Go认为子组是<code>“3年”，“1月”，“2日”</code>。 由于这样的子组不存在，最终替换成了空字符串，所以使用的时候要注意这一点。</p><h3 id="javascript-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#javascript-2"><span class="icon icon-link"></span></a>JavaScript</h3><p>在 JavaScript 中替换和查找类似，需要指定 g 模式，否则只会替换第一个，就像下面这样。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 使用g模式，替换所有的</span></div><div class="token-line"><span class="token plain">    &quot;02-20-2020 05-21-2020&quot;.replace(/(\d{2})-(\d{2})-(\d{4})/g, &quot;$3年$1月$2日&quot;)</span></div><div class="token-line"><span class="token plain">    // 输出 &quot;2020年02月20日 2020年05月21日&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 不使用 g 模式时，只替换一次</span></div><div class="token-line"><span class="token plain">    &quot;02-20-2020 05-21-2020&quot;.replace(/(\d{2})-(\d{2})-(\d{4})/, &quot;$3年$1月$2日&quot;)</span></div><div class="token-line"><span class="token plain">    // 输出 &quot;2020年02月20日 05-21-2020&quot;</span></div></pre></div><h3 id="java-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#java-2"><span class="icon icon-link"></span></a>Java</h3><p>在 Java 中，一般是使用 replaceAll 方法进行替换，一次性替换所有的匹配到的文本。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.regex.Matcher;</span></div><div class="token-line"><span class="token plain">    import java.util.regex.Pattern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Main {</span></div><div class="token-line"><span class="token plain">      public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">        //方法1，输出 2020年02月20日 2020年05月21日</span></div><div class="token-line"><span class="token plain">        System.out.println(&quot;02-20-2020 05-21-2020&quot;.replaceAll(&quot;(\\d{2})-(\\d{2})-(\\d{4})&quot;, &quot;$3年$1月$2日&quot;));</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //方法2，输出 2020年02月20日 2020年05月21日</span></div><div class="token-line"><span class="token plain">        final Pattern pattern = Pattern.compile(&quot;(\\d{2})-(\\d{2})-(\\d{4})&quot;);</span></div><div class="token-line"><span class="token plain">        Matcher match = pattern.matcher(&quot;02-20-2020 05-21-2020&quot;);</span></div><div class="token-line"><span class="token plain">        System.out.println(match.replaceAll(&quot;$3年$1月$2日&quot;));</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>部分常见编程语言替换文本方式，你可以参考下面的表。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage98yy98603bb41c59dac186bab6dc12a494yy.c697bffb.jpg" alt=""/></p><h2 id="4切割文本内容"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#4切割文本内容"><span class="icon icon-link"></span></a>4.切割文本内容</h2><p>我们最后再来看一下文本内容切割，通常切割用于变长的空白符号，多变的标点符号等。</p><p>下面我们来讲解一下具体的例子，让你了解一下正则切割文本在部分常见编程语言中的使用。</p><h3 id="python-3"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#python-3"><span class="icon icon-link"></span></a>Python</h3><p>在 Python 中切割相关的方法是 re.split。如果我们有按照任意空白符切割的需求，可以直接使用字符串的 split 方法，不传任何参数时就是按任意连续一到多个空白符切割。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 使用字符串的切割方法</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; &quot;a b  c\n\nd\t\n \te&quot;.split()</span></div><div class="token-line"><span class="token plain">    [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></div></pre></div><p>使用正则进行切割，比如我们要通过标点符号切割，得到所有的单词（这里简单使用非单词组成字符来表示）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;\W+&#x27;)</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.split(&quot;apple, pear! orange; tea&quot;)</span></div><div class="token-line"><span class="token plain">    [&#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;tea&#x27;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 限制切割次数，比如切一刀，变成两部分</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.split(&quot;apple, pear! orange; tea&quot;, 1)</span></div><div class="token-line"><span class="token plain">    [&#x27;apple&#x27;, &#x27;pear! orange; tea&#x27;]</span></div></pre></div><h3 id="go-3"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#go-3"><span class="icon icon-link"></span></a>Go</h3><p>在 Go语言里面，切割是 Split 方法，和 Python 非常地类似，只不过Go语言中这个方法的第二个参数是必传的，如果不限制次数，我们传入 -1 即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">package main</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    import (</span></div><div class="token-line"><span class="token plain">      &quot;fmt&quot;</span></div><div class="token-line"><span class="token plain">      &quot;regexp&quot;</span></div><div class="token-line"><span class="token plain">    )</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    func main() {</span></div><div class="token-line"><span class="token plain">      re := regexp.MustCompile(`\W+`)</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 返回 []string{&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;tea&quot;}</span></div><div class="token-line"><span class="token plain">      fmt.Printf(&quot;%#v&quot;, re.Split(&quot;apple, pear! orange; tea&quot;, -1)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但在Go语言中，有个地方和 Python 不太一样，就是传入的第二个参数代表切割成几个部分，而不是切割几刀。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 返回 []string{&quot;apple&quot;, &quot;pear! orange; tea&quot;}</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%#v\n&quot;, re.Split(&quot;apple, pear! orange; tea&quot;, 2))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 返回 []string{&quot;apple&quot;}</span></div><div class="token-line"><span class="token plain">    fmt.Printf(&quot;%#v\n&quot;, re.Split(&quot;apple&quot;, 2))</span></div></pre></div><p>这里有一个<a target="_blank" rel="noopener noreferrer" href="https://play.golang.org/p/4VsBKxxXzYp">在线测试链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以尝试一下。</p><h3 id="javascript-3"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#javascript-3"><span class="icon icon-link"></span></a>JavaScript</h3><p>在 JavaScript 中，正则的切割和刚刚讲过的 Python 和 Go 有些类似，但又有区别。当第二个参数是2的时候，表示切割成2个部分，而不是切2刀（Go和Java也是类似的），但数组的内容不是 apple 后面的剩余部分，而是全部切割之后的 pear，你可以注意比较一下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&quot;apple, pear! orange; tea&quot;.split(/\W+/)</span></div><div class="token-line"><span class="token plain">    // 输出：[&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;tea&quot;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 传入第二个参数的情况</span></div><div class="token-line"><span class="token plain">    &quot;apple, pear! orange; tea&quot;.split(/\W+/, 1)</span></div><div class="token-line"><span class="token plain">    // 输出 [&quot;apple&quot;]</span></div><div class="token-line"><span class="token plain">    &quot;apple, pear! orange; tea&quot;.split(/\W+/, 2)</span></div><div class="token-line"><span class="token plain">    // 输出 [&quot;apple&quot;, &quot;pear&quot;]</span></div><div class="token-line"><span class="token plain">    &quot;apple, pear! orange; tea&quot;.split(/\W+/, 10)</span></div><div class="token-line"><span class="token plain">    // 输出 [&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;tea&quot;]</span></div></pre></div><h3 id="java-3"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#java-3"><span class="icon icon-link"></span></a>Java</h3><p>Java中切割也是类似的，由于没有原生字符串，转义稍微麻烦点。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">import java.util.regex.Matcher;</span></div><div class="token-line"><span class="token plain">    import java.util.regex.Pattern;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Main {</span></div><div class="token-line"><span class="token plain">      public static void main(String[] args) {</span></div><div class="token-line"><span class="token plain">        Pattern pattern = Pattern.compile(&quot;\\W+&quot;);</span></div><div class="token-line"><span class="token plain">        for(String s : pattern.split(&quot;apple, pear! orange; tea&quot;)) {</span></div><div class="token-line"><span class="token plain">          System.out.println(s);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在 Java 中，也可以传入第二个参数，类似于 Go 的结果。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">pattern.split(&quot;apple, pear! orange; tea&quot;, 2)</span></div><div class="token-line"><span class="token plain">    // 返回 &quot;apple&quot; 和 &quot;pear! orange; tea&quot;</span></div></pre></div><p>部分常见编程语言切割文本方式，你可以参考下面的表。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage67566708a65e269e645abb9c6ca85b5a4b56.0fe987c1.jpg" alt=""/></p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，今天的内容讲完了，我来带你总结回顾一下。</p><p>今天我们学习了正则解决的问题大概可以分成四类，分别是校验文本内容、提取文本内容、替换文本内容、切割文本内容。从这四个功能出发，我们学习了在一些常见的编程语言中，如何正确地使用相应的方法来实现这些功能。这些方法都比较详细，希望你能够认真练习，掌握好这些方法。</p><p>我给你总结了一个今天所讲内容的详细脑图，你可以长按保存下来，经常回顾一下：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagef125f1d925e4795e1310886aaf82caf42325.bc94315b.png" alt=""/></p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/06#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>最后，我们来做一个小练习吧。很多网页为了防止爬虫，喜欢把邮箱里面的 @ 符号替换成 # 符号，你可以写一个正则，兼容一下这种情况么？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">例如网页的底部可能是这样的：</span></div><div class="token-line"><span class="token plain">    联系邮箱：xxx#163.com (请把#换成@)</span></div></pre></div><p>你可以试试自己动手，使用你熟悉的编程语言，测试一下你写的正则能不能提取出这种“防爬”的邮箱。</p><p>好，今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，并把文章分享给你的朋友或者同事，一起交流一下。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/正则表达式入门/03.应用篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
