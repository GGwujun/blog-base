<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>11 | 如何理解正则的匹配原理以及优化原则？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/正则表达式入门/03.应用篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li><li><a href="/blog-base/正则表达式入门/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/正则表达式入门/01.开篇词/01"><span>开篇词丨学习正则，我们到底要学什么？</span></a></li><li><a href="/blog-base/正则表达式入门/01.开篇词/02"><span>导读 | 余晟：我是怎么学习和使用正则的？</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/正则表达式入门/02.基础篇/01"><span>01 | 元字符：如何巧妙记忆正则表达式的基本元件？</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/02"><span>02丨量词与贪婪：小小的正则，也可能把CPU拖垮！</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/03"><span>03 | 分组与引用：如何用正则实现更复杂的查找和替换操作？</span></a></li><li><a href="/blog-base/正则表达式入门/02.基础篇/04"><span>04 | 匹配模式：一次性掌握正则中常见的4种匹配模式</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门/03.应用篇">03.应用篇</a><ul><li><a href="/blog-base/正则表达式入门/03.应用篇/01"><span>05 | 断言：如何用断言更好地实现替换重复出现的单词？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/02"><span>06 | 转义：正则中转义需要注意哪些问题？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/03"><span>07 | 正则有哪些常见的流派及其特性？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/04"><span>08 | 应用1：正则如何处理 Unicode 编码的文本？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/05"><span>09 | 应用2：如何在编辑器中使用正则完成工作？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/06"><span>10 | 应用3：如何在语言中用正则让文本处理能力上一个台阶？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/正则表达式入门/03.应用篇/07"><span>11 | 如何理解正则的匹配原理以及优化原则？</span></a></li><li><a href="/blog-base/正则表达式入门/03.应用篇/08"><span>12 | 问题集锦：详解正则常见问题及解决方案</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/04.加餐">04.加餐</a><ul><li><a href="/blog-base/正则表达式入门/04.加餐/01"><span>加餐 | 从编程语言的角度来理解正则表达式</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/05.结束语">05.结束语</a><ul><li><a href="/blog-base/正则表达式入门/05.结束语/01"><span>结束语 | 使用正则提高你的人生效率</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/06.测试题">06.测试题</a><ul><li><a href="/blog-base/正则表达式入门/06.测试题/01"><span>结课测试 | 这些正则知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-base/正则表达式入门/summary">正则表达式入门</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="有穷状态自动机" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#有穷状态自动机"><span>有穷状态自动机</span></a></li><li title="正则的匹配过程" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#正则的匹配过程"><span>正则的匹配过程</span></a></li><li title="DFA&amp; NFA 工作机制" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#dfa-nfa-工作机制"><span>DFA&amp; NFA 工作机制</span></a></li><li title="POSIX NFA 与 传统 NFA 区别" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#posix-nfa-与-传统-nfa-区别"><span>POSIX NFA 与 传统 NFA 区别</span></a></li><li title="回溯" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#回溯"><span>回溯</span></a></li><li title="优化建议" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#优化建议"><span>优化建议</span></a></li><li title="1.测试性能的方法" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#1测试性能的方法"><span>1.测试性能的方法</span></a></li><li title="2.提前编译好正则" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#2提前编译好正则"><span>2.提前编译好正则</span></a></li><li title="3.尽量准确表示匹配范围" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#3尽量准确表示匹配范围"><span>3.尽量准确表示匹配范围</span></a></li><li title="4.提取出公共部分" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#4提取出公共部分"><span>4.提取出公共部分</span></a></li><li title="5.出现可能性大的放左边" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#5出现可能性大的放左边"><span>5.出现可能性大的放左边</span></a></li><li title="6.只在必要时才使用子组" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#6只在必要时才使用子组"><span>6.只在必要时才使用子组</span></a></li><li title="7.警惕嵌套的子组重复" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#7警惕嵌套的子组重复"><span>7.警惕嵌套的子组重复</span></a></li><li title="8.避免不同分支重复匹配" data-depth="3"><a href="/blog-base/正则表达式入门/03.应用篇/07#8避免不同分支重复匹配"><span>8.避免不同分支重复匹配</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#总结"><span>总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/正则表达式入门/03.应用篇/07#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="11--如何理解正则的匹配原理以及优化原则"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#11--如何理解正则的匹配原理以及优化原则"><span class="icon icon-link"></span></a>11 | 如何理解正则的匹配原理以及优化原则？</h1><p>你好，我是伟忠，这一节课我们一起来学习正则匹配原理相关的内容，以及在书写正则时的一些优化方法。</p><p>这节课我主要给你讲解一下正则匹配过程，回顾一下之前讲的回溯，以及 DFA 和 NFA 引擎的工作方式，方便你明白正则是如何进行匹配的。这些原理性的知识，能够帮助我们快速理解为什么有些正则表达式不符合预期，也可以避免一些常见的错误。只有了解正则引擎的工作原理，我们才可以更轻松地写出正确的，性能更好的正则表达式。</p><h2 id="有穷状态自动机"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#有穷状态自动机"><span class="icon icon-link"></span></a>有穷状态自动机</h2><p>正则之所以能够处理复杂文本，就是因为采用了**有穷状态自动机（****finite automaton）。**那什么是有穷自动机呢？有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。</p><p>有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的NFA 和POSIX NFA。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">DFA：确定性有穷自动机（Deterministic finite automaton）</span></div><div class="token-line"><span class="token plain">    NFA：非确定性有穷自动机（Non-deterministic finite automaton）</span></div></pre></div><p>接下来我们来通过一些示例，来详细看下正则表达式的匹配过程。</p><h2 id="正则的匹配过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#正则的匹配过程"><span class="icon icon-link"></span></a>正则的匹配过程</h2><p>在使用到编程语言时，我们经常会“编译”一下正则表达式，来提升效率，比如在 Python3 中它是下面这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;a(?:bb)+a&#x27;)</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.findall(&#x27;abbbba&#x27;)</span></div><div class="token-line"><span class="token plain">    [&#x27;abbbba&#x27;]</span></div></pre></div><p>这个编译的过程，其实就是生成自动机的过程，正则引擎会拿着这个自动机去和字符串进行匹配。生成的自动机可能是这样的（下图是使用<a target="_blank" rel="noopener noreferrer" href="https://regexper.com/#a(?:bb)+a">Regexper工具<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>生成，再次加工得到的）。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagee34fe3e052fac55209937cfd20ab5117f24f.png" alt=""/></p><p>在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称NFA）。</p><p>**NFA和DFA是可以相互转化的，**当我们把上面的状态表示成下面这样，就是一台DFA状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagec7f7c7e756e33fd5ce6156e35d8ec66e2df7.png" alt=""/></p><p>那这两种状态机的工作方式到底有什么不同呢？我们接着往下看。</p><h3 id="dfa-nfa-工作机制"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#dfa-nfa-工作机制"><span class="icon icon-link"></span></a>DFA&amp; NFA 工作机制</h3><p>下面我通过一个示例，来简单说明 <strong>NFA 与 DFA 引擎工作方式的区别</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">字符串：we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">    正则：jike(zhushou|shijian|shixi)</span></div></pre></div><p>NFA引擎的工作方式是，先看正则，再看文本，而且以正则为主导。正则中的第一个字符是j，NFA引擎在字符串中查找 j，接着匹配其后是否为 i ，如果是 i 则继续，这样一直找到 jike。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">              ^</span></div><div class="token-line"><span class="token plain">    text: we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">                         ^</span></div></pre></div><p>我们再根据正则看文本后面是不是 z，发现不是，此时 zhushou 分支淘汰。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">                ^</span></div><div class="token-line"><span class="token plain">             淘汰此分支(zhushou)</span></div><div class="token-line"><span class="token plain">    text: we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">                          ^</span></div></pre></div><p>我们接着看其它的分支，看文本部分是不是 s，直到 shijian 整个匹配上。shijian 在匹配过程中如果不失败，就不会看后面的 shixi 分支。当匹配上了 shijian 后，整个文本匹配完毕，也不会再看 shixi 分支。</p><p>假设这里文本改一下，把 jikeshijian 变成 jikeshixi，正则 shi<strong>j</strong>ian 的 j 匹配不上时shixi 的 x，会接着使用正则 shixi 来进行匹配，重新从 s 开始（NFA引擎会记住这里）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">第二个分支匹配失败</span></div><div class="token-line"><span class="token plain">    regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">                           ^</span></div><div class="token-line"><span class="token plain">                      淘汰此分支(正则j匹配不上文本x)</span></div><div class="token-line"><span class="token plain">    text: we study on jikeshixi app</span></div><div class="token-line"><span class="token plain">                             ^</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    再次尝试第三个分支</span></div><div class="token-line"><span class="token plain">    regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">                                ^</span></div><div class="token-line"><span class="token plain">    text: we study on jikeshixi app</span></div><div class="token-line"><span class="token plain">                          ^</span></div></pre></div><p>也就是说， NFA 是以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次。</p><p>而 DFA 不是这样的，DFA 会先看文本，再看正则表达式，是以文本为主导的。在具体匹配过程中，DFA 会从 we 中的 w 开始依次查找 j，定位到 j ，这个字符后面是 i。所以我们接着看正则部分是否有 i ，如果正则后面是个 i ，那就以同样的方式，匹配到后面的 ke。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">text: we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">                         ^</span></div><div class="token-line"><span class="token plain">    regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">              ^</span></div></pre></div><p>继续进行匹配，文本 e 后面是字符 s ，DFA 接着看正则表达式部分，此时 zhushou 分支被淘汰，开头是s的分支 shijian 和 shixi 符合要求。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">text: we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">                          ^</span></div><div class="token-line"><span class="token plain">    regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">                ^       ^       ^</span></div><div class="token-line"><span class="token plain">               淘汰     符合    符合</span></div></pre></div><p>然后 DFA 依次检查字符串，检测到 shijian 中的 j 时，只有 shijian 分支符合，淘汰 shixi，接着看分别文本后面的 ian，和正则比较，匹配成功。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">text: we study on jikeshijian app</span></div><div class="token-line"><span class="token plain">                             ^</span></div><div class="token-line"><span class="token plain">    regex: jike(zhushou|shijian|shixi)</span></div><div class="token-line"><span class="token plain">                           ^       ^</span></div><div class="token-line"><span class="token plain">                          符合     淘汰</span></div></pre></div><p>从这个示例你可以看到，DFA 和 NFA 两种引擎的工作方式完全不同。NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导，先看文本，再看正则表达式。</p><p>一般来说，DFA 引擎会更快一些，因为整个匹配过程中，字符串只看一遍，不会发生回溯，相同的字符不会被测试两次。也就是说DFA 引擎执行的时间一般是线性的。DFA 引擎可以确保匹配到可能的最长字符串。但由于 DFA 引擎只包含有限的状态，所以它没有反向引用功能；并且因为它不构造显示扩展，它也不支持捕获子组。</p><p>NFA 以表达式为主导，它的引擎是使用贪心匹配回溯算法实现。NFA 通过构造特定扩展，支持子组和反向引用。但由于 NFA 引擎会发生回溯，即它会对字符串中的同一部分，进行很多次对比。因此，在最坏情况下，它的执行速度可能非常慢。</p><h3 id="posix-nfa-与-传统-nfa-区别"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#posix-nfa-与-传统-nfa-区别"><span class="icon icon-link"></span></a>POSIX NFA 与 传统 NFA 区别</h3><p>因为传统的 NFA 引擎“急于”报告匹配结果，找到第一个匹配上的就返回了，所以可能会导致还有更长的匹配未被发现。比如使用正则 pos|posix 在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage435f4386yyd95dc71323098e9c6ae187645f.png" alt=""/></p><p>POSIX NFA的应用很少，主要是 Unix/Linux 中的某些工具。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（“The Longest-Leftmost”）。因此，POSIX NFA 引擎的速度要慢于传统的 NFA 引擎。</p><p>我们日常面对的，一般都是传统的NFA，所以通常都是最左侧的分支优先，在书写正则的时候务必要注意这一点。</p><p>下面是 DFA、传统NFA 以及 POSIX NFA 引擎的特点总结：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagef61af60e745b693a11d50e4c41b02f9f4c1a.jpg" alt=""/></p><h2 id="回溯"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#回溯"><span class="icon icon-link"></span></a>回溯</h2><p>回溯是 NFA引擎才有的，并且只有在正则中出现<strong>量词</strong>或<strong>多选分支结构</strong>时，才可能会发生回溯。</p><p>比如我们使用正则 a+ab 来匹配 文本 aab 的时候，过程是这样的，a+是贪婪匹配，会占用掉文本中的两个 a，但正则接着又是 a，文本部分只剩下 b，只能通过回溯，让 a+ 吐出一个 a，再次尝试。</p><p>如果正则是使用 <code>.*ab</code> 去匹配一个比较长的字符串就更糟糕了，因为 <code>.*</code> 会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将 <code>.*</code> 匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。<br/><img src="/images/httpsstatic001geekbangorgresourceimagef224f2aac8643c053fd7fb010e18f9431624.jpg" alt=""/></p><p>所以在工作中，我们要尽量不用 <strong>.</strong>* ，除非真的有必要，因为点能匹配的范围太广了，我们要尽可能精确。常见的解决方式有两种，比如要提取引号中的内容时，使用 “<strong>[^&quot;]+</strong>”，或者使用非贪婪的方式 “<strong>.+?</strong>”，来减少“匹配上的内容不断吐出，再次尝试”的过程。</p><p>我们再回头看一下之前讲解的店铺名匹配示例：</p><p><img src="/images/httpsstatic001geekbangorgresourceimageacfbac99c68754d4e6c54d958970e9c3a5fb.png" alt=""/></p><p>从<a target="_blank" rel="noopener noreferrer" href="https://regex101.com/r/Qbsm4g/1">示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我们可以看到，一个很短的字符串，NFA引擎尝试步骤达到了 9021 次，由于是贪婪匹配，第一个分支能匹配上 this is a cat 部分，接着后面的逗号匹配失败，使用第二个分支匹配，再次失败，此时贪婪匹配部分结束。NFA引擎接着用正则后面的 $ 来进行匹配，但此处不是文本结尾，匹配不上，发生回溯，吐出第一个分支匹配上的 t，使用第二个分支匹配 t 再试，还是匹配不上。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage102810160dab5ccfcffb63abd79fc2299528.png" alt=""/><br/>我们继续回溯，第二个分支匹配上的 t 吐出，第一个分支匹配上的 a 也吐出，再用第二个分支匹配 a 再试，如此发生了大量的回溯。你可以使用 regex101.com 中的 Regex Debugger 来调试一下这个过程，加深你的理解。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage06f20646f1d176e08cbeayyf005495e301f2.png" alt=""/></p><p><img src="/images/httpsstatic001geekbangorgresourceimage1f371f8860d7fd9f0bf88cc6b3be2e08e937.png" alt=""/></p><p>我们来尝试优化一下，把第一个分支中的 A-Za-z 去掉，因为后面多选分支结构中重复了，我们再看一下正则尝试匹配的次数（<a target="_blank" rel="noopener noreferrer" href="https://regex101.com/r/Qbsm4g/2">示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），可以看到只尝试匹配了 57 次就结束了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea779a7438f0dc228edcb21fa69cd2fca8979.png" alt=""/></p><p>所以一定要记住，不要在多选择分支中，出现重复的元素。到这里，你对之前文章提到的“回溯不可怕，我们要尽量减少回溯后的判断” 是不是有了进一步的理解呢？</p><p>另外，之前我们说的独占模式，你可以把它可以理解为贪婪模式的一种优化，它也会发生广义的回溯，但它不会吐出已经匹配上的字符。独占模式匹配到英文逗号那儿，不会吐出已经匹配上的字符，匹配就失败了，所以采用独占模式也能解决性能问题（<a target="_blank" rel="noopener noreferrer" href="https://regex101.com/r/Qbsm4g/3">示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageb1bdb12a4239a5ee7a1071e7752d19ba23bd.png" alt=""/></p><p>但要提醒你的是，独占模式“不吐出已匹配字符”的特性，会使得一些场景不能使用它。另外，只有少数编程语言支持独占模式。</p><p>解决这个问题还有其它的方式，比如我们可以尝试移除多选分支选择结构，直接用中括号表示多选一（<a target="_blank" rel="noopener noreferrer" href="https://regex101.com/r/Qbsm4g/4">示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage7c077c2c0660cb4187fc7e9e9c60a827ce07.png" alt=""/></p><p>我们会发现性能也是有显著提升（这里只是测试，真正使用的时候，重复的元素都应该去掉，另外这里也不需要保存子组）。</p><h2 id="优化建议"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#优化建议"><span class="icon icon-link"></span></a>优化建议</h2><p>学习了原理之后，有助于我们写出更好的正则。我们必须先保证正则的功能是正确的，然后再进行优化性能，下面我给了你一些优化的方法供你参考。</p><h3 id="1测试性能的方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#1测试性能的方法"><span class="icon icon-link"></span></a>1.测试性能的方法</h3><p>我们可以使用 ipython 来测试正则的性能，ipython 是一个 Python shell 增强交互工具，在 macOS/Windows/Linux 上都可以安装使用。在测试正则表达式时，它非常有用，比如下面通过一个示例，来测试在字符串中查找 abc 时的时间消耗。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">In [1]: import re</span></div><div class="token-line"><span class="token plain">    In [2]: x = &#x27;-&#x27; * 1000000 + &#x27;abc&#x27;</span></div><div class="token-line"><span class="token plain">    In [3]: timeit re.search(&#x27;abc&#x27;, x)</span></div><div class="token-line"><span class="token plain">    480 µs ± 8.06 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></div></pre></div><p>另外，你也可以通过前面 regex101.com 查看正则和文本匹配的次数，来得知正则的性能信息。</p><h3 id="2提前编译好正则"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#2提前编译好正则"><span class="icon icon-link"></span></a>2.提前编译好正则</h3><p>编程语言中一般都有“编译”方法，我们可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; import re</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg = re.compile(r&#x27;ab?c&#x27;)  # 先编译好，再使用</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; reg.findall(&#x27;abc&#x27;)</span></div><div class="token-line"><span class="token plain">    [&#x27;abc&#x27;]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; re.findall(r&#x27;ab?c&#x27;, &#x27;abc&#x27;)  # 正式使用不建议，但测试功能时较方便</span></div><div class="token-line"><span class="token plain">    [&#x27;abc&#x27;]</span></div></pre></div><h3 id="3尽量准确表示匹配范围"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#3尽量准确表示匹配范围"><span class="icon icon-link"></span></a>3.尽量准确表示匹配范围</h3><p>比如我们要匹配引号里面的内容，除了写成 “.+?” 之外，我们可以写成 “<strong>[^&quot;]+</strong>”。使用 [^&quot;] 要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题。</p><h3 id="4提取出公共部分"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#4提取出公共部分"><span class="icon icon-link"></span></a>4.提取出公共部分</h3><p>通过上面对 NFA引擎的学习，相信你应该明白<code>(abcd|abxy)</code>这样的表达式，可以优化成<code>ab(cd|xy)</code>，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率。</p><p>因此我们会知道<code>th(?:is|at)</code>要比<code>this|that</code>要快一些，但从可读性上看，后者要好一些，这个就需要用的时候去权衡，也可以添加代码注释让代码更容易理解。</p><p>类似地，如果是锚点，比如<code>(^this|^that) is</code>这样的，锚点部分也应该独立出来，可以写成比如<code>^th(is|at) is</code>的形式，因为锚点部分也是需要尝试去匹配的，匹配次数要尽可能少。</p><h3 id="5出现可能性大的放左边"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#5出现可能性大的放左边"><span class="icon icon-link"></span></a>5.出现可能性大的放左边</h3><p>由于正则是从左到右看的，把出现概率大的放左边，域名中 .com 的使用是比 .net 多的，所以我们可以写成<code>\.(?:com|net)\b</code>，而不是<code>\.(?:net|com)\b</code>。</p><h3 id="6只在必要时才使用子组"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#6只在必要时才使用子组"><span class="icon icon-link"></span></a>6.只在必要时才使用子组</h3><p>在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 ?: 来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能。</p><h3 id="7警惕嵌套的子组重复"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#7警惕嵌套的子组重复"><span class="icon icon-link"></span></a>7.警惕嵌套的子组重复</h3><p>如果一个组里面包含重复，接着这个组整体也可以重复，比如 <code>(.*)*</code> 这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则。</p><h3 id="8避免不同分支重复匹配"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#8避免不同分支重复匹配"><span class="icon icon-link"></span></a>8.避免不同分支重复匹配</h3><p>在多选分支选择中，要避免不同分支出现相同范围的情况，上面回溯的例子中，我们已经进行了比较详细的讲解。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#总结"><span class="icon icon-link"></span></a>总结</h2><p>好了，今天的内容讲完了，我来带你总结回顾一下。</p><p>今天带你简单学习了有穷自动机的概念，自动机的具体实现称之为正则引擎。</p><p>我们学习了正则引擎的匹配原理，NFA 和 DFA 两种引擎的工作方式完全不同，NFA 是以表达式为主导的，先看正则表达式，再看文本。而 DFA 则是以文本为主导的，先看文本，再看正则表达式。POSIX NFA是指符合POSIX标准的NFA引擎，它会不断回溯，以确保找到最左侧最长匹配。</p><p>接着我们学习了测试正则表达式性能的方法，以及优化的一些方法，比如提前编译好正则，提取出公共部分，尽量准确地表示范围，必要时才使用子组等。</p><p>今天所讲的内容总结脑图如下，你可以回顾一下：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebd0bbddcyy348af2539aeedd72a7ebe5390b.png" alt=""/></p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/正则表达式入门/03.应用篇/07#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>最后，我们来做一个小练习吧。通过今天学习的内容，这里有一个示例，要求匹配“由字母或数字组成的字符串，但第一个字符要是小写英文字母”，你能说一下针对这个示例，NFA引擎的匹配过程么？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">文本：a12</span></div><div class="token-line"><span class="token plain">    正则：^(?=[a-z])[a-z0-9]+$</span></div></pre></div><p>好，今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，并把文章分享给你的朋友或者同事，一起交流一下。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/正则表达式入门/03.应用篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:34:11</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
