<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？ - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇">01.入门准备篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/01"><span>开篇词 | 为什么要学习Linux操作系统？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/02"><span>01 | 入学测验：你究竟对Linux操作系统了解多少？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/03"><span>02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述">02.核心原理篇第一部分Linux操作系统综述</a><ul><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/01"><span>03 | 你可以把Linux内核当成一家软件外包公司的老板</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/02"><span>04 | 快速上手几个Linux命令：每家公司都有自己的黑话</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/03"><span>05 | 学会几个系统调用：咱们公司能接哪些类型的项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化">03.核心原理篇第二部分系统初始化</a><ul><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/01"><span>06 | x86架构：有了开放的架构，才能打造开放的营商环境</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/02"><span>07 | 从BIOS到bootloader：创业伊始，有活儿老板自己上</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/03"><span>08 | 内核初始化：生意做大了就得成立公司</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/04"><span>09 | 系统调用：公司成立好了就要开始接项目</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理">04.核心原理篇第三部分进程管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/01"><span>10 | 进程：公司接这么多项目，如何管？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/02"><span>11 | 线程：如何让复杂的项目并行执行？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/03"><span>12 | 进程数据结构（上）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/04"><span>13 | 进程数据结构（中）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/05"><span>14 | 进程数据结构（下）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/06"><span>15 | 调度（上）：如何制定项目管理流程？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/07"><span>16 | 调度（中）：主动调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/08"><span>17 | 调度（下）：抢占式调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/09"><span>18 | 进程的创建：如何发起一个新项目？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/10"><span>19 | 线程的创建：如何执行一个新子项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理">05.核心原理篇第四部分内存管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/01"><span>20 | 内存管理（上）：为客户保密，规划进程内存空间布局</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/02"><span>21 | 内存管理（下）：为客户保密，项目组独享会议室封闭开发</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/03"><span>22 | 进程空间管理：项目组还可以自行布置会议室</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/04"><span>23 | 物理内存管理（上）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/05"><span>24 | 物理内存管理（下）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/06"><span>25 | 用户态内存映射：如何找到正确的会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/07"><span>26 | 内核态内存映射：如何找到正确的会议室？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统">06.核心原理篇第五部分文件系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/01"><span>27 | 文件系统：项目成果要归档，我们就需要档案库</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/02"><span>28 | 硬盘文件系统：如何最合理地组织档案库的文档？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/03"><span>29 | 虚拟文件系统：文件多了就需要档案管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/04"><span>30 | 文件缓存：常用文档应该放在触手可得的地方</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统">07.核心原理篇第六部分输入输出系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/01"><span>31 | 输入与输出：如何建立售前售后生态体系？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/02"><span>32 | 字符设备（上）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/03"><span>33 | 字符设备（下）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/04"><span>34 | 块设备（上）：如何建立代理商销售模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/05"><span>35 | 块设备（下）：如何建立代理商销售模式？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信">08.核心原理篇第七部分进程间通信</a><ul><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01"><span>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/02"><span>37 | 信号（上）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/03"><span>38 | 信号（下）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/04"><span>39 | 管道：项目组A完成了，如何交接给项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/05"><span>40 | IPC（上）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/06"><span>41 | IPC（中）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07"><span>42 | IPC（下）：不同项目组之间抢资源，如何协调？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统">09.核心原理篇第八部分网络系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/01"><span>43 预习 | Socket通信之网络协议基本原理</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/02"><span>43 | Socket通信：遇上特大项目，要学会和其他公司合作</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/03"><span>44 | Socket内核数据结构：如何成立特大项目合作部？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/04"><span>45 | 发送网络包（上）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/05"><span>46 | 发送网络包（下）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06"><span>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/07"><span>48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化">10.核心原理篇第九部分虚拟化</a><ul><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/01"><span>49 | 虚拟机：如何成立子公司，让公司变集团？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/02"><span>50 | 计算虚拟化之CPU（上）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/03"><span>51 | 计算虚拟化之CPU（下）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/04"><span>52 | 计算虚拟化之内存：如何建立独立的办公室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/05"><span>53 | 存储虚拟化（上）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/06"><span>54 | 存储虚拟化（下）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07"><span>55 | 网络虚拟化：如何成立独立的合作部？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化">11.核心原理篇第十部分容器化</a><ul><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/01"><span>56 | 容器：大公司为保持创新，鼓励内部创业</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/02"><span>57 | Namespace技术：内部创业公司应该独立运营</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/03"><span>58 | cgroup技术：内部创业公司应该独立核算成本</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/04"><span>59 | 数据中心操作系统：上市敲钟</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇">12.实战串讲篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/01"><span>60 | 搭建操作系统实验环境（上）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/02"><span>61 | 搭建操作系统实验环境（下）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/03"><span>62 | 知识串讲：用一个创业故事串起操作系统原理（一）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/04"><span>63 | 知识串讲：用一个创业故事串起操作系统原理（二）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/05"><span>64 | 知识串讲：用一个创业故事串起操作系统原理（三）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/06"><span>65 | 知识串讲：用一个创业故事串起操作系统原理（四）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/07"><span>66 | 知识串讲：用一个创业故事串起操作系统原理（五）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/08"><span>期末测试 | 这些操作系统问题，你真的掌握了吗？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/09"><span>结束语 | 永远别轻视任何技术，也永远别轻视自己</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐">13.专栏加餐</a><ul><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/01"><span>学习攻略（一）：学好操作系统，需要掌握哪些前置知识？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/02"><span>“趣谈Linux操作系统”食用指南</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/summary">趣谈linux操作系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="设备驱动层" data-depth="2"><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#设备驱动层"><span>设备驱动层</span></a></li><li title="网络协议栈的二层逻辑" data-depth="2"><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#网络协议栈的二层逻辑"><span>网络协议栈的二层逻辑</span></a></li><li title="网络协议栈的IP层" data-depth="2"><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#网络协议栈的ip层"><span>网络协议栈的IP层</span></a></li><li title="总结时刻" data-depth="2"><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#总结时刻"><span>总结时刻</span></a></li><li title="课堂练习" data-depth="2"><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#课堂练习"><span>课堂练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="47--接收网络包上如何搞明白合作伙伴让我们做什么"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#47--接收网络包上如何搞明白合作伙伴让我们做什么"><span class="icon icon-link"></span></a>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</h1><p>前面两节，我们分析了发送网络包的整个过程。这一节，我们来解析接收网络包的过程。</p><p>如果说网络包的发送是从应用层开始，层层调用，一直到网卡驱动程序的话，网络包的结束过程，就是一个反过来的过程，我们不能从应用层的读取开始，而应该从网卡接收到一个网络包开始。我们用两节来解析这个过程，这一节我们从硬件网卡解析到IP层，下一节，我们从IP层解析到Socket层。</p><h2 id="设备驱动层"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#设备驱动层"><span class="icon icon-link"></span></a>设备驱动层</h2><p>网卡作为一个硬件，接收到网络包，应该怎么通知操作系统，这个网络包到达了呢？咱们学习过输入输出设备和中断。没错，我们可以触发一个中断。但是这里有个问题，就是网络包的到来，往往是很难预期的。网络吞吐量比较大的时候，网络包的到达会十分频繁。这个时候，如果非常频繁地去触发中断，想想就觉得是个灾难。</p><p>比如说，CPU正在做某个事情，一些网络包来了，触发了中断，CPU停下手里的事情，去处理这些网络包，处理完毕按照中断处理的逻辑，应该回去继续处理其他事情。这个时候，另一些网络包又来了，又触发了中断，CPU手里的事情还没捂热，又要停下来去处理网络包。能不能大家要来的一起来，把网络包好好处理一把，然后再回去集中处理其他事情呢？</p><p>网络包能不能一起来，这个我们没法儿控制，但是我们可以有一种机制，就是当一些网络包到来触发了中断，内核处理完这些网络包之后，我们可以先进入主动轮询poll网卡的方式，主动去接收到来的网络包。如果一直有，就一直处理，等处理告一段落，就返回干其他的事情。当再有下一批网络包到来的时候，再中断，再轮询poll。这样就会大大减少中断的数量，提升网络处理的效率，这种处理方式我们称为<strong>NAPI</strong>。</p><p>为了帮你了解设备驱动层的工作机制，我们还是以上一节发送网络包时的网卡drivers/net/ethernet/intel/ixgb/ixgb_main.c为例子，来进行解析。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static struct pci_driver ixgb_driver = {</span></div><div class="token-line"><span class="token plain">    	.name     = ixgb_driver_name,</span></div><div class="token-line"><span class="token plain">    	.id_table = ixgb_pci_tbl,</span></div><div class="token-line"><span class="token plain">    	.probe    = ixgb_probe,</span></div><div class="token-line"><span class="token plain">    	.remove   = ixgb_remove,</span></div><div class="token-line"><span class="token plain">    	.err_handler = &amp;ixgb_err_handler</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    MODULE_AUTHOR(&quot;Intel Corporation, &lt;linux.nics@intel.com&gt;&quot;);</span></div><div class="token-line"><span class="token plain">    MODULE_DESCRIPTION(&quot;Intel(R) PRO/10GbE Network Driver&quot;);</span></div><div class="token-line"><span class="token plain">    MODULE_LICENSE(&quot;GPL&quot;);</span></div><div class="token-line"><span class="token plain">    MODULE_VERSION(DRV_VERSION);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * ixgb_init_module - Driver Registration Routine</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * ixgb_init_module is the first routine called when the driver is</span></div><div class="token-line"><span class="token plain">     * loaded. All it does is register with the PCI subsystem.</span></div><div class="token-line"><span class="token plain">     **/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int __init</span></div><div class="token-line"><span class="token plain">    ixgb_init_module(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	pr_info(&quot;%s - version %s\n&quot;, ixgb_driver_string, ixgb_driver_version);</span></div><div class="token-line"><span class="token plain">    	pr_info(&quot;%s\n&quot;, ixgb_copyright);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return pci_register_driver(&amp;ixgb_driver);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    module_init(ixgb_init_module);</span></div></pre></div><p>在网卡驱动程序初始化的时候，我们会调用ixgb_init_module，注册一个驱动ixgb_driver，并且调用它的probe函数ixgb_probe。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int</span></div><div class="token-line"><span class="token plain">    ixgb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct net_device *netdev = NULL;</span></div><div class="token-line"><span class="token plain">    	struct ixgb_adapter *adapter;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	netdev = alloc_etherdev(sizeof(struct ixgb_adapter));</span></div><div class="token-line"><span class="token plain">    	SET_NETDEV_DEV(netdev, &amp;pdev-&gt;dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	pci_set_drvdata(pdev, netdev);</span></div><div class="token-line"><span class="token plain">    	adapter = netdev_priv(netdev);</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;netdev = netdev;</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;pdev = pdev;</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;hw.back = adapter;</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	adapter-&gt;hw.hw_addr = pci_ioremap_bar(pdev, BAR_0);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	netdev-&gt;netdev_ops = &amp;ixgb_netdev_ops;</span></div><div class="token-line"><span class="token plain">    	ixgb_set_ethtool_ops(netdev);</span></div><div class="token-line"><span class="token plain">    	netdev-&gt;watchdog_timeo = 5 * HZ;</span></div><div class="token-line"><span class="token plain">    	netif_napi_add(netdev, &amp;adapter-&gt;napi, ixgb_clean, 64);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	strncpy(netdev-&gt;name, pci_name(pdev), sizeof(netdev-&gt;name) - 1);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	adapter-&gt;bd_number = cards_found;</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;link_speed = 0;</span></div><div class="token-line"><span class="token plain">    	adapter-&gt;link_duplex = 0;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在ixgb_probe中，我们会创建一个struct net_device表示这个网络设备，并且netif_napi_add函数为这个网络设备注册一个轮询poll函数ixgb_clean，将来一旦出现网络包的时候，就是要通过它来轮询了。</p><p>当一个网卡被激活的时候，我们会调用函数ixgb_open-&gt;ixgb_up，在这里面注册一个硬件的中断处理函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int</span></div><div class="token-line"><span class="token plain">    ixgb_up(struct ixgb_adapter *adapter)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct net_device *netdev = adapter-&gt;netdev;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        err = request_irq(adapter-&gt;pdev-&gt;irq, ixgb_intr, irq_flags,</span></div><div class="token-line"><span class="token plain">    	                  netdev-&gt;name, netdev);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * ixgb_intr - Interrupt Handler</span></div><div class="token-line"><span class="token plain">     * @irq: interrupt number</span></div><div class="token-line"><span class="token plain">     * @data: pointer to a network interface device structure</span></div><div class="token-line"><span class="token plain">     **/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static irqreturn_t</span></div><div class="token-line"><span class="token plain">    ixgb_intr(int irq, void *data)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct net_device *netdev = data;</span></div><div class="token-line"><span class="token plain">    	struct ixgb_adapter *adapter = netdev_priv(netdev);</span></div><div class="token-line"><span class="token plain">    	struct ixgb_hw *hw = &amp;adapter-&gt;hw;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (napi_schedule_prep(&amp;adapter-&gt;napi)) {</span></div><div class="token-line"><span class="token plain">    		IXGB_WRITE_REG(&amp;adapter-&gt;hw, IMC, ~0);</span></div><div class="token-line"><span class="token plain">    		__napi_schedule(&amp;adapter-&gt;napi);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return IRQ_HANDLED;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果一个网络包到来，触发了硬件中断，就会调用ixgb_intr，这里面会调用__napi_schedule。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * __napi_schedule - schedule for receive</span></div><div class="token-line"><span class="token plain">     * @n: entry to schedule</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * The entry&#x27;s receive function will be scheduled to run.</span></div><div class="token-line"><span class="token plain">     * Consider using __napi_schedule_irqoff() if hard irqs are masked.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    void __napi_schedule(struct napi_struct *n)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	unsigned long flags;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	local_irq_save(flags);</span></div><div class="token-line"><span class="token plain">    	____napi_schedule(this_cpu_ptr(&amp;softnet_data), n);</span></div><div class="token-line"><span class="token plain">    	local_irq_restore(flags);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static inline void ____napi_schedule(struct softnet_data *sd,</span></div><div class="token-line"><span class="token plain">    				     struct napi_struct *napi)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span></div><div class="token-line"><span class="token plain">    	__raise_softirq_irqoff(NET_RX_SOFTIRQ);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>__napi_schedule是处于中断处理的关键部分，在他被调用的时候，中断是暂时关闭的，但是处理网络包是个复杂的过程，需要到延迟处理部分，所以____napi_schedule将当前设备放到struct softnet_data结构的poll_list里面，说明在延迟处理部分可以接着处理这个poll_list里面的网络设备。</p><p>然后____napi_schedule触发一个软中断NET_RX_SOFTIRQ，通过软中断触发中断处理的延迟处理部分，也是常用的手段。</p><p>上一节，我们知道，软中断NET_RX_SOFTIRQ对应的中断处理函数是net_rx_action。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static __latent_entropy void net_rx_action(struct softirq_action *h)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data);</span></div><div class="token-line"><span class="token plain">        LIST_HEAD(list);</span></div><div class="token-line"><span class="token plain">        list_splice_init(&amp;sd-&gt;poll_list, &amp;list);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	for (;;) {</span></div><div class="token-line"><span class="token plain">    		struct napi_struct *n;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		n = list_first_entry(&amp;list, struct napi_struct, poll_list);</span></div><div class="token-line"><span class="token plain">    		budget -= napi_poll(n, &amp;repoll);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在net_rx_action中，会得到struct softnet_data结构，这个结构在发送的时候我们也遇到过。当时它的output_queue用于网络包的发送，这里的poll_list用于网络包的接收。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct softnet_data {</span></div><div class="token-line"><span class="token plain">    	struct list_head	poll_list;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	struct Qdisc		*output_queue;</span></div><div class="token-line"><span class="token plain">    	struct Qdisc		**output_queue_tailp;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在net_rx_action中，接下来是一个循环，在poll_list里面取出网络包到达的设备，然后调用napi_poll来轮询这些设备，napi_poll会调用最初设备初始化的时候，注册的poll函数，对于ixgb_driver，对应的函数是ixgb_clean。</p><p>ixgb_clean会调用ixgb_clean_rx_irq。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static bool</span></div><div class="token-line"><span class="token plain">    ixgb_clean_rx_irq(struct ixgb_adapter *adapter, int *work_done, int work_to_do)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct ixgb_desc_ring *rx_ring = &amp;adapter-&gt;rx_ring;</span></div><div class="token-line"><span class="token plain">    	struct net_device *netdev = adapter-&gt;netdev;</span></div><div class="token-line"><span class="token plain">    	struct pci_dev *pdev = adapter-&gt;pdev;</span></div><div class="token-line"><span class="token plain">    	struct ixgb_rx_desc *rx_desc, *next_rxd;</span></div><div class="token-line"><span class="token plain">    	struct ixgb_buffer *buffer_info, *next_buffer, *next2_buffer;</span></div><div class="token-line"><span class="token plain">    	u32 length;</span></div><div class="token-line"><span class="token plain">    	unsigned int i, j;</span></div><div class="token-line"><span class="token plain">    	int cleaned_count = 0;</span></div><div class="token-line"><span class="token plain">    	bool cleaned = false;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	i = rx_ring-&gt;next_to_clean;</span></div><div class="token-line"><span class="token plain">    	rx_desc = IXGB_RX_DESC(*rx_ring, i);</span></div><div class="token-line"><span class="token plain">    	buffer_info = &amp;rx_ring-&gt;buffer_info[i];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	while (rx_desc-&gt;status &amp; IXGB_RX_DESC_STATUS_DD) {</span></div><div class="token-line"><span class="token plain">    		struct sk_buff *skb;</span></div><div class="token-line"><span class="token plain">    		u8 status;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		status = rx_desc-&gt;status;</span></div><div class="token-line"><span class="token plain">    		skb = buffer_info-&gt;skb;</span></div><div class="token-line"><span class="token plain">    		buffer_info-&gt;skb = NULL;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		prefetch(skb-&gt;data - NET_IP_ALIGN);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		if (++i == rx_ring-&gt;count)</span></div><div class="token-line"><span class="token plain">    			i = 0;</span></div><div class="token-line"><span class="token plain">    		next_rxd = IXGB_RX_DESC(*rx_ring, i);</span></div><div class="token-line"><span class="token plain">    		prefetch(next_rxd);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		j = i + 1;</span></div><div class="token-line"><span class="token plain">    		if (j == rx_ring-&gt;count)</span></div><div class="token-line"><span class="token plain">    			j = 0;</span></div><div class="token-line"><span class="token plain">    		next2_buffer = &amp;rx_ring-&gt;buffer_info[j];</span></div><div class="token-line"><span class="token plain">    		prefetch(next2_buffer);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		next_buffer = &amp;rx_ring-&gt;buffer_info[i];</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		length = le16_to_cpu(rx_desc-&gt;length);</span></div><div class="token-line"><span class="token plain">    		rx_desc-&gt;length = 0;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		ixgb_check_copybreak(&amp;adapter-&gt;napi, buffer_info, length, &amp;skb);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		/* Good Receive */</span></div><div class="token-line"><span class="token plain">    		skb_put(skb, length);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		/* Receive Checksum Offload */</span></div><div class="token-line"><span class="token plain">    		ixgb_rx_checksum(adapter, rx_desc, skb);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		skb-&gt;protocol = eth_type_trans(skb, netdev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		netif_receive_skb(skb);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		/* use prefetched values */</span></div><div class="token-line"><span class="token plain">    		rx_desc = next_rxd;</span></div><div class="token-line"><span class="token plain">    		buffer_info = next_buffer;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	rx_ring-&gt;next_to_clean = i;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在网络设备的驱动层，有一个用于接收网络包的rx_ring。它是一个环，从网卡硬件接收的包会放在这个环里面。这个环里面的buffer_info[]是一个数组，存放的是网络包的内容。i和j是这个数组的下标，在ixgb_clean_rx_irq里面的while循环中，依次处理环里面的数据。在这里面，我们看到了i和j加一之后，如果超过了数组的大小，就跳回下标0，就说明这是一个环。</p><p>ixgb_check_copybreak函数将buffer_info里面的内容，拷贝到struct sk_buff *skb，从而可以作为一个网络包进行后续的处理，然后调用netif_receive_skb。</p><h2 id="网络协议栈的二层逻辑"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#网络协议栈的二层逻辑"><span class="icon icon-link"></span></a>网络协议栈的二层逻辑</h2><p>从netif_receive_skb函数开始，我们就进入了内核的网络协议栈。</p><p>接下来的调用链为：netif_receive_skb-&gt;netif_receive_skb_internal-&gt;__netif_receive_skb-&gt;__netif_receive_skb_core。</p><p>在__netif_receive_skb_core中，我们先是处理了二层的一些逻辑。例如，对于VLAN的处理，接下来要想办法交给第三层。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct packet_type *ptype, *pt_prev;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	type = skb-&gt;protocol;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	deliver_ptype_list_skb(skb, &amp;pt_prev, orig_dev, type,</span></div><div class="token-line"><span class="token plain">    			       &amp;orig_dev-&gt;ptype_specific);</span></div><div class="token-line"><span class="token plain">    	if (pt_prev) {</span></div><div class="token-line"><span class="token plain">    		ret = pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static inline void deliver_ptype_list_skb(struct sk_buff *skb,</span></div><div class="token-line"><span class="token plain">    					  struct packet_type **pt,</span></div><div class="token-line"><span class="token plain">    					  struct net_device *orig_dev,</span></div><div class="token-line"><span class="token plain">    					  __be16 type,</span></div><div class="token-line"><span class="token plain">    					  struct list_head *ptype_list)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct packet_type *ptype, *pt_prev = *pt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	list_for_each_entry_rcu(ptype, ptype_list, list) {</span></div><div class="token-line"><span class="token plain">    		if (ptype-&gt;type != type)</span></div><div class="token-line"><span class="token plain">    			continue;</span></div><div class="token-line"><span class="token plain">    		if (pt_prev)</span></div><div class="token-line"><span class="token plain">    			deliver_skb(skb, pt_prev, orig_dev);</span></div><div class="token-line"><span class="token plain">    		pt_prev = ptype;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	*pt = pt_prev;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在网络包struct sk_buff里面，二层的头里面有一个protocol，表示里面一层，也即三层是什么协议。deliver_ptype_list_skb在一个协议列表中逐个匹配。如果能够匹配到，就返回。</p><p>这些协议的注册在网络协议栈初始化的时候， inet_init函数调用dev_add_pack(&amp;ip_packet_type)，添加IP协议。协议被放在一个链表里面。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void dev_add_pack(struct packet_type *pt)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct list_head *head = ptype_head(pt);</span></div><div class="token-line"><span class="token plain">        list_add_rcu(&amp;pt-&gt;list, head);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static inline struct list_head *ptype_head(const struct packet_type *pt)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if (pt-&gt;type == htons(ETH_P_ALL))</span></div><div class="token-line"><span class="token plain">            return pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_all : &amp;ptype_all;</span></div><div class="token-line"><span class="token plain">        else</span></div><div class="token-line"><span class="token plain">            return pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_specific : &amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>假设这个时候的网络包是一个IP包，则在这个链表里面一定能够找到ip_packet_type，在__netif_receive_skb_core中会调用ip_packet_type的func函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static struct packet_type ip_packet_type __read_mostly = {</span></div><div class="token-line"><span class="token plain">    	.type = cpu_to_be16(ETH_P_IP),</span></div><div class="token-line"><span class="token plain">    	.func = ip_rcv,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>从上面的定义我们可以看出，接下来，ip_rcv会被调用。</p><h2 id="网络协议栈的ip层"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#网络协议栈的ip层"><span class="icon icon-link"></span></a>网络协议栈的IP层</h2><p>从ip_rcv函数开始，我们的处理逻辑就从二层到了三层，IP层。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	const struct iphdr *iph;</span></div><div class="token-line"><span class="token plain">    	struct net *net;</span></div><div class="token-line"><span class="token plain">    	u32 len;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	net = dev_net(dev);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	iph = ip_hdr(skb);</span></div><div class="token-line"><span class="token plain">    	len = ntohs(iph-&gt;tot_len);</span></div><div class="token-line"><span class="token plain">    	skb-&gt;transport_header = skb-&gt;network_header + iph-&gt;ihl*4;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span></div><div class="token-line"><span class="token plain">    		       net, NULL, skb, dev, NULL,</span></div><div class="token-line"><span class="token plain">    		       ip_rcv_finish);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在ip_rcv中，得到IP头，然后又遇到了我们见过多次的NF_HOOK，这次因为是接收网络包，第一个hook点是NF_INET_PRE_ROUTING，也就是iptables的PREROUTING链。如果里面有规则，则执行规则，然后调用ip_rcv_finish。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	const struct iphdr *iph = ip_hdr(skb);</span></div><div class="token-line"><span class="token plain">    	struct net_device *dev = skb-&gt;dev;</span></div><div class="token-line"><span class="token plain">    	struct rtable *rt;</span></div><div class="token-line"><span class="token plain">    	int err;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	rt = skb_rtable(skb);</span></div><div class="token-line"><span class="token plain">    .....</span></div><div class="token-line"><span class="token plain">    	return dst_input(skb);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static inline int dst_input(struct sk_buff *skb)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	return skb_dst(skb)-&gt;input(skb);</span></div></pre></div><p>ip_rcv_finish得到网络包对应的路由表，然后调用dst_input，在dst_input中，调用的是struct rtable的成员的dst的input函数。在rt_dst_alloc中，我们可以看到，input函数指向的是ip_local_deliver。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int ip_local_deliver(struct sk_buff *skb)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 *	Reassemble IP fragments.</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	struct net *net = dev_net(skb-&gt;dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (ip_is_fragment(ip_hdr(skb))) {</span></div><div class="token-line"><span class="token plain">    		if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))</span></div><div class="token-line"><span class="token plain">    			return 0;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,</span></div><div class="token-line"><span class="token plain">    		       net, NULL, skb, skb-&gt;dev, NULL,</span></div><div class="token-line"><span class="token plain">    		       ip_local_deliver_finish);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在ip_local_deliver函数中，如果IP层进行了分段，则进行重新的组合。接下来就是我们熟悉的NF_HOOK。hook点在NF_INET_LOCAL_IN，对应iptables里面的INPUT链。在经过iptables规则处理完毕后，我们调用ip_local_deliver_finish。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	__skb_pull(skb, skb_network_header_len(skb));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	int protocol = ip_hdr(skb)-&gt;protocol;</span></div><div class="token-line"><span class="token plain">    	const struct net_protocol *ipprot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	ipprot = rcu_dereference(inet_protos[protocol]);</span></div><div class="token-line"><span class="token plain">    	if (ipprot) {</span></div><div class="token-line"><span class="token plain">    		int ret;</span></div><div class="token-line"><span class="token plain">    		ret = ipprot-&gt;handler(skb);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在IP头中，有一个字段protocol用于指定里面一层的协议，在这里应该是TCP协议。于是，从inet_protos数组中，找出TCP协议对应的处理函数。这个数组的定义如下，里面的内容是struct net_protocol。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct net_protocol __rcu *inet_protos[MAX_INET_PROTOS] __read_mostly;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int inet_add_protocol(const struct net_protocol *prot, unsigned char protocol)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	return !cmpxchg((const struct net_protocol **)&amp;inet_protos[protocol],</span></div><div class="token-line"><span class="token plain">    			NULL, prot) ? 0 : -1;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int __init inet_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0)</span></div><div class="token-line"><span class="token plain">    		pr_crit(&quot;%s: Cannot add UDP protocol\n&quot;, __func__);</span></div><div class="token-line"><span class="token plain">    	if (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; 0)</span></div><div class="token-line"><span class="token plain">    		pr_crit(&quot;%s: Cannot add TCP protocol\n&quot;, __func__);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static struct net_protocol tcp_protocol = {</span></div><div class="token-line"><span class="token plain">    	.early_demux	=	tcp_v4_early_demux,</span></div><div class="token-line"><span class="token plain">    	.early_demux_handler =  tcp_v4_early_demux,</span></div><div class="token-line"><span class="token plain">    	.handler	=	tcp_v4_rcv,</span></div><div class="token-line"><span class="token plain">    	.err_handler	=	tcp_v4_err,</span></div><div class="token-line"><span class="token plain">    	.no_policy	=	1,</span></div><div class="token-line"><span class="token plain">    	.netns_ok	=	1,</span></div><div class="token-line"><span class="token plain">    	.icmp_strict_tag_validation = 1,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static struct net_protocol udp_protocol = {</span></div><div class="token-line"><span class="token plain">    	.early_demux =	udp_v4_early_demux,</span></div><div class="token-line"><span class="token plain">    	.early_demux_handler =	udp_v4_early_demux,</span></div><div class="token-line"><span class="token plain">    	.handler =	udp_rcv,</span></div><div class="token-line"><span class="token plain">    	.err_handler =	udp_err,</span></div><div class="token-line"><span class="token plain">    	.no_policy =	1,</span></div><div class="token-line"><span class="token plain">    	.netns_ok =	1,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在系统初始化的时候，网络协议栈的初始化调用的是inet_init，它会调用inet_add_protocol，将TCP协议对应的处理函数tcp_protocol、UDP协议对应的处理函数udp_protocol，放到inet_protos数组中。</p><p>在上面的网络包的接收过程中，会取出TCP协议对应的处理函数tcp_protocol，然后调用handler函数，也即tcp_v4_rcv函数。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>这一节我们讲了接收网络包的上半部分，分以下几个层次。</p><ul><li>硬件网卡接收到网络包之后，通过DMA技术，将网络包放入Ring Buffer。</li><li>硬件网卡通过中断通知CPU新的网络包的到来。</li><li>网卡驱动程序会注册中断处理函数ixgb_intr。</li><li>中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断NET_RX_SOFTIRQ触发接下来的处理过程。</li><li>NET_RX_SOFTIRQ软中断处理函数net_rx_action，net_rx_action会调用napi_poll，进而调用ixgb_clean_rx_irq，从Ring Buffer中读取数据到内核struct sk_buff。</li><li>调用netif_receive_skb进入内核网络协议栈，进行一些关于VLAN的二层逻辑处理后，调用ip_rcv进入三层IP层。</li><li>在IP层，会处理iptables规则，然后调用ip_local_deliver，交给更上层TCP层。</li><li>在TCP层调用tcp_v4_rcv。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea537a51af8ada1135101e252271626669337.dc03c92b.png" alt=""/></p><h2 id="课堂练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06#课堂练习"><span class="icon icon-link"></span></a>课堂练习</h2><p>我们没有仔细分析对于二层VLAN的处理，请你研究一下VLAN的原理，然后在代码中看一下对于VLAN的处理过程，这是一项重要的网络基础知识。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage8c378c0a95fa07a8b9a1abfd394479bdd637.f286080c.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
