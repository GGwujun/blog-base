<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>55 | 网络虚拟化：如何成立独立的合作部？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇">01.入门准备篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/01"><span>开篇词 | 为什么要学习Linux操作系统？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/02"><span>01 | 入学测验：你究竟对Linux操作系统了解多少？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/03"><span>02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述">02.核心原理篇第一部分Linux操作系统综述</a><ul><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/01"><span>03 | 你可以把Linux内核当成一家软件外包公司的老板</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/02"><span>04 | 快速上手几个Linux命令：每家公司都有自己的黑话</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/03"><span>05 | 学会几个系统调用：咱们公司能接哪些类型的项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化">03.核心原理篇第二部分系统初始化</a><ul><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/01"><span>06 | x86架构：有了开放的架构，才能打造开放的营商环境</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/02"><span>07 | 从BIOS到bootloader：创业伊始，有活儿老板自己上</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/03"><span>08 | 内核初始化：生意做大了就得成立公司</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/04"><span>09 | 系统调用：公司成立好了就要开始接项目</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理">04.核心原理篇第三部分进程管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/01"><span>10 | 进程：公司接这么多项目，如何管？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/02"><span>11 | 线程：如何让复杂的项目并行执行？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/03"><span>12 | 进程数据结构（上）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/04"><span>13 | 进程数据结构（中）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/05"><span>14 | 进程数据结构（下）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/06"><span>15 | 调度（上）：如何制定项目管理流程？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/07"><span>16 | 调度（中）：主动调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/08"><span>17 | 调度（下）：抢占式调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/09"><span>18 | 进程的创建：如何发起一个新项目？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/10"><span>19 | 线程的创建：如何执行一个新子项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理">05.核心原理篇第四部分内存管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/01"><span>20 | 内存管理（上）：为客户保密，规划进程内存空间布局</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/02"><span>21 | 内存管理（下）：为客户保密，项目组独享会议室封闭开发</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/03"><span>22 | 进程空间管理：项目组还可以自行布置会议室</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/04"><span>23 | 物理内存管理（上）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/05"><span>24 | 物理内存管理（下）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/06"><span>25 | 用户态内存映射：如何找到正确的会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/07"><span>26 | 内核态内存映射：如何找到正确的会议室？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统">06.核心原理篇第五部分文件系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/01"><span>27 | 文件系统：项目成果要归档，我们就需要档案库</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/02"><span>28 | 硬盘文件系统：如何最合理地组织档案库的文档？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/03"><span>29 | 虚拟文件系统：文件多了就需要档案管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/04"><span>30 | 文件缓存：常用文档应该放在触手可得的地方</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统">07.核心原理篇第六部分输入输出系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/01"><span>31 | 输入与输出：如何建立售前售后生态体系？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/02"><span>32 | 字符设备（上）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/03"><span>33 | 字符设备（下）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/04"><span>34 | 块设备（上）：如何建立代理商销售模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/05"><span>35 | 块设备（下）：如何建立代理商销售模式？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信">08.核心原理篇第七部分进程间通信</a><ul><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01"><span>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/02"><span>37 | 信号（上）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/03"><span>38 | 信号（下）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/04"><span>39 | 管道：项目组A完成了，如何交接给项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/05"><span>40 | IPC（上）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/06"><span>41 | IPC（中）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07"><span>42 | IPC（下）：不同项目组之间抢资源，如何协调？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统">09.核心原理篇第八部分网络系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/01"><span>43 预习 | Socket通信之网络协议基本原理</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/02"><span>43 | Socket通信：遇上特大项目，要学会和其他公司合作</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/03"><span>44 | Socket内核数据结构：如何成立特大项目合作部？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/04"><span>45 | 发送网络包（上）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/05"><span>46 | 发送网络包（下）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06"><span>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/07"><span>48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化">10.核心原理篇第九部分虚拟化</a><ul><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/01"><span>49 | 虚拟机：如何成立子公司，让公司变集团？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/02"><span>50 | 计算虚拟化之CPU（上）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/03"><span>51 | 计算虚拟化之CPU（下）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/04"><span>52 | 计算虚拟化之内存：如何建立独立的办公室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/05"><span>53 | 存储虚拟化（上）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/06"><span>54 | 存储虚拟化（下）：如何建立自己保管的单独档案库？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07"><span>55 | 网络虚拟化：如何成立独立的合作部？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化">11.核心原理篇第十部分容器化</a><ul><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/01"><span>56 | 容器：大公司为保持创新，鼓励内部创业</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/02"><span>57 | Namespace技术：内部创业公司应该独立运营</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/03"><span>58 | cgroup技术：内部创业公司应该独立核算成本</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/04"><span>59 | 数据中心操作系统：上市敲钟</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇">12.实战串讲篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/01"><span>60 | 搭建操作系统实验环境（上）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/02"><span>61 | 搭建操作系统实验环境（下）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/03"><span>62 | 知识串讲：用一个创业故事串起操作系统原理（一）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/04"><span>63 | 知识串讲：用一个创业故事串起操作系统原理（二）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/05"><span>64 | 知识串讲：用一个创业故事串起操作系统原理（三）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/06"><span>65 | 知识串讲：用一个创业故事串起操作系统原理（四）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/07"><span>66 | 知识串讲：用一个创业故事串起操作系统原理（五）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/08"><span>期末测试 | 这些操作系统问题，你真的掌握了吗？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/09"><span>结束语 | 永远别轻视任何技术，也永远别轻视自己</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐">13.专栏加餐</a><ul><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/01"><span>学习攻略（一）：学好操作系统，需要掌握哪些前置知识？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/02"><span>“趣谈Linux操作系统”食用指南</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/summary">趣谈linux操作系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="解析初始化过程" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#解析初始化过程"><span>解析初始化过程</span></a></li><li title="qemu的启动过程中的网络虚拟化" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#qemu的启动过程中的网络虚拟化"><span>qemu的启动过程中的网络虚拟化</span></a></li><li title="关联前端设备驱动和后端设备驱动" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#关联前端设备驱动和后端设备驱动"><span>关联前端设备驱动和后端设备驱动</span></a></li><li title="发送网络包过程" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#发送网络包过程"><span>发送网络包过程</span></a></li><li title="总结时刻" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#总结时刻"><span>总结时刻</span></a></li><li title="课堂练习" data-depth="2"><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#课堂练习"><span>课堂练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="55--网络虚拟化如何成立独立的合作部"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#55--网络虚拟化如何成立独立的合作部"><span class="icon icon-link"></span></a>55 | 网络虚拟化：如何成立独立的合作部？</h1><p>上一节，我们讲了存储虚拟化，这一节我们来讲网络虚拟化。</p><p>网络虚拟化有和存储虚拟化类似的地方，例如，它们都是基于virtio的，因而我们在看网络虚拟化的过程中，会看到和存储虚拟化很像的数据结构和原理。但是，网络虚拟化也有自己的特殊性。例如，存储虚拟化是将宿主机上的文件作为客户机上的硬盘，而网络虚拟化需要依赖于内核协议栈进行网络包的封装与解封装。那怎么实现客户机和宿主机之间的互通呢？我们就一起来看一看。</p><h2 id="解析初始化过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#解析初始化过程"><span class="icon icon-link"></span></a>解析初始化过程</h2><p>我们还是从Virtio Network Device这个设备的初始化讲起。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static const TypeInfo device_type_info = {</span></div><div class="token-line"><span class="token plain">        .name = TYPE_DEVICE,</span></div><div class="token-line"><span class="token plain">        .parent = TYPE_OBJECT,</span></div><div class="token-line"><span class="token plain">        .instance_size = sizeof(DeviceState),</span></div><div class="token-line"><span class="token plain">        .instance_init = device_initfn,</span></div><div class="token-line"><span class="token plain">        .instance_post_init = device_post_init,</span></div><div class="token-line"><span class="token plain">        .instance_finalize = device_finalize,</span></div><div class="token-line"><span class="token plain">        .class_base_init = device_class_base_init,</span></div><div class="token-line"><span class="token plain">        .class_init = device_class_init,</span></div><div class="token-line"><span class="token plain">        .abstract = true,</span></div><div class="token-line"><span class="token plain">        .class_size = sizeof(DeviceClass),</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static const TypeInfo virtio_device_info = {</span></div><div class="token-line"><span class="token plain">        .name = TYPE_VIRTIO_DEVICE,</span></div><div class="token-line"><span class="token plain">        .parent = TYPE_DEVICE,</span></div><div class="token-line"><span class="token plain">        .instance_size = sizeof(VirtIODevice),</span></div><div class="token-line"><span class="token plain">        .class_init = virtio_device_class_init,</span></div><div class="token-line"><span class="token plain">        .instance_finalize = virtio_device_instance_finalize,</span></div><div class="token-line"><span class="token plain">        .abstract = true,</span></div><div class="token-line"><span class="token plain">        .class_size = sizeof(VirtioDeviceClass),</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static const TypeInfo virtio_net_info = {</span></div><div class="token-line"><span class="token plain">        .name = TYPE_VIRTIO_NET,</span></div><div class="token-line"><span class="token plain">        .parent = TYPE_VIRTIO_DEVICE,</span></div><div class="token-line"><span class="token plain">        .instance_size = sizeof(VirtIONet),</span></div><div class="token-line"><span class="token plain">        .instance_init = virtio_net_instance_init,</span></div><div class="token-line"><span class="token plain">        .class_init = virtio_net_class_init,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static void virtio_register_types(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        type_register_static(&amp;virtio_net_info);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    type_init(virtio_register_types)</span></div></pre></div><p>Virtio Network Device这种类的定义是有多层继承关系的，TYPE_VIRTIO_NET的父类是TYPE_VIRTIO_DEVICE，TYPE_VIRTIO_DEVICE的父类是TYPE_DEVICE，TYPE_DEVICE的父类是TYPE_OBJECT，继承关系到头了。</p><p>type_init用于注册这种类。这里面每一层都有class_init，用于从TypeImpl生成xxxClass，也有instance_init，会将xxxClass初始化为实例。</p><p>TYPE_VIRTIO_NET层的class_init函数virtio_net_class_init，定义了DeviceClass的realize函数为virtio_net_device_realize，这一点和存储块设备是一样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static void virtio_net_device_realize(DeviceState *dev, Error **errp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        VirtIODevice *vdev = VIRTIO_DEVICE(dev);</span></div><div class="token-line"><span class="token plain">        VirtIONet *n = VIRTIO_NET(dev);</span></div><div class="token-line"><span class="token plain">        NetClientState *nc;</span></div><div class="token-line"><span class="token plain">        int i;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        virtio_init(vdev, &quot;virtio-net&quot;, VIRTIO_ID_NET, n-&gt;config_size);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /*</span></div><div class="token-line"><span class="token plain">         * We set a lower limit on RX queue size to what it always was.</span></div><div class="token-line"><span class="token plain">         * Guests that want a smaller ring can always resize it without</span></div><div class="token-line"><span class="token plain">         * help from us (using virtio 1 and up).</span></div><div class="token-line"><span class="token plain">         */</span></div><div class="token-line"><span class="token plain">        if (n-&gt;net_conf.rx_queue_size &lt; VIRTIO_NET_RX_QUEUE_MIN_SIZE ||</span></div><div class="token-line"><span class="token plain">            n-&gt;net_conf.rx_queue_size &gt; VIRTQUEUE_MAX_SIZE ||</span></div><div class="token-line"><span class="token plain">            !is_power_of_2(n-&gt;net_conf.rx_queue_size)) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (n-&gt;net_conf.tx_queue_size &lt; VIRTIO_NET_TX_QUEUE_MIN_SIZE ||</span></div><div class="token-line"><span class="token plain">            n-&gt;net_conf.tx_queue_size &gt; VIRTQUEUE_MAX_SIZE ||</span></div><div class="token-line"><span class="token plain">            !is_power_of_2(n-&gt;net_conf.tx_queue_size)) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        n-&gt;max_queues = MAX(n-&gt;nic_conf.peers.queues, 1);</span></div><div class="token-line"><span class="token plain">        if (n-&gt;max_queues * 2 + 1 &gt; VIRTIO_QUEUE_MAX) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        n-&gt;vqs = g_malloc0(sizeof(VirtIONetQueue) * n-&gt;max_queues);</span></div><div class="token-line"><span class="token plain">        n-&gt;curr_queues = 1;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        n-&gt;net_conf.tx_queue_size = MIN(virtio_net_max_tx_queue_size(n),</span></div><div class="token-line"><span class="token plain">                                        n-&gt;net_conf.tx_queue_size);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (i = 0; i &lt; n-&gt;max_queues; i++) {</span></div><div class="token-line"><span class="token plain">            virtio_net_add_queue(n, i);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        n-&gt;ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);</span></div><div class="token-line"><span class="token plain">        qemu_macaddr_default_if_unset(&amp;n-&gt;nic_conf.macaddr);</span></div><div class="token-line"><span class="token plain">        memcpy(&amp;n-&gt;mac[0], &amp;n-&gt;nic_conf.macaddr, sizeof(n-&gt;mac));</span></div><div class="token-line"><span class="token plain">        n-&gt;status = VIRTIO_NET_S_LINK_UP;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (n-&gt;netclient_type) {</span></div><div class="token-line"><span class="token plain">            n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,</span></div><div class="token-line"><span class="token plain">                                  n-&gt;netclient_type, n-&gt;netclient_name, n);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            n-&gt;nic = qemu_new_nic(&amp;net_virtio_info, &amp;n-&gt;nic_conf,</span></div><div class="token-line"><span class="token plain">                                  object_get_typename(OBJECT(dev)), dev-&gt;id, n);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里面创建了一个VirtIODevice，这一点和存储虚拟化也是一样的。virtio_init用来初始化这个设备。VirtIODevice结构里面有一个VirtQueue数组，这就是virtio前端和后端互相传数据的队列，最多有VIRTIO_QUEUE_MAX个。</p><p>刚才我们说的都是一样的地方，其实也有不一样的地方，我们下面来看。</p><p>你会发现，这里面有这样的语句n-&gt;max_queues * 2 + 1 &gt; VIRTIO_QUEUE_MAX。为什么要乘以2呢？这是因为，对于网络设备来讲，应该分发送队列和接收队列两个方向，所以乘以2。</p><p>接下来，我们调用virtio_net_add_queue来初始化队列，可以看出来，这里面就有发送tx_vq和接收rx_vq两个队列。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct VirtIONetQueue {</span></div><div class="token-line"><span class="token plain">        VirtQueue *rx_vq;</span></div><div class="token-line"><span class="token plain">        VirtQueue *tx_vq;</span></div><div class="token-line"><span class="token plain">        QEMUTimer *tx_timer;</span></div><div class="token-line"><span class="token plain">        QEMUBH *tx_bh;</span></div><div class="token-line"><span class="token plain">        uint32_t tx_waiting;</span></div><div class="token-line"><span class="token plain">        struct {</span></div><div class="token-line"><span class="token plain">            VirtQueueElement *elem;</span></div><div class="token-line"><span class="token plain">        } async_tx;</span></div><div class="token-line"><span class="token plain">        struct VirtIONet *n;</span></div><div class="token-line"><span class="token plain">    } VirtIONetQueue;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static void virtio_net_add_queue(VirtIONet *n, int index)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        VirtIODevice *vdev = VIRTIO_DEVICE(n);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        n-&gt;vqs[index].rx_vq = virtio_add_queue(vdev, n-&gt;net_conf.rx_queue_size, virtio_net_handle_rx);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        n-&gt;vqs[index].tx_vq = virtio_add_queue(vdev, n-&gt;net_conf.tx_queue_size, virtio_net_handle_tx_bh);</span></div><div class="token-line"><span class="token plain">        n-&gt;vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &amp;n-&gt;vqs[index]);</span></div><div class="token-line"><span class="token plain">        n-&gt;vqs[index].n = n;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>每个VirtQueue中，都有一个vring用来维护这个队列里面的数据；另外还有函数virtio_net_handle_rx用于处理网络包的接收；函数virtio_net_handle_tx_bh用于网络包的发送，这个函数我们后面会用到。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">NICState *qemu_new_nic(NetClientInfo *info,</span></div><div class="token-line"><span class="token plain">                           NICConf *conf,</span></div><div class="token-line"><span class="token plain">                           const char *model,</span></div><div class="token-line"><span class="token plain">                           const char *name,</span></div><div class="token-line"><span class="token plain">                           void *opaque)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        NetClientState **peers = conf-&gt;peers.ncs;</span></div><div class="token-line"><span class="token plain">        NICState *nic;</span></div><div class="token-line"><span class="token plain">        int i, queues = MAX(1, conf-&gt;peers.queues);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        nic = g_malloc0(info-&gt;size + sizeof(NetClientState) * queues);</span></div><div class="token-line"><span class="token plain">        nic-&gt;ncs = (void *)nic + info-&gt;size;</span></div><div class="token-line"><span class="token plain">        nic-&gt;conf = conf;</span></div><div class="token-line"><span class="token plain">        nic-&gt;opaque = opaque;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (i = 0; i &lt; queues; i++) {</span></div><div class="token-line"><span class="token plain">            qemu_net_client_setup(&amp;nic-&gt;ncs[i], info, peers[i], model, name, NULL);</span></div><div class="token-line"><span class="token plain">            nic-&gt;ncs[i].queue_index = i;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return nic;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static void qemu_net_client_setup(NetClientState *nc,</span></div><div class="token-line"><span class="token plain">                                      NetClientInfo *info,</span></div><div class="token-line"><span class="token plain">                                      NetClientState *peer,</span></div><div class="token-line"><span class="token plain">                                      const char *model,</span></div><div class="token-line"><span class="token plain">                                      const char *name,</span></div><div class="token-line"><span class="token plain">                                      NetClientDestructor *destructor)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        nc-&gt;info = info;</span></div><div class="token-line"><span class="token plain">        nc-&gt;model = g_strdup(model);</span></div><div class="token-line"><span class="token plain">        if (name) {</span></div><div class="token-line"><span class="token plain">            nc-&gt;name = g_strdup(name);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            nc-&gt;name = assign_name(nc, model);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        QTAILQ_INSERT_TAIL(&amp;net_clients, nc, next);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        nc-&gt;incoming_queue = qemu_new_net_queue(qemu_deliver_packet_iov, nc);</span></div><div class="token-line"><span class="token plain">        nc-&gt;destructor = destructor;</span></div><div class="token-line"><span class="token plain">        QTAILQ_INIT(&amp;nc-&gt;filters);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，qemu_new_nic会创建一个虚拟机里面的网卡。</p><h2 id="qemu的启动过程中的网络虚拟化"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#qemu的启动过程中的网络虚拟化"><span class="icon icon-link"></span></a>qemu的启动过程中的网络虚拟化</h2><p>初始化过程解析完毕以后，我们接下来从qemu的启动过程看起。</p><p>对于网卡的虚拟化，qemu的启动参数里面有关的是下面两行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">-netdev tap,fd=32,id=hostnet0,vhost=on,vhostfd=37</span></div><div class="token-line"><span class="token plain">    -device virtio-net-pci,netdev=hostnet0,id=net0,mac=fa:16:3e:d1:2d:99,bus=pci.0,addr=0x3</span></div></pre></div><p>qemu的main函数会调用net_init_clients进行网络设备的初始化，可以解析net参数，也可以在net_init_clients中解析netdev参数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int net_init_clients(Error **errp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        QTAILQ_INIT(&amp;net_clients);</span></div><div class="token-line"><span class="token plain">        if (qemu_opts_foreach(qemu_find_opts(&quot;netdev&quot;),</span></div><div class="token-line"><span class="token plain">                              net_init_netdev, NULL, errp)) {</span></div><div class="token-line"><span class="token plain">            return -1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (qemu_opts_foreach(qemu_find_opts(&quot;nic&quot;), net_param_nic, NULL, errp)) {</span></div><div class="token-line"><span class="token plain">            return -1;</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">        if (qemu_opts_foreach(qemu_find_opts(&quot;net&quot;), net_init_client, NULL, errp)) {</span></div><div class="token-line"><span class="token plain">            return -1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>net_init_clients会解析参数。上面的参数netdev会调用net_init_netdev-&gt;net_client_init-&gt;net_client_init1。</p><p>net_client_init1会根据不同的driver类型，调用不同的初始化函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(</span></div><div class="token-line"><span class="token plain">        const Netdev *netdev,</span></div><div class="token-line"><span class="token plain">        const char *name,</span></div><div class="token-line"><span class="token plain">        NetClientState *peer, Error **errp) = {</span></div><div class="token-line"><span class="token plain">            [NET_CLIENT_DRIVER_NIC]       = net_init_nic,</span></div><div class="token-line"><span class="token plain">            [NET_CLIENT_DRIVER_TAP]       = net_init_tap,</span></div><div class="token-line"><span class="token plain">            [NET_CLIENT_DRIVER_SOCKET]    = net_init_socket,</span></div><div class="token-line"><span class="token plain">            [NET_CLIENT_DRIVER_HUBPORT]   = net_init_hubport,</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>由于我们配置的driver的类型是tap，因而这里会调用net_init_tap-&gt;net_tap_init-&gt;tap_open。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define PATH_NET_TUN &quot;/dev/net/tun&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int tap_open(char *ifname, int ifname_size, int *vnet_hdr,</span></div><div class="token-line"><span class="token plain">                 int vnet_hdr_required, int mq_required, Error **errp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct ifreq ifr;</span></div><div class="token-line"><span class="token plain">        int fd, ret;</span></div><div class="token-line"><span class="token plain">        int len = sizeof(struct virtio_net_hdr);</span></div><div class="token-line"><span class="token plain">        unsigned int features;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        TFR(fd = open(PATH_NET_TUN, O_RDWR));</span></div><div class="token-line"><span class="token plain">        memset(&amp;ifr, 0, sizeof(ifr));</span></div><div class="token-line"><span class="token plain">        ifr.ifr_flags = IFF_TAP | IFF_NO_PI;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (ioctl(fd, TUNGETFEATURES, &amp;features) == -1) {</span></div><div class="token-line"><span class="token plain">            features = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (features &amp; IFF_ONE_QUEUE) {</span></div><div class="token-line"><span class="token plain">            ifr.ifr_flags |= IFF_ONE_QUEUE;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (*vnet_hdr) {</span></div><div class="token-line"><span class="token plain">            if (features &amp; IFF_VNET_HDR) {</span></div><div class="token-line"><span class="token plain">                *vnet_hdr = 1;</span></div><div class="token-line"><span class="token plain">                ifr.ifr_flags |= IFF_VNET_HDR;</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                *vnet_hdr = 0;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            ioctl(fd, TUNSETVNETHDRSZ, &amp;len);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        ret = ioctl(fd, TUNSETIFF, (void *) &amp;ifr);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        fcntl(fd, F_SETFL, O_NONBLOCK);</span></div><div class="token-line"><span class="token plain">        return fd;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在tap_open中，我们打开一个文件&quot;/dev/net/tun&quot;，然后通过ioctl操作这个文件。这是Linux内核的一项机制，和KVM机制很像。其实这就是一种通过打开这个字符设备文件，然后通过ioctl操作这个文件和内核打交道，来使用内核的能力。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage24d3243e93913b18c3ab00be5676bef334d3.png" alt=""/></p><p>为什么需要使用内核的机制呢？因为网络包需要从虚拟机里面发送到虚拟机外面，发送到宿主机上的时候，必须是一个正常的网络包才能被转发。要形成一个网络包，我们那就需要经过复杂的协议栈，协议栈的复杂咱们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/106490">发送网络包<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>那一节讲过了。</p><p>客户机会将网络包发送给qemu。qemu自己没有网络协议栈，现去实现一个也不可能，太复杂了。于是，它就要借助内核的力量。</p><p>qemu会将客户机发送给它的网络包，然后转换成为文件流，写入&quot;/dev/net/tun&quot;字符设备。就像写一个文件一样。内核中TUN/TAP字符设备驱动会收到这个写入的文件流，然后交给TUN/TAP的虚拟网卡驱动。这个驱动会将文件流再次转成网络包，交给TCP/IP栈，最终从虚拟TAP网卡tap0发出来，成为标准的网络包。后面我们会看到这个过程。</p><p>现在我们到内核里面，看一看打开&quot;/dev/net/tun&quot;字符设备后，内核会发生什么事情。内核的实现在drivers/net/tun.c文件中。这是一个字符设备驱动程序，应该符合字符设备的格式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">module_init(tun_init);</span></div><div class="token-line"><span class="token plain">    module_exit(tun_cleanup);</span></div><div class="token-line"><span class="token plain">    MODULE_DESCRIPTION(DRV_DESCRIPTION);</span></div><div class="token-line"><span class="token plain">    MODULE_AUTHOR(DRV_COPYRIGHT);</span></div><div class="token-line"><span class="token plain">    MODULE_LICENSE(&quot;GPL&quot;);</span></div><div class="token-line"><span class="token plain">    MODULE_ALIAS_MISCDEV(TUN_MINOR);</span></div><div class="token-line"><span class="token plain">    MODULE_ALIAS(&quot;devname:net/tun&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int __init tun_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ret = rtnl_link_register(&amp;tun_link_ops);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ret = misc_register(&amp;tun_miscdev);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ret = register_netdevice_notifier(&amp;tun_notifier_block);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里面注册了一个tun_miscdev字符设备，从它的定义可以看出，这就是&quot;/dev/net/tun&quot;字符设备。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static struct miscdevice tun_miscdev = {</span></div><div class="token-line"><span class="token plain">    	.minor = TUN_MINOR,</span></div><div class="token-line"><span class="token plain">    	.name = &quot;tun&quot;,</span></div><div class="token-line"><span class="token plain">    	.nodename = &quot;net/tun&quot;,</span></div><div class="token-line"><span class="token plain">    	.fops = &amp;tun_fops,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static const struct file_operations tun_fops = {</span></div><div class="token-line"><span class="token plain">    	.owner	= THIS_MODULE,</span></div><div class="token-line"><span class="token plain">    	.llseek = no_llseek,</span></div><div class="token-line"><span class="token plain">    	.read_iter  = tun_chr_read_iter,</span></div><div class="token-line"><span class="token plain">    	.write_iter = tun_chr_write_iter,</span></div><div class="token-line"><span class="token plain">    	.poll	= tun_chr_poll,</span></div><div class="token-line"><span class="token plain">    	.unlocked_ioctl	= tun_chr_ioctl,</span></div><div class="token-line"><span class="token plain">    	.open	= tun_chr_open,</span></div><div class="token-line"><span class="token plain">    	.release = tun_chr_close,</span></div><div class="token-line"><span class="token plain">    	.fasync = tun_chr_fasync,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>qemu的tap_open函数会打开这个字符设备PATH_NET_TUN。打开字符设备的过程我们不再重复。我就说一下，到了驱动这一层，调用的是tun_chr_open。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int tun_chr_open(struct inode *inode, struct file * file)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct tun_file *tfile;</span></div><div class="token-line"><span class="token plain">    	tfile = (struct tun_file *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,</span></div><div class="token-line"><span class="token plain">    					    &amp;tun_proto, 0);</span></div><div class="token-line"><span class="token plain">    	RCU_INIT_POINTER(tfile-&gt;tun, NULL);</span></div><div class="token-line"><span class="token plain">    	tfile-&gt;flags = 0;</span></div><div class="token-line"><span class="token plain">    	tfile-&gt;ifindex = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	init_waitqueue_head(&amp;tfile-&gt;wq.wait);</span></div><div class="token-line"><span class="token plain">    	RCU_INIT_POINTER(tfile-&gt;socket.wq, &amp;tfile-&gt;wq);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tfile-&gt;socket.file = file;</span></div><div class="token-line"><span class="token plain">    	tfile-&gt;socket.ops = &amp;tun_socket_ops;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	sock_init_data(&amp;tfile-&gt;socket, &amp;tfile-&gt;sk);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tfile-&gt;sk.sk_write_space = tun_sock_write_space;</span></div><div class="token-line"><span class="token plain">    	tfile-&gt;sk.sk_sndbuf = INT_MAX;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	file-&gt;private_data = tfile;</span></div><div class="token-line"><span class="token plain">    	INIT_LIST_HEAD(&amp;tfile-&gt;next);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	sock_set_flag(&amp;tfile-&gt;sk, SOCK_ZEROCOPY);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在tun_chr_open的参数里面，有一个struct file，这是代表什么文件呢？它代表的就是打开的字符设备文件&quot;/dev/net/tun&quot;，因而往这个字符设备文件中写数据，就会通过这个struct file写入。这个struct file里面的file_operations，按照字符设备打开的规则，指向的就是tun_fops。</p><p>另外，我们还需要在tun_chr_open创建了一个结构struct tun_file，并且将struct file的private_data指向它。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/* A tun_file connects an open character device to a tuntap netdevice. It</span></div><div class="token-line"><span class="token plain">     * also contains all socket related structures </span></div><div class="token-line"><span class="token plain">     * to serve as one transmit queue for tuntap device. </span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    struct tun_file {</span></div><div class="token-line"><span class="token plain">    	struct sock sk;</span></div><div class="token-line"><span class="token plain">    	struct socket socket;</span></div><div class="token-line"><span class="token plain">    	struct socket_wq wq;</span></div><div class="token-line"><span class="token plain">    	struct tun_struct __rcu *tun;</span></div><div class="token-line"><span class="token plain">    	struct fasync_struct *fasync;</span></div><div class="token-line"><span class="token plain">    	/* only used for fasnyc */</span></div><div class="token-line"><span class="token plain">    	unsigned int flags;</span></div><div class="token-line"><span class="token plain">    	union {</span></div><div class="token-line"><span class="token plain">    		u16 queue_index;</span></div><div class="token-line"><span class="token plain">    		unsigned int ifindex;</span></div><div class="token-line"><span class="token plain">    	};</span></div><div class="token-line"><span class="token plain">    	struct list_head next;</span></div><div class="token-line"><span class="token plain">    	struct tun_struct *detached;</span></div><div class="token-line"><span class="token plain">    	struct skb_array tx_array;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct tun_struct {</span></div><div class="token-line"><span class="token plain">    	struct tun_file __rcu	*tfiles[MAX_TAP_QUEUES];</span></div><div class="token-line"><span class="token plain">    	unsigned int            numqueues;</span></div><div class="token-line"><span class="token plain">    	unsigned int 		flags;</span></div><div class="token-line"><span class="token plain">    	kuid_t			owner;</span></div><div class="token-line"><span class="token plain">    	kgid_t			group;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	struct net_device	*dev;</span></div><div class="token-line"><span class="token plain">    	netdev_features_t	set_features;</span></div><div class="token-line"><span class="token plain">    	int			align;</span></div><div class="token-line"><span class="token plain">    	int			vnet_hdr_sz;</span></div><div class="token-line"><span class="token plain">    	int			sndbuf;</span></div><div class="token-line"><span class="token plain">    	struct tap_filter	txflt;</span></div><div class="token-line"><span class="token plain">    	struct sock_fprog	fprog;</span></div><div class="token-line"><span class="token plain">    	/* protected by rtnl lock */</span></div><div class="token-line"><span class="token plain">    	bool			filter_attached;</span></div><div class="token-line"><span class="token plain">    	spinlock_t lock;</span></div><div class="token-line"><span class="token plain">    	struct hlist_head flows[TUN_NUM_FLOW_ENTRIES];</span></div><div class="token-line"><span class="token plain">    	struct timer_list flow_gc_timer;</span></div><div class="token-line"><span class="token plain">    	unsigned long ageing_time;</span></div><div class="token-line"><span class="token plain">    	unsigned int numdisabled;</span></div><div class="token-line"><span class="token plain">    	struct list_head disabled;</span></div><div class="token-line"><span class="token plain">    	void *security;</span></div><div class="token-line"><span class="token plain">    	u32 flow_count;</span></div><div class="token-line"><span class="token plain">    	u32 rx_batched;</span></div><div class="token-line"><span class="token plain">    	struct tun_pcpu_stats __percpu *pcpu_stats;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static const struct proto_ops tun_socket_ops = {</span></div><div class="token-line"><span class="token plain">    	.peek_len = tun_peek_len,</span></div><div class="token-line"><span class="token plain">    	.sendmsg = tun_sendmsg,</span></div><div class="token-line"><span class="token plain">    	.recvmsg = tun_recvmsg,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在struct tun_file中，有一个成员struct tun_struct，它里面有一个struct net_device，这个用来表示宿主机上的tuntap网络设备。在struct tun_file中，还有struct socket和struct sock，因为要用到内核的网络协议栈，所以就需要这两个结构，这在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/105338">网络协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>那一节已经分析过了。</p><p>所以，按照struct tun_file的注释说的，这是一个很重要的数据结构。&quot;/dev/net/tun&quot;对应的struct file的private_data指向它，因而可以接收qemu发过来的数据。除此之外，它还可以通过struct sock来操作内核协议栈，然后将网络包从宿主机上的tuntap网络设备发出去，宿主机上的tuntap网络设备对应的struct net_device也归它管。</p><p>在qemu的tap_open函数中，打开这个字符设备文件之后，接下来要做的事情是，通过ioctl来设置宿主机的网卡TUNSETIFF。</p><p>接下来，ioctl到了内核里面，会调用tun_chr_ioctl。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static long __tun_chr_ioctl(struct file *file, unsigned int cmd,</span></div><div class="token-line"><span class="token plain">    			    unsigned long arg, int ifreq_len)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct tun_file *tfile = file-&gt;private_data;</span></div><div class="token-line"><span class="token plain">    	struct tun_struct *tun;</span></div><div class="token-line"><span class="token plain">    	void __user* argp = (void __user*)arg;</span></div><div class="token-line"><span class="token plain">    	struct ifreq ifr;</span></div><div class="token-line"><span class="token plain">    	kuid_t owner;</span></div><div class="token-line"><span class="token plain">    	kgid_t group;</span></div><div class="token-line"><span class="token plain">    	int sndbuf;</span></div><div class="token-line"><span class="token plain">    	int vnet_hdr_sz;</span></div><div class="token-line"><span class="token plain">    	unsigned int ifindex;</span></div><div class="token-line"><span class="token plain">    	int le;</span></div><div class="token-line"><span class="token plain">    	int ret;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (cmd == TUNSETIFF || cmd == TUNSETQUEUE || _IOC_TYPE(cmd) == SOCK_IOC_TYPE) {</span></div><div class="token-line"><span class="token plain">    		if (copy_from_user(&amp;ifr, argp, ifreq_len))</span></div><div class="token-line"><span class="token plain">    			return -EFAULT;</span></div><div class="token-line"><span class="token plain">    	} </span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	tun = __tun_get(tfile);</span></div><div class="token-line"><span class="token plain">    	if (cmd == TUNSETIFF) {</span></div><div class="token-line"><span class="token plain">    		ifr.ifr_name[IFNAMSIZ-1] = &#x27;\0&#x27;;</span></div><div class="token-line"><span class="token plain">    		ret = tun_set_iff(sock_net(&amp;tfile-&gt;sk), file, &amp;ifr);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		if (copy_to_user(argp, &amp;ifr, ifreq_len))</span></div><div class="token-line"><span class="token plain">    			ret = -EFAULT;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在__tun_chr_ioctl中，我们首先通过copy_from_user把配置从用户态拷贝到内核态，调用tun_set_iff设置tuntap网络设备，然后调用copy_to_user将配置结果返回。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct tun_struct *tun;</span></div><div class="token-line"><span class="token plain">    	struct tun_file *tfile = file-&gt;private_data;</span></div><div class="token-line"><span class="token plain">    	struct net_device *dev;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	char *name;</span></div><div class="token-line"><span class="token plain">    	unsigned long flags = 0;</span></div><div class="token-line"><span class="token plain">    	int queues = ifr-&gt;ifr_flags &amp; IFF_MULTI_QUEUE ?</span></div><div class="token-line"><span class="token plain">    			     MAX_TAP_QUEUES : 1;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (ifr-&gt;ifr_flags &amp; IFF_TUN) {</span></div><div class="token-line"><span class="token plain">    		/* TUN device */</span></div><div class="token-line"><span class="token plain">    		flags |= IFF_TUN;</span></div><div class="token-line"><span class="token plain">    		name = &quot;tun%d&quot;;</span></div><div class="token-line"><span class="token plain">    	} else if (ifr-&gt;ifr_flags &amp; IFF_TAP) {</span></div><div class="token-line"><span class="token plain">    		/* TAP device */</span></div><div class="token-line"><span class="token plain">    		flags |= IFF_TAP;</span></div><div class="token-line"><span class="token plain">    		name = &quot;tap%d&quot;;</span></div><div class="token-line"><span class="token plain">    	} else</span></div><div class="token-line"><span class="token plain">    		return -EINVAL;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (*ifr-&gt;ifr_name)</span></div><div class="token-line"><span class="token plain">    		name = ifr-&gt;ifr_name;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	dev = alloc_netdev_mqs(sizeof(struct tun_struct), name,</span></div><div class="token-line"><span class="token plain">    				       NET_NAME_UNKNOWN, tun_setup, queues,</span></div><div class="token-line"><span class="token plain">    				       queues);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	err = dev_get_valid_name(net, dev, name);</span></div><div class="token-line"><span class="token plain">    	dev_net_set(dev, net);</span></div><div class="token-line"><span class="token plain">    	dev-&gt;rtnl_link_ops = &amp;tun_link_ops;</span></div><div class="token-line"><span class="token plain">    	dev-&gt;ifindex = tfile-&gt;ifindex;</span></div><div class="token-line"><span class="token plain">    	dev-&gt;sysfs_groups[0] = &amp;tun_attr_group;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tun = netdev_priv(dev);</span></div><div class="token-line"><span class="token plain">    	tun-&gt;dev = dev;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;flags = flags;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;txflt.count = 0;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;vnet_hdr_sz = sizeof(struct virtio_net_hdr);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tun-&gt;align = NET_SKB_PAD;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;filter_attached = false;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;sndbuf = tfile-&gt;socket.sk-&gt;sk_sndbuf;</span></div><div class="token-line"><span class="token plain">    	tun-&gt;rx_batched = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tun_net_init(dev);</span></div><div class="token-line"><span class="token plain">    	tun_flow_init(tun);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	err = tun_attach(tun, file, false);</span></div><div class="token-line"><span class="token plain">    	err = register_netdevice(tun-&gt;dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	netif_carrier_on(tun-&gt;dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (netif_running(tun-&gt;dev))</span></div><div class="token-line"><span class="token plain">    		netif_tx_wake_all_queues(tun-&gt;dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	strcpy(ifr-&gt;ifr_name, tun-&gt;dev-&gt;name);</span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>tun_set_iff创建了struct tun_struct和struct net_device，并且将这个tuntap网络设备通过register_netdevice注册到内核中。这样，我们就能在宿主机上通过ip addr看到这个网卡了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage98fd9826223c7375bec19bd13588f3875ffd.png" alt=""/></p><p>至此宿主机上的内核的数据结构也完成了。</p><h2 id="关联前端设备驱动和后端设备驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#关联前端设备驱动和后端设备驱动"><span class="icon icon-link"></span></a>关联前端设备驱动和后端设备驱动</h2><p>下面，我们来解析在客户机中发送一个网络包的时候，会发生哪些事情。</p><p>虚拟机里面的进程发送一个网络包，通过文件系统和Socket调用网络协议栈，到达网络设备层。只不过这个不是普通的网络设备，而是virtio_net的驱动。</p><p>virtio_net的驱动程序代码在Linux操作系统的源代码里面，文件名为drivers/net/virtio_net.c。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static __init int virtio_net_driver_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        ret = register_virtio_driver(&amp;virtio_net_driver);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    module_init(virtio_net_driver_init);</span></div><div class="token-line"><span class="token plain">    module_exit(virtio_net_driver_exit);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    MODULE_DEVICE_TABLE(virtio, id_table);</span></div><div class="token-line"><span class="token plain">    MODULE_DESCRIPTION(&quot;Virtio network driver&quot;);</span></div><div class="token-line"><span class="token plain">    MODULE_LICENSE(&quot;GPL&quot;);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static struct virtio_driver virtio_net_driver = {</span></div><div class="token-line"><span class="token plain">    	.driver.name =	KBUILD_MODNAME,</span></div><div class="token-line"><span class="token plain">    	.driver.owner =	THIS_MODULE,</span></div><div class="token-line"><span class="token plain">    	.id_table =	id_table,</span></div><div class="token-line"><span class="token plain">    	.validate =	virtnet_validate,</span></div><div class="token-line"><span class="token plain">    	.probe =	virtnet_probe,</span></div><div class="token-line"><span class="token plain">    	.remove =	virtnet_remove,</span></div><div class="token-line"><span class="token plain">    	.config_changed = virtnet_config_changed,</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在virtio_net的驱动程序的初始化代码中，我们需要注册一个驱动函数virtio_net_driver。</p><p>当一个设备驱动作为一个内核模块被初始化的时候，probe函数会被调用，因而我们来看一下virtnet_probe。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int virtnet_probe(struct virtio_device *vdev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int i, err;</span></div><div class="token-line"><span class="token plain">    	struct net_device *dev;</span></div><div class="token-line"><span class="token plain">    	struct virtnet_info *vi;</span></div><div class="token-line"><span class="token plain">    	u16 max_queue_pairs;</span></div><div class="token-line"><span class="token plain">    	int mtu;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Allocate ourselves a network device with room for our info */</span></div><div class="token-line"><span class="token plain">    	dev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Set up network device as normal. */</span></div><div class="token-line"><span class="token plain">    	dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;</span></div><div class="token-line"><span class="token plain">    	dev-&gt;netdev_ops = &amp;virtnet_netdev;</span></div><div class="token-line"><span class="token plain">    	dev-&gt;features = NETIF_F_HIGHDMA;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span></div><div class="token-line"><span class="token plain">    	SET_NETDEV_DEV(dev, &amp;vdev-&gt;dev);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	/* MTU range: 68 - 65535 */</span></div><div class="token-line"><span class="token plain">    	dev-&gt;min_mtu = MIN_MTU;</span></div><div class="token-line"><span class="token plain">    	dev-&gt;max_mtu = MAX_MTU;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Set up our device-specific information */</span></div><div class="token-line"><span class="token plain">    	vi = netdev_priv(dev);</span></div><div class="token-line"><span class="token plain">    	vi-&gt;dev = dev;</span></div><div class="token-line"><span class="token plain">    	vi-&gt;vdev = vdev;</span></div><div class="token-line"><span class="token plain">    	vdev-&gt;priv = vi;</span></div><div class="token-line"><span class="token plain">    	vi-&gt;stats = alloc_percpu(struct virtnet_stats);</span></div><div class="token-line"><span class="token plain">    	INIT_WORK(&amp;vi-&gt;config_work, virtnet_config_changed_work);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	vi-&gt;max_queue_pairs = max_queue_pairs;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Allocate/initialize the rx/tx queues, and invoke find_vqs */</span></div><div class="token-line"><span class="token plain">    	err = init_vqs(vi);</span></div><div class="token-line"><span class="token plain">    	netif_set_real_num_tx_queues(dev, vi-&gt;curr_queue_pairs);</span></div><div class="token-line"><span class="token plain">    	netif_set_real_num_rx_queues(dev, vi-&gt;curr_queue_pairs);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	virtnet_init_settings(dev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	err = register_netdev(dev);</span></div><div class="token-line"><span class="token plain">    	virtio_device_ready(vdev);</span></div><div class="token-line"><span class="token plain">    	virtnet_set_queues(vi, vi-&gt;curr_queue_pairs);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在virtnet_probe中，会创建struct net_device，并且通过register_netdev注册这个网络设备，这样在客户机里面，就能看到这个网卡了。</p><p>在virtnet_probe中，还有一件重要的事情就是，init_vqs会初始化发送和接收的virtqueue。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int init_vqs(struct virtnet_info *vi)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int ret;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Allocate send &amp; receive queues */</span></div><div class="token-line"><span class="token plain">    	ret = virtnet_alloc_queues(vi);</span></div><div class="token-line"><span class="token plain">    	ret = virtnet_find_vqs(vi);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	get_online_cpus();</span></div><div class="token-line"><span class="token plain">    	virtnet_set_affinity(vi);</span></div><div class="token-line"><span class="token plain">    	put_online_cpus();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int virtnet_alloc_queues(struct virtnet_info *vi)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int i;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	vi-&gt;sq = kzalloc(sizeof(*vi-&gt;sq) * vi-&gt;max_queue_pairs, GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    	vi-&gt;rq = kzalloc(sizeof(*vi-&gt;rq) * vi-&gt;max_queue_pairs, GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	INIT_DELAYED_WORK(&amp;vi-&gt;refill, refill_work);</span></div><div class="token-line"><span class="token plain">    	for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) {</span></div><div class="token-line"><span class="token plain">    		vi-&gt;rq[i].pages = NULL;</span></div><div class="token-line"><span class="token plain">    		netif_napi_add(vi-&gt;dev, &amp;vi-&gt;rq[i].napi, virtnet_poll,</span></div><div class="token-line"><span class="token plain">    			       napi_weight);</span></div><div class="token-line"><span class="token plain">    		netif_tx_napi_add(vi-&gt;dev, &amp;vi-&gt;sq[i].napi, virtnet_poll_tx,</span></div><div class="token-line"><span class="token plain">    				  napi_tx ? napi_weight : 0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		sg_init_table(vi-&gt;rq[i].sg, ARRAY_SIZE(vi-&gt;rq[i].sg));</span></div><div class="token-line"><span class="token plain">    		ewma_pkt_len_init(&amp;vi-&gt;rq[i].mrg_avg_pkt_len);</span></div><div class="token-line"><span class="token plain">    		sg_init_table(vi-&gt;sq[i].sg, ARRAY_SIZE(vi-&gt;sq[i].sg));</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>按照上一节的virtio原理，virtqueue是一个介于客户机前端和qemu后端的一个结构，用于在这两端之间传递数据，对于网络设备来讲有发送和接收两个方向的队列。这里建立的struct virtqueue是客户机前端对于队列的管理的数据结构。</p><p>队列的实体需要通过函数virtnet_find_vqs查找或者生成，这里还会指定接收队列的callback函数为skb_recv_done，发送队列的callback函数为skb_xmit_done。那当buffer使用发生变化的时候，我们可以调用这个callback函数进行通知。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int virtnet_find_vqs(struct virtnet_info *vi)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	vq_callback_t **callbacks;</span></div><div class="token-line"><span class="token plain">    	struct virtqueue **vqs;</span></div><div class="token-line"><span class="token plain">    	int ret = -ENOMEM;</span></div><div class="token-line"><span class="token plain">    	int i, total_vqs;</span></div><div class="token-line"><span class="token plain">    	const char **names;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Allocate space for find_vqs parameters */</span></div><div class="token-line"><span class="token plain">    	vqs = kzalloc(total_vqs * sizeof(*vqs), GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    	callbacks = kmalloc(total_vqs * sizeof(*callbacks), GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    	names = kmalloc(total_vqs * sizeof(*names), GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/* Allocate/initialize parameters for send/receive virtqueues */</span></div><div class="token-line"><span class="token plain">    	for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) {</span></div><div class="token-line"><span class="token plain">    		callbacks[rxq2vq(i)] = skb_recv_done;</span></div><div class="token-line"><span class="token plain">    		callbacks[txq2vq(i)] = skb_xmit_done;</span></div><div class="token-line"><span class="token plain">    		names[rxq2vq(i)] = vi-&gt;rq[i].name;</span></div><div class="token-line"><span class="token plain">    		names[txq2vq(i)] = vi-&gt;sq[i].name;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	ret = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, total_vqs, vqs, callbacks, names, ctx, NULL);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) {</span></div><div class="token-line"><span class="token plain">    		vi-&gt;rq[i].vq = vqs[rxq2vq(i)];</span></div><div class="token-line"><span class="token plain">    		vi-&gt;rq[i].min_buf_len = mergeable_min_buf_len(vi, vi-&gt;rq[i].vq);</span></div><div class="token-line"><span class="token plain">    		vi-&gt;sq[i].vq = vqs[txq2vq(i)];</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里的find_vqs是在struct virtnet_info里的struct virtio_device里的struct virtio_config_ops *config里面定义的。</p><p>根据virtio_config_ops的定义，find_vqs会调用vp_modern_find_vqs，到这一步和块设备是一样的了。</p><p>在vp_modern_find_vqs中，vp_find_vqs会调用vp_find_vqs_intx。在vp_find_vqs_intx中，通过request_irq注册一个中断处理函数vp_interrupt。当设备向队列中写入信息时，会产生一个中断，也就是vq中断。中断处理函数需要调用相应的队列的回调函数，然后根据队列的数目，依次调用vp_setup_vq完成virtqueue、vring的分配和初始化。</p><p>同样，这些数据结构会和virtio后端的VirtIODevice、VirtQueue、vring对应起来，都应该指向刚才创建的那一段内存。</p><p>客户机同样会通过调用专门给外部设备发送指令的函数iowrite告诉外部的pci设备，这些共享内存的地址。</p><p>至此前端设备驱动和后端设备驱动之间的两个收发队列就关联好了，这两个队列的格式和块设备是一样的。</p><h2 id="发送网络包过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#发送网络包过程"><span class="icon icon-link"></span></a>发送网络包过程</h2><p>接下来，我们来看当真的发送一个网络包的时候，会发生什么。</p><p>当网络包经过客户机的协议栈到达virtio_net驱动的时候，按照net_device_ops的定义，start_xmit会被调用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static const struct net_device_ops virtnet_netdev = {</span></div><div class="token-line"><span class="token plain">    	.ndo_open            = virtnet_open,</span></div><div class="token-line"><span class="token plain">    	.ndo_stop   	     = virtnet_close,</span></div><div class="token-line"><span class="token plain">    	.ndo_start_xmit      = start_xmit,</span></div><div class="token-line"><span class="token plain">    	.ndo_validate_addr   = eth_validate_addr,</span></div><div class="token-line"><span class="token plain">    	.ndo_set_mac_address = virtnet_set_mac_address,</span></div><div class="token-line"><span class="token plain">    	.ndo_set_rx_mode     = virtnet_set_rx_mode,</span></div><div class="token-line"><span class="token plain">    	.ndo_get_stats64     = virtnet_stats,</span></div><div class="token-line"><span class="token plain">    	.ndo_vlan_rx_add_vid = virtnet_vlan_rx_add_vid,</span></div><div class="token-line"><span class="token plain">    	.ndo_vlan_rx_kill_vid = virtnet_vlan_rx_kill_vid,</span></div><div class="token-line"><span class="token plain">    	.ndo_xdp		= virtnet_xdp,</span></div><div class="token-line"><span class="token plain">    	.ndo_features_check	= passthru_features_check,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>接下来的调用链为：start_xmit-&gt;xmit_skb-&gt; virtqueue_add_outbuf-&gt;virtqueue_add，将网络包放入队列中，并调用virtqueue_notify通知接收方。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct virtnet_info *vi = netdev_priv(dev);</span></div><div class="token-line"><span class="token plain">    	int qnum = skb_get_queue_mapping(skb);</span></div><div class="token-line"><span class="token plain">    	struct send_queue *sq = &amp;vi-&gt;sq[qnum];</span></div><div class="token-line"><span class="token plain">    	int err;</span></div><div class="token-line"><span class="token plain">    	struct netdev_queue *txq = netdev_get_tx_queue(dev, qnum);</span></div><div class="token-line"><span class="token plain">    	bool kick = !skb-&gt;xmit_more;</span></div><div class="token-line"><span class="token plain">    	bool use_napi = sq-&gt;napi.weight;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	/* Try to transmit */</span></div><div class="token-line"><span class="token plain">    	err = xmit_skb(sq, skb);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (kick || netif_xmit_stopped(txq))</span></div><div class="token-line"><span class="token plain">    		virtqueue_kick(sq-&gt;vq);</span></div><div class="token-line"><span class="token plain">    	return NETDEV_TX_OK;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    bool virtqueue_kick(struct virtqueue *vq)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	if (virtqueue_kick_prepare(vq))</span></div><div class="token-line"><span class="token plain">    		return virtqueue_notify(vq);</span></div><div class="token-line"><span class="token plain">    	return true;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>写入一个I/O会使得qemu触发VM exit，这个逻辑我们在解析CPU的时候看到过。</p><p>接下来，我们那会调用VirtQueue的handle_output函数。前面我们已经设置过这个函数了，其实就是virtio_net_handle_tx_bh。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static void virtio_net_handle_tx_bh(VirtIODevice *vdev, VirtQueue *vq)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        VirtIONet *n = VIRTIO_NET(vdev);</span></div><div class="token-line"><span class="token plain">        VirtIONetQueue *q = &amp;n-&gt;vqs[vq2q(virtio_get_queue_index(vq))];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        q-&gt;tx_waiting = 1;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        virtio_queue_set_notification(vq, 0);</span></div><div class="token-line"><span class="token plain">        qemu_bh_schedule(q-&gt;tx_bh);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>virtio_net_handle_tx_bh调用了qemu_bh_schedule，而在virtio_net_add_queue中调用qemu_bh_new，并把函数设置为virtio_net_tx_bh。</p><p>virtio_net_tx_bh函数调用发送函数virtio_net_flush_tx。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int32_t virtio_net_flush_tx(VirtIONetQueue *q)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        VirtIONet *n = q-&gt;n;</span></div><div class="token-line"><span class="token plain">        VirtIODevice *vdev = VIRTIO_DEVICE(n);</span></div><div class="token-line"><span class="token plain">        VirtQueueElement *elem;</span></div><div class="token-line"><span class="token plain">        int32_t num_packets = 0;</span></div><div class="token-line"><span class="token plain">        int queue_index = vq2q(virtio_get_queue_index(q-&gt;tx_vq));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (;;) {</span></div><div class="token-line"><span class="token plain">            ssize_t ret;</span></div><div class="token-line"><span class="token plain">            unsigned int out_num;</span></div><div class="token-line"><span class="token plain">            struct iovec sg[VIRTQUEUE_MAX_SIZE], sg2[VIRTQUEUE_MAX_SIZE + 1], *out_sg;</span></div><div class="token-line"><span class="token plain">            struct virtio_net_hdr_mrg_rxbuf mhdr;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            elem = virtqueue_pop(q-&gt;tx_vq, sizeof(VirtQueueElement));</span></div><div class="token-line"><span class="token plain">            out_num = elem-&gt;out_num;</span></div><div class="token-line"><span class="token plain">            out_sg = elem-&gt;out_sg;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">            ret = qemu_sendv_packet_async(qemu_get_subqueue(n-&gt;nic, queue_index),out_sg, out_num, virtio_net_tx_complete);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        return num_packets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>virtio_net_flush_tx会调用virtqueue_pop。这里面，我们能看到对于vring的操作，也即从这里面将客户机里面写入的数据读取出来。</p><p>然后，我们调用qemu_sendv_packet_async发送网络包。接下来的调用链为：qemu_sendv_packet_async-&gt;qemu_net_queue_send_iov-&gt;qemu_net_queue_flush-&gt;qemu_net_queue_deliver。</p><p>在qemu_net_queue_deliver中，我们会调用NetQueue的deliver函数。前面qemu_new_net_queue会把deliver函数设置为qemu_deliver_packet_iov。它会调用nc-&gt;info-&gt;receive_iov。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static NetClientInfo net_tap_info = {</span></div><div class="token-line"><span class="token plain">        .type = NET_CLIENT_DRIVER_TAP,</span></div><div class="token-line"><span class="token plain">        .size = sizeof(TAPState),</span></div><div class="token-line"><span class="token plain">        .receive = tap_receive,</span></div><div class="token-line"><span class="token plain">        .receive_raw = tap_receive_raw,</span></div><div class="token-line"><span class="token plain">        .receive_iov = tap_receive_iov,</span></div><div class="token-line"><span class="token plain">        .poll = tap_poll,</span></div><div class="token-line"><span class="token plain">        .cleanup = tap_cleanup,</span></div><div class="token-line"><span class="token plain">        .has_ufo = tap_has_ufo,</span></div><div class="token-line"><span class="token plain">        .has_vnet_hdr = tap_has_vnet_hdr,</span></div><div class="token-line"><span class="token plain">        .has_vnet_hdr_len = tap_has_vnet_hdr_len,</span></div><div class="token-line"><span class="token plain">        .using_vnet_hdr = tap_using_vnet_hdr,</span></div><div class="token-line"><span class="token plain">        .set_offload = tap_set_offload,</span></div><div class="token-line"><span class="token plain">        .set_vnet_hdr_len = tap_set_vnet_hdr_len,</span></div><div class="token-line"><span class="token plain">        .set_vnet_le = tap_set_vnet_le,</span></div><div class="token-line"><span class="token plain">        .set_vnet_be = tap_set_vnet_be,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>根据net_tap_info的定义调用的是tap_receive_iov。他会调用tap_write_packet-&gt;writev写入这个字符设备。</p><p>在内核的字符设备驱动中，tun_chr_write_iter会被调用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static ssize_t tun_chr_write_iter(struct kiocb *iocb, struct iov_iter *from)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct file *file = iocb-&gt;ki_filp;</span></div><div class="token-line"><span class="token plain">    	struct tun_struct *tun = tun_get(file);</span></div><div class="token-line"><span class="token plain">    	struct tun_file *tfile = file-&gt;private_data;</span></div><div class="token-line"><span class="token plain">    	ssize_t result;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	result = tun_get_user(tun, tfile, NULL, from,</span></div><div class="token-line"><span class="token plain">    			      file-&gt;f_flags &amp; O_NONBLOCK, false);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	tun_put(tun);</span></div><div class="token-line"><span class="token plain">    	return result;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当我们使用writev()系统调用向tun/tap设备的字符设备文件写入数据时，tun_chr_write函数将被调用。它会使用tun_get_user，从用户区接收数据，将数据存入skb中，然后调用关键的函数netif_rx_ni(skb) ，将skb送给tcp/ip协议栈处理，最终完成虚拟网卡的数据接收。</p><p>至此，从虚拟机内部到宿主机的网络传输过程才算结束。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>最后，我们把网络虚拟化场景下网络包的发送过程总结一下。</p><ul><li>在虚拟机里面的用户态，应用程序通过write系统调用写入socket。</li><li>写入的内容经过VFS层，内核协议栈，到达虚拟机里面的内核的网络设备驱动，也即virtio_net。</li><li>virtio_net网络设备有一个操作结构struct net_device_ops，里面定义了发送一个网络包调用的函数为start_xmit。</li><li>在virtio_net的前端驱动和qemu中的后端驱动之间，有两个队列virtqueue，一个用于发送，一个用于接收。然后，我们需要在start_xmit中调用virtqueue_add，将网络包放入发送队列，然后调用virtqueue_notify通知qemu。</li><li>qemu本来处于KVM_RUN的状态，收到通知后，通过VM exit指令退出客户机模式，进入宿主机模式。发送网络包的时候，virtio_net_handle_tx_bh函数会被调用。</li><li>接下来是一个for循环，我们需要在循环中调用virtqueue_pop，从传输队列中获取要发送的数据，然后调用qemu_sendv_packet_async进行发送。</li><li>qemu会调用writev向字符设备文件写入，进入宿主机的内核。</li><li>在宿主机内核中字符设备文件的file_operations里面的write_iter会被调用，也即会调用tun_chr_write_iter。</li><li>在tun_chr_write_iter函数中，tun_get_user将要发送的网络包从qemu拷贝到宿主机内核里面来，然后调用netif_rx_ni开始调用宿主机内核协议栈进行处理。</li><li>宿主机内核协议栈处理完毕之后，会发送给tap虚拟网卡，完成从虚拟机里面到宿主机的整个发送过程。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimagee344e329505cfcd367612f8ae47054ec8e44.jpg" alt=""/></p><h2 id="课堂练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07#课堂练习"><span class="icon icon-link"></span></a>课堂练习</h2><p>这一节我们解析的是发送过程，请你根据类似的思路，解析一下接收过程。</p><p>欢迎留言和我分享你的疑惑和见解，也欢迎收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage8c378c0a95fa07a8b9a1abfd394479bdd637.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:35:29</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
