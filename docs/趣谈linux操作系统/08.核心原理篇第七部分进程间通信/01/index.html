<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>36 | 进程间通信：遇到大项目需要项目组之间的合作才行 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇">01.入门准备篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/01"><span>开篇词 | 为什么要学习Linux操作系统？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/02"><span>01 | 入学测验：你究竟对Linux操作系统了解多少？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/03"><span>02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述">02.核心原理篇第一部分Linux操作系统综述</a><ul><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/01"><span>03 | 你可以把Linux内核当成一家软件外包公司的老板</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/02"><span>04 | 快速上手几个Linux命令：每家公司都有自己的黑话</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/03"><span>05 | 学会几个系统调用：咱们公司能接哪些类型的项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化">03.核心原理篇第二部分系统初始化</a><ul><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/01"><span>06 | x86架构：有了开放的架构，才能打造开放的营商环境</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/02"><span>07 | 从BIOS到bootloader：创业伊始，有活儿老板自己上</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/03"><span>08 | 内核初始化：生意做大了就得成立公司</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/04"><span>09 | 系统调用：公司成立好了就要开始接项目</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理">04.核心原理篇第三部分进程管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/01"><span>10 | 进程：公司接这么多项目，如何管？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/02"><span>11 | 线程：如何让复杂的项目并行执行？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/03"><span>12 | 进程数据结构（上）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/04"><span>13 | 进程数据结构（中）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/05"><span>14 | 进程数据结构（下）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/06"><span>15 | 调度（上）：如何制定项目管理流程？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/07"><span>16 | 调度（中）：主动调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/08"><span>17 | 调度（下）：抢占式调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/09"><span>18 | 进程的创建：如何发起一个新项目？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/10"><span>19 | 线程的创建：如何执行一个新子项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理">05.核心原理篇第四部分内存管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/01"><span>20 | 内存管理（上）：为客户保密，规划进程内存空间布局</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/02"><span>21 | 内存管理（下）：为客户保密，项目组独享会议室封闭开发</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/03"><span>22 | 进程空间管理：项目组还可以自行布置会议室</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/04"><span>23 | 物理内存管理（上）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/05"><span>24 | 物理内存管理（下）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/06"><span>25 | 用户态内存映射：如何找到正确的会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/07"><span>26 | 内核态内存映射：如何找到正确的会议室？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统">06.核心原理篇第五部分文件系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/01"><span>27 | 文件系统：项目成果要归档，我们就需要档案库</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/02"><span>28 | 硬盘文件系统：如何最合理地组织档案库的文档？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/03"><span>29 | 虚拟文件系统：文件多了就需要档案管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/04"><span>30 | 文件缓存：常用文档应该放在触手可得的地方</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统">07.核心原理篇第六部分输入输出系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/01"><span>31 | 输入与输出：如何建立售前售后生态体系？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/02"><span>32 | 字符设备（上）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/03"><span>33 | 字符设备（下）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/04"><span>34 | 块设备（上）：如何建立代理商销售模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/05"><span>35 | 块设备（下）：如何建立代理商销售模式？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信">08.核心原理篇第七部分进程间通信</a><ul><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01"><span>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/02"><span>37 | 信号（上）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/03"><span>38 | 信号（下）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/04"><span>39 | 管道：项目组A完成了，如何交接给项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/05"><span>40 | IPC（上）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/06"><span>41 | IPC（中）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07"><span>42 | IPC（下）：不同项目组之间抢资源，如何协调？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统">09.核心原理篇第八部分网络系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/01"><span>43 预习 | Socket通信之网络协议基本原理</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/02"><span>43 | Socket通信：遇上特大项目，要学会和其他公司合作</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/03"><span>44 | Socket内核数据结构：如何成立特大项目合作部？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/04"><span>45 | 发送网络包（上）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/05"><span>46 | 发送网络包（下）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06"><span>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/07"><span>48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化">10.核心原理篇第九部分虚拟化</a><ul><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/01"><span>49 | 虚拟机：如何成立子公司，让公司变集团？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/02"><span>50 | 计算虚拟化之CPU（上）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/03"><span>51 | 计算虚拟化之CPU（下）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/04"><span>52 | 计算虚拟化之内存：如何建立独立的办公室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/05"><span>53 | 存储虚拟化（上）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/06"><span>54 | 存储虚拟化（下）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07"><span>55 | 网络虚拟化：如何成立独立的合作部？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化">11.核心原理篇第十部分容器化</a><ul><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/01"><span>56 | 容器：大公司为保持创新，鼓励内部创业</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/02"><span>57 | Namespace技术：内部创业公司应该独立运营</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/03"><span>58 | cgroup技术：内部创业公司应该独立核算成本</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/04"><span>59 | 数据中心操作系统：上市敲钟</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇">12.实战串讲篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/01"><span>60 | 搭建操作系统实验环境（上）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/02"><span>61 | 搭建操作系统实验环境（下）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/03"><span>62 | 知识串讲：用一个创业故事串起操作系统原理（一）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/04"><span>63 | 知识串讲：用一个创业故事串起操作系统原理（二）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/05"><span>64 | 知识串讲：用一个创业故事串起操作系统原理（三）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/06"><span>65 | 知识串讲：用一个创业故事串起操作系统原理（四）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/07"><span>66 | 知识串讲：用一个创业故事串起操作系统原理（五）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/08"><span>期末测试 | 这些操作系统问题，你真的掌握了吗？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/09"><span>结束语 | 永远别轻视任何技术，也永远别轻视自己</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐">13.专栏加餐</a><ul><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/01"><span>学习攻略（一）：学好操作系统，需要掌握哪些前置知识？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/02"><span>“趣谈Linux操作系统”食用指南</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/summary">趣谈linux操作系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="管道模型" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#管道模型"><span>管道模型</span></a></li><li title="消息队列模型" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#消息队列模型"><span>消息队列模型</span></a></li><li title="共享内存模型" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#共享内存模型"><span>共享内存模型</span></a></li><li title="信号量" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#信号量"><span>信号量</span></a></li><li title="信号" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#信号"><span>信号</span></a></li><li title="总结时刻" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#总结时刻"><span>总结时刻</span></a></li><li title="课堂练习" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#课堂练习"><span>课堂练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="36--进程间通信遇到大项目需要项目组之间的合作才行"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#36--进程间通信遇到大项目需要项目组之间的合作才行"><span class="icon icon-link"></span></a>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</h1><p>前面咱们接项目的时候，主要强调项目之间的隔离性。这是因为，我们刚开始接的都是小项目。随着我们接的项目越来越多，就难免遇到大项目，这就需要多个项目组进行合作才能完成。</p><p>两个项目组应该通过什么样的方式进行沟通与合作呢？作为老板，你应该如何设计整个流程呢？</p><h2 id="管道模型"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#管道模型"><span class="icon icon-link"></span></a>管道模型</h2><p>好在有这么多成熟的项目管理流程可以参考。最最传统的模型就是软件开发的<strong>瀑布模型</strong>（Waterfall Model）。所谓的瀑布模型，其实就是将整个软件开发过程分成多个阶段，往往是上一个阶段完全做完，才将输出结果交给下一个阶段。就像下面这张图展示的一样。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageedc9ed1fd2ede7a8fef5508c877e722345c9.6a7d0a8e.png" alt=""/></p><p>这种模型类似进程间通信的<strong>管道模型</strong>。还记得咱们最初学Linux命令的时候，有下面这样一行命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ps -ef | grep 关键字 | awk &#x27;{print $2}&#x27; | xargs kill -9</span></div></pre></div><p>这里面的竖线“|”就是一个管道。它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行。</p><p>管道分为两种类型，“|” 表示的管道称为<strong>匿名管道</strong>，意思就是这个类型的管道没有名字，用完了就销毁了。就像上面那个命令里面的一样，竖线代表的管道随着命令的执行自动创建、自动销毁。用户甚至都不知道自己在用管道这种技术，就已经解决了问题。所以这也是面试题里面经常会问的，到时候千万别说这是竖线，而要回答背后的机制，管道。</p><p>另外一种类型是<strong>命名管道</strong>。这个类型的管道需要通过mkfifo命令显式地创建。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mkfifo hello</span></div></pre></div><p>hello就是这个管道的名称。管道以文件的形式存在，这也符合Linux里面一切皆文件的原则。这个时候，我们ls一下，可以看到，这个文件的类型是p，就是pipe的意思。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># ls -l</span></div><div class="token-line"><span class="token plain">    prw-r--r--  1 root root         0 May 21 23:29 hello</span></div></pre></div><p>接下来，我们可以往管道里面写入东西。例如，写入一个字符串。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># echo &quot;hello world&quot; &gt; hello</span></div></pre></div><p>这个时候，管道里面的内容没有被读出，这个命令就是停在这里的，这说明当一个项目组要把它的输出交接给另一个项目组做输入，当没有交接完毕的时候，前一个项目组是不能撒手不管的。</p><p>这个时候，我们就需要重新连接一个终端。在终端中，用下面的命令读取管道里面的内容：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># cat &lt; hello </span></div><div class="token-line"><span class="token plain">    hello world</span></div></pre></div><p>一方面，我们能够看到，管道里面的内容被读取出来，打印到了终端上；另一方面，echo那个命令正常退出了，也即交接完毕，前一个项目组就完成了使命，可以解散了。</p><p>我们可以看出，瀑布模型的开发流程效率比较低下，因为团队之间无法频繁地沟通。而且，管道的使用模式，也不适合进程间频繁地交换数据。</p><p>于是，我们还得想其他的办法，例如我们是不是可以借鉴传统外企的沟通方式——邮件。邮件有一定的格式，例如抬头，正文，附件等，发送邮件可以建立收件人列表，所有在这个列表中的人，都可以反复地在此邮件基础上回复，达到频繁沟通的目的。</p><h2 id="消息队列模型"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#消息队列模型"><span class="icon icon-link"></span></a>消息队列模型</h2><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageaca4ac6ad6c9e7e3831f6d813113ae1c5ba4.ddd88225.png" alt=""/></p><p>这种模型类似进程间通信的消息队列模型。和管道将信息一股脑儿地从一个进程，倒给另一个进程不同，消息队列有点儿像邮件，发送数据时，会分成一个一个独立的数据单元，也就是消息体，每个消息体都是固定大小的存储块，在字节流上不连续。</p><p>这个消息结构的定义我写在下面了。这里面的类型type和正文text没有强制规定，只要消息的发送方和接收方约定好即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct msg_buffer {</span></div><div class="token-line"><span class="token plain">        long mtype;</span></div><div class="token-line"><span class="token plain">        char mtext[1024];</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>接下来，我们需要创建一个消息队列，使用<strong>msgget函数</strong>。这个函数需要有一个参数key，这是消息队列的唯一标识，应该是唯一的。如何保持唯一性呢？这个还是和文件关联。</p><p>我们可以指定一个文件，ftok会根据这个文件的inode，生成一个近乎唯一的key。只要在这个消息队列的生命周期内，这个文件不要被删除就可以了。只要不删除，无论什么时刻，再调用ftok，也会得到同样的key。这种key的使用方式在这一章会经常遇到，这是因为它们都属于System V IPC进程间通信机制体系中。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;stdlib.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/msg.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">      int messagequeueid;</span></div><div class="token-line"><span class="token plain">      key_t key;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if((key = ftok(&quot;/root/messagequeue/messagequeuekey&quot;, 1024)) &lt; 0)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">          perror(&quot;ftok error&quot;);</span></div><div class="token-line"><span class="token plain">          exit(1);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      printf(&quot;Message Queue key: %d.\n&quot;, key);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if ((messagequeueid = msgget(key, IPC_CREAT|0777)) == -1)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">          perror(&quot;msgget error&quot;);</span></div><div class="token-line"><span class="token plain">          exit(1);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      printf(&quot;Message queue id: %d.\n&quot;, messagequeueid);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在运行上面这个程序之前，我们先使用命令touch messagequeuekey，创建一个文件，然后多次执行的结果就会像下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># ./a.out </span></div><div class="token-line"><span class="token plain">    Message Queue key: 92536.</span></div><div class="token-line"><span class="token plain">    Message queue id: 32768.</span></div></pre></div><p>System V IPC体系有一个统一的命令行工具：ipcmk，ipcs和ipcrm用于创建、查看和删除IPC对象。</p><p>例如，ipcs -q就能看到上面我们创建的消息队列对象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># ipcs -q</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ------ Message Queues --------</span></div><div class="token-line"><span class="token plain">    key        msqid      owner      perms      used-bytes   messages    </span></div><div class="token-line"><span class="token plain">    0x00016978 32768      root       777        0            0</span></div></pre></div><p>接下来，我们来看如何发送信息。发送消息主要调用<strong>msgsnd函数</strong>。第一个参数是message queue的id，第二个参数是消息的结构体，第三个参数是消息的长度，最后一个参数是flag。这里IPC_NOWAIT表示发送的时候不阻塞，直接返回。</p><p>下面的这段程序，getopt_long、do-while循环以及switch，是用来解析命令行参数的。命令行参数的格式定义在long_options里面。每一项的第一个成员“id”“type”“message”是参数选项的全称，第二个成员都为1，表示参数选项后面要跟参数，最后一个成员’i’‘t’&#x27;m’是参数选项的简称。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;stdlib.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/msg.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;getopt.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct msg_buffer {</span></div><div class="token-line"><span class="token plain">        long mtype;</span></div><div class="token-line"><span class="token plain">        char mtext[1024];</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main(int argc, char *argv[]) {</span></div><div class="token-line"><span class="token plain">      int next_option;</span></div><div class="token-line"><span class="token plain">      const char* const short_options = &quot;i:t:m:&quot;;</span></div><div class="token-line"><span class="token plain">      const struct option long_options[] = {</span></div><div class="token-line"><span class="token plain">        { &quot;id&quot;, 1, NULL, &#x27;i&#x27;},</span></div><div class="token-line"><span class="token plain">        { &quot;type&quot;, 1, NULL, &#x27;t&#x27;},</span></div><div class="token-line"><span class="token plain">        { &quot;message&quot;, 1, NULL, &#x27;m&#x27;},</span></div><div class="token-line"><span class="token plain">        { NULL, 0, NULL, 0 }</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      int messagequeueid = -1;</span></div><div class="token-line"><span class="token plain">      struct msg_buffer buffer;</span></div><div class="token-line"><span class="token plain">      buffer.mtype = -1;</span></div><div class="token-line"><span class="token plain">      int len = -1;</span></div><div class="token-line"><span class="token plain">      char * message = NULL;</span></div><div class="token-line"><span class="token plain">      do {</span></div><div class="token-line"><span class="token plain">        next_option = getopt_long (argc, argv, short_options, long_options, NULL);</span></div><div class="token-line"><span class="token plain">        switch (next_option)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">          case &#x27;i&#x27;:</span></div><div class="token-line"><span class="token plain">            messagequeueid = atoi(optarg);</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">          case &#x27;t&#x27;:</span></div><div class="token-line"><span class="token plain">            buffer.mtype = atol(optarg);</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">          case &#x27;m&#x27;:</span></div><div class="token-line"><span class="token plain">            message = optarg;</span></div><div class="token-line"><span class="token plain">            len = strlen(message) + 1;</span></div><div class="token-line"><span class="token plain">            if (len &gt; 1024) {</span></div><div class="token-line"><span class="token plain">              perror(&quot;message too long.&quot;);</span></div><div class="token-line"><span class="token plain">              exit(1);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            memcpy(buffer.mtext, message, len);</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">          default:</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }while(next_option != -1);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if(messagequeueid != -1 &amp;&amp; buffer.mtype != -1 &amp;&amp; len != -1 &amp;&amp; message != NULL){</span></div><div class="token-line"><span class="token plain">        if(msgsnd(messagequeueid, &amp;buffer, len, IPC_NOWAIT) == -1){</span></div><div class="token-line"><span class="token plain">          perror(&quot;fail to send message.&quot;);</span></div><div class="token-line"><span class="token plain">          exit(1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        perror(&quot;arguments error&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，我们可以编译并运行这个发送程序。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gcc -o send sendmessage.c</span></div><div class="token-line"><span class="token plain">    ./send -i 32768 -t 123 -m &quot;hello world&quot;</span></div></pre></div><p>接下来，我们再来看如何收消息。收消息主要调用<strong>msgrcv函数</strong>，第一个参数是message queue的id，第二个参数是消息的结构体，第三个参数是可接受的最大长度，第四个参数是消息类型,最后一个参数是flag，这里IPC_NOWAIT表示接收的时候不阻塞，直接返回。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;stdlib.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/msg.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;getopt.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct msg_buffer {</span></div><div class="token-line"><span class="token plain">        long mtype;</span></div><div class="token-line"><span class="token plain">        char mtext[1024];</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main(int argc, char *argv[]) {</span></div><div class="token-line"><span class="token plain">      int next_option;</span></div><div class="token-line"><span class="token plain">      const char* const short_options = &quot;i:t:&quot;;</span></div><div class="token-line"><span class="token plain">      const struct option long_options[] = {</span></div><div class="token-line"><span class="token plain">        { &quot;id&quot;, 1, NULL, &#x27;i&#x27;},</span></div><div class="token-line"><span class="token plain">        { &quot;type&quot;, 1, NULL, &#x27;t&#x27;},</span></div><div class="token-line"><span class="token plain">        { NULL, 0, NULL, 0 }</span></div><div class="token-line"><span class="token plain">      };</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      int messagequeueid = -1;</span></div><div class="token-line"><span class="token plain">      struct msg_buffer buffer;</span></div><div class="token-line"><span class="token plain">      long type = -1;</span></div><div class="token-line"><span class="token plain">      do {</span></div><div class="token-line"><span class="token plain">        next_option = getopt_long (argc, argv, short_options, long_options, NULL);</span></div><div class="token-line"><span class="token plain">        switch (next_option)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">          case &#x27;i&#x27;:</span></div><div class="token-line"><span class="token plain">            messagequeueid = atoi(optarg);</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">          case &#x27;t&#x27;:</span></div><div class="token-line"><span class="token plain">            type = atol(optarg);</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">          default:</span></div><div class="token-line"><span class="token plain">            break;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }while(next_option != -1);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      if(messagequeueid != -1 &amp;&amp; type != -1){</span></div><div class="token-line"><span class="token plain">        if(msgrcv(messagequeueid, &amp;buffer, 1024, type, IPC_NOWAIT) == -1){</span></div><div class="token-line"><span class="token plain">          perror(&quot;fail to recv message.&quot;);</span></div><div class="token-line"><span class="token plain">          exit(1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        printf(&quot;received message type : %d, text: %s.&quot;, buffer.mtype, buffer.mtext);</span></div><div class="token-line"><span class="token plain">      } else {</span></div><div class="token-line"><span class="token plain">        perror(&quot;arguments error&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，我们可以编译并运行这个发送程序。可以看到，如果有消息，可以正确地读到消息；如果没有，则返回没有消息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># ./recv -i 32768 -t 123</span></div><div class="token-line"><span class="token plain">    received message type : 123, text: hello world.</span></div><div class="token-line"><span class="token plain">    # ./recv -i 32768 -t 123</span></div><div class="token-line"><span class="token plain">    fail to recv message.: No message of desired type</span></div></pre></div><p>有了消息这种模型，两个进程之间的通信就像咱们平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><h2 id="共享内存模型"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#共享内存模型"><span class="icon icon-link"></span></a>共享内存模型</h2><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagedf38df910e4383885b1aceaafb52b9bb5638.74c6d534.png" alt=""/></p><p>但是有时候，项目组之间的沟通需要特别紧密，而且要分享一些比较大的数据。如果使用邮件，就发现，一方面邮件的来去不及时；另外一方面，附件大小也有限制，所以，这个时候，我们经常采取的方式就是，把两个项目组在需要合作的期间，拉到一个会议室进行合作开发，这样大家可以直接交流文档呀，架构图呀，直接在白板上画或者直接扔给对方，就可以直接看到。</p><p>可以看出来，共享会议室这种模型，类似进程间通信的<strong>共享内存模型</strong>。前面咱们讲内存管理的时候，知道每个进程都有自己独立的虚拟内存空间，不同的进程的虚拟内存空间映射到不同的物理内存中去。这个进程访问A地址和另一个进程访问A地址，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p>但是，咱们是不是可以变通一下，拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p><p>共享内存也是System V IPC进程间通信机制体系中的，所以从它使用流程可以看到熟悉的面孔。</p><p>我们可以创建一个共享内存，调用shmget。在这个体系中，创建一个IPC对象都是xxxget，这里面第一个参数是key，和msgget里面的key一样，都是唯一定位一个共享内存对象，也可以通过关联文件的方式实现唯一性。第二个参数是共享内存的大小。第三个参数如果是IPC_CREAT，同样表示创建一个新的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int shmget(key_t key, size_t size, int flag);</span></div></pre></div><p>创建完毕之后，我们可以通过ipcs命令查看这个共享内存。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#ipcs ­­--shmems</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ------ Shared Memory Segments ------ ­­­­­­­­</span></div><div class="token-line"><span class="token plain">    key        shmid    owner perms    bytes nattch status</span></div><div class="token-line"><span class="token plain">    0x00000000 19398656 marc  600    1048576 2      dest</span></div></pre></div><p>接下来，如果一个进程想要访问这一段共享内存，需要将这个内存加载到自己的虚拟地址空间的某个位置，通过shmat函数，就是attach的意思。其中addr就是要指定attach到这个地方。但是这个地址的设定难度比较大，除非对于内存布局非常熟悉，否则可能会attach到一个非法地址。所以，通常的做法是将addr设为NULL，让内核选一个合适的地址。返回值就是真正被attach的地方。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void *shmat(int shm_id, const void *addr, int flag);</span></div></pre></div><p>如果共享内存使用完毕，可以通过shmdt解除绑定，然后通过shmctl，将cmd设置为IPC_RMID，从而删除这个共享内存对象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int shmdt(void *addr); </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int shmctl(int shm_id, int cmd, struct shmid_ds *buf);</span></div></pre></div><h2 id="信号量"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#信号量"><span class="icon icon-link"></span></a>信号量</h2><p>这里你是不是有一个疑问，如果两个进程attach同一个共享内存，大家都往里面写东西，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p><p>所以，这里就需要一种保护机制，使得同一个共享的资源，同时只能被一个进程访问。在System V IPC进程间通信机制体系中，早就想好了应对办法，就是信号量（Semaphore）。因此，信号量和共享内存往往要配合使用。</p><p>信号量其实是一个计数器，主要用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</p><p>我们可以将信号量初始化为一个数值，来代表某种资源的总体数量。对于信号量来讲，会定义两种原子操作，一个是<strong>P操作</strong>，我们称为<strong>申请资源操作</strong>。这个操作会申请将信号量的数值减去N，表示这些数量被他申请使用了，其他人不能用了。另一个是<strong>V操作</strong>，我们称为<strong>归还资源操作</strong>，这个操作会申请将信号量加上M，表示这些数量已经还给信号量了，其他人可以使用了。</p><p>例如，你有100元钱，就可以将信号量设置为100。其中A向你借80元，就会调用P操作，申请减去80。如果同时B向你借50元，但是B的P操作比A晚，那就没有办法，只好等待A归还钱的时候，B的P操作才能成功。之后，A调用V操作，申请加上30元，也就是还给你30元，这个时候信号量有50元了，这时候B的P操作才能成功，才能借走这50元。</p><p>所谓<strong>原子操作</strong>（Atomic Operation），就是任何一块钱，都只能通过P操作借给一个人，不能同时借给两个人。也就是说，当A的P操作（借80）和B的P操作（借50），几乎同时到达的时候，不能因为大家都看到账户里有100就都成功，必须分个先来后到。</p><p>如果想创建一个信号量，我们可以通过semget函数。看，又是xxxget，第一个参数key也是类似的，第二个参数num_sems不是指资源的数量，而是表示可以创建多少个信号量，形成一组信号量，也就是说，如果你有多种资源需要管理，可以创建一个信号量组。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int semget(key_t key, int num_sems, int sem_flags);</span></div></pre></div><p>接下来，我们需要初始化信号量的总的资源数量。通过semctl函数，第一个参数semid是这个信号量组的id，第二个参数semnum才是在这个信号量组中某个信号量的id，第三个参数是命令，如果是初始化，则用SETVAL，第四个参数是一个union。如果初始化，应该用里面的val设置资源总量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int semctl(int semid, int semnum, int cmd, union semun args);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    union semun</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      int val;</span></div><div class="token-line"><span class="token plain">      struct semid_ds *buf;</span></div><div class="token-line"><span class="token plain">      unsigned short int *array;</span></div><div class="token-line"><span class="token plain">      struct seminfo *__buf;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>无论是P操作还是V操作，我们统一用semop函数。第一个参数还是信号量组的id，一次可以操作多个信号量。第三个参数numops就是有多少个操作，第二个参数将这些操作放在一个数组中。</p><p>数组的每一项是一个struct sembuf，里面的第一个成员是这个操作的对象是哪个信号量。</p><p>第二个成员就是要对这个信号量做多少改变。如果sem_op &lt; 0，就请求sem_op的绝对值的资源。如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</p><p>当相应的资源数不能满足请求时，就要看sem_flg了。如果把sem_flg设置为IPC_NOWAIT，也就是没有资源也不等待，则semop函数出错返回EAGAIN。如果sem_flg 没有指定IPC_NOWAIT，则进程挂起，直到当相应的资源数可以满足请求。若sem_op &gt; 0，表示进程归还相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则唤醒它们。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int semop(int semid, struct sembuf semoparray[], size_t numops);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct sembuf </span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      short sem_num; // 信号量组中对应的序号，0～sem_nums-1</span></div><div class="token-line"><span class="token plain">      short sem_op;  // 信号量值在一次操作中的改变量</span></div><div class="token-line"><span class="token plain">      short sem_flg; // IPC_NOWAIT, SEM_UNDO</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>信号量和共享内存都比较复杂，两者还要结合起来用，就更加复杂，它们内核的机制就更加复杂。这一节我们先不讲，放到本章的最后一节重点讲解。</p><h2 id="信号"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#信号"><span class="icon icon-link"></span></a>信号</h2><p>上面讲的进程间通信的方式，都是常规状态下的工作模式，对应到咱们平时的工作交接，收发邮件、联合开发等，其实还有一种异常情况下的工作模式。</p><p>例如出现线上系统故障，这个时候，什么流程都来不及了，不可能发邮件，也来不及开会，所有的架构师、开发、运维都要被通知紧急出动。所以，7乘24小时不间断执行的系统都需要有告警系统，一旦出事情，就要通知到人，哪怕是半夜，也要电话叫起来，处理故障。</p><p>对应到操作系统中，就是信号。信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。这就像咱们看警匪片，对于紧急的行动，都是说，“1号作战任务”开始执行，警察就开始行动了。情况紧急，不能啰里啰嗦了。</p><p>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。这就相当于咱们运维一个系统应急手册，当遇到什么情况，做什么事情，都事先准备好，出了事情照着做就可以了。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>这一节，我们整体讲解了一下进程间通信的各种模式。你现在还能记住多少？</p><ul><li>类似瀑布开发模式的管道</li><li>类似邮件模式的消息队列</li><li>类似会议室联合开发的共享内存加信号量</li><li>类似应急预案的信号</li></ul><p>当你自己使用的时候，可以根据不同的通信需要，选择不同的模式。</p><ul><li>管道，请你记住这是命令行中常用的模式，面试问到的话，不要忘了。</li><li>消息队列其实很少使用，因为有太多的用户级别的消息队列，功能更强大。</li><li>共享内存加信号量是常用的模式。这个需要牢记，常见到一些知名的以C语言开发的开源软件都会用到它。</li><li>信号更加常用，机制也比较复杂。我们后面会有单独的一节来解析。</li></ul><h2 id="课堂练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01#课堂练习"><span class="icon icon-link"></span></a>课堂练习</h2><p>这节课的程序，请你务必自己编译通过，搞清楚参数解析是怎么做的，这个以后你自己写程序的时候，很有用，另外消息队列模型的API调用流程，也要搞清楚，要知道他们都属于System V系列，后面我们学共享内存和信号量，能看到完全类似的API调用流程。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage8c378c0a95fa07a8b9a1abfd394479bdd637.f286080c.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
