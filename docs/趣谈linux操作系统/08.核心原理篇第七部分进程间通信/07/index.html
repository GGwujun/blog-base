<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>42 | IPC（下）：不同项目组之间抢资源，如何协调？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇">01.入门准备篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/01"><span>开篇词 | 为什么要学习Linux操作系统？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/02"><span>01 | 入学测验：你究竟对Linux操作系统了解多少？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/01.入门准备篇/03"><span>02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述">02.核心原理篇第一部分Linux操作系统综述</a><ul><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/01"><span>03 | 你可以把Linux内核当成一家软件外包公司的老板</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/02"><span>04 | 快速上手几个Linux命令：每家公司都有自己的黑话</span></a></li><li><a href="/blog-base/趣谈linux操作系统/02.核心原理篇第一部分linux操作系统综述/03"><span>05 | 学会几个系统调用：咱们公司能接哪些类型的项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化">03.核心原理篇第二部分系统初始化</a><ul><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/01"><span>06 | x86架构：有了开放的架构，才能打造开放的营商环境</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/02"><span>07 | 从BIOS到bootloader：创业伊始，有活儿老板自己上</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/03"><span>08 | 内核初始化：生意做大了就得成立公司</span></a></li><li><a href="/blog-base/趣谈linux操作系统/03.核心原理篇第二部分系统初始化/04"><span>09 | 系统调用：公司成立好了就要开始接项目</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理">04.核心原理篇第三部分进程管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/01"><span>10 | 进程：公司接这么多项目，如何管？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/02"><span>11 | 线程：如何让复杂的项目并行执行？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/03"><span>12 | 进程数据结构（上）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/04"><span>13 | 进程数据结构（中）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/05"><span>14 | 进程数据结构（下）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/06"><span>15 | 调度（上）：如何制定项目管理流程？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/07"><span>16 | 调度（中）：主动调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/08"><span>17 | 调度（下）：抢占式调度是如何发生的？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/09"><span>18 | 进程的创建：如何发起一个新项目？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/04.核心原理篇第三部分进程管理/10"><span>19 | 线程的创建：如何执行一个新子项目？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理">05.核心原理篇第四部分内存管理</a><ul><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/01"><span>20 | 内存管理（上）：为客户保密，规划进程内存空间布局</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/02"><span>21 | 内存管理（下）：为客户保密，项目组独享会议室封闭开发</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/03"><span>22 | 进程空间管理：项目组还可以自行布置会议室</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/04"><span>23 | 物理内存管理（上）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/05"><span>24 | 物理内存管理（下）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/06"><span>25 | 用户态内存映射：如何找到正确的会议室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/05.核心原理篇第四部分内存管理/07"><span>26 | 内核态内存映射：如何找到正确的会议室？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统">06.核心原理篇第五部分文件系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/01"><span>27 | 文件系统：项目成果要归档，我们就需要档案库</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/02"><span>28 | 硬盘文件系统：如何最合理地组织档案库的文档？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/03"><span>29 | 虚拟文件系统：文件多了就需要档案管理系统</span></a></li><li><a href="/blog-base/趣谈linux操作系统/06.核心原理篇第五部分文件系统/04"><span>30 | 文件缓存：常用文档应该放在触手可得的地方</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统">07.核心原理篇第六部分输入输出系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/01"><span>31 | 输入与输出：如何建立售前售后生态体系？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/02"><span>32 | 字符设备（上）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/03"><span>33 | 字符设备（下）：如何建立直销模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/04"><span>34 | 块设备（上）：如何建立代理商销售模式？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/07.核心原理篇第六部分输入输出系统/05"><span>35 | 块设备（下）：如何建立代理商销售模式？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信">08.核心原理篇第七部分进程间通信</a><ul><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/01"><span>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/02"><span>37 | 信号（上）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/03"><span>38 | 信号（下）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/04"><span>39 | 管道：项目组A完成了，如何交接给项目组B？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/05"><span>40 | IPC（上）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/06"><span>41 | IPC（中）：不同项目组之间抢资源，如何协调？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07"><span>42 | IPC（下）：不同项目组之间抢资源，如何协调？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统">09.核心原理篇第八部分网络系统</a><ul><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/01"><span>43 预习 | Socket通信之网络协议基本原理</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/02"><span>43 | Socket通信：遇上特大项目，要学会和其他公司合作</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/03"><span>44 | Socket内核数据结构：如何成立特大项目合作部？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/04"><span>45 | 发送网络包（上）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/05"><span>46 | 发送网络包（下）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/06"><span>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/09.核心原理篇第八部分网络系统/07"><span>48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化">10.核心原理篇第九部分虚拟化</a><ul><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/01"><span>49 | 虚拟机：如何成立子公司，让公司变集团？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/02"><span>50 | 计算虚拟化之CPU（上）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/03"><span>51 | 计算虚拟化之CPU（下）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/04"><span>52 | 计算虚拟化之内存：如何建立独立的办公室？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/05"><span>53 | 存储虚拟化（上）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/06"><span>54 | 存储虚拟化（下）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/10.核心原理篇第九部分虚拟化/07"><span>55 | 网络虚拟化：如何成立独立的合作部？</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化">11.核心原理篇第十部分容器化</a><ul><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/01"><span>56 | 容器：大公司为保持创新，鼓励内部创业</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/02"><span>57 | Namespace技术：内部创业公司应该独立运营</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/03"><span>58 | cgroup技术：内部创业公司应该独立核算成本</span></a></li><li><a href="/blog-base/趣谈linux操作系统/11.核心原理篇第十部分容器化/04"><span>59 | 数据中心操作系统：上市敲钟</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇">12.实战串讲篇</a><ul><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/01"><span>60 | 搭建操作系统实验环境（上）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/02"><span>61 | 搭建操作系统实验环境（下）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/03"><span>62 | 知识串讲：用一个创业故事串起操作系统原理（一）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/04"><span>63 | 知识串讲：用一个创业故事串起操作系统原理（二）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/05"><span>64 | 知识串讲：用一个创业故事串起操作系统原理（三）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/06"><span>65 | 知识串讲：用一个创业故事串起操作系统原理（四）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/07"><span>66 | 知识串讲：用一个创业故事串起操作系统原理（五）</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/08"><span>期末测试 | 这些操作系统问题，你真的掌握了吗？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/12.实战串讲篇/09"><span>结束语 | 永远别轻视任何技术，也永远别轻视自己</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐">13.专栏加餐</a><ul><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/01"><span>学习攻略（一）：学好操作系统，需要掌握哪些前置知识？</span></a></li><li><a href="/blog-base/趣谈linux操作系统/13.专栏加餐/02"><span>“趣谈Linux操作系统”食用指南</span></a></li></ul></li><li><a href="/blog-base/趣谈linux操作系统/summary">趣谈linux操作系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="总结时刻" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07#总结时刻"><span>总结时刻</span></a></li><li title="课堂练习" data-depth="2"><a href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07#课堂练习"><span>课堂练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="42--ipc下不同项目组之间抢资源如何协调"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07#42--ipc下不同项目组之间抢资源如何协调"><span class="icon icon-link"></span></a>42 | IPC（下）：不同项目组之间抢资源，如何协调？</h1><p>IPC这块的内容比较多，为了让你能够更好地理解，我分成了三节来讲。前面我们解析完了共享内存的内核机制后，今天我们来看最后一部分，信号量的内核机制。</p><p>首先，我们需要创建一个信号量，调用的是系统调用semget。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SYSCALL_DEFINE3(semget, key_t, key, int, nsems, int, semflg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct ipc_namespace *ns;</span></div><div class="token-line"><span class="token plain">    	static const struct ipc_ops sem_ops = {</span></div><div class="token-line"><span class="token plain">    		.getnew = newary,</span></div><div class="token-line"><span class="token plain">    		.associate = sem_security,</span></div><div class="token-line"><span class="token plain">    		.more_checks = sem_more_checks,</span></div><div class="token-line"><span class="token plain">    	};</span></div><div class="token-line"><span class="token plain">    	struct ipc_params sem_params;</span></div><div class="token-line"><span class="token plain">    	ns = current-&gt;nsproxy-&gt;ipc_ns;</span></div><div class="token-line"><span class="token plain">    	sem_params.key = key;</span></div><div class="token-line"><span class="token plain">    	sem_params.flg = semflg;</span></div><div class="token-line"><span class="token plain">    	sem_params.u.nsems = nsems;</span></div><div class="token-line"><span class="token plain">    	return ipcget(ns, &amp;sem_ids(ns), &amp;sem_ops, &amp;sem_params);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们解析过了共享内存，再看信号量，就顺畅很多了。这里同样调用了抽象的ipcget，参数分别为信号量对应的sem_ids、对应的操作sem_ops以及对应的参数sem_params。</p><p>ipcget的代码我们已经解析过了。如果key设置为IPC_PRIVATE则永远创建新的；如果不是的话，就会调用ipcget_public。</p><p>在ipcget_public中，我们能会按照key，去查找struct kern_ipc_perm。如果没有找到，那就看看是否设置了IPC_CREAT。如果设置了，就创建一个新的。如果找到了，就将对应的id返回。</p><p>我们这里重点看，如何按照参数sem_ops，创建新的信号量会调用newary。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int retval;</span></div><div class="token-line"><span class="token plain">    	struct sem_array *sma;</span></div><div class="token-line"><span class="token plain">    	key_t key = params-&gt;key;</span></div><div class="token-line"><span class="token plain">    	int nsems = params-&gt;u.nsems;</span></div><div class="token-line"><span class="token plain">    	int semflg = params-&gt;flg;</span></div><div class="token-line"><span class="token plain">    	int i;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sma = sem_alloc(nsems);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO);</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_perm.key = key;</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_perm.security = NULL;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	for (i = 0; i &lt; nsems; i++) {</span></div><div class="token-line"><span class="token plain">    		INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_alter);</span></div><div class="token-line"><span class="token plain">    		INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_const);</span></div><div class="token-line"><span class="token plain">    		spin_lock_init(&amp;sma-&gt;sems[i].lock);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	sma-&gt;complex_count = 0;</span></div><div class="token-line"><span class="token plain">    	sma-&gt;use_global_lock = USE_GLOBAL_LOCK_HYSTERESIS;</span></div><div class="token-line"><span class="token plain">    	INIT_LIST_HEAD(&amp;sma-&gt;pending_alter);</span></div><div class="token-line"><span class="token plain">    	INIT_LIST_HEAD(&amp;sma-&gt;pending_const);</span></div><div class="token-line"><span class="token plain">    	INIT_LIST_HEAD(&amp;sma-&gt;list_id);</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_nsems = nsems;</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_ctime = get_seconds();</span></div><div class="token-line"><span class="token plain">    	retval = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ns-&gt;used_sems += nsems;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	return sma-&gt;sem_perm.id;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>newary函数的第一步，通过kvmalloc在直接映射区分配一个struct sem_array结构。这个结构是用来描述信号量的，这个结构最开始就是上面说的struct kern_ipc_perm结构。接下来就是填充这个struct sem_array结构，例如key、权限等。</p><p>struct sem_array里有多个信号量，放在struct sem sems[]数组里面，在struct sem里面有当前的信号量的数值semval。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sem {</span></div><div class="token-line"><span class="token plain">    	int	semval;		/* current value */</span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 * PID of the process that last modified the semaphore. For</span></div><div class="token-line"><span class="token plain">    	 * Linux, specifically these are:</span></div><div class="token-line"><span class="token plain">    	 *  - semop</span></div><div class="token-line"><span class="token plain">    	 *  - semctl, via SETVAL and SETALL.</span></div><div class="token-line"><span class="token plain">    	 *  - at task exit when performing undo adjustments (see exit_sem).</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	int	sempid;</span></div><div class="token-line"><span class="token plain">    	spinlock_t	lock;	/* spinlock for fine-grained semtimedop */</span></div><div class="token-line"><span class="token plain">    	struct list_head pending_alter; /* pending single-sop operations that alter the semaphore */</span></div><div class="token-line"><span class="token plain">    	struct list_head pending_const; /* pending single-sop operations that do not alter the semaphore*/</span></div><div class="token-line"><span class="token plain">    	time_t	sem_otime;	/* candidate for sem_otime */</span></div><div class="token-line"><span class="token plain">    } ____cacheline_aligned_in_smp;</span></div></pre></div><p>struct sem_array和struct sem各有一个链表struct list_head pending_alter，分别表示对于整个信号量数组的修改和对于某个信号量的修改。</p><p>newary函数的第二步，就是初始化这些链表。</p><p>newary函数的第三步，通过ipc_addid将新创建的struct sem_array结构，挂到sem_ids里面的基数树上，并返回相应的id。</p><p>信号量创建的过程到此结束，接下来我们来看，如何通过semctl对信号量数组进行初始化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SYSCALL_DEFINE4(semctl, int, semid, int, semnum, int, cmd, unsigned long, arg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int version;</span></div><div class="token-line"><span class="token plain">    	struct ipc_namespace *ns;</span></div><div class="token-line"><span class="token plain">    	void __user *p = (void __user *)arg;</span></div><div class="token-line"><span class="token plain">    	ns = current-&gt;nsproxy-&gt;ipc_ns;</span></div><div class="token-line"><span class="token plain">    	switch (cmd) {</span></div><div class="token-line"><span class="token plain">    	case IPC_INFO:</span></div><div class="token-line"><span class="token plain">    	case SEM_INFO:</span></div><div class="token-line"><span class="token plain">    	case IPC_STAT:</span></div><div class="token-line"><span class="token plain">    	case SEM_STAT:</span></div><div class="token-line"><span class="token plain">    		return semctl_nolock(ns, semid, cmd, version, p);</span></div><div class="token-line"><span class="token plain">    	case GETALL:</span></div><div class="token-line"><span class="token plain">    	case GETVAL:</span></div><div class="token-line"><span class="token plain">    	case GETPID:</span></div><div class="token-line"><span class="token plain">    	case GETNCNT:</span></div><div class="token-line"><span class="token plain">    	case GETZCNT:</span></div><div class="token-line"><span class="token plain">    	case SETALL:</span></div><div class="token-line"><span class="token plain">    		return semctl_main(ns, semid, semnum, cmd, p);</span></div><div class="token-line"><span class="token plain">    	case SETVAL:</span></div><div class="token-line"><span class="token plain">    		return semctl_setval(ns, semid, semnum, arg);</span></div><div class="token-line"><span class="token plain">    	case IPC_RMID:</span></div><div class="token-line"><span class="token plain">    	case IPC_SET:</span></div><div class="token-line"><span class="token plain">    		return semctl_down(ns, semid, cmd, version, p);</span></div><div class="token-line"><span class="token plain">    	default:</span></div><div class="token-line"><span class="token plain">    		return -EINVAL;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里我们重点看，SETALL操作调用的semctl_main函数，以及SETVAL操作调用的semctl_setval函数。</p><p>对于SETALL操作来讲，传进来的参数为union semun里面的unsigned short *array，会设置整个信号量集合。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,</span></div><div class="token-line"><span class="token plain">    		int cmd, void __user *p)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct sem_array *sma;</span></div><div class="token-line"><span class="token plain">    	struct sem *curr;</span></div><div class="token-line"><span class="token plain">    	int err, nsems;</span></div><div class="token-line"><span class="token plain">    	ushort fast_sem_io[SEMMSL_FAST];</span></div><div class="token-line"><span class="token plain">    	ushort *sem_io = fast_sem_io;</span></div><div class="token-line"><span class="token plain">    	DEFINE_WAKE_Q(wake_q);</span></div><div class="token-line"><span class="token plain">    	sma = sem_obtain_object_check(ns, semid);</span></div><div class="token-line"><span class="token plain">    	nsems = sma-&gt;sem_nsems;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	switch (cmd) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	case SETALL:</span></div><div class="token-line"><span class="token plain">    	{</span></div><div class="token-line"><span class="token plain">    		int i;</span></div><div class="token-line"><span class="token plain">    		struct sem_undo *un;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		if (copy_from_user(sem_io, p, nsems*sizeof(ushort))) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		for (i = 0; i &lt; nsems; i++) {</span></div><div class="token-line"><span class="token plain">    			sma-&gt;sems[i].semval = sem_io[i];</span></div><div class="token-line"><span class="token plain">    			sma-&gt;sems[i].sempid = task_tgid_vnr(current);</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		sma-&gt;sem_ctime = get_seconds();</span></div><div class="token-line"><span class="token plain">    		/* maybe some queued-up processes were waiting for this */</span></div><div class="token-line"><span class="token plain">    		do_smart_update(sma, NULL, 0, 0, &amp;wake_q);</span></div><div class="token-line"><span class="token plain">    		err = 0;</span></div><div class="token-line"><span class="token plain">    		goto out_unlock;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        wake_up_q(&amp;wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在semctl_main函数中，先是通过sem_obtain_object_check，根据信号量集合的id在基数树里面找到struct sem_array对象，发现如果是SETALL操作，就将用户的参数中的unsigned short *array通过copy_from_user拷贝到内核里面的sem_io数组，然后是一个循环，对于信号量集合里面的每一个信号量，设置semval，以及修改这个信号量值的pid。</p><p>对于SETVAL操作来讲，传进来的参数union semun里面的int val，仅仅会设置某个信号量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,</span></div><div class="token-line"><span class="token plain">    		unsigned long arg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct sem_undo *un;</span></div><div class="token-line"><span class="token plain">    	struct sem_array *sma;</span></div><div class="token-line"><span class="token plain">    	struct sem *curr;</span></div><div class="token-line"><span class="token plain">    	int err, val;</span></div><div class="token-line"><span class="token plain">    	DEFINE_WAKE_Q(wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sma = sem_obtain_object_check(ns, semid);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	curr = &amp;sma-&gt;sems[semnum];</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	curr-&gt;semval = val;</span></div><div class="token-line"><span class="token plain">    	curr-&gt;sempid = task_tgid_vnr(current);</span></div><div class="token-line"><span class="token plain">    	sma-&gt;sem_ctime = get_seconds();</span></div><div class="token-line"><span class="token plain">    	/* maybe some queued-up processes were waiting for this */</span></div><div class="token-line"><span class="token plain">    	do_smart_update(sma, NULL, 0, 0, &amp;wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	wake_up_q(&amp;wake_q);</span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在semctl_setval函数中，我们先是通过sem_obtain_object_check，根据信号量集合的id在基数树里面找到struct sem_array对象，对于SETVAL操作，直接根据参数中的val设置semval，以及修改这个信号量值的pid。</p><p>至此，信号量数组初始化完毕。接下来我们来看P操作和V操作。无论是P操作，还是V操作都是调用semop系统调用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SYSCALL_DEFINE3(semop, int, semid, struct sembuf __user *, tsops,</span></div><div class="token-line"><span class="token plain">    		unsigned, nsops)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	return sys_semtimedop(semid, tsops, nsops, NULL);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,</span></div><div class="token-line"><span class="token plain">    		unsigned, nsops, const struct timespec __user *, timeout)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int error = -EINVAL;</span></div><div class="token-line"><span class="token plain">    	struct sem_array *sma;</span></div><div class="token-line"><span class="token plain">    	struct sembuf fast_sops[SEMOPM_FAST];</span></div><div class="token-line"><span class="token plain">    	struct sembuf *sops = fast_sops, *sop;</span></div><div class="token-line"><span class="token plain">    	struct sem_undo *un;</span></div><div class="token-line"><span class="token plain">    	int max, locknum;</span></div><div class="token-line"><span class="token plain">    	bool undos = false, alter = false, dupsop = false;</span></div><div class="token-line"><span class="token plain">    	struct sem_queue queue;</span></div><div class="token-line"><span class="token plain">    	unsigned long dup = 0, jiffies_left = 0;</span></div><div class="token-line"><span class="token plain">    	struct ipc_namespace *ns;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	ns = current-&gt;nsproxy-&gt;ipc_ns;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (copy_from_user(sops, tsops, nsops * sizeof(*tsops))) {</span></div><div class="token-line"><span class="token plain">    		error =  -EFAULT;</span></div><div class="token-line"><span class="token plain">    		goto out_free;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (timeout) {</span></div><div class="token-line"><span class="token plain">    		struct timespec _timeout;</span></div><div class="token-line"><span class="token plain">    		if (copy_from_user(&amp;_timeout, timeout, sizeof(*timeout))) {</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		jiffies_left = timespec_to_jiffies(&amp;_timeout);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	/* On success, find_alloc_undo takes the rcu_read_lock */</span></div><div class="token-line"><span class="token plain">    	un = find_alloc_undo(ns, semid);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sma = sem_obtain_object_check(ns, semid);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	queue.sops = sops;</span></div><div class="token-line"><span class="token plain">    	queue.nsops = nsops;</span></div><div class="token-line"><span class="token plain">    	queue.undo = un;</span></div><div class="token-line"><span class="token plain">    	queue.pid = task_tgid_vnr(current);</span></div><div class="token-line"><span class="token plain">    	queue.alter = alter;</span></div><div class="token-line"><span class="token plain">    	queue.dupsop = dupsop;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	error = perform_atomic_semop(sma, &amp;queue);</span></div><div class="token-line"><span class="token plain">    	if (error == 0) { /* non-blocking succesfull path */</span></div><div class="token-line"><span class="token plain">    		DEFINE_WAKE_Q(wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		do_smart_update(sma, sops, nsops, 1, &amp;wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		wake_up_q(&amp;wake_q);</span></div><div class="token-line"><span class="token plain">    		goto out_free;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 * We need to sleep on this operation, so we put the current</span></div><div class="token-line"><span class="token plain">    	 * task into the pending queue and go to sleep.</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	if (nsops == 1) {</span></div><div class="token-line"><span class="token plain">    		struct sem *curr;</span></div><div class="token-line"><span class="token plain">    		curr = &amp;sma-&gt;sems[sops-&gt;sem_num];</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		list_add_tail(&amp;queue.list,</span></div><div class="token-line"><span class="token plain">    						&amp;curr-&gt;pending_alter);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	} else {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		list_add_tail(&amp;queue.list, &amp;sma-&gt;pending_alter);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	do {</span></div><div class="token-line"><span class="token plain">    		queue.status = -EINTR;</span></div><div class="token-line"><span class="token plain">    		queue.sleeper = current;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		__set_current_state(TASK_INTERRUPTIBLE);</span></div><div class="token-line"><span class="token plain">    		if (timeout)</span></div><div class="token-line"><span class="token plain">    			jiffies_left = schedule_timeout(jiffies_left);</span></div><div class="token-line"><span class="token plain">    		else</span></div><div class="token-line"><span class="token plain">    			schedule();</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		/*</span></div><div class="token-line"><span class="token plain">    		 * If an interrupt occurred we have to clean up the queue.</span></div><div class="token-line"><span class="token plain">    		 */</span></div><div class="token-line"><span class="token plain">    		if (timeout &amp;&amp; jiffies_left == 0)</span></div><div class="token-line"><span class="token plain">    			error = -EAGAIN;</span></div><div class="token-line"><span class="token plain">    	} while (error == -EINTR &amp;&amp; !signal_pending(current)); /* spurious */</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>semop会调用semtimedop，这是一个非常复杂的函数。</p><p>semtimedop做的第一件事情，就是将用户的参数，例如，对于信号量的操作struct sembuf，拷贝到内核里面来。另外，如果是P操作，很可能让进程进入等待状态，是否要为这个等待状态设置一个超时，timeout也是一个参数，会把它变成时钟的滴答数目。</p><p>semtimedop做的第二件事情，是通过sem_obtain_object_check，根据信号量集合的id，获得struct sem_array，然后，创建一个struct sem_queue表示当前的信号量操作。为什么叫queue呢？因为这个操作可能马上就能完成，也可能因为无法获取信号量不能完成，不能完成的话就只好排列到队列上，等待信号量满足条件的时候。semtimedop会调用perform_atomic_semop在实施信号量操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int perform_atomic_semop(struct sem_array *sma, struct sem_queue *q)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	int result, sem_op, nsops;</span></div><div class="token-line"><span class="token plain">    	struct sembuf *sop;</span></div><div class="token-line"><span class="token plain">    	struct sem *curr;</span></div><div class="token-line"><span class="token plain">    	struct sembuf *sops;</span></div><div class="token-line"><span class="token plain">    	struct sem_undo *un;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	sops = q-&gt;sops;</span></div><div class="token-line"><span class="token plain">    	nsops = q-&gt;nsops;</span></div><div class="token-line"><span class="token plain">    	un = q-&gt;undo;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	for (sop = sops; sop &lt; sops + nsops; sop++) {</span></div><div class="token-line"><span class="token plain">    		curr = &amp;sma-&gt;sems[sop-&gt;sem_num];</span></div><div class="token-line"><span class="token plain">    		sem_op = sop-&gt;sem_op;</span></div><div class="token-line"><span class="token plain">    		result = curr-&gt;semval;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		result += sem_op;</span></div><div class="token-line"><span class="token plain">    		if (result &lt; 0)</span></div><div class="token-line"><span class="token plain">    			goto would_block;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		if (sop-&gt;sem_flg &amp; SEM_UNDO) {</span></div><div class="token-line"><span class="token plain">    			int undo = un-&gt;semadj[sop-&gt;sem_num] - sem_op;</span></div><div class="token-line"><span class="token plain">    .....</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	for (sop = sops; sop &lt; sops + nsops; sop++) {</span></div><div class="token-line"><span class="token plain">    		curr = &amp;sma-&gt;sems[sop-&gt;sem_num];</span></div><div class="token-line"><span class="token plain">    		sem_op = sop-&gt;sem_op;</span></div><div class="token-line"><span class="token plain">    		result = curr-&gt;semval;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		if (sop-&gt;sem_flg &amp; SEM_UNDO) {</span></div><div class="token-line"><span class="token plain">    			int undo = un-&gt;semadj[sop-&gt;sem_num] - sem_op;</span></div><div class="token-line"><span class="token plain">    			un-&gt;semadj[sop-&gt;sem_num] = undo;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    		curr-&gt;semval += sem_op;</span></div><div class="token-line"><span class="token plain">    		curr-&gt;sempid = q-&gt;pid;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    would_block:</span></div><div class="token-line"><span class="token plain">    	q-&gt;blocking = sop;</span></div><div class="token-line"><span class="token plain">    	return sop-&gt;sem_flg &amp; IPC_NOWAIT ? -EAGAIN : 1;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在perform_atomic_semop函数中，对于所有信号量操作都进行两次循环。在第一次循环中，如果发现计算出的result小于0，则说明必须等待，于是跳到would_block中，设置q-&gt;blocking = sop表示这个queue是block在这个操作上，然后如果需要等待，则返回1。如果第一次循环中发现无需等待，则第二个循环实施所有的信号量操作，将信号量的值设置为新的值，并且返回0。</p><p>接下来，我们回到semtimedop，来看它干的第三件事情，就是如果需要等待，应该怎么办？</p><p>如果需要等待，则要区分刚才的对于信号量的操作，是对一个信号量的，还是对于整个信号量集合的。如果是对于一个信号量的，那我们就将queue挂到这个信号量的pending_alter中；如果是对于整个信号量集合的，那我们就将queue挂到整个信号量集合的pending_alter中。</p><p>接下来的do-while循环，就是要开始等待了。如果等待没有时间限制，则调用schedule让出CPU；如果等待有时间限制，则调用schedule_timeout让出CPU，过一段时间还回来。当回来的时候，判断是否等待超时，如果没有等待超时则进入下一轮循环，再次等待，如果超时则退出循环，返回错误。在让出CPU的时候，设置进程的状态为TASK_INTERRUPTIBLE，并且循环的结束会通过signal_pending查看是否收到过信号，这说明这个等待信号量的进程是可以被信号中断的，也即一个等待信号量的进程是可以通过kill杀掉的。</p><p>我们再来看，semtimedop要做的第四件事情，如果不需要等待，应该怎么办？</p><p>如果不需要等待，就说明对于信号量的操作完成了，也改变了信号量的值。接下来，就是一个标准流程。我们通过DEFINE_WAKE_Q(wake_q)声明一个wake_q，调用do_smart_update，看这次对于信号量的值的改变，可以影响并可以激活等待队列中的哪些struct sem_queue，然后把它们都放在wake_q里面，调用wake_up_q唤醒这些进程。其实，所有的对于信号量的值的修改都会涉及这三个操作，如果你回过头去仔细看SETALL和SETVAL操作，在设置完毕信号量之后，也是这三个操作。</p><p>我们来看do_smart_update是如何实现的。do_smart_update会调用update_queue。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int update_queue(struct sem_array *sma, int semnum, struct wake_q_head *wake_q)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct sem_queue *q, *tmp;</span></div><div class="token-line"><span class="token plain">    	struct list_head *pending_list;</span></div><div class="token-line"><span class="token plain">    	int semop_completed = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (semnum == -1)</span></div><div class="token-line"><span class="token plain">    		pending_list = &amp;sma-&gt;pending_alter;</span></div><div class="token-line"><span class="token plain">    	else</span></div><div class="token-line"><span class="token plain">    		pending_list = &amp;sma-&gt;sems[semnum].pending_alter;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    again:</span></div><div class="token-line"><span class="token plain">    	list_for_each_entry_safe(q, tmp, pending_list, list) {</span></div><div class="token-line"><span class="token plain">    		int error, restart;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		error = perform_atomic_semop(sma, q);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		/* Does q-&gt;sleeper still need to sleep? */</span></div><div class="token-line"><span class="token plain">    		if (error &gt; 0)</span></div><div class="token-line"><span class="token plain">    			continue;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		unlink_queue(sma, q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		wake_up_sem_queue_prepare(q, error, wake_q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return semop_completed;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static inline void wake_up_sem_queue_prepare(struct sem_queue *q, int error,</span></div><div class="token-line"><span class="token plain">    					     struct wake_q_head *wake_q)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	wake_q_add(wake_q, q-&gt;sleeper);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>update_queue会依次循环整个信号量集合的等待队列pending_alter，或者某个信号量的等待队列。试图在信号量的值变了的情况下，再次尝试perform_atomic_semop进行信号量操作。如果不成功，则尝试队列中的下一个；如果尝试成功，则调用unlink_queue从队列上取下来，然后调用wake_up_sem_queue_prepare，将q-&gt;sleeper加到wake_q上去。q-&gt;sleeper是一个task_struct，是等待在这个信号量操作上的进程。</p><p>接下来，wake_up_q就依次唤醒wake_q上的所有task_struct，调用的是我们在进程调度那一节学过的wake_up_process方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void wake_up_q(struct wake_q_head *head)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct wake_q_node *node = head-&gt;first;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	while (node != WAKE_Q_TAIL) {</span></div><div class="token-line"><span class="token plain">    		struct task_struct *task;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		task = container_of(node, struct task_struct, wake_q);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		node = node-&gt;next;</span></div><div class="token-line"><span class="token plain">    		task-&gt;wake_q.next = NULL;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		wake_up_process(task);</span></div><div class="token-line"><span class="token plain">    		put_task_struct(task);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>至此，对于信号量的主流操作都解析完毕了。</p><p>其实还有一点需要强调一下，信号量是一个整个Linux可见的全局资源，而不像咱们在线程同步那一节讲过的都是某个进程独占的资源，好处是可以跨进程通信，坏处就是如果一个进程通过P操作拿到了一个信号量，但是不幸异常退出了，如果没有来得及归还这个信号量，可能所有其他的进程都阻塞了。</p><p>那怎么办呢？Linux有一种机制叫SEM_UNDO，也即每一个semop操作都会保存一个反向struct sem_undo操作，当因为某个进程异常退出的时候，这个进程做的所有的操作都会回退，从而保证其他进程可以正常工作。</p><p>如果你回头看，我们写的程序里面的semaphore_p函数和semaphore_v函数，都把sem_flg设置为SEM_UNDO，就是这个作用。</p><p>等待队列上的每一个struct sem_queue，都有一个struct sem_undo，以此来表示这次操作的反向操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sem_queue {</span></div><div class="token-line"><span class="token plain">    	struct list_head	list;	 /* queue of pending operations */</span></div><div class="token-line"><span class="token plain">    	struct task_struct	*sleeper; /* this process */</span></div><div class="token-line"><span class="token plain">    	struct sem_undo		*undo;	 /* undo structure */</span></div><div class="token-line"><span class="token plain">    	int			pid;	 /* process id of requesting process */</span></div><div class="token-line"><span class="token plain">    	int			status;	 /* completion status of operation */</span></div><div class="token-line"><span class="token plain">    	struct sembuf		*sops;	 /* array of pending operations */</span></div><div class="token-line"><span class="token plain">    	struct sembuf		*blocking; /* the operation that blocked */</span></div><div class="token-line"><span class="token plain">    	int			nsops;	 /* number of operations */</span></div><div class="token-line"><span class="token plain">    	bool			alter;	 /* does *sops alter the array? */</span></div><div class="token-line"><span class="token plain">    	bool                    dupsop;	 /* sops on more than one sem_num */</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在进程的task_struct里面对于信号量有一个成员struct sysv_sem，里面是一个struct sem_undo_list，将这个进程所有的semop所带来的undo操作都串起来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct task_struct {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    struct sysv_sem			sysvsem;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct sysv_sem {</span></div><div class="token-line"><span class="token plain">    	struct sem_undo_list *undo_list;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct sem_undo {</span></div><div class="token-line"><span class="token plain">    	struct list_head	list_proc;	/* per-process list: *</span></div><div class="token-line"><span class="token plain">    						 * all undos from one process</span></div><div class="token-line"><span class="token plain">    						 * rcu protected */</span></div><div class="token-line"><span class="token plain">    	struct rcu_head		rcu;		/* rcu struct for sem_undo */</span></div><div class="token-line"><span class="token plain">    	struct sem_undo_list	*ulp;		/* back ptr to sem_undo_list */</span></div><div class="token-line"><span class="token plain">    	struct list_head	list_id;	/* per semaphore array list:</span></div><div class="token-line"><span class="token plain">    						 * all undos for one array */</span></div><div class="token-line"><span class="token plain">    	int			semid;		/* semaphore set identifier */</span></div><div class="token-line"><span class="token plain">    	short			*semadj;	/* array of adjustments */</span></div><div class="token-line"><span class="token plain">    						/* one per semaphore */</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct sem_undo_list {</span></div><div class="token-line"><span class="token plain">    	atomic_t		refcnt;</span></div><div class="token-line"><span class="token plain">    	spinlock_t		lock;</span></div><div class="token-line"><span class="token plain">    	struct list_head	list_proc;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>为了让你更清楚地理解struct sem_undo的原理，我们这里举一个例子。</p><p>假设我们创建了两个信号量集合。一个叫semaphore1，它包含三个信号量，初始化值为3，另一个叫semaphore2，它包含4个信号量，初始化值都为4。初始化时候的信号量以及undo结构里面的值如图中(1)标号所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage03d60352227c5f49d194b6094f229220cdd6.png" alt=""/></p><p>首先，我们来看进程1。我们调用semop，将semaphore1的三个信号量的值，分别加1、加2和减3，从而信号量的值变为4,5,0。于是在semaphore1和进程1链表交汇的undo结构里面，填写-1,-2,+3，是semop操作的反向操作，如图中(2)标号所示。</p><p>然后，我们来看进程2。我们调用semop，将semaphore1的三个信号量的值，分别减3、加2和加1，从而信号量的值变为1、7、1。于是在semaphore1和进程2链表交汇的undo结构里面，填写+3、-2、-1，是semop操作的反向操作，如图中(3)标号所示。</p><p>然后，我们接着看进程2。我们调用semop，将semaphore2的四个信号量的值，分别减3、加1、加4和减1，从而信号量的值变为1、5、8、3。于是，在semaphore2和进程2链表交汇的undo结构里面，填写+3、-1、-4、+1，是semop操作的反向操作，如图中(4)标号所示。</p><p>然后，我们再来看进程1。我们调用semop，将semaphore2的四个信号量的值，分别减1、减4、减5和加2，从而信号量的值变为0、1、3、5。于是在semaphore2和进程1链表交汇的undo结构里面，填写+1、+4、+5、-2，是semop操作的反向操作，如图中(5)标号所示。</p><p>从这个例子可以看出，无论哪个进程异常退出，只要将undo结构里面的值加回当前信号量的值，就能够得到正确的信号量的值，不会因为一个进程退出，导致信号量的值处于不一致的状态。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>信号量的机制也很复杂，我们对着下面这个图总结一下。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage607c6028c83b0aa00e65916988911aa01b7c.png" alt=""/></p><ol><li>调用semget创建信号量集合。</li><li>ipc_findkey会在基数树中，根据key查找信号量集合sem_array对象。如果已经被创建，就会被查询出来。例如producer被创建过，在consumer中就会查询出来。</li><li>如果信号量集合没有被创建过，则调用sem_ops的newary方法，创建一个信号量集合对象sem_array。例如，在producer中就会新建。</li><li>调用semctl(SETALL)初始化信号量。</li><li>sem_obtain_object_check先从基数树里面找到sem_array对象。</li><li>根据用户指定的信号量数组，初始化信号量集合，也即初始化sem_array对象的struct sem sems[]成员。</li><li>调用semop操作信号量。</li><li>创建信号量操作结构sem_queue，放入队列。</li><li>创建undo结构，放入链表。</li></ol><h2 id="课堂练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07#课堂练习"><span class="icon icon-link"></span></a>课堂练习</h2><p>现在，我们的共享内存、信号量、消息队列都讲完了，你是不是觉得，它们的API非常相似。为了方便记忆，你可以自己整理一个表格，列一下这三种进程间通信机制、行为创建xxxget、使用、控制xxxctl、对应的API和系统调用。</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/趣谈linux操作系统/08.核心原理篇第七部分进程间通信/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:35:05</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
