<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06 | 中间代码：不是只有一副面孔 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/02.预备知识篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a href="/blog/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="IR的用途和层次" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#ir的用途和层次"><span>IR的用途和层次</span></a></li><li title="HIR：基于源语言做一些分析和变换" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#hir基于源语言做一些分析和变换"><span>HIR：基于源语言做一些分析和变换</span></a></li><li title="MIR：独立于源语言和CPU架构做分析和优化" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#mir独立于源语言和cpu架构做分析和优化"><span>MIR：独立于源语言和CPU架构做分析和优化</span></a></li><li title="LIR：依赖于CPU架构做优化和代码生成" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#lir依赖于cpu架构做优化和代码生成"><span>LIR：依赖于CPU架构做优化和代码生成</span></a></li><li title="P-code：用于解释执行的IR" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#p-code用于解释执行的ir"><span>P-code：用于解释执行的IR</span></a></li><li title="IR的呈现格式" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#ir的呈现格式"><span>IR的呈现格式</span></a></li><li title="IR的数据结构" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#ir的数据结构"><span>IR的数据结构</span></a></li><li title="第一种：类似TAC的线性结构（Linear Form）" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#第一种类似tac的线性结构linear-form"><span>第一种：类似TAC的线性结构（Linear Form）</span></a></li><li title="第二种：树结构" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#第二种树结构"><span>第二种：树结构</span></a></li><li title="第三种：有向无环图（Directed Acyclic Graph，DAG）" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#第三种有向无环图directed-acyclic-graphdag"><span>第三种：有向无环图（Directed Acyclic Graph，DAG）</span></a></li><li title="第四种：程序依赖图（Program Dependence Graph，PDG）" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#第四种程序依赖图program-dependence-graphpdg"><span>第四种：程序依赖图（Program Dependence Graph，PDG）</span></a></li><li title="SSA格式的IR" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#ssa格式的ir"><span>SSA格式的IR</span></a></li><li title="课程小结" data-depth="2"><a href="/blog/编译原理实战/02.预备知识篇/06#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="3"><a href="/blog/编译原理实战/02.预备知识篇/06#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06--中间代码不是只有一副面孔"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#06--中间代码不是只有一副面孔"><span class="icon icon-link"></span></a>06 | 中间代码：不是只有一副面孔</h1><p>你好，我是宫文学。今天这一讲，我来带你认识一下中间代码（IR）。</p><p>IR，也就是中间代码（Intermediate Representation，有时也称Intermediate Code，IC），它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成IR，并在此基础上执行各种优化算法，最后再生成目标代码。</p><p>所以说，编译技术的IR非常重要，它是运行各种优化算法、代码生成算法的基础。不过，鉴于IR的设计一般与编译器密切相关，而一些教科书可能更侧重于讲理论，所以对IR的介绍就不那么具体。这就导致我们对IR有非常多的疑问，比如：</p><ul><li><strong>IR都有哪些不同的设计，可以分成什么类型？</strong></li><li><strong>IR有像高级语言和汇编代码那样的标准书写格式吗？</strong></li><li><strong>IR可以采用什么数据结构来实现？</strong></li></ul><p>为了帮助你把对IR的认识从抽象变得具体，我今天就从全局的视角和你一起梳理下IR有关的认知。</p><p>首先，我们来了解一下IR的用途，并一起看看由于用途不同导致IR分成的多个层次。</p><h2 id="ir的用途和层次"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#ir的用途和层次"><span class="icon icon-link"></span></a>IR的用途和层次</h2><p>设计IR的目的，是要满足编译器中的各种需求。需求的不同，就会导致IR的设计不同。通常情况下，IR有两种用途，一种是用来做分析和变换的，一种是直接用于解释执行的。我们先来看第一种。</p><p>编译器中，基于IR的分析和处理工作，一开始可以基于一些抽象层次比较高的语义，这时所需要的IR更接近源代码。而在后面，则会使用低层次的、更加接近目标代码的语义。</p><p>基于这种从高到低的抽象层次，IR可以归结为HIR、MIR和LIR三类。</p><h3 id="hir基于源语言做一些分析和变换"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#hir基于源语言做一些分析和变换"><span class="icon icon-link"></span></a>HIR：基于源语言做一些分析和变换</h3><p>假设你要开发一款IDE，那最主要的功能包括：发现语法错误、分析符号之间的依赖关系（以便进行跳转、判断方法的重载等）、根据需要自动生成或修改一些代码（提供重构能力）。</p><p>这个时候，你对IR的需求，是能够准确表达源语言的语义就行了。这种类型的IR，可以叫做High IR，简称HIR。</p><p>其实，AST和符号表就可以满足这个需求。也就是说，AST也可以算作一种IR。如果你要开发IDE、代码翻译工具（从一门语言翻译到另一门语言）、代码生成工具、代码统计工具等，使用AST（加上符号表）就够了。</p><p>当然，有些HIR并不是树状结构（比如可以采用线性结构），但一般会保留诸如条件判断、循环、数组等抽象层次比较高的语法结构。</p><p>基于HIR，可以做一些高层次的代码优化，比如常数折叠、内联等。在Java和Go的编译器中，你可以看到不少基于AST做的优化工作。</p><h3 id="mir独立于源语言和cpu架构做分析和优化"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#mir独立于源语言和cpu架构做分析和优化"><span class="icon icon-link"></span></a>MIR：独立于源语言和CPU架构做分析和优化</h3><p>大量的优化算法是可以通用的，没有必要依赖源语言的语法和语义，也没有必要依赖具体的CPU架构。</p><p>这些优化包括部分算术优化、常量和变量传播、死代码删除等，我会在下一讲和你介绍。实现这类分析和优化功能的IR可以叫做Middle IR，简称MIR。</p><p>因为MIR跟源代码和目标代码都无关，所以在讲解优化算法时，通常是基于MIR，比如三地址代码（Three Address Code，TAC）。</p><p>TAC的特点是，最多有三个地址（也就是变量），其中赋值符号的左边是用来写入的，而右边最多可以有两个地址和一个操作符，用于读取数据并计算。</p><p>我们来看一个例子，示例函数foo：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int foo (int a){</span></div><div class="token-line"><span class="token plain">      int b = 0;</span></div><div class="token-line"><span class="token plain">      if (a &gt; 10)</span></div><div class="token-line"><span class="token plain">        b = a;</span></div><div class="token-line"><span class="token plain">      else</span></div><div class="token-line"><span class="token plain">        b = 10;</span></div><div class="token-line"><span class="token plain">      return b;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>对应的TAC可能是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">BB1:</span></div><div class="token-line"><span class="token plain">      b := 0</span></div><div class="token-line"><span class="token plain">      if a&gt;10 goto BB3   //如果t是false(0),转到BB3</span></div><div class="token-line"><span class="token plain">    BB2:</span></div><div class="token-line"><span class="token plain">      b := 10</span></div><div class="token-line"><span class="token plain">      goto BB4</span></div><div class="token-line"><span class="token plain">    BB3:</span></div><div class="token-line"><span class="token plain">      b := a</span></div><div class="token-line"><span class="token plain">    BB4:</span></div><div class="token-line"><span class="token plain">      return b</span></div></pre></div><p>可以看到，TAC用goto语句取代了if语句、循环语句这种比较高级的语句，当然也不会有类、继承这些高层的语言结构。但是，它又没有涉及数据如何在内存读写等细节，书写格式也不像汇编代码，与具体的目标代码也是独立的。</p><p>所以，它的抽象程度算是不高不低。</p><h3 id="lir依赖于cpu架构做优化和代码生成"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#lir依赖于cpu架构做优化和代码生成"><span class="icon icon-link"></span></a>LIR：依赖于CPU架构做优化和代码生成</h3><p>最后一类IR就是Low IR，简称LIR。</p><p>这类IR的特点，是它的指令通常可以与机器指令一一对应，比较容易翻译成机器指令（或汇编代码）。因为LIR体现了CPU架构的底层特征，因此可以做一些与具体CPU架构相关的优化。</p><p>比如，下面是Java的JIT编译器输出的LIR信息，里面的指令名称已经跟汇编代码很像了，并且会直接使用AMD64架构的寄存器名称。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimaged98fd9ebaec471be87da8afff32c0718f48f.jpg" alt=""/></p><p>图1：Java的JIT编译器的LIR</p><p>好了，以上就是根据不同的使用目的和抽象层次，所划分出来的不同IR的关键知识点了。</p><p>HIR、MIR和LIR这种划分方法，主要是参考“鲸书（Advanced Compiler Design and Implementation）”的提法。对此有兴趣的话，你可以参考一下这本书。</p><p>在实际操作时，有时候IR的划分标准不一定跟鲸书一致。在有的编译器里（比如Graal编译器），把相对高层次的IR叫做HIR，相对低层次的叫做LIR，而没有MIR。你只要知道它们代表了不同的抽象层次就足够了。</p><p>其实，在一个编译器里，有时候会使用抽象层次从高到低的多种IR，从便于“人”理解到便于“机器”理解。而编译过程可以理解为，抽象层次高的IR一直lower到抽象层次低的IR的过程，并且在每种IR上都会做一些适合这种IR的分析和处理工作，直到最后生成了优化的目标代码。</p><p>扩展：lower这个词的意思，就是把对计算机程序的表示，从抽象层次比较高的、便于人理解的格式，转化为抽象层次比较低的、便于机器理解的格式。</p><p>有些IR的设计，本身就混合了多个抽象层次的元素，比如Java的Graal编译器里就采用了这种设计。Graal的IR采用的是一种图结构，但随着优化阶段的进展，图中的一些节点会逐步从语义比较抽象的节点，lower到体现具体架构特征的节点。</p><h2 id="p-code用于解释执行的ir"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#p-code用于解释执行的ir"><span class="icon icon-link"></span></a>P-code：用于解释执行的IR</h2><p>好了，前3类IR是从抽象层次来划分的，它们都是用来做分析和变换的。我们继续看看第二种直接用于解释执行的IR。这类IR还有一个名称，叫做P-code，也就是Portable Code的意思。由于它与具体机器无关，因此可以很容易地运行在多种电脑上。这类IR对编译器来说，就是做编译的目标代码。</p><p>到这里，你一下子就会想到，Java的字节码就是这种IR。除此之外，Python、Erlang也有自己的字节码，.NET平台、Visual Basic程序也不例外。</p><p>其实，你也完全可以基于AST实现一个全功能的解释器，只不过性能会差一些。对于专门用来解释执行IR，通常会有一些特别的设计，跟虚拟机配合来尽量提升运行速度。</p><p>需要注意的是，P-code也可能被进一步编译，形成可以直接执行的机器码。Java的字节码就是这样的例子。因此，在这门课程里，我会带你探究Java的两个编译器，一个把源代码编译成字节码，一个把字节码编译成目标代码（支持JIT和AOT两种方式）。</p><p>好了，通过了解IR的不同用途，你应该会对IR的概念更清晰一些。用途不同，对IR的需求也就不同，IR的设计自然也就会不同。这跟软件设计是由需求决定的，是同一个道理。</p><p>接下来的一个问题是，<strong>IR是怎样书写的呢？</strong></p><h2 id="ir的呈现格式"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#ir的呈现格式"><span class="icon icon-link"></span></a>IR的呈现格式</h2><p>虽然说是中间代码，但总得有一个书写格式吧，就像源代码和汇编代码那样。</p><p>其实IR通常是没有书写格式的。一方面，大多数的IR跟AST一样，只是编译过程中的一个数据结构而已，或者说只有内存格式。比如，LLVM的IR在内存里是一些对象和接口。</p><p>另一方面，为了调试的需要，你可以把IR以文本的方式输出，用于显示和分析。在这门课里，你也会看到很多IR的输出格式。比如，下面是Julia的IR：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimage0d8d0dc758c3d40f9c41f026663271a4858d.jpg" alt=""/></p><p>图2：Julia语言输出的IR信息</p><p>在少量情况下，IR有比较严格的输出格式，不仅用于显示和分析，还可以作为结果保存，并可以重新读入编译器中。比如，LLVM的bitcode，可以保存成文本和二进制两种格式，这两种格式间还可以相互转换。</p><p>我们以C语言为例，来看下fun1函数，及其对应的LLVM IR的文本格式和二进制格式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//fun1.c </span></div><div class="token-line"><span class="token plain">    int fun1(int a, int b){</span></div><div class="token-line"><span class="token plain">        int c = 10;</span></div><div class="token-line"><span class="token plain">        return a+b+c;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>LLVM IR的文本格式（用“clang -emit-llvm -S fun1.c -o fun1.ll”命令生成，这里只节选了主要部分）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">; ModuleID = &#x27;fun1.c&#x27;</span></div><div class="token-line"><span class="token plain">    source_filename = &quot;function-call1.c&quot;</span></div><div class="token-line"><span class="token plain">    target datalayout = &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;</span></div><div class="token-line"><span class="token plain">    target triple = &quot;x86_64-apple-macosx10.14.0&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ; Function Attrs: noinline nounwind optnone ssp uwtable</span></div><div class="token-line"><span class="token plain">    define i32 @fun1(i32, i32) #0 {</span></div><div class="token-line"><span class="token plain">      %3 = alloca i32, align 4</span></div><div class="token-line"><span class="token plain">      %4 = alloca i32, align 4</span></div><div class="token-line"><span class="token plain">      %5 = alloca i32, align 4</span></div><div class="token-line"><span class="token plain">      store i32 %0, i32* %3, align 4</span></div><div class="token-line"><span class="token plain">      store i32 %1, i32* %4, align 4</span></div><div class="token-line"><span class="token plain">      store i32 10, i32* %5, align 4</span></div><div class="token-line"><span class="token plain">      %6 = load i32, i32* %3, align 4</span></div><div class="token-line"><span class="token plain">      %7 = load i32, i32* %4, align 4</span></div><div class="token-line"><span class="token plain">      %8 = add nsw i32 %6, %7</span></div><div class="token-line"><span class="token plain">      %9 = load i32, i32* %5, align 4</span></div><div class="token-line"><span class="token plain">      %10 = add nsw i32 %8, %9</span></div><div class="token-line"><span class="token plain">      ret i32 %10</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>二进制格式（用“clang -emit-llvm -c fun1.c -o fun1.bc”命令生成，用“hexdump -C fun1.bc”命令显示）：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimage984b9830e3f7bb6e250a56805d8802eb564b.jpg" alt=""/></p><p>图3：LLVM IR的二进制格式</p><h2 id="ir的数据结构"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#ir的数据结构"><span class="icon icon-link"></span></a>IR的数据结构</h2><p>既然我们一直说IR会表现为内存中的数据结构，那它到底是什么结构呢？</p><p>在实际的实现中，有线性结构、树结构、有向无环图（DAG）、程序依赖图（PDG）等多种格式。编译器会根据需要，选择合适的数据结构。在运行某些算法的时候，采用某个数据结构可能会更顺畅，而采用另一些结构可能会带来内在的阻滞。所以，<strong>我们一定要根据具体要处理的工作的特点，来选择合适的数据结构。</strong></p><p>那我们接下来，就具体看看每种格式的特点。</p><h3 id="第一种类似tac的线性结构linear-form"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#第一种类似tac的线性结构linear-form"><span class="icon icon-link"></span></a>第一种：类似TAC的线性结构（Linear Form）</h3><p>你可以把代码表示成一行行的指令或语句，用数组或者列表保存就行了。其中的符号，需要引用符号表，来提供类型等信息。</p><p>这种线性结构有时候也被称作goto格式。因为高级语言里的条件语句、循环语句，要变成用goto语句跳转的方式。</p><h3 id="第二种树结构"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#第二种树结构"><span class="icon icon-link"></span></a>第二种：树结构</h3><p>树结构当然可以用作IR，AST就是一种树结构。</p><p>很多资料中讲指令选择的时候，也会用到一种树状的结构，便于执行树覆盖算法。这个树结构，就属于一种LIR。</p><p>树结构的缺点是，可能有冗余的子树。比如，语句“<code>a=5; b=(2+a)+a*3;</code> ”形成的AST就有冗余。如果基于这个树结构生成代码，可能会做两次从内存中读取a的值的操作，并存到两个临时变量中。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimage742f74e6c6d63d3c49656ecee767a8d8b52f.jpg" alt=""/></p><p>图4：冗余的子树</p><h3 id="第三种有向无环图directed-acyclic-graphdag"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#第三种有向无环图directed-acyclic-graphdag"><span class="icon icon-link"></span></a>第三种：有向无环图（Directed Acyclic Graph，DAG）</h3><p>DAG结构，是在树结构的基础上，消除了冗余的子树。比如，上面的例子转化成DAG以后，对a的内存访问只做一次就行了。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimage16a2168f1617889bbe76095e65d4968333a2.jpg" alt=""/></p><p>图5：DAG结构消除了冗余的子树</p><p>在LLVM的目标代码生成环节，就使用了DAG来表示基本块内的代码。</p><h3 id="第四种程序依赖图program-dependence-graphpdg"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#第四种程序依赖图program-dependence-graphpdg"><span class="icon icon-link"></span></a>第四种：程序依赖图（Program Dependence Graph，PDG）</h3><p>程序依赖图，是显式地把程序中的数据依赖和控制依赖表示出来，形成一个图状的数据结构。基于这个数据结构，我们再做一些优化算法的时候，会更容易实现。</p><p>所以现在，有很多编译器在运行优化算法的时候，都基于类似PDG的数据结构，比如我在课程后面会分析的Java的JIT编译器和JavaScript的编译器。</p><p>这种数据结构里，因为会有很多图节点，又被形象地称为“<strong>节点之海（Sea of Nodes）</strong>”。你在很多文章中，都会看到这个词。</p><p>以上就是常用于IR的数据结构了。接下来，我再介绍一个重要的IR设计范式：SSA格式。</p><h2 id="ssa格式的ir"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#ssa格式的ir"><span class="icon icon-link"></span></a>SSA格式的IR</h2><p>SSA是Static Single Assignment的缩写，也就是静态单赋值。这是IR的一种设计范式，它要求一个变量只能被赋值一次。我们来看个例子。</p><p>“y = x1 + x2 + x3 + x4”的普通TAC如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">y := x1 + x2;</span></div><div class="token-line"><span class="token plain">    y := y + x3;</span></div><div class="token-line"><span class="token plain">    y := y + x4;</span></div></pre></div><p>其中，y被赋值了三次，如果我们写成SSA的形式，就只能写成下面的样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">t1 := x1 + x2;</span></div><div class="token-line"><span class="token plain">    t2 := t1 + x3;</span></div><div class="token-line"><span class="token plain">    y  := t2 + x4;</span></div></pre></div><p><strong>那我们为什么要费力写成这种形式呢，还要为此多添加t1和t2两个临时变量？</strong></p><p>原因是，使用SSA的形式，体现了精确的“<strong>使用-定义（use-def）</strong>”关系。并且由于变量的值定义出来以后就不再变化，使得基于SSA更容易运行一些优化算法。在后面的课程中，我会通过实际的例子带你体会这一点。</p><p>在SSA格式的IR中，还会涉及一个你经常会碰到的，但有些特别的指令，叫做 <strong>phi指令</strong>。它是什么意思呢？我们看一个例子。</p><p>同样对于示例代码foo：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int foo (int a){</span></div><div class="token-line"><span class="token plain">      int b = 0;</span></div><div class="token-line"><span class="token plain">      if (a &gt; 10)</span></div><div class="token-line"><span class="token plain">        b = a;</span></div><div class="token-line"><span class="token plain">      else</span></div><div class="token-line"><span class="token plain">        b = 10;</span></div><div class="token-line"><span class="token plain">      return b;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>它对应的SSA格式的IR可以写成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">BB1:</span></div><div class="token-line"><span class="token plain">      b1 := 0</span></div><div class="token-line"><span class="token plain">      if a&gt;10 goto BB3</span></div><div class="token-line"><span class="token plain">    BB2:</span></div><div class="token-line"><span class="token plain">      b2 := 10</span></div><div class="token-line"><span class="token plain">      goto BB4</span></div><div class="token-line"><span class="token plain">    BB3:</span></div><div class="token-line"><span class="token plain">      b3 := a</span></div><div class="token-line"><span class="token plain">    BB4:</span></div><div class="token-line"><span class="token plain">      b4 := phi(BB2, BB3, b2, b3)</span></div><div class="token-line"><span class="token plain">      return b4</span></div></pre></div><p>其中，变量b有4个版本：b1是初始值，b2是else块（BB2）的取值，b3是if块（BB3）的取值，最后一个基本块（BB4）要把b的最后取值作为函数返回值。很明显，b的取值有可能是b2，也有可能是b3。这时候，就需要phi指令了。</p><p>phi指令，会根据控制流的实际情况确定b4的值。如果BB4的前序节点是BB2，那么b4的取值是b2；而如果BB4的前序节点是BB3，那么b4的取值就是b3。所以你会看到，如果要满足SSA的要求，也就是一个变量只能赋值一次，那么在遇到有程序分支的情况下，就必须引入phi指令。关于这一点，你也会在课程后面经常见到它。</p><p>最后我要指出的是，**由于SSA格式的优点，现代语言用于优化的IR，很多都是基于SSA的了，包括我们本课程涉及的Java的JIT编译器、JavaScript的V8编译器、Go语言的gc编译器、Julia编译器，以及LLVM工具等。**所以，你一定要高度重视SSA。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>今天这一讲，我希望你能记住关于IR的几个重要概念：</p><ul><li><strong>根据抽象层次和使用目的不同，可以设计不同的IR；</strong></li><li><strong>IR可能采取多种数据结构，每种结构适合不同的处理工作；</strong></li><li><strong>由于SSA格式的优点，主流的编译器都在采用这种范式来设计IR。</strong></li></ul><p>通过学习IR，你会形成看待编译过程的一个新视角：整个编译过程，就是生成从高抽象度到低抽象度的一系列IR，以及发生在这些IR上的分析与处理过程。</p><p>我还展示了三地址代码、LLVM IR等一些具体的IR设计，希望能给你增加一些直观印象。在有的教科书里，还会有三元式、四元式、逆波兰格式等不同的设计，你也可以参考。而在后面的课程里，你会接触到每门编译器的IR，从而对IR的理解更加具体和丰满。</p><p>本讲的思维导图如下：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimage195519a96336d4b579a86263f82d98c72255.jpg" alt=""/></p><h3 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#一课一思"><span class="icon icon-link"></span></a>一课一思</h3><p>你能试着把下面这段简单的程序，改写成TAC和SSA格式吗？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bar(a){</span></div><div class="token-line"><span class="token plain">        int sum = 0;</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i&lt; a; i++){</span></div><div class="token-line"><span class="token plain">            sum = sum+i;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return sum;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>欢迎在留言区分享你的见解，也欢迎你把今天的内容分享给更多的朋友。</p><h3 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/02.预备知识篇/06#参考资料"><span class="icon icon-link"></span></a>参考资料</h3><ol><li>关于程序依赖图的论文参考：<a target="_blank" rel="noopener noreferrer" href="https://www.cs.utexas.edu/~pingali/CS395T/2009fa/papers/ferrante87.pdf">The Program Dependence Graph and its Use in Optimization<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>更多的关于LLVM IR的介绍，你可以参考《编译原理之美》的第<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/153192">25<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/154438">26<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲，以及<a target="_blank" rel="noopener noreferrer" href="https://llvm.org/docs/LangRef.html">LLVM官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>对Java字节码的介绍，你可以参考《编译原理之美》的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/161944">第32讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，还可以参考<a target="_blank" rel="noopener noreferrer" href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-6.html">Java Language Specification<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>鲸书（Advanced Compiler Design and Implementation）第4章。</li></ol></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/编译原理实战/02.预备知识篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
