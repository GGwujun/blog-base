<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>知识地图 | 一起来复习编译技术核心概念与算法 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/02.预备知识篇/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog-base/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog-base/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog-base/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog-base/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog-base/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="一、词法分析：根据词法规则，把字符串转换为Token" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#一词法分析根据词法规则把字符串转换为token"><span>一、词法分析：根据词法规则，把字符串转换为Token</span></a></li><li title="核心概念：正则文法" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念正则文法"><span>核心概念：正则文法</span></a></li><li title="具体实现：手工构造词法分析器、自动生成词法分析器" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现手工构造词法分析器自动生成词法分析器"><span>具体实现：手工构造词法分析器、自动生成词法分析器</span></a></li><li title="技术难点" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#技术难点"><span>技术难点</span></a></li><li title="二、语法分析：依据语法规则，编写语法分析程序，把 Token 串转化成 AST" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#二语法分析依据语法规则编写语法分析程序把-token-串转化成-ast"><span>二、语法分析：依据语法规则，编写语法分析程序，把 Token 串转化成 AST</span></a></li><li title="核心概念：上下文无关文法" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念上下文无关文法"><span>核心概念：上下文无关文法</span></a></li><li title="具体实现：自顶向下、自底向上" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现自顶向下自底向上"><span>具体实现：自顶向下、自底向上</span></a></li><li title="技术难点" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#技术难点-1"><span>技术难点</span></a></li><li title="三、语义分析：检查程序是否符合语义规则，并为后续的编译工作收集语义信息" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#三语义分析检查程序是否符合语义规则并为后续的编译工作收集语义信息"><span>三、语义分析：检查程序是否符合语义规则，并为后续的编译工作收集语义信息</span></a></li><li title="核心概念：上下文相关文法" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念上下文相关文法"><span>核心概念：上下文相关文法</span></a></li><li title="场景案例" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#场景案例"><span>场景案例</span></a></li><li title="具体实现：引用消解、符号表、类型系统、属性计算" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现引用消解符号表类型系统属性计算"><span>具体实现：引用消解、符号表、类型系统、属性计算</span></a></li><li title="四、运行时机制：程序的两种不同的执行模式" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#四运行时机制程序的两种不同的执行模式"><span>四、运行时机制：程序的两种不同的执行模式</span></a></li><li title="在物理机上运行" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#在物理机上运行"><span>在物理机上运行</span></a></li><li title="在虚拟机上运行" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#在虚拟机上运行"><span>在虚拟机上运行</span></a></li><li title="五、中间代码：运行各种优化算法、代码生成算法的基础" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#五中间代码运行各种优化算法代码生成算法的基础"><span>五、中间代码：运行各种优化算法、代码生成算法的基础</span></a></li><li title="IR的用途和层次（从抽象层次的角度来划分）" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#ir的用途和层次从抽象层次的角度来划分"><span>IR的用途和层次（从抽象层次的角度来划分）</span></a></li><li title="IR的解释执行" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#ir的解释执行"><span>IR的解释执行</span></a></li><li title="IR的呈现格式" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#ir的呈现格式"><span>IR的呈现格式</span></a></li><li title="IR的数据结构" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#ir的数据结构"><span>IR的数据结构</span></a></li><li title="SSA格式的IR" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#ssa格式的ir"><span>SSA格式的IR</span></a></li><li title="六、代码分析与优化：优化程序对计算机资源的使用，以提高程序的性能" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#六代码分析与优化优化程序对计算机资源的使用以提高程序的性能"><span>六、代码分析与优化：优化程序对计算机资源的使用，以提高程序的性能</span></a></li><li title="优化分类" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#优化分类"><span>优化分类</span></a></li><li title="优化方法" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#优化方法"><span>优化方法</span></a></li><li title="分析方法" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#分析方法"><span>分析方法</span></a></li><li title="优化方法的重要性和顺序" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#优化方法的重要性和顺序"><span>优化方法的重要性和顺序</span></a></li><li title="七、目标代码生成：编译器最后一个阶段的工作，生成针对不同架构的目标代码，也就是生成汇编代码" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#七目标代码生成编译器最后一个阶段的工作生成针对不同架构的目标代码也就是生成汇编代码"><span>七、目标代码生成：编译器最后一个阶段的工作，生成针对不同架构的目标代码，也就是生成汇编代码</span></a></li><li title="生成针对不同架构的目标代码" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#生成针对不同架构的目标代码"><span>生成针对不同架构的目标代码</span></a></li><li title="生成目标代码时的优化工作" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#生成目标代码时的优化工作"><span>生成目标代码时的优化工作</span></a></li><li title="调用约定的影响" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#调用约定的影响"><span>调用约定的影响</span></a></li><li title="整体的处理过程" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/09#整体的处理过程"><span>整体的处理过程</span></a></li><li title="知识地图" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/09#知识地图"><span>知识地图</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="知识地图--一起来复习编译技术核心概念与算法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#知识地图--一起来复习编译技术核心概念与算法"><span class="icon icon-link"></span></a>知识地图 | 一起来复习编译技术核心概念与算法</h1><p>你好，我是学习委员朱英达。</p><p>在“预备知识篇”这个模块，宫老师系统地梳理了编译过程中各个阶段的核心要点，目的就是让我们建立一个编译原理的基础知识体系。那到今天为止，我们就学完了这部分内容，迈出了编译之旅中扎实的第一步。不知道你对这些知识掌握得怎样了？</p><p><strong>为了复习，也为了检测我们的学习成果，我根据自己的知识积累和学习情况，整理了一张知识大地图，你可以根据这张地图中标记的七大编译阶段，随时速查常用的编译原理概念和关键算法。</strong></p><p>如果你也总结了知识地图，那你可以对照着我这个，给自己一个反馈，看看它们之间有哪些异同点，我们可以在留言区中一起交流和讨论。</p><p>不过知识地图的形式，虽然便于你保存、携带、速查，但考虑到图中涉及的概念等内容较多，不方便查看和检索。**所以，我还把地图上的知识点，用文字的形式帮你梳理出来了。**你可以对照着它，来复习和回顾编译技术的核心概念和算法的知识点，构建自己的知识框架。</p><p>你在学习这些预备知识的过程中，可能会发现，宫老师并没有非常深入地讲解编译原理的具体概念、理论和算法。所以，如果你想继续深入学习这些基础知识，可以根据宫老师在每讲最后给出的参考资料，去学习龙书、虎书、鲸书等经典编译原理书籍。当然，你也可以去看看宫老师的第一季专栏课《编译原理之美》。</p><p>在我看来，相较于编译方面的教科书而言，《编译原理之美》这门课的优势在于，更加通俗易懂、与时俱进，既可以作为新手的起步指导，也能够帮助已经熟悉编译技术的工程师扩展视野，我很推荐你去学习这门课。所以，我邀请编辑添加了相应的知识点到《编译原理之美》的文章链接，如果你有深入学习的需要，你会很方便地找到它。</p><p>好了，一起开始复习吧！</p><h2 id="一词法分析根据词法规则把字符串转换为token"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#一词法分析根据词法规则把字符串转换为token"><span class="icon icon-link"></span></a>一、词法分析：根据词法规则，把字符串转换为Token</h2><h3 id="核心概念正则文法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念正则文法"><span class="icon icon-link"></span></a>核心概念：正则文法</h3><ul><li>正则文法：词法分析工作的主要文法，它涉及的重要概念是正则表达式。</li><li>正则表达式：正则文法的一种直观描述，它是按照指定模式匹配字符串的一种字符组合。</li><li>正则表达式工具：字符串的模式匹配工具。大多数程序语言都内置了正则表达式的匹配方法，也可以借助一些编译工具，自动化根据正则表达式生成字符串匹配程序，例如C++的Lex/Yacc以及Java的ANTLR。</li></ul><h3 id="具体实现手工构造词法分析器自动生成词法分析器"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现手工构造词法分析器自动生成词法分析器"><span class="icon icon-link"></span></a>具体实现：手工构造词法分析器、自动生成词法分析器</h3><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/118378"><strong>手工构造词法分析器</strong></a></p><ul><li>构造词法分析器使用的计算模型：有限自动机（FSA）。它是用于识别正则文法的一种程序实现方案。</li><li>其组成的词法单元是Token，也就是指程序中标记出来的单词和标点符号，它可以分成关键字、标识符、字面量、操作符号等多个种类。</li><li>在实际的编译器中，词法分析器一般都是手写的。</li></ul><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/137286"><strong>自动生成词法分析器</strong></a></p><ul><li>具体实现思路：把一个正则表达式翻译成NFA，然后把NFA转换成DFA。</li><li>DFA：确定的有限自动机。它的特点是：该状态机在任何一个状态，基于输入的字符，都能做一个确定的状态转换。</li><li>NFA：不确定的有限自动机。它的特点是：该状态机中存在某些状态，针对某些输入，不能做一个确定的转换。这里可以细分成两种情况：一种是对于一个输入，它有两个状态可以转换；另一种是存在ε转换的情况，也就是没有任何字符输入的情况下，NFA也可以从一个状态迁移到另一个状态。</li></ul><h3 id="技术难点"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#技术难点"><span class="icon icon-link"></span></a>技术难点</h3><p><strong>首先，你需要注意，NFA和DFA都有各自的优缺点，以及不同的适用场景。</strong></p><ul><li>NFA：优点是在设计上更简单直观，缺点是它无法避免回溯问题，在某些极端的情况下可能会造成编译器运行的性能低下。主要适用于状态较为简单，且不存在回溯的场景。</li><li>DFA：优点是它可以避免回溯问题，运行性能较高，缺点是DFA通常不容易直接设计出来，需要通过一系列方案，基于NFA的转换而得到，并且需要占用额外的空间。主要适用于状态较为复杂，或者对时间复杂度要求较为严苛的工业级词法分析器。</li></ul><p><strong>其次，你需要了解基于正则表达式构造NFA，再去进行模式匹配的算法思路。</strong></p><ul><li>从正则表达式到NFA：这是自动生成词法分析器的一种算法思路。它的翻译方法是，匹配一个字符i —&gt;匹配“或”模式s|t —&gt; 匹配“与”模式st —&gt; 重复模式，如“?”“*”和“+”等符号，它们的意思是可以重复0次、0到多次、1到多次，注意在转换时要增加额外的状态和边。</li><li>从NFA到DFA：NFA的运行可能导致大量的回溯，所以我们可以把NFA转换成DFA，让字符串的匹配过程更简单。从NFA转换成DFA的算法是子集构造法，具体的算法思路你可以参考第16讲。</li></ul><h2 id="二语法分析依据语法规则编写语法分析程序把-token-串转化成-ast"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#二语法分析依据语法规则编写语法分析程序把-token-串转化成-ast"><span class="icon icon-link"></span></a>二、语法分析：依据语法规则，编写语法分析程序，把 Token 串转化成 AST</h2><h3 id="核心概念上下文无关文法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念上下文无关文法"><span class="icon icon-link"></span></a>核心概念：上下文无关文法</h3><ul><li>上下文无关的意思：在任何情况下，文法的推导规则都是一样的。</li><li>语法规则由4个部分组成：一个有穷的非终结符（或变元）的集合、一个有穷的终结符的集合、一个有穷的产生式集合、一个起始非终结符（变元）。符合这四个特点的文法规则就是上下文无关文法。</li><li>两种描述形式：一种是巴科斯范式（BNF），另一种是巴科斯范式的一种扩展形式（EBNF），它更利于自动化生成语法分析器。其中，产生式、终结符、非终结符、开始符号是巴科斯范式的基本组成要素。</li><li>上下文无关文法与正则文法的区别：上下文无关文法允许递归调用，而正则文法不允许。上下文无关文法比正则文法的表达能力更强，正则文法是上下文无关文法的一个子集。</li></ul><h3 id="具体实现自顶向下自底向上"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现自顶向下自底向上"><span class="icon icon-link"></span></a>具体实现：自顶向下、自底向上</h3><p><strong>一种是自顶向下的算法思路，它是指从根节点逐层往下分解，形成最后的AST。</strong></p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/119891">递归下降算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：它的算法思路是按照语法规则去匹配Token串。优点：程序结构基本上是跟文法规则同构的。缺点：会造成<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/120388">左递归<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/125926">回溯<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>问题。<strong>注意</strong>，递归下降是深度优先（DFS）的，只有最左边的子树都生成完了，才会往右生成它的兄弟节点。</li><li><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/138385">LL算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：对于一些比较复杂的语法规则来说，这个算法可以自动计算出选择不同产生式的依据。方法：从左到右地消化掉 Token。要点：计算 First 和 Follow 集合。</li></ul><p><strong>另一种是</strong><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/139628"><strong>自底向上的算法思路</strong></a><strong>，它是指从底下先拼凑出AST的一些局部拼图，并逐步组装成一棵完整的AST。</strong></p><ul><li>自底向上的语法分析思路：移进，把token加入工作区；规约，在工作区内组装AST的片段。</li><li>LR算法和 LL 算法一样，也是从左到右地消化掉 Token。</li></ul><h3 id="技术难点-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#技术难点-1"><span class="icon icon-link"></span></a>技术难点</h3><p><strong>首先，你需要掌握LL算法的要点，也就是</strong><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/138385"><strong>计算First和Follow集合</strong></a>。</p><p><strong>其次，你要了解LL算法与LR算法的异同点。</strong></p><ul><li>LL算法：优点是较为直观、容易实现，缺点是在一些情况下不得不处理左递归消除和提取左因子问题。</li><li>LR算法：优点是不怕左递归，缺点是缺少完整的上下文信息，编译错误显示不友好。</li></ul><h2 id="三语义分析检查程序是否符合语义规则并为后续的编译工作收集语义信息"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#三语义分析检查程序是否符合语义规则并为后续的编译工作收集语义信息"><span class="icon icon-link"></span></a>三、语义分析：检查程序是否符合语义规则，并为后续的编译工作收集语义信息</h2><h3 id="核心概念上下文相关文法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#核心概念上下文相关文法"><span class="icon icon-link"></span></a>核心概念：<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/133737">上下文相关文法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><ul><li>属性文法：上下文相关文法对EBNF进行了扩充，在上下文无关的推导过程中，辅助性解决一些上下文相关的问题。</li><li>注意：上下文相关文法没有像状态图、BNF那样直观的分析范式。</li><li>应用场景：控制流检查、闭包分析、引用消解等。</li></ul><h3 id="场景案例"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#场景案例"><span class="icon icon-link"></span></a>场景案例</h3><p><strong>1.控制流检查</strong></p><p>像return、break 和continue等语句，都与程序的控制流有关，它们必须符合控制流方面的规则。在 Java 这样的语言中，语义规则会规定：如果返回值不是 void，那么在退出函数体之前，一定要执行一个 return 语句，那么就要检查所有的控制流分支，是否都以 return 语句结尾。</p><p><strong>2.</strong><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/131317"><strong>闭包分析</strong></a></p><p>很多语言都支持闭包。而要正确地使用闭包，就必须在编译期知道哪些变量是自由变量。这里的自由变量是指在本函数外面定义的变量，但被这个函数中的代码所使用。这样，在运行期，编译器就会用特殊的内存管理机制来管理这些变量。所以，对闭包的分析，也是上下文敏感的。</p><h3 id="具体实现引用消解符号表类型系统属性计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#具体实现引用消解符号表类型系统属性计算"><span class="icon icon-link"></span></a>具体实现：引用消解、符号表、类型系统、属性计算</h3><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/133737"><strong>引用消解</strong></a></p><ul><li>概念解释：引用消解是一种非常重要的上下文相关的语义规则，它其实就是从符号表里查找被引用的符号的定义。</li><li><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/128623">作用域<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：指计算机语言中变量、函数、类等起作用的范围。对于变量来说，为了找到正确的引用，就需要用到作用域。一般来说，它有两种使用场景，一种是标识符作用域，一种是词法作用域。</li></ul><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/130422"><strong>符号表</strong></a></p><ul><li>符号表内包含的信息：名称、分类、类型、作用域等。</li><li>存储形式：线性表格、层次化表格。</li><li>符号表的作用：维护程序中定义的标识符（ID类Token），提供给编译器的各个环节进行操作。</li><li>建立符号表的过程：整个编译器前端都会涉及到，词法分析阶段将ID类Token收集到符号表中，语法分析阶段可进行读取和补充，语义分析阶段做引用消解时符号表的作用至关重要。</li><li>注意：符号表跟编译过程的多个阶段都相关。</li></ul><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/132693"><strong>类型系统</strong></a></p><ul><li>类型：在计算机语言里，类型是数据的一个属性，它的作用是来告诉编译器或解释器，程序可以如何使用这些数据。</li><li>类型系统：类型系统是一门语言所有的类型的集合，操作这些类型的规则，以及类型之间怎么相互作用的（比如一个类型能否转换成另一个类型）。</li><li>类型检查：这是与类型有关的分析和处理工作之一。主要用于对源程序代码中的一些类型不匹配的情况进行隐式类型转换或直接抛错。</li><li><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134978">子类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：面向对象编程时，我们可以给某个类创建不同的子类，实现一些个性化的功能；写程序时，我们可以站在抽象度更高的层次上，不去管具体的差异。把这里的结论抽象成一般意义上的类型理论，就是子类型。</li><li>类型转换：比如说，表达式“<code>a=b+10</code>”，如果 a 的类型是浮点型，而右边传过来的是整型，那么一般就要进行缺省的类型转换。</li><li>参数化类型/泛型：泛型是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。</li></ul><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/133737"><strong>属性计算</strong></a></p><ul><li>编译器一般会采用属性计算的方法，来计算出每个 AST 节点的类型属性，然后检查它们是否匹配。</li><li>属性文法：属性计算的方法，就是基于语法规则，来定义一些属性计算的规则，在做语法解析或遍历AST的时候执行这些规则，我们就可以计算出属性值。这种基于语法规则定义的计算规则，被叫做属性文法（Attribute Grammar）。</li><li>属性计算：S属性（综合属性）、I属性（继承属性）。</li><li>形成的数据结构：Annotated AST（带有标注信息的AST）。</li><li>语法制导的翻译：属性计算的特点是会基于语法规则，增加一些与语义处理有关的规则，我们把这种语义规则的定义叫做语法制导的定义，如果变成计算动作，就叫做语法制导的翻译。</li></ul><h2 id="四运行时机制程序的两种不同的执行模式"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#四运行时机制程序的两种不同的执行模式"><span class="icon icon-link"></span></a>四、运行时机制：程序的两种不同的执行模式</h2><p>通常情况下，程序有两种执行模式：基于物理机、基于虚拟机。</p><h3 id="在物理机上运行"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#在物理机上运行"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/146635">在物理机上运行<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p><strong>举例</strong>：C、C++、Golang。</p><p><strong>程序运行的原理</strong>：基于指令指针寄存器的控制，顺序从内存读取指令执行。</p><p><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/147854"><strong>CPU</strong></a>：运行指令的地方。</p><ul><li>多种架构：x86、ARM、MIPS、RISC-V、PowerPC等。</li><li>关键构成：寄存器、高速缓存、功能单元。</li><li><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/150798">汇编代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：操作码（让 CPU 执行的动作）、操作数（指令的操作对象，可以是常数、寄存器和某个内存地址）。</li></ul><p><strong>内存</strong>：执行指令相关的另一个硬件。</p><p>1.代码区：存放编译完成以后的机器码。<br/>2.静态数据区：保存程序中全局的变量和常量。<br/>3.栈：适合保存生存期比较短的数据，比如函数和方法里的本地变量。</p><ul><li>重要知识点：栈帧的构成、活动记录、逐级调用过程。</li><li>栈的特点：申请和释放—修改栈顶指针，生存期与作用域相同。</li></ul><p>4.堆：适合管理生存期较长的一些数据，这些数据在退出作用域以后也不会消失。</p><ul><li>重要知识点：通过操作系统API手动申请和释放。</li><li>管理机制：自动管理、手动管理。</li></ul><p><strong>操作系统</strong>：除了硬件支撑，程序的运行还需要软件，这就是运行时系统。</p><ul><li>定义：除了硬件支撑，程序的运行还需要软件，这些软件叫做运行时系统。</li><li>操作系统：对于把源代码编译成机器码在操作系统上运行的语言来说（比如 C、C++），操作系统本身就可以看做是它们的运行时系统。</li><li>管理CPU资源：分时执行。比如，时间片轮转算法，将CPU以时钟周期为单元执行多进程任务，实现并发。</li><li>管理内存资源：逻辑内存（系统内核对内存地址的划定）、物理内存（硬件中具体每一个bit实际的硬件存储情况）、虚拟内存（基于操作系统内核对内存管理问题的抽象，通常有一部分虚拟内存实际上是存在磁盘上的）。</li></ul><h3 id="在虚拟机上运行"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#在虚拟机上运行"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/161944">在虚拟机上运行<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p><strong>举例</strong>：Java、Python、Erlang、Lua。</p><p><strong>程序运行的原理</strong>：虚拟机是计算机语言的另一种运行时系统。虚拟机上运行的是中间代码，而不是 CPU 可以直接认识的指令。</p><p><strong>基于栈的虚拟机</strong>：指令在操作数栈的栈顶获取操作数（如JVM、Python虚拟机）。</p><ul><li>优点：易于生成代码。</li><li>缺点：代码数量较多、不能充分利用寄存器。</li></ul><p><strong>基于寄存器的虚拟机</strong>：类似于物理机，从寄存器取操作数（如Erlang、Lua、Dalvik、Ignition）。</p><ul><li>优点与缺点：与栈机相反。</li></ul><p>**二者的区别：**主要在于如何获取指令的操作数。</p><h2 id="五中间代码运行各种优化算法代码生成算法的基础"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#五中间代码运行各种优化算法代码生成算法的基础"><span class="icon icon-link"></span></a>五、中间代码：运行各种优化算法、代码生成算法的基础</h2><p>在这门课程中，宫老师主要从用途和层次、解释执行、呈现格式和数据结构等角度来给你讲解IR这一关键概念。如果你想要更深入地了解IR的特点，理解如何生成IR来实现静态编译的语言，你可以去看《编译原理之美》的第<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/151939">24<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/153192">25<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/154438">26<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲。</p><h3 id="ir的用途和层次从抽象层次的角度来划分"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#ir的用途和层次从抽象层次的角度来划分"><span class="icon icon-link"></span></a>IR的用途和层次（从抽象层次的角度来划分）</h3><ul><li>第一类用途：基于源语言做一些分析和变换（HIR）。</li><li>第二类用途：独立于源语言和CPU架构做分析和优化（MIR）。</li><li>第三类用途：依赖于CPU架构做优化和代码生成（LIR）。</li></ul><h3 id="ir的解释执行"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#ir的解释执行"><span class="icon icon-link"></span></a>IR的解释执行</h3><ul><li>P-code：直接用于解释执行的IR。由于它与具体机器无关，因此可以很容易地运行在多种电脑上。这类IR对编译器来说，就是做编译的目标代码。</li><li>注意：P-code也可能被进一步编译，形成可以直接执行的机器码。如Java的字节码。</li></ul><h3 id="ir的呈现格式"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#ir的呈现格式"><span class="icon icon-link"></span></a>IR的呈现格式</h3><p>大部分IR没有像源代码和汇编代码那样的书写格式。</p><ul><li>大多数的IR跟AST一样，只是编译过程中的一个数据结构而已，或者说只有内存格式。比如，LLVM的IR在内存里是一些对象和接口。</li><li>为了调试的需要，你可以把IR以文本的方式输出，用于显示和分析。</li></ul><h3 id="ir的数据结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#ir的数据结构"><span class="icon icon-link"></span></a>IR的数据结构</h3><ul><li>第一种：类似TAC的线性结构。</li><li>第二种：树结构。</li><li>第三种：DAG-有向无环图。</li><li>第四种：PDG-程序依赖图。</li></ul><h3 id="ssa格式的ir"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#ssa格式的ir"><span class="icon icon-link"></span></a>SSA格式的IR</h3><ul><li>概念：SSA，即静态单赋值。这是IR的一种设计范式，它要求一个变量只能被赋值一次。</li><li>要点：使用SSA的形式，体现了精确的“<strong>使用-定义（Use-def）</strong>”关系，并且由于变量的值定义出来以后就不再变化，使得基于SSA更容易运行一些优化算法。</li><li>注意：现代语言用于优化的IR，很多都是基于SSA的，包括Java的JIT编译器、JavaScript的V8编译器、Go语言的gc编译器、Julia编译器，以及LLVM工具等。</li></ul><h2 id="六代码分析与优化优化程序对计算机资源的使用以提高程序的性能"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#六代码分析与优化优化程序对计算机资源的使用以提高程序的性能"><span class="icon icon-link"></span></a>六、代码分析与优化：优化程序对计算机资源的使用，以提高程序的性能</h2><h3 id="优化分类"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#优化分类"><span class="icon icon-link"></span></a>优化分类</h3><p><strong>是否与机器有关</strong></p><ul><li>机器无关：指与硬件特征无关，比如把常数值在编译期计算出来（常数折叠）。</li><li>机器有关：需要利用某硬件特有的特征，比如 SIMD 指令可以在一条指令里完成多个数据的计算。</li></ul><p><strong>优化范围</strong></p><ul><li>本地优化/局部优化：基本块内。</li><li>全局优化：函数（过程）内。</li><li>过程间优化：跨函数（过程）。</li></ul><h3 id="优化方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#优化方法"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/155338"><strong>优化方法</strong></a></h3><p><strong>1.把常量提前计算出来</strong></p><ul><li>常数折叠：程序里的有些表达式，肯定能计算出一个常数值，那就不要等到运行时再去计算，干脆在编译期就计算出来。比如“<code>x=2*3</code>”可以优化成“<code>x=6</code>” 。</li><li>常数传播：如果你一旦知道 x 的值其实是一个常量，那你就可以把所有用到 x 的地方，替换成这个常量。</li><li>稀疏有条件的常数传播：基于常数传播，还可以进一步导致分支判断条件转化为常量，导致一个分支的代码不会被执行。</li></ul><p><strong>2.用低代价的方法做计算</strong></p><ul><li>代数简化：利用代数运算规则所做的简化，比如“<code>x=x*0</code>”可以简化成“<code>x=0</code>”。</li></ul><p><strong>3.消除重复的计算</strong></p><ul><li>拷贝传播：遇到相同引用的变量，拷贝替换为同一个，节省内存到寄存器的操作，以此提升运算速度。</li><li>值编号（VN和GVN）：把相同的值，在系统里给一个相同的编号，并且只计算一次。</li><li>公共子表达式消除（CSE）：也会减少程序的计算次数。比如“<code>x:=a+b</code>”和“<code>y:=a+b</code>”，x和y右边的形式是一样的，就可以让y等于x，从而减少了一次对“<code>a+b</code>”的计算。</li><li>部分冗余消除（PRE）：是公共子表达式消除的一种特殊情况。</li></ul><p><strong>4.化零为整，向量计算</strong></p><ul><li>超字级并行（SLP）：把基本块中的多个变量组成一个向量，用一个指令完成多个变量的计算。</li><li>循环向量化：在循环展开的基础上，把多次计算优化成一个向量计算。</li></ul><p><strong>5.化整为零，各个优化</strong></p><ul><li>聚合体的标量替换（SROA）：很多语言都有结构和对象这样的复合数据类型，内部包含了多个成员变量，这种数据类型叫做聚合体（aggregates）。</li><li>编译器可以把聚合体的成员变量放在寄存器中进行计算，不需要访问内存。</li></ul><p><strong>6.针对循环，重点优化</strong></p><ul><li>归纳变量优化：归纳变量是指在循环体内由循环变量派生出来的变量，其变化是很有规律的，因此可以尝试做强度折减优化。</li><li>边界检查消除：在循环体内每次循环都会执行的边界检查代码，将其整合抽离出来，避免每次重复判断。</li><li>循环展开：通过把循环次数减少，但在每一次循环里，完成原来多次循环的工作量。</li><li>循环向量化：在循环展开的基础上，把多次计算优化成一个向量计算。</li><li>重组：在循环结构中，使用代数简化和重组，能获得更大的收益。</li><li>循环不变代码外提（LICM）：在循环结构中，如果发现有些代码其实跟循环无关，那就应该提到循环外面去，避免一次次重复计算。</li><li>代码提升：在条件语句中，如果多个分支条件里都执行了同一句代码，可将其提升至判断条件之前；如果是在循环体内，还可以继续借助循环不变代码外提优化，进一步提升到循环体之外，从而降低计算量。</li></ul><p><strong>7.减少过程调用的开销</strong></p><ul><li>尾调用优化和尾递归优化：尾调用就是一个函数的最后一句，是对另一个函数的调用。如果函数最后一句调用的函数是自己，就称为尾递归。尾调用可以将函数调用栈合并，尾递归还可以转换成循环，从而进一步做一系列针对循环语句的优化工作。</li><li>内联：内联也叫做过程集成，就是把被调用函数的代码拷贝到调用者中，从而避免函数调用。</li><li>内联扩展：内联扩展跟普通内联类似，也是在调用的地方展开代码。不过内联扩展被展开的代码，通常是手写的、高度优化的汇编代码。</li><li>叶子程序优化：叶子程序，是指不会再调用其他程序的函数（或过程）。因此，它也可以对栈的使用做一些优化。</li></ul><p><strong>8.对控制流做优化</strong></p><ul><li>不可达代码的消除：根据控制流的分析，发现有些代码是不可能到达的，可以直接删掉，比如 return 语句后面的代码。</li><li>死代码删除：通过对流程的分析，发现某个变量赋值了以后，后面根本没有再用到这个变量。这样的代码就是死代码，就可以删除。</li><li>if简化：在讲常量传播时我们就见到过，如果有可能if条件肯定为真或者假，那么就可以消除掉 if 结构中的then块、else块，甚至整个消除if结构。</li><li>循环简化：也就是把空循环或者简单的循环，变成直线代码，从而增加了其他优化的机会，比如指令的流水线化。</li><li>循环反转：这是对循环语句常做的一种优化，就是把一个 while 循环改成一个 repeat…until 循环（或者 do…while 循环）。这样会使基本块的结构更简化，从而更有利于其他优化。</li><li>拉直：如果发现两个基本块是线性连接的，那可以把它们合并，从而增加优化机会。</li><li>反分支：也就是减少程序分支，因为分支会导致程序从一个基本块跳到另一个基本块，这样就不容易做优化。比如，把循环内部的 if 分支挪到循环外面去，先做 if 判断，然后再执行循环，这样总的执行 if 判断的次数就会减少，并且循环体里面的基本块不那么零碎，就更加容易优化。</li></ul><h3 id="分析方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#分析方法"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/156878"><strong>分析方法</strong></a></h3><ol><li><strong>控制流分析</strong>（CFA）： 基于程序的控制语句（如条件语句、循环语句、分支语句和基本块语句等）进行分析，建立对程序执行过程的理解，从而进一步做出优化。</li><li><strong>数据流分析</strong>（DFA）：基于数据流分析框架（包含“方向(D)”“值(V)”“转换函数(F)”“初始值(I)”和“交运算(Λ)”5 个元素）等方式，建立对程序中数据变化情况的理解，从而进一步做出优化。</li><li><strong>依赖分析</strong>：分析出程序代码的控制依赖（Control Dependency）和数据依赖（Data Dependency）关系。这对指令排序和缓存优化很重要。</li><li><strong>别名分析</strong>：在 C、C++ 等可以使用指针的语言中，同一个内存地址可能会有多个别名，因为不同的指针都可能指向同一个地址。编译器需要知道不同变量是否是别名关系，以便决定能否做某些优化。</li></ol><h3 id="优化方法的重要性和顺序"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#优化方法的重要性和顺序"><span class="icon icon-link"></span></a>优化方法的重要性和顺序</h3><p><strong>重要性</strong></p><ul><li>对所有语言都重要：循环优化等。</li><li>面向对象语言：内联、逃逸等。</li><li>函数式语言：尾递归优化等。</li></ul><p><strong>顺序</strong></p><ul><li>要点：机器无关-早期，机器相关-后期。</li><li>注意：一个优化会导致另一个优化，同一个优化会多遍运行。</li></ul><h2 id="七目标代码生成编译器最后一个阶段的工作生成针对不同架构的目标代码也就是生成汇编代码"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#七目标代码生成编译器最后一个阶段的工作生成针对不同架构的目标代码也就是生成汇编代码"><span class="icon icon-link"></span></a>七、目标代码生成：编译器最后一个阶段的工作，生成针对不同架构的目标代码，也就是生成汇编代码</h2><h3 id="生成针对不同架构的目标代码"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#生成针对不同架构的目标代码"><span class="icon icon-link"></span></a>生成针对不同架构的目标代码</h3><ul><li><strong>x86</strong>：CISC指令，Register-Memory架构。在指令里可以混合使用内存地址和寄存器。</li><li><strong>ARM</strong>：RISC指令，Load-Store架构。在ARM的汇编中，从寄存器到内存要使用str（也就是Store）指令，而从内存到寄存器要使用ldr（也就是Load）指令。在这种架构下，指令被分为内存访问（Load和Store）和ALU操作两大类，且后者只能在寄存器上操作。</li><li><strong>策略</strong>：编写“代码生成器的生成器”。也就是把CPU架构的各种信息描述出来，基于这些信息生成目标代码的生成器，就像根据语法规则，用ANTLR、bison这样的工具来生成语法解析器一样。</li></ul><h3 id="生成目标代码时的优化工作"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#生成目标代码时的优化工作"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/158315"><strong>生成目标代码时的优化工作</strong></a></h3><p><strong>1.指令选择</strong></p><ul><li>做指令选择的原因：生成更精简、性能更高的代码；使得同一个功能可以由多种方式实现。</li><li>算法：树覆盖算法、自底向上的重写系统（BURS）</li></ul><p><strong>2.寄存器分配</strong></p><ul><li>原理：两个变量，不同时活跃，可以共享寄存器。</li><li>算法：图染色算法（优点-更优化，缺点-速度慢）、线性扫描算法（优点-不够优化，缺点-速度快）</li></ul><p><strong>3.</strong><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/159552"><strong>指令排序</strong></a></p><ul><li>原理：CPU内部的单元可并行。</li><li>实现：基于数据依赖图的List Scheduling算法。</li></ul><p><strong>4.窥孔优化</strong></p><p>思路：提供一个固定大小的窗口，比如能够容纳10条指令，并检查窗口内的指令，看看是否可以优化；然后往下滑动窗口，再次检查优化机会。</p><h3 id="调用约定的影响"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#调用约定的影响"><span class="icon icon-link"></span></a>调用约定的影响</h3><ul><li>调用约定：你可以发明自己的调用约定，比如哪些寄存器用来放参数、哪些用来放返回值。但是如果要使用别的语言编译好的目标文件，或者想让自己的编译器生成的目标文件被别人使用，那就要遵守某种特定的ABI标准。</li><li>Unix和Linux系统的调用约定：System V AMD64 ABI。</li><li>ABI：即Application Binary Interface，应用程序的二进制接口。</li></ul><h3 id="整体的处理过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#整体的处理过程"><span class="icon icon-link"></span></a>整体的处理过程</h3><ul><li>典型过程：指令选择-&gt;指令排序-&gt;寄存器分配-&gt;指令排序-&gt;Emit目标代码</li><li>要点：基于LIR，并且不断lower。</li></ul><h2 id="知识地图"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/09#知识地图"><span class="icon icon-link"></span></a>知识地图</h2><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/02.%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E7%AF%87/resourceimagea222a260d574faae4a033b9ae3f616d45222.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理实战/02.预备知识篇/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:08:05</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
