<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07 | 代码优化：跟编译器做朋友，让你的代码飞起来 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/02.预备知识篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog-base/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog-base/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog-base/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog-base/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog-base/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="常见的代码优化方法" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#常见的代码优化方法"><span>常见的代码优化方法</span></a></li><li title="思路1：把常量提前计算出来" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路1把常量提前计算出来"><span>思路1：把常量提前计算出来</span></a></li><li title="思路2：用低代价的方法做计算" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路2用低代价的方法做计算"><span>思路2：用低代价的方法做计算</span></a></li><li title="思路3：消除重复的计算" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路3消除重复的计算"><span>思路3：消除重复的计算</span></a></li><li title="思路4：化零为整，向量计算" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路4化零为整向量计算"><span>思路4：化零为整，向量计算</span></a></li><li title="思路5：化整为零，各个优化" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路5化整为零各个优化"><span>思路5：化整为零，各个优化</span></a></li><li title="思路6：针对循环，重点优化" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路6针对循环重点优化"><span>思路6：针对循环，重点优化</span></a></li><li title="思路7：减少过程调用的开销" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路7减少过程调用的开销"><span>思路7：减少过程调用的开销</span></a></li><li title="思路8：对控制流做优化" data-depth="3"><a href="/blog-base/编译原理实战/02.预备知识篇/07#思路8对控制流做优化"><span>思路8：对控制流做优化</span></a></li><li title="代码优化所依赖的分析方法" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#代码优化所依赖的分析方法"><span>代码优化所依赖的分析方法</span></a></li><li title="优化方法的重要性和顺序" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#优化方法的重要性和顺序"><span>优化方法的重要性和顺序</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-base/编译原理实战/02.预备知识篇/07#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07--代码优化跟编译器做朋友让你的代码飞起来"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#07--代码优化跟编译器做朋友让你的代码飞起来"><span class="icon icon-link"></span></a>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</h1><p>你好，我是宫文学。</p><p>一门语言的性能高低，是它能否成功的关键。拿JavaScript来说，十多年来，它的性能多次得到成倍的提升，这也是前端技术栈如此丰富和强大的根本原因。</p><p>因此，编译器会无所不用其极地做优化，而优化工作在编译器的运行时间中，也占据了很大的比例。</p><p>不过，对编译技术的初学者来说，通常会搞不清楚编译器到底做了哪些优化，这些优化的实现思路又是怎样的。</p><p>所以今天这一讲，我就重点给你普及下编译器所做的优化工作，及其工作原理。在这个过程中，你还会弄明白很多似曾相识的术语，比如在前端必须了解的AST、终结符、非终结符等，在中后端必须熟悉的常数折叠、值编号、公共子表达式消除等。只有这样，你才算是入门了。</p><p>首先，我带你认识一些常见的代码优化方法。</p><h2 id="常见的代码优化方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#常见的代码优化方法"><span class="icon icon-link"></span></a>常见的代码优化方法</h2><p>对代码做优化的方法有很多。如果要把它们分一下类的话，可以按照下面两个维度：</p><ul><li>**第一个分类维度，是机器无关的优化与机器相关的优化。**机器无关的优化与硬件特征无关，比如把常数值在编译期计算出来（常数折叠）。而机器相关的优化则需要利用某硬件特有的特征，比如SIMD指令可以在一条指令里完成多个数据的计算。</li><li>**第二个分类维度，是优化的范围。**本地优化是针对一个基本块中的代码，全局优化是针对整个函数（或过程），过程间优化则能够跨越多个函数（或过程）做优化。</li></ul><p>但优化算法很多，仅仅按照这两个维度分类，仍显粗糙。所以，我就按照优化的实现思路再分分类，让你了解起来更轻松一些。</p><h3 id="思路1把常量提前计算出来"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路1把常量提前计算出来"><span class="icon icon-link"></span></a>思路1：把常量提前计算出来</h3><p>程序里的有些表达式，肯定能计算出一个常数值，那就不要等到运行时再去计算，干脆在编译期就计算出来。比如 “<code>x=2*3</code>”可以优化成“<code>x=6</code>”。这种优化方法，叫做<strong>常数折叠（Constant Folding）</strong>。</p><p>而如果你一旦知道x的值其实是一个常量，那你就可以把所有用到x的地方，替换成这个常量，这叫做<strong>常数传播（Constant Propagation）</strong>。如果有“<code>y=x*2</code>”这样一个语句，那么就能计算出来“<code>y=12</code>”。所以说，常数传播会导致更多的常数折叠。</p><p>就算不能引起新的常数折叠，比如说“<code>z=a+x</code>”，替换成“<code>z=a+6</code>”以后，计算速度也会更快。因为对于很多CPU来说，“<code>a+x</code>”和“<code>a+6</code>”对应的指令是不一样的。前者可能要生成两条指令（比如先把a放到寄存器上，再把x加上去），而后者用一条指令就行了，因为常数可以作为操作数。</p><p>更有用的是，常数传播可能导致分支判断条件是常量，因此导致一个分支的代码不需要被执行。这种优化叫做<strong>稀疏有条件的常数传播（Sparse Conditional Constant Propagation）</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a = 2</span></div><div class="token-line"><span class="token plain">    b = 3</span></div><div class="token-line"><span class="token plain">    if(a&lt;b){  //判断语句去掉</span></div><div class="token-line"><span class="token plain">      ...     //直接执行这个代码块</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    else{</span></div><div class="token-line"><span class="token plain">      ...     //else分支会去掉</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="思路2用低代价的方法做计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路2用低代价的方法做计算"><span class="icon icon-link"></span></a>思路2：用低代价的方法做计算</h3><p>完成相同的计算，可以用代价更低的方法。比如“<code>x=x+0</code>”这行代码，操作前后x没有任何变化，所以这样的代码可以删掉；又比如“<code>x=x*0</code>” 可以简化成“<code>x=0</code>”。这类利用代数运算的规则所做的简化，叫做<strong>代数简化（Algebra Simplification）。</strong></p><p>对于很多CPU来说，乘法运算改成移位运算，速度会更快。比如，“<code>x*2</code>”等价于“<code>x&lt;&lt;1</code>”，“<code>x*9</code>”等价于“<code>x&lt;&lt;3+x</code>”。这种采用代价更低的运算的方法，也叫做<strong>强度折减（Strength Reduction）</strong>。</p><h3 id="思路3消除重复的计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路3消除重复的计算"><span class="icon icon-link"></span></a>思路3：消除重复的计算</h3><p>下面的示例代码中，第三行可以被替换成“<code>z:=2*x</code>”， 因为y的值就等于x。这个时候，可能x的值已经在寄存器中，所以直接采用x，运算速度会更快。这种优化叫做<strong>拷贝传播（Copy Propagation）。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x := a + b</span></div><div class="token-line"><span class="token plain">    y := x</span></div><div class="token-line"><span class="token plain">    z := 2 * y</span></div></pre></div><p>**值编号（Value Numbering）**也能减少重复计算。值编号是把相同的值，在系统里给一个相同的编号，并且只计算一次即可。比如，<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Value_numbering">Wikipedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上的这个案例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">w := 3</span></div><div class="token-line"><span class="token plain">    x := 3</span></div><div class="token-line"><span class="token plain">    y := x + 4</span></div><div class="token-line"><span class="token plain">    z := w + 4</span></div></pre></div><p>其中w和x的值是一样的，因此编号是相同的。这会进一步导致y和z的编号也是相同的。进而，它们可以简化成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">w := 3</span></div><div class="token-line"><span class="token plain">    x := w</span></div><div class="token-line"><span class="token plain">    y := w + 4</span></div><div class="token-line"><span class="token plain">    z := y</span></div></pre></div><p>值编号又可以分为两种，本地值编号（在一个基本块中）和全局值编号（GVN，在一个函数范围内）。</p><p>还有一种优化方法叫做**公共子表达式消除（Common Subexpression Elimination，CSE），**也会减少计算次数。下面这两行代码，x和y右边的形式是一样的，如果这两行代码之间，a和b的值没有发生变化（比如采用SSA形式），那么x和y的值一定是一样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x := a + b</span></div><div class="token-line"><span class="token plain">    y := a + b</span></div></pre></div><p>那我们就可以让y等于x，从而减少了一次对“<code>a+b</code>”的计算，这就是公共子表达式消除。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">x := a + b</span></div><div class="token-line"><span class="token plain">    y := x</span></div></pre></div><p><strong>部分冗余消除（Partial Redundancy Elimination，PRE）</strong>，是公共子表达式消除的一种特殊情况。比如，这个来自<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Partial_redundancy_elimination">Wikipedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的例子中，一个分支有“<code>x+4</code>”这个公共子表达式，而另一个分支则没有。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (some_condition) {</span></div><div class="token-line"><span class="token plain">       // some code that does not alter x</span></div><div class="token-line"><span class="token plain">       y = x + 4;</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     else {</span></div><div class="token-line"><span class="token plain">       // other code that does not alter x</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     z = x + 4;</span></div></pre></div><p>但是，上述代码仍然可以优化，使得在if结构中，“<code>x+4</code>”这个值肯定会被计算一次，因此“<code>z=x+4</code>”就可以被优化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (some_condition) {</span></div><div class="token-line"><span class="token plain">       // some code that does not alter x</span></div><div class="token-line"><span class="token plain">       t = x + 4;</span></div><div class="token-line"><span class="token plain">       y = t;</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     else {</span></div><div class="token-line"><span class="token plain">       // other code that does not alter x</span></div><div class="token-line"><span class="token plain">       t = x + 4;</span></div><div class="token-line"><span class="token plain">     }</span></div><div class="token-line"><span class="token plain">     z = t;</span></div></pre></div><h3 id="思路4化零为整向量计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路4化零为整向量计算"><span class="icon icon-link"></span></a>思路4：化零为整，向量计算</h3><p>很多CPU支持向量运算，也就是SIMD（Single Instruction Multiple Data）指令。这就可以在一条指令里计算多个数据。比如AVX-512指令集，可以使用512位的寄存器做运算，这个指令集的一条add指令相当于一次能把16个整数加到另16个整数上，以1当16呀。</p><p>比如，把16万个整数相加，应该怎样写程序呢？普通方法，是循环16万次，每次读1个数据，并做累加。向量化的方法，是每次读取16个，用AVX-512指令做加法计算，一共循环计算1万次，最后再把得到的16个数字相加就行了。</p><p>向量优化的一个例子是<strong>超字级并行（Superword-Level Parallelism，SLP)</strong>。它是把基本块中的多个变量组成一个向量，用一个指令完成多个变量的计算。</p><p>向量优化的另一个例子是<strong>循环向量化（Loop Vectorization）</strong>，我会在下面针对循环的优化思路中讲到它。</p><h3 id="思路5化整为零各个优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路5化整为零各个优化"><span class="icon icon-link"></span></a>思路5：化整为零，各个优化</h3><p>另一个思路是反着的，是化整为零。</p><p>很多语言都有结构和对象这样的复合数据类型，内部包含了多个成员变量，这种数据类型叫做<strong>聚合体（aggregates）</strong>。通常，为这些对象申请内存的时候，是一次就申请一整块，能放下里面的所有成员。但这样做，非常不利于做优化。</p><p>通常的优化算法都是针对标量（Scalar）的。如果经过分析，发现可以把聚合体打散，像使用单个本地变量（也就是标量）一样使用聚合体的成员变量，那就有可能带来其他优化的机会。比如，可以把聚合体的成员变量放在寄存器中进行计算，根本不需要访问内存。</p><p>这种优化叫做**聚合体的标量替换（Scalar Replacement of Aggregates，SROA）。**在研究Java的JIT编译器时，我们会见到一个这类优化的例子。</p><h3 id="思路6针对循环重点优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路6针对循环重点优化"><span class="icon icon-link"></span></a>思路6：针对循环，重点优化</h3><p>在编译器中，对循环的优化从来都是重点，因为程序中最多的计算量都是被各种循环消耗掉的。所以，对循环做优化，会起到事半功倍的效果。如果一个循环执行了10000次，那么你的优化效果就会被扩大10000倍。</p><p>对循环做优化，有很多种方法，我来和你介绍几种常用的。</p><p><strong>第一种：归纳变量优化（Induction Variable Optimization）。</strong></p><p>看下面这个循环，其中的变量j是由循环变量派生出来的，这种变量叫做该循环的归纳变量。归纳变量的变化是很有规律的，因此可以尝试做<strong>强度折减</strong>优化。示例代码中的乘法可以由加法替代。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int j = 0;</span></div><div class="token-line"><span class="token plain">    for (int i = 1; i &lt; 100; i++) {</span></div><div class="token-line"><span class="token plain">        j = 2*i;  //2*i可以替换成j+2</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    return j;</span></div></pre></div><p><strong>第二种：边界检查消除（Unnecessary Bounds-checking Elimination）。</strong></p><p>当引用一个数组成员的时候，通常要检查下标是否越界。在循环里面，如果每次都要检查的话，代价就会相当高（例如做多个数组的向量运算的时候）。如果编译器能够确定，在循环中使用的数组下标（通常是循环变量或者基于循环变量的归纳变量）不会越界，那就可以消除掉边界检查的代码，从而大大提高性能。</p><p><strong>第三种：循环展开（Loop Unrolling）。</strong></p><p>把循环次数减少，但在每一次循环里，完成原来多次循环的工作量。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (int i = 0; i&lt; 100; i++){</span></div><div class="token-line"><span class="token plain">      sum = sum + i;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>优化后可以变成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (int i = 0; i&lt; 100; i+=5){</span></div><div class="token-line"><span class="token plain">      sum = sum + i;</span></div><div class="token-line"><span class="token plain">      sum = sum + i + 1;</span></div><div class="token-line"><span class="token plain">      sum = sum + i + 2;</span></div><div class="token-line"><span class="token plain">      sum = sum + i + 3;</span></div><div class="token-line"><span class="token plain">      sum = sum + i + 4;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>进一步，循环体内的5条语句就可以优化成1条语句：“<code>sum = sum + i*5 + 10;</code>”。</p><p>减少循环次数，本身就能减少循环条件的执行次数。同时，它还会增加一个基本块中的指令数量，从而为指令排序的优化算法创造机会。指令排序会在下一讲中介绍。</p><p><strong>第四种：循环向量化（Loop Vectorization）。</strong></p><p>在循环展开的基础上，我们有机会把多次计算优化成一个向量计算。比如，如果要循环16万次，对一个包含了16万个整数的数组做汇总，就可以变成循环1万次，每次用向量化的指令计算16个整数。</p><p><strong>第五种：重组（Reassociation）。</strong></p><p>在循环结构中，使用代数简化和重组，能获得更大的收益。比如，如下对数组的循环操作，其中数组<code>a[i,j]</code>的地址是“<code>a+i*N+j</code>”。但这个运算每次循环就要计算一次，一共要计算<code>M*N</code>次。但其实，这个地址表达式的前半截“<code>a+i*N</code>”不需要每次都在内循环里计算，只要在外循环计算就行了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (i = 0; i&lt; M; i++){</span></div><div class="token-line"><span class="token plain">      for (j = 0; j&lt;N; j++){</span></div><div class="token-line"><span class="token plain">        a[i,j] = b + a[i,j];</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>优化后的代码相当于：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (i = 0; i&lt; M; i++){</span></div><div class="token-line"><span class="token plain">      t=a+i*N;</span></div><div class="token-line"><span class="token plain">      for (j = 0; j&lt;N; j++){</span></div><div class="token-line"><span class="token plain">        *(t+j) = b + *(t+j);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>第六种：循环不变代码外提（Loop-Invariant Code Motion，LICM）。</strong></p><p>在循环结构中，如果发现有些代码其实跟循环无关，那就应该提到循环外面去，避免一次次重复计算。</p><p><strong>第七种：代码提升（Code Hoisting，或Expression Hoisting）。</strong></p><p>在下面的if结构中，then块和else块都有“<code>z=x+y</code>”这个语句，它可以提到if语句的外面。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (x &gt; y)</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        z = x + y</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      else{</span></div><div class="token-line"><span class="token plain">        z = x + y</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>这样变换以后，至少代码量会降低。但是，如果这个if结构是在循环里面，那么可以继续借助<strong>循环不变代码外提</strong>优化，把“<code>z=x+y</code>”从循环体中提出来，从而降低计算量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">z = x + y</span></div><div class="token-line"><span class="token plain">    for(int i = 0; i &lt; 10000; i++){</span></div><div class="token-line"><span class="token plain">      if (x &gt; y)</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      else{</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另外，前面说过的部分冗余优化，也可能会产生可以外提的代码，借助这一优化方法，可以形成进一步优化的效果。</p><p>针对循环能做的优化还有不少，因为对循环做优化往往是收益很高的！</p><h3 id="思路7减少过程调用的开销"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路7减少过程调用的开销"><span class="icon icon-link"></span></a>思路7：减少过程调用的开销</h3><p>你知道，当程序调用一个函数的时候，开销是很大的，比如保存原来的栈指针、保存某些寄存器的值、保存返回地址、设置参数，等等。其中很多都是内存读写操作，速度比较慢。</p><p>所以，如果能做一些优化，减少这些开销，那么带来的优化效果会是很显著的，具体的优化方法主要有下面几种。</p><p><strong>第一种：尾调用优化（Tail-call Optimization）和尾递归优化（Tail-recursion Elimination）。</strong></p><p>尾调用就是一个函数的最后一句，是对另一个函数的调用。比如，下面这段示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">f(){</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      return g(a,b);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而如果g()本身就是f()的最后一行代码，那么f()的栈帧已经没有什么用了，可以撤销掉了（修改栈顶指针的值），然后直接跳转到g()的代码去执行，就像f()和g()是同一个函数一样。这样可以让g()复用f()的栈空间，减少内存消耗，也减少一些内存读写操作（比如，保护寄存器、写入返回地址等）。</p><p>如果f()和g()是同一个函数，这就叫做<strong>尾递归</strong>。很多同学都应该知道，尾递归是可以转化为一个循环的。我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/244906">第3讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>改写左递归文法为右递归文法的时候，就曾经用循环代替了递归调用。尾递归转化为循环，不但可以节省栈帧的开销，还可以进一步导致针对循环的各种优化。</p><p><strong>第二种：内联（inlining）。</strong></p><p>内联也叫做过程集成（Procedure Integration），就是把被调用函数的代码拷贝到调用者中，从而避免函数调用。</p><p>对于我们现在使用的面向对象的语言来说，有很多短方法，比如getter、settter方法。这些方法内联以后，不仅仅可以减少函数调用的开销，还可以带来其他的优化机会。在探究Java的JIT编译器时，我就会为你剖析一个内联的例子。</p><p><strong>第三种：内联扩展（In-Line Expansion）。</strong></p><p>内联扩展跟普通内联类似，也是在调用的地方展开代码。不过内联扩展被展开的代码，通常是手写的、高度优化的汇编代码。</p><p><strong>第四种：叶子程序优化（Leaf-Routine Optimization）。</strong></p><p>叶子程序，是指不会再调用其他程序的函数（或过程）。因此，它也可以对栈的使用做一些优化。比如，你甚至可以不用生成栈帧，因为根据某些调用约定，程序可以访问栈顶之外一定大小的内存。这样就省去了保存原来栈顶、修改栈顶指针等一系列操作。</p><h3 id="思路8对控制流做优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#思路8对控制流做优化"><span class="icon icon-link"></span></a>思路8：对控制流做优化</h3><p>通过对程序的控制流分析，我们可以发现很多优化的机会。这就好比在做公司管理，优化业务流程，就会提升经营效率。我们来看一下这方面的优化方法有哪些。</p><p><strong>第一种：不可达代码消除（Unreacheable-code Elimination）</strong>。根据控制流的分析，发现有些代码是不可能到达的，可以直接删掉，比如return语句后面的代码。</p><p><strong>第二种：死代码删除（Dead-code Elimination）</strong>。通过对流程的分析，发现某个变量赋值了以后，后面根本没有再用到这个变量。这样的代码就是死代码，就可以删除。</p><p><strong>第三种：If简化（If Simplification)</strong>。在讲常量传播时我们就见到过，如果有可能if条件肯定为真或者假，那么就可以消除掉if结构中的then块、else块，甚至整个消除if结构。</p><p><strong>第四种：循环简化（Loop Simplification）</strong>。也就是把空循环或者简单的循环，变成直线代码，从而增加了其他优化的机会，比如指令的流水线化。</p><p><strong>第五种：循环反转（Loop Inversion）</strong>。这是对循环语句常做的一种优化，就是把一个while循环改成一个repeat…until循环（或者do…while循环）。这样会使基本块的结构更简化，从而更有利于其他优化。</p><p><strong>第六种：拉直（Straightening）</strong>。如果发现两个基本块是线性连接的，那可以把它们合并，从而增加优化机会。</p><p><strong>第七种：反分支（Unswitching）</strong>。也就是减少程序分支，因为分支会导致程序从一个基本块跳到另一个基本块，这样就不容易做优化。比如，把循环内部的if分支挪到循环外面去，先做if判断，然后再执行循环，这样总的执行if判断的次数就会减少，并且循环体里面的基本块不那么零碎，就更加容易优化。</p><p>这七种优化方法，都是对控制流的优化，有的减少了基本块，有的减少了分支，有的直接删除了无用的代码。</p><h2 id="代码优化所依赖的分析方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#代码优化所依赖的分析方法"><span class="icon icon-link"></span></a>代码优化所依赖的分析方法</h2><p>前面我列举了很多优化方法，目的是让你认识到编译器花费大量时间去做的，到底都是一些什么工作。当然了，我只是和你列举了最常用的一些优化方法，不过这已经足够帮助你建立对代码优化的直觉认知了。我们在研究具体的编译器的时候，还会见到其他一些优化方法。不过你不用担心，根据上面讲到的各种优化思路，你可以举一反三，非常快速地理解这些新的优化方法。</p><p>上述优化方法，有的比较简单，比如常数折叠，依据AST或MIR做点处理就可以完成。但有些优化，就需要比较复杂的分析方法做支撑才能完成。这些分析方法包括控制流分析、数据流分析、依赖分析和别名分析等。</p><p><strong>控制流分析（Control-Flow Analysis，CFA）</strong>。控制流分析是帮助我们建立对程序执行过程的理解，比如哪里是程序入口，哪里是出口，哪些语句构成了一个基本块，基本块之间跳转关系，哪个结构是一个循环结构（从而去做循环优化），等等。</p><p>前面提到的控制流优化，就是要基于对控制流的正确理解。下面要讲的数据流分析算法，在做全局分析的时候，也要基于控制流图（CFG），所以也需要以控制流分析为基础。</p><p><strong>数据流分析（Data-Flow Analysis，DFA）</strong>。数据流分析，能够帮助我们理解程序中的数据变化情况。我们看一个分析变量活跃性的例子。</p><p>如下图所示，它从后到前顺序扫描代码，花括号中的是在当前位置需要的变量的集合。如果某个变量不被需要，那就可以做死代码删除的优化。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage688f6812816f06d89014070633aed1ee3f8f.jpg" alt=""/></p><p>经过多遍扫描和删除后，最后的代码会精简成一行：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage00b900e66d72db71e2fd1f674af2589e89b9.jpg" alt=""/></p><p>关于数据流分析框架的详细描述，你可以再参考下其他资料（比如，《编译原理之美》专栏第<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/155338">27<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/156878">28<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>两讲）。</p><p>除了做变量活跃性分析以外，数据流分析方法还可以做很多有用的分析。比如，可达定义分析（Reaching Definitions Analysis）、可用表达式分析（Available Expressions Analysis）、向上暴露使用分析（Upward Exposed Uses Analysis）、拷贝传播分析（Copy-Propagation Analysis）、常量传播分析（Constant-Propagation Analysis）、局部冗余分析（Partial-Redundancy Analysis）等。</p><p>就像基于变量活跃性分析可以做死代码删除的优化一样，上述分析是做其他很多优化的基础。</p><p><strong>依赖分析（Dependency Analysis）</strong>。依赖分析，就是分析出程序代码的控制依赖（Control Dependency）和数据依赖（Data Dependency）关系。这对指令排序和缓存优化很重要。</p><p>指令排序会在下一讲介绍。它能通过调整指令之间的顺序来提升执行效率。但指令排序不能打破指令间的依赖关系，否则程序的执行就不正确。</p><p><strong>别名分析（Alias Analysis）</strong>。在C、C++等可以使用指针的语言中，同一个内存地址可能会有多个别名，因为不同的指针都可能指向同一个地址。编译器需要知道不同变量是否是别名关系，以便决定能否做某些优化。</p><p>好了，你已经了解了优化的方法和所依赖的分析方法。那么，这些方法这么多，哪些优化方法更重要，优化的顺序又是什么呢？</p><h2 id="优化方法的重要性和顺序"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#优化方法的重要性和顺序"><span class="icon icon-link"></span></a>优化方法的重要性和顺序</h2><p>我们先看看哪些优化方法更重要。</p><p>有些优化，比如对循环的优化，对每门语言都很重要，因为循环优化的收益很大。</p><p>而有些优化，对于特定的语言更加重要。在课程后面分析像Java、JavaScript这样的面向对象的现代语言时，你会看到，内联优化和逃逸分析的收益就比较大。而对于某些频繁使用尾递归的函数式编程语言来说，尾递归的优化就必不可少，否则性能损失太大。</p><p>至于优化的顺序，有的优化适合在早期做（基于HIR和MIR），有的优化适合在后期做（基于LIR和机器代码）。并且，你通过前面的例子也可以看到，一般做完某个优化以后，会给别的优化带来机会，所以经常会在执行某个优化算法的时候，调用了另一个优化算法，而同样的优化算法也可能会运行好几遍。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>今天这讲，我带你认识了很多常见的优化方法和背后的分析方法。我们很难一下子记住所有的方法，但完全可以先对这些概念建立总体印象。这样可以避免在研究具体编译器时，我们产生“瞎子摸象”的感觉。</p><p>另外，熟悉我提到的那些名词术语也很重要，因为它们经常在代码注释和相关文献里出现。这些名词要成为你的一项基本功。</p><p>我把今天的课程内容，也整理成了思维导图，供你复习、参考。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageeca0ec83e01a9471d19b285aac365694c3a0.jpg" alt=""/></p><p>在课程的第二个模块“真实编译器解析篇”的时候，我会和你分析某些优化算法具体的实现细节，并带你跟踪编译优化的过程。</p><p>根据我的经验，当你写的程序对性能要求很高的时候，你需要能够跟踪了解编译优化的过程，看看如何才能达到最好的优化效果。我之前写过与内存计算有关的程序，就特别关注如何才能让编译器做向量优化。因为是否使用向量，性能差别很大。现在做AI工作的同学，一定也有类似的需求。</p><p>还有些开源项目，它们的性能与内联关系密切。这就要做一定的调优，以确保使用频率最高、性能影响最大的函数全部内联。</p><p>还有，Chrome、Android和Flutter共同使用的二维图形引擎Skia对性能很敏感，所以即使在Windows平台上，仍然要求用Clang编译。为啥坚持用Clang编译呢？因为Skia跟LLVM的优化方法是紧密配合的，换了其他编译器就达不到这么好的优化效果。</p><p>类似的例子还有很多。了解优化，能够充分利用编译器的优化能力，应该是我们想拥有的一项高级技能。</p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>你可以比较一下值编号和公共子表达式消除这两个优化方法，说说它们的相同点和不同点吗？你能举出一个例子来，是其中一个算法能做优化，而另一个算法不能的吗？</p><p>欢迎在留言区中分享你的思考，也欢迎你把这节课分享给你的朋友。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/02.预备知识篇/07#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><ol><li>龙书（Compilers Principles, Techniques and Tools）：第9章，机器无关的优化，里面介绍了各种优化算法。</li><li>鲸书（Advanced Compiler Design and Implementation）中讲优化的算法有很多，第7~15章你都可以看看。</li></ol></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理实战/02.预备知识篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:44:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
