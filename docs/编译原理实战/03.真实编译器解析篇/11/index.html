<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | Python编译器（三）：运行时机制 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/03.真实编译器解析篇/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog-base/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog-base/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog-base/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog-base/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog-base/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="理解字节码的执行过程" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#理解字节码的执行过程"><span>理解字节码的执行过程</span></a></li><li title="Python对象的设计" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的设计"><span>Python对象的设计</span></a></li><li title="Python的类型系统" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python的类型系统"><span>Python的类型系统</span></a></li><li title="Python对象的一些协议" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的一些协议"><span>Python对象的一些协议</span></a></li><li title="Python对象的创建" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的创建"><span>Python对象的创建</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--python编译器三运行时机制"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#19--python编译器三运行时机制"><span class="icon icon-link"></span></a>19 | Python编译器（三）：运行时机制</h1><p>你好，我是宫文学。</p><p>在前面两讲中，我们已经分析了Python从开始编译到生成字节码的机制。但是，我们对Python只是了解了一半，还有很多问题需要解答。比如：**Python字节码是如何运行的呢？它是如何管理程序所用到的数据的？它的类型体系是如何设计的，有什么特点？**等等。</p><p>所以今天这一讲，我们就来讨论一下Python的运行时机制。其中的<strong>核心，是Python对象机制的设计</strong>。</p><p>我们先来研究一下字节码的运行机制。你会发现，它跟Python的对象机制密切相关。</p><h2 id="理解字节码的执行过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#理解字节码的执行过程"><span class="icon icon-link"></span></a>理解字节码的执行过程</h2><p>我们用GDB跟踪执行一个简单的示例程序，它只有一行：“<code>a=1</code>”。</p><p>这行代码对应的字节码如下。其中，前两行指令实现了“<code>a=1</code>”的功能（后两行是根据Python的规定，在执行完一个模块之后，缺省返回一个None值）。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage8a508ae69517e1bfec78fddea57e4da89e50.33d174af.jpg" alt=""/></p><p>你需要在**_PyEval_EvalFrameDefault()函数**这里设置一个断点，在这里实际解释指令并执行。</p><p><strong>首先是执行第一行指令，LOAD_CONST。</strong></p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagede48def47ca68f979af8cf684e47c0889848.1ac55abc.jpg" alt=""/></p><p>你会看到，解释器做了三件事情：</p><ol><li>从常数表里取出0号常数。你知道，编译完毕以后会形成PyCodeObject，而在这个对象里会记录所有的常量、符号名称、本地变量等信息。常量1就是从它的常量表中取出来的。</li><li>把对象引用值加1。对象引用跟垃圾收集机制相关。</li><li>把这个常数对象入栈。</li></ol><p>从这第一行指令的执行过程，你能得到什么信息呢？</p><p>第一个信息，常量1在Python内部，它是一个对象。你可以在GDB里显示这个对象的信息：该对象的类型是PyLong_Type型，这是Python的整型在内部的实现。</p><p>另外，该对象的引用数是126个，说明这个常量对象其实是被共享的，LOAD_CONST指令会让它的引用数加1。我们用的常数是1，这个值在Python内部也是会经常被用到，所以引用数会这么高。你可以试着选个不那么常见的常数，看看它的引用数是多少，都是在哪里被引用的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage02e1028e92c61293d4fd2eb7c6acc00b5ce1.939eb49b.jpg" alt=""/></p><p>进一步，我们会发现，往栈里放的数据，其实是个对象指针，而不像Java的栈机那样，是放了个整数。</p><p>总结上述信息，我其实可以告诉你一个结论：**在Python里，程序中的任何符号都是对象，包括整数、浮点数这些基础数据，或者是自定义的类，或者是函数，它们都是对象。**在栈机里处理的，是这些对象的引用。</p><p><strong>我们再继续往下分析一条指令，也就是STORE_NAME指令</strong>，来加深一下对Python运行机制的理解。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagec836c89af4691c41517545acc20486648c36.d9f1291d.jpg" alt=""/></p><p>执行STORE_NAME指令时，解释器做了5件事情：</p><ol><li>根据指令的参数，从名称表里取出变量名称。这个名称表也是来自于PyCodeObject。前面我刚说过了，Python程序中的一切都是对象，那么name也是对象。你可以查看它的类型，是PyUnicode_Type，也就是Unicode的字符串。</li><li>从栈顶弹出上一步存进去的常量对象。</li><li>获取保存了所有本地变量的字典，这也是来自PyCodeObject。</li><li>在字典里，设置a的值为该常量。如果你深入跟踪其执行过程，你会发现在存入字典的时候，name对象和v对象的引用都会加1。这也是可以理解的，因为它们一个作为key，一个作为value，都要被字典所引用。</li><li>减少常量对象的引用计数。意思是栈机本身不再引用该常量。</li></ol><p>好了，通过详细解读这两条指令的执行过程，我相信你对Python的运行机制摸到一点头绪了，但可能还是会提出很多问题来，比如说：</p><ul><li><strong>既然栈里的操作数都是对象指针，那么如何做加减乘除等算术运算？</strong></li><li><strong>如果函数也是对象，那么执行函数的过程又是怎样的？</strong></li><li>……</li></ul><p>别着急，我在后面会带你探究清楚这些问题。不过在此之前，我们有必要先加深一下对Python对象的了解。</p><h2 id="python对象的设计"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的设计"><span class="icon icon-link"></span></a>Python对象的设计</h2><p>Python的对象定义在object.h中。阅读文件头部的注释和对各类数据结构的定义，你就可以理解Python对象的设计思路。</p><p>首先是PyObject和PyVarObject两个基础的数据结构，它们分别表示定长的数据和变长的数据。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct _object {          //定长对象</span></div><div class="token-line"><span class="token plain">        Py_ssize_t ob_refcnt;         //对象引用计数</span></div><div class="token-line"><span class="token plain">        struct _typeobject *ob_type;  //对象类型</span></div><div class="token-line"><span class="token plain">    } PyObject;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    typedef struct {         //变长对象</span></div><div class="token-line"><span class="token plain">        PyObject ob_base;             </span></div><div class="token-line"><span class="token plain">        Py_ssize_t ob_size;  //变长部分的项目数量，在申请内存时有确定的值，不再变</span></div><div class="token-line"><span class="token plain">    } PyVarObject;</span></div></pre></div><p>PyObject是最基础的结构，所有的对象在Python内部都表示为一个PyObject指针。它里面只包含两个成员：对象引用计数（ob_refcnt）和对象类型（ob_type），你在用GDB跟踪执行时也见过它们。可能你会问，<strong>为什么只有这两个成员呢？对象的数据（比如一个整数）保存在哪里？</strong></p><p>实际上，任何对象都会在一开头包含PyObject，其他数据都跟在PyObject的后面。比如说，Python3的整数的设计是一个变长对象，会用一到多个32位的段，来表示任意位数的整数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define PyObject_VAR_HEAD      PyVarObject ob_base;</span></div><div class="token-line"><span class="token plain">    struct _longobject {</span></div><div class="token-line"><span class="token plain">        PyObject_VAR_HEAD       //PyVarObject</span></div><div class="token-line"><span class="token plain">        digit ob_digit[1];      //数字段的第一个元素</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    typedef struct _longobject PyLongObject;    //整型</span></div></pre></div><p>它在内存中的布局是这样的：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3d243d80b4e2750cdf5701yy5fa1d68fde24.d4923b18.jpg" alt=""/></p><p>图1：Python3的整数对象的内存布局</p><p>所以你会看出，<strong><code>PyObject*</code>、<code>PyVarObject*</code>和<code>PyLongObject*</code>指向的内存地址是相同的</strong>。你可以根据ob_type的类型，把<code>PyObject*</code>强制转换成<code>PyLongObject*</code>。</p><p>实际上，像C++这样的面向对象语言的内存布局也是如此，父类的成员变量在最前面，子类的成员变量在后面，父类和子类的指针之间可以强制转换。懂得了这个原理，我们用C语言照样可以模拟出面向对象的继承结构出来。</p><p>你可以注意到，我在图1中标出了每个字段所占内存的大小，总共是28个字节（这是64位macOS下的数值，如果是另外的环境，比如32位环境，数值会有所不同）。</p><p>你可以用sys.getsizeof()函数，来测量对象占据的内存空间。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; a = 10</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; import sys</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; sys.getsizeof(a)</span></div><div class="token-line"><span class="token plain">    28       #ob_size = 1</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; a = 1234567890</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; sys.getsizeof(a)</span></div><div class="token-line"><span class="token plain">    32       #ob_size = 2，支持更大的整数</span></div></pre></div><p>到这里，我们总结一下Python对象设计的三个特点：</p><p><strong>1.基于堆</strong></p><p>Python对象全部都是在堆里申请的，没有静态申请和在栈里申请的。这跟C、C++和Java这样的静态类型的语言很不一样。</p><p>C的结构体和C++的对象都既可以在栈里，也可以在堆里；Java也是一样，除了原生数据类型可以在栈里申请，未逃逸的Java对象的内存也可以在栈里管理，我们在讲<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/257504">Java的JIT编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候已经讲过了。</p><p><strong>2.基于引用计数的垃圾收集机制</strong></p><p>每个Python对象会保存一个引用计数。也就是说，Python的垃圾收集机制是基于引用计数的。</p><p>它的优点是可以实现增量收集，只要引用计数为零就回收，避免出现周期性的暂停；缺点是需要解决循环引用问题，并且要经常修改引用计数（比如在每次赋值和变量超出作用域的时候），开销有点大。</p><p><strong>3.唯一ID</strong></p><p>每个Python对象都有一个唯一ID，它们在生存期内是不变的。用id()函数就可以获得对象的ID。根据Python的<a target="_blank" rel="noopener noreferrer" href="https://docs.python.org/3/library/functions.html#id">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个ID实际就是对象的内存地址。所以，实际上，你不需要在对象里用一个单独的字段来记录对象ID。这同时也说明，Python对象的地址在整个生命周期内是不会变的，这也符合基于引用计数的垃圾收集算法。对比一下，如果采用“停止和拷贝”的算法，对象在内存中会被移动，地址会发生变化。所以你能看出，ID的算法与垃圾收集算法是环环相扣的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; a = 10</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; id(a)</span></div><div class="token-line"><span class="token plain">    140330839057200</span></div></pre></div><p>接下来，我们看看ob_type这个字段，它指向的是对象的类型。以这个字段为线索，我们就可以牵出Python的整个类型系统的设计。</p><h2 id="python的类型系统"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python的类型系统"><span class="icon icon-link"></span></a>Python的类型系统</h2><p>Python是动态类型的语言。它的类型系统的设计相当精巧，Python语言的很多优点，都来自于它的类型系统。我们来看一下。</p><p>首先，Python里每个PyObject对象都有一个类型信息。保存类型信息的数据结构是PyTypeObject（定义在Include/cpython/object.h中）。PyTypeObject本身也是一个PyObject，只不过这个对象是用于记录类型信息的而已。它是一个挺大的结构体，包含了对一个类型的各种描述信息，也包含了一些函数的指针，这些函数就是对该类型可以做的操作。可以说，只要你对这个结构体的每个字段的作用都了解清楚了，那么你对Python的类型体系也就了解透彻了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct _typeobject {</span></div><div class="token-line"><span class="token plain">        PyObject_VAR_HEAD</span></div><div class="token-line"><span class="token plain">        const char *tp_name;  /* 用于打印的名称格式是&quot;&lt;模块&gt;.&lt;名称&gt;&quot; */</span></div><div class="token-line"><span class="token plain">        Py_ssize_t tp_basicsize, tp_itemsize; /* 用于申请内存 */</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        /* 后面还有很多字段，比如用于支持数值计算、序列、映射等操作的函数，用于描述属性、子类型、文档等内容的字段，等等。 */</span></div><div class="token-line"><span class="token plain">        ...  </span></div><div class="token-line"><span class="token plain">    } PyTypeObject</span></div></pre></div><p>因为这个结构非常重要，所以我把一些有代表性的字段整理了一下，你可以重点关注它们：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2b162bd631d8b2c0c7fcc700dce65af8a916.d42abe9a.jpg" alt=""/></p><p>你会看到，这个结构里的很多部分都是一个函数插槽（Slot），你可以往插槽里保存一些函数指针，用来实现各种标准操作，比如对象生命周期管理、转成字符串、获取哈希值等。</p><p>在上面的表格中，你还会看到像“<code>__init__</code>”这样的方法，它的两边都是有两个下划线的，也就是“double underscore”，简称dunder方法，也叫做“<strong>魔术方法</strong>”。在用Python编写自定义的类的时候，你可以实现这些魔术方法，它们就会被缺省的<code>tp_*</code>函数所调用，比如，“<code>__init__</code>”会被缺省的<code>tp_init</code>函数调用，完成类的初始化工作。</p><p>现在我们拿整型对象来举个例子，一起来看看它的PyTypeObject是什么样子。</p><p>对于整型对象来说，它的ob_type会指向一个PyLong_Type对象。这个对象是在longobject.c中初始化的，它是PyTypeObject的一个实例。从中你会看到一些信息：类型名称是“int”，转字符串的函数是<code>long_to_decimal_string</code>，此外还有比较函数、方法描述、属性描述、构建和析构函数等。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageaaabaabb1ce39b937b38c7e34bc23ca65cab.af62bdb0.jpg" alt=""/></p><p>我们运行type()函数，可以获得一个对象的类型名称，这个名称就来自PyTypeObject的<code>tp_name</code>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; a = 10</span></div><div class="token-line"><span class="token plain">    &gt;&gt;&gt; type(a)</span></div><div class="token-line"><span class="token plain">    &lt;type &#x27;int&#x27;&gt;</span></div></pre></div><p>我们用dir()函数，可以从PyTypeObject中查询出一个对象所支持的所有属性和方法。比如，下面是查询一个整型对象获得的结果：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage5edf5ea14dda16663f78705fd37897e403df.5c2261d0.jpg" alt=""/></p><p>好，我们刚才讲了整型，它对应的PyTypeObject的实例是PyLong_Type。Python里其实还有其他一些内置的类型，它们分别都对应了一个PyTypeObject的实例。你可以参考一下这个表格。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimaged391d3c8c591b89832b5ff71a08856247491.f23768ee.jpg" alt=""/></p><p>上面列出的这些都是Python的内置类型。有些内置类型跟语法是关联着的，比如说，“<code>a = 1</code>”就会自动创建一个整型对象，“<code>a = [2, &#x27;john&#x27;, 3]</code>”就会自动创建一个List对象。<strong>这些内置对象都是用C语言实现的。</strong></p><p><strong>Python比较有优势的一点，是你可以用C语言，像实现内置类型一样实现自己的类型，并拥有很高的性能。</strong></p><p>当然，如果性能不是你最重要的考虑因素，那么你也可以用Python来创建新的类型，也就是以class关键字开头的自定义类。class编译以后，也会形成一个PyTypeObject对象，来代表这个类。你为这个类编写的各种属性（比如类名称）和方法，会被存到类型对象中。</p><p>好了，现在你已经初步了解了Python的类型系统的特征。接下来，我就带你更深入地了解一下类型对象中一些重要的函数插槽的作用，以及它们所构成的一些协议。</p><h2 id="python对象的一些协议"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的一些协议"><span class="icon icon-link"></span></a>Python对象的一些协议</h2><p>前面在研究整型对象的时候，你会发现PyLong_Type的tp_as_number字段被赋值了，这是一个结构体（PyNumberMethods），里面是很多与数值计算有关的函数指针，包括加减乘除等。这些函数指针是实现Python的数值计算方面的协议。任何类型，只要提供了这些函数，就可以像整型对象一样进行计算。这实际上是Python定义的一个针对数值计算的协议。</p><p>既然如此，我们再次用GDB来跟踪一下Python的执行过程，看看整数的加法是怎么实现的。我们的示例程序增加了一行代码，变成：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">a = 1</span></div><div class="token-line"><span class="token plain">    b = a + 2</span></div></pre></div><p>它对应的字节码如下：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimaged04ed0409d6d751cb403fb722fae14ba724e.227eb7f6.jpg" alt=""/></p><p>我们重点来关注BINARY_ADD指令的执行情况，如下图所示：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb3deb387350911c24493f73722667847efde.937821f9.jpg" alt=""/></p><p>可以看到，如果+号两边是字符串，那么编译器就会执行字符串连接操作。否则，就作为数字相加。</p><p>我们继续跟踪进入PyNumber_Add函数。在这个函数中，Python求出了加法函数指针在PyNumberMethods结构体中的偏移量，接着就进入了binary_op1()函数。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea6a3a61339a2e5ae1b3b48b3f55dc780b8a3.a781a512.jpg" alt=""/></p><p>在binary_op1函数中，Python首先从第一个参数的类型对象中，取出了加法函数的指针。你在GDB中打印出输出信息，就会发现它是binaryfunc类型的，函数名称是long_add。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimaged26bd2566a006c6a3367c89c372d2526f86b.d0f1a2f8.jpg" alt=""/></p><p>binaryfunc类型的定义是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);</span></div></pre></div><p>也就是说，它是指向的函数要求有两个Python对象（的指针）作为参数，返回值也是一个Python对象（的指针）。</p><p>你再继续跟踪下去，会发现程序就进入到了long_add函数。这个函数是在longobject.c里定义的，是Python整型类型做加法计算的内置函数。</p><p>这里有一个隐秘的问题，<strong>为什么是使用了第一个参数（也就是加法左边的对象）所关联的加法函数，而不是第二个参数的加法函数？</strong></p><p>在我们的示例程序中，由于加法两边的对象的类型是相同的，都是整型，所以它们所关联的加法函数是同一个。但是，如果两边的类型不一样怎么办呢？这个其实是一个很有意思的函数分派问题，你可以先思考一下答案，我会在后面讲Julia的编译器时再回到这个问题上。</p><p>好了，现在我们就能理解了，像加减乘除这样运算，它们在Python里都是怎么实现的了。Python是到对象的类型中，去查找针对这些运算的函数来执行。</p><p>除了内置的函数，我们也可以自己写这样的函数，并被Python所调用。来看看下面的示例程序，我们定义了一个“<code>__add__</code>”魔术方法。这个方法会被Python作为SimpleComplex的加法函数所使用，实现了加法操作符的重载，从而支持复数的加法操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class SimpleComplex(object):</span></div><div class="token-line"><span class="token plain">        def __init__(self, x, y):</span></div><div class="token-line"><span class="token plain">            self.x = x</span></div><div class="token-line"><span class="token plain">            self.y = y</span></div><div class="token-line"><span class="token plain">        def __str__(self):  </span></div><div class="token-line"><span class="token plain">            return &quot;x: %d, y: %d&quot; % (self.x, self.y)</span></div><div class="token-line"><span class="token plain">        def __add__(self, other):</span></div><div class="token-line"><span class="token plain">            return SimpleComplex(self.x + other.x, self.y + other.y)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    a = SimpleComplex(1, 2)</span></div><div class="token-line"><span class="token plain">    b = SimpleComplex(3, 4)</span></div><div class="token-line"><span class="token plain">    c = a + b</span></div><div class="token-line"><span class="token plain">    print(c)</span></div></pre></div><p>**那么对于这么一个自定义类，在执行BINARY_ADD指令时会有什么不同呢？**通过GDB做跟踪，你会发现几点不同：</p><p>首先，在SimpleComplex的type对象中，add函数插槽里放了一个slot_nb_add()函数指针，这个函数会到对象里查找“<code>__add__</code>”函数。因为Python的一切都是对象，因此它找到的是一个函数对象。</p><p>所以，接下来，Python需要运行这个函数对象，而不是用C语言写的内置函数。<strong>那么怎么运行这个函数对象呢？</strong></p><p>这就需要用到Python的另一个协议，<strong>Callable协议</strong>。这个协议规定，只要为对象的类型中的tp_call属性定义了一个合法的函数，那么该对象就是可被调用的。</p><p>对于自定义的函数，Python会设置一个缺省的tp_call函数。这个函数所做的事情，实际上就是找到该函数所编译出来的PyCodeObject，并让解释器执行其中的字节码！</p><p>好了，通过上面的示例程序，我们加深了对类型对象的了解，也了解了Python关于数值计算和可调用性（Callable）方面的协议。</p><p>Python还有其他几个协议，比如枚举协议和映射协议等，用来支持对象的枚举、把对象加入字典等操作。你可以利用这些协议，充分融入到Python语言的框架中，比如说，你可以重载加减乘除等运算。</p><p>接下来，我们再运用Callable协议的知识，来探究一下Python对象的创建机制。</p><h2 id="python对象的创建"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#python对象的创建"><span class="icon icon-link"></span></a>Python对象的创建</h2><p>用Python语言，我们可以编写class，来支持自定义的类型。我们来看一段示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class myclass:</span></div><div class="token-line"><span class="token plain">        def __init__(self, x):</span></div><div class="token-line"><span class="token plain">            self.x = x    </span></div><div class="token-line"><span class="token plain">        def foo(self, b):</span></div><div class="token-line"><span class="token plain">            c = self.x + b</span></div><div class="token-line"><span class="token plain">            return c</span></div><div class="token-line"><span class="token plain">    a = myclass(2);</span></div></pre></div><p>其中，myclass(2)是生成了一个myclass对象。</p><p>可是，你发现没有，Python创建一个对象实例的方式，其实跟调用一个函数没啥区别（不像Java语言，还需要new关键字）。如果你不知道myclass是一个自定义的类，你会以为只是在调用一个函数而已。</p><p>不过，我们前面已经提到了Python的Callable协议。所以，利用这个协议，任何对象只要在其类型中定义了tp_call，那么就都可以被调用。</p><p>我再举个例子，加深你对Callable协议的理解。在下面的示例程序中，我定义了一个类型Bar，并创建了一个对象b。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Bar:</span></div><div class="token-line"><span class="token plain">        def __call__(self):</span></div><div class="token-line"><span class="token plain">                print(&quot;in __call__: &quot;, self)</span></div><div class="token-line"><span class="token plain">    b = Bar()</span></div><div class="token-line"><span class="token plain">    b()                              #这里会打印对象信息，并显示对象地址</span></div></pre></div><p>现在，我在b对象后面加一对括号，就可以调用b了！实际执行的就是Bar的“<code>__call__</code>”函数（缺省的tp_call函数会查找“<code>__call__</code>”属性，并调用）。</p><p>所以，我们调用myclass()，那一定是因为myclass的类型对象中定义了tp_call。</p><p>你还可以把“myclass(2)”这个语句编译成字节码看看，它生成的是CALL_FUNCTION指令，与函数调用没有任何区别。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage1aa01aac8d9cc637f06aa480d86e722dc8a0.40b179c8.jpg" alt=""/></p><p>可是，我们知道，示例程序中a的类型对象是myclass，但myclass的类型对象是什么呢？</p><p>换句话说，一个普通的对象的类型，是一个类型对象。<strong>那么一个类型对象的类型又是什么呢？</strong></p><p>答案是<strong>元类（metaclass）</strong>，元类是类型的类型。举例来说，整型的metaclass是PyType_Type。其实，大部分类型的metaclass是PyType_Type。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage613e6135aa92c8f7787f664307ab3cf2a83e.5086bb1d.jpg" alt=""/></p><p>所以说，调用类型来实例化一个对象，就是调用PyType_Type的tp_call函数。<strong>那么PyType_Type的tp_call函数都做了些什么事情呢？</strong></p><p>这个函数是type_call()，它也是在typeobject.c中定义的。Python以type_call()为入口，会完成创建一个对象的过程：</p><ul><li><strong>创建</strong></li></ul><p>tp_call会调用类型对象的tp_new插槽的函数。对于PyLong_Type来说，它是long_new。</p><p>如果我们是创建一个Point对象，如果你为它定义了一个“<code>__new__</code>”函数，那么就将调用这个函数来创建对象，否则，就会查找基类中的tp_new。</p><ul><li><strong>初始化</strong></li></ul><p>tp_call会调用类型对象的tp_init。对于Point这样的自定义类型来说，如果定义了“<code>__init__</code>”函数，就会执行来做初始化。否则，就会调用基类的tp_init。对于PyBaseType_Object来说，这个函数是object_init。</p><p>除了自定义的类型，内置类型的对象也可以用类型名称加括号的方式来创建。我还是以整型为例，创建一个整型对象，也可以用“int(10)”这种格式，其中int是类型名称。而且，它的metaclass也是PyType_Type。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageea3deac9e78929331459d160018703c7c53d.76f9147f.jpg" alt=""/></p><p>当然，你也可以给你的类型指定另一个metaclass，从而支持不同的对象创建和初始化功能。虽然大部分情况下你不需要这么做，但这种可定制的能力，就为你编写某些特殊的功能（比如元编程）提供了可能性。</p><p>好了，现在你已经知道，类型的类型是元类（metaclass），它能为类型的调用提供支持。你可能进一步会问，<strong>那么元类的类型又是什么呢？是否还有元元类？直接调用元类又会发生什么呢？</strong></p><p>缺省情况下，PyType_Type的类型仍然是PyType_Type，也就是指向它自身。对元类做调用，也一样会启动上面的tp_call()过程。</p><p>到目前为止，我们谈论Python中的对象，还没有谈论那些面向对象的传统话题：继承啦、多态啦，等等。这些特性在Python中的实现，仍然只是在类型对象里设置一些字段即可。你可以在tp_base里设定基类（父类）来支持继承，甚至在tp_bases中设置多个基类来支持多重继承。所有对象缺省的基类是object，tp_base指向的是一个PyBaseObject_Type对象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">&gt;&gt;&gt; int.__base__     #查看int类型的基类</span></div><div class="token-line"><span class="token plain">    &lt;class &#x27;object&#x27;&gt;</span></div></pre></div><p>到目前为止，我们已经对于对象的类型、元类，以及对象之间的继承关系有了比较全面的了解，为了方便你重点复习和回顾，我把它们画成了一张图。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3a5f3a24633cf6a4637224bd84faac641f5f.85aedb8f.jpg" alt=""/></p><p>图2：Python对象的类型关系和继承关系</p><p>你要注意，图中我用两种颜色的箭头区分了两种关系。<strong>一种是橙色箭头，代表的是类型关系</strong>，比如PyLong_Type是PyLongObject的类型，而PyType_Type是PyLong_Type的类型；<strong>另一种是黑色箭头，代表的是继承关系</strong>，比如int的基类是object，所以PyLong_Type的tp_base指向PyBaseObject_Type。</p><p>到这里，你可能会觉得有点挑战认知。因为通常我们谈面向对象的体系结构，只会涉及图中的继承关系线，不太会考虑其中的类型关系线。Python的类型关系，体现了“数据即程序”的概念。Java语言里，某个类型对应于一个class的字节码，而在Python里，一个类型只是一个Python对象而已。</p><p>并且，在Java里也不会有元类，因为对象的创建和初始化过程都是语言里规定死的。而在Python里，你却拥有一定的掌控能力。</p><p>这些特点，都体现了Python类型体系的强大之处。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>好了，我们来总结一下Python的运行时的特征。你会发现，Python的运行时设计的核心，就是<strong>PyObject对象</strong>，Python对象所有的特性都是从PyObject的设计中延伸出来的，给人一种精巧的美感。</p><ul><li>Python程序中的符号都是Python对象，栈机中存的也都是Python对象指针。</li><li>所有对象的头部信息是相同的，而后面的信息可扩展。这就让Python可以用PyObject指针来访问各种对象，这种设计技巧你需要掌握。</li><li>每个对象都有类型，类型描述信息在一个类型对象里。系统内有内置的类型对象，你也可以通过C语言或Python语言创建新的类型对象，从而支持新的类型。</li><li>类型对象里有一些字段保存了一些函数指针，用于完成数值计算、比较等功能。这是Python指定的接口协议，符合这些协议的程序可以被无缝集成到Python语言的框架中，比如支持加减乘除运算。</li><li>函数的运行、对象的创建，都源于Python的Callable协议，也就是在类型对象中制定tp_call函数。面向对象的特性，也是通过在类型对象里建立与基类的链接而实现的。</li></ul><p>我照例把本讲的重点知识，整理成了一张思维导图，供你参考和回顾：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage0a5d0a4916368758e1a1608408bc89a93e5d.de678977.jpg" alt=""/></p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>今天给你的思考题是很有意思的。</p><p>我前面讲到，当Python做加法运算的时候，如果对象类型相同，那么只有一个加法函数可选。但如果两边的对象类型是不同的，该怎么办呢？你可以看看Python是怎么实现的。这其实是编译技术的一个关注点，我们在后面课程中还会提及这个问题。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/11#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><p>Python的<a target="_blank" rel="noopener noreferrer" href="https://docs.python.org/3.8/library/stdtypes.html">内置类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理实战/03.真实编译器解析篇/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
