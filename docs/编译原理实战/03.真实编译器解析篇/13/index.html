<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>21 | JavaScript编译器（二）：V8的解释器和优化编译器 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/03.真实编译器解析篇/13" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog-base/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog-base/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog-base/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog-base/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog-base/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="TurboFan的优化编译技术" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#turbofan的优化编译技术"><span>TurboFan的优化编译技术</span></a></li><li title="基于推理的优化（Speculative Optimazition）" data-depth="3"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#基于推理的优化speculative-optimazition"><span>基于推理的优化（Speculative Optimazition）</span></a></li><li title="IR和优化算法" data-depth="3"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#ir和优化算法"><span>IR和优化算法</span></a></li><li title="隐藏类（Shapes）和内联缓存（Inline Caching）" data-depth="3"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#隐藏类shapes和内联缓存inline-caching"><span>隐藏类（Shapes）和内联缓存（Inline Caching）</span></a></li><li title="提升Ignition的速度" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#提升ignition的速度"><span>提升Ignition的速度</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="21--javascript编译器二v8的解释器和优化编译器"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#21--javascript编译器二v8的解释器和优化编译器"><span class="icon icon-link"></span></a>21 | JavaScript编译器（二）：V8的解释器和优化编译器</h1><p>你好，我是宫文学。通过前一讲的学习，我们已经了解了V8的整个编译过程，并重点探讨了一个问题，就是<strong>V8的编译速度为什么那么快</strong>。</p><p>V8把解析过程做了重点的优化，解析完毕以后就可以马上通过Ignition解释执行了。这就让JavaScript可以快速运行起来。</p><p>今天这一讲呢，我们重点来讨论一下，<strong>V8的运行速度为什么也这么快</strong>，一起来看看V8所采用的优化技术。</p><p>上一讲我也提及过，V8在2008年刚推出的时候，它提供了一个快速编译成机器码的编译器，虽然没做太多优化，但性能已经是当时其他JavaScript引擎的10倍了。而现在，V8的速度又是2008年刚发布时候的10倍。那么，是什么技术造成了这么大的性能优化的呢？</p><p>这其中，**一方面原因，是TurboFan这个优化编译器，采用了很多的优化技术。**那么，它采用了什么优化算法？采用了什么IR？其优化思路跟Java的JIT编译器有什么相同点和不同点？</p><p>**另一方面，最新的Ignition解释器，虽然只是做解释执行的功能，但竟然也比一个基础的编译器生成的代码慢不了多少。**这又是什么原因呢？</p><p>所以今天，我们就一起把这些问题都搞清楚，这样你就能全面了解V8所采用的编译技术的特点了，你对动态类型语言的编译，也就能有更深入的了解，并且这也有助于你编写更高效的JavaScript程序。</p><p>好，首先，我们来了解一下TurboFan的优化编译技术。</p><h2 id="turbofan的优化编译技术"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#turbofan的优化编译技术"><span class="icon icon-link"></span></a>TurboFan的优化编译技术</h2><p>TurboFan是一个优化编译器。不过它跟Java的优化编译器要完成的任务是不太相同的。因为JavaScript是动态类型的语言，所以如果它能够推断出准确的类型再来做优化，就会带来巨大的性能提升。</p><p>同时，TurboFan也会像Java的JIT编译器那样，基于IR来运行各种优化算法，以及在后端做指令选择、寄存器分配等优化。所有的这些因素加起来，才使得TurboFan能达到很高的性能。</p><p>我们先来看看V8最特别的优化，也就是通过对类型的推理所做的优化。</p><h3 id="基于推理的优化speculative-optimazition"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#基于推理的优化speculative-optimazition"><span class="icon icon-link"></span></a>基于推理的优化（Speculative Optimazition）</h3><p>对于基于推理的优化，我们其实并不陌生。在研究<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/257504">Java的JIT编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时，你就发现了Graal会针对解释器收集的一些信息，对于代码做一些推断，从而做一些激进的优化，比如说会跳过一些不必要的程序分支。</p><p>而JavaScript是动态类型的语言，所以对于V8来说，最重要的优化，就是能够在运行时正确地做出类型推断。举个例子来说，假设示例函数中的add函数，在解释器里多次执行的时候，接受的参数都是整型，那么TurboFan就处理整型加法运算的代码就行了。这也就是上一讲中我们生成的汇编代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function add(a,b){</span></div><div class="token-line"><span class="token plain">        return a+b;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    for (i = 0; i&lt;100000; i++){</span></div><div class="token-line"><span class="token plain">        if (i%1000==0)</span></div><div class="token-line"><span class="token plain">            console.log(i);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        add(i, i+1);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><img src="/images/httpsstatic001geekbangorgresourceimageb307b3256505bef28fb15c37dcb36117f507.jpg" alt=""/></p><p>但是，<strong>如果不在解释器里执行，直接要求TurboFan做编译，会生成什么样的汇编代码呢？</strong></p><p>你可以在运行d8的时候，加上“–always-opt”参数，这样V8在第一次遇到add函数的时候，就会编译成机器码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">./d8 --trace-opt-verbose \</span></div><div class="token-line"><span class="token plain">        --trace-turbo \</span></div><div class="token-line"><span class="token plain">        --turbo-filter=add \</span></div><div class="token-line"><span class="token plain">        --print-code \</span></div><div class="token-line"><span class="token plain">        --print-opt-code \</span></div><div class="token-line"><span class="token plain">        --code-comments \</span></div><div class="token-line"><span class="token plain">        --always-opt \</span></div><div class="token-line"><span class="token plain">        add.js</span></div></pre></div><p>这一次生成的汇编代码，跟上一讲生成的就不一样了。由于编译器不知道add函数的参数是什么类型的，所以实际上，编译器是去调用实现Add指令的内置函数，来生成了汇编代码。</p><p>这个内置函数当然支持所有加法操作的语义，但是它也就无法启动基于推理的优化机制了。这样的代码，跟解释器直接解释执行，性能上没太大的差别，因为它们本质上都是调用一个全功能的内置函数。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebb82bb27e6dece4cf36d5f3f9f8d87c15082.jpg" alt=""/></p><p>而推理式优化的版本则不同，它直接生成了针对整型数字进行处理的汇编代码：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage5043503abd5987b387750b31574a37bc0943.jpg" alt=""/></p><p>我来给你解释一下这几行指令的意思：</p><ul><li>第1行和第3行，是把参数1和参数2分别拷贝到r8和r9寄存器。<strong>注意</strong>，这里是从物理寄存器里取值，而不是像前一个版本一样，在栈里取值。前一个版本遵循的是更加保守和安全的调用约定。</li><li>第2行和第4行，是把r8和r9寄存器的值向右移1位。</li><li>第5行，是把r8和r9相加。</li></ul><p>看到这里，你可能就发现了一个问题：**只是做个简单的加法而已，为什么要做移位操作呢？**实际上，如果你熟悉汇编语言的话，要想实现上面的功能，其实只需要下面这两行代码就可以了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">movq rax, rdi   #把参数1拷贝到rax寄存器</span></div><div class="token-line"><span class="token plain">    addq rax, rcx   #把参数2加到rax寄存器上，作为返回值</span></div></pre></div><p>那么，多出来的移位操作是干什么的呢？</p><p>这就涉及到了V8的<strong>内存管理机制</strong>。原来，V8对象都保存在堆中。在栈帧中保存的数值，都是指向堆的指针。垃圾收集器可以通过这些指针，知道哪些内存对象是不再被使用的，从而把它们释放掉。我们前面学过，Java的虚拟机和Python对于对象引用，本质上也是这么处理的。</p><p>但是，这种机制对于基础数据类型，比如整型，就不太合适了。因为你没有必要为一个简单的整型数据在堆中申请内存，这样既浪费内存，又降低了访问效率，V8需要访问两次内存才能读到一个整型变量的值（第一次读到地址，第二次根据该地址到堆里读到值）。你记得，Python就是这么访问基础数据的。</p><p>V8显然不能忍受这种低效的方式。它采用的优化机制，是一种被广泛采用的技术，叫做<strong>标记指针</strong>（Tagged Pointer）或者<strong>标记值</strong>（Tagged Value）。《<a target="_blank" rel="noopener noreferrer" href="https://v8.dev/blog/pointer-compression">Pointer Compression in V8<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》这篇文章，就介绍了V8中采用Tagged Pointer技术的细节。</p><p>比如说，对于一个32位的指针值，它的最低位是标记位。当标记位是0的时候，前31位是一个短整数（简写为Smi）；而当标记位是1的时候，那么前31位是一个地址。这样，V8就可以用指针来直接保存一个整数值，用于计算，从而降低了内存占用，并提高了运行效率。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage8d008dcef79f95f098yy29283a65f4e19000.jpg" alt=""/></p><p>图1：用标记指针技术来表示一个整数</p><p>好了，现在你已经理解了V8的推理式编译的机制。那么，还有什么手段能提升代码的性能呢？</p><p>当然，还有基于IR的各种优化算法。</p><h3 id="ir和优化算法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#ir和优化算法"><span class="icon icon-link"></span></a>IR和优化算法</h3><p>在讲<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/256914">Java的JIT编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时我就提过，V8做优化编译时采用的IR，也是基于Sea of Nodes的。</p><p>你可以回忆一下Sea of Nodes的特点：合并了数据流图与控制流图；是SSA形式；没有把语句划分成基本块。</p><p>它的重要优点，就是优化算法可以自由调整语句的顺序，只要不破坏数据流图中的依赖关系。在Sea of Nodes中，没有变量（有时也叫做寄存器）的概念，只有一个个数据节点，所以对于死代码删除等优化方法来说，它也具备天然的优势。</p><p><strong>说了这么多，那么要如何查看TurboFan的IR呢？<strong>一个好消息是，V8也像GraalVm一样，提供了一个图形化的工具，来查看TurboFan的IR。这个工具是</strong>turbolizer</strong>，它位于V8源代码的tools/turbolizer目录下。你可以按照该目录下的README.md文档，构建一下该工具，并运行它。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">python -m SimpleHTTPServer 8000</span></div></pre></div><p>它实际启动了一个简单的Web服务。你可以在浏览器中输入“0.0.0.0:8000”，打开turbolizer的界面。</p><p>在运行d8的时候，如果带上参数“–trace-turbo”，就会在当前目录下输出一个.json文件，打开这个文件就能显示出TurboFan的IR来。比如，上一讲的示例程序add.js，所显示出的add函数的IR：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage9da99dd569674080e7f58455b0f1432276a9.jpg" alt=""/></p><p>图2：在turbolizer中显示add函数的IR</p><p>界面中最左边一栏是源代码，中间一栏是IR，最右边一栏是生成的汇编代码。</p><p>上图中的IR只显示了控制节点。你可以在工具栏中找到一个按钮，把所有节点都呈现出来。在左侧的Info标签页中，还有一些命令的快捷键，你最好熟悉一下它们，以便于控制IR都显示哪些节点。这对于一个大的IR图来说很重要，否则你会看得眼花缭乱：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage77d8771f9962ed9788656124d63b14c1a2d8.jpg" alt=""/></p><p>图3：完整展开的add函数的IR</p><p>在这个图中，不同类型的节点用了不同的颜色来区分：</p><ul><li>黄色：控制流的节点，比如Start、End和Return；</li><li>淡蓝色：代表一个值的节点；</li><li>红色：JavaScript层级的操作，比如JSEqual、JSToBoolean等；</li><li>深蓝色：代表一种中间层次的操作，介于JavaScript层和机器层级中间；</li><li>绿色：机器级别的语言，代表一些比较低层级的操作。</li></ul><p>在turbolizer的界面上，还有一个下拉菜单，里面有多个优化步骤。你可以挨个点击，看看经过不同的优化步骤以后，IR的变化是什么样子的。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage3ffe3f37d37bfa29b0fa0531ebbaea5a3afe.jpg" alt=""/></p><p>图4：TurboFan对IR的处理步骤</p><p>你可以看到，在第一步“v8.TFBytecodeGraphBuilder”阶段显示的IR中，它显示的节点还是有点儿多。我们先隐藏掉与计算功能无关的节点，得到了下面的主干。<strong>你要注意其中的绿色节点</strong>，这里已经进行了类型推测，因此它采用了一个整型计算节点：SpeculativeSafeIntegerAdd。</p><p>这个节点的功能是：当两个参数都是整数的时候，那就符合类型推断，做整数加法操作；如果不符合类型推断，那么就执行逆优化。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage1594159b51ee21c0yy129d251c5ee3660e94.jpg" alt=""/></p><p>图5：v8.TFBytecodeGraphBuilder”阶段的IR</p><p>你可以再去点击其他的优化步骤，看看图形会有什么变化。</p><p><strong>在v8.TFGenericLowering阶段</strong>，我们得到了如下所示的IR图，这个图只保留了计算过程的主干。里面增加了两个绿色节点，这两个节点就是把标记指针转换成整数的；还增加了一个深蓝色的节点，这个节点是在函数返回之前，把整数再转换成标记指针。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea63aa6f4a7ba782c38e604469bda41310c3a.jpg" alt=""/></p><p>图6：v8.TFGenericLowering阶段的IR</p><p><strong>在v8.TFLateGraphTrimming阶段</strong>，图中的节点增加了更多的细节，它更接近于具体CPU架构的汇编代码。比如，我们把前面图6中的标记指针，转换成32位整数的操作，就变成了两个节点：</p><ul><li>TruncateInt64ToInt32：把64位整型截短为32位整型；</li><li>Word32Sar：32位整数的移位运算，用于把标记指针转换为整数。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimage5ya45yydb5b9e989b15c39c19585035765a4.jpg" alt=""/></p><p>图7：v8.TFLateGraphTrimming阶段的IR</p><p>这三个阶段就形象地展示出了TurboFan的IR是如何Lower的，从比较抽象的、机器无关的节点，逐步变成了与具体架构相关的操作。</p><p>所以，基本上IR的节点可以分为四类：顶层代表复杂操作的JavaScript节点、底层代表简单操作的机器节点、处于二者之间做了一定简化的节点，以及可以被各个层次共享的节点。</p><p>刚才我们对V8做优化编译时，所采用的IR的分析，只关注了与加法计算有关的主干节点。你还可以用同样的方法，来看看其他的节点。这些节点主要是针对异常情况的处理。比如，如果发现参数类型不是整型，那么就要去执行逆优化。</p><p>在做完了所有的优化之后，编译器就会进入指令排序、寄存器分配等步骤，最后生成机器码。</p><p>现在，你就了解了TurboFan是如何借助Sea of Nodes来做优化和Lower的了。但我们还没有涉及具体的优化算法。<strong>那么，什么优化算法会帮助V8提升性能呢？</strong></p><p>前面在研究<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/257504">Java的JIT编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候，我们重点关注了内联和逃逸分析的优化算法。那么，对于JavaScript来说，这两种优化也同样非常重要，一样能带来巨大的优化效果。</p><p>我们先来看看<strong>内联优化</strong>。对于之前的示例程序，由于我们使用了“–turbo-filter=add”选项来运行代码，因此TurboFan只会编译add方法，这就避免了顶层函数把add函数给内联进去。而如果你去掉了这个选项，就会发现TurboFan在编译完毕以后，程序后面的运行速度会大大加快，一闪而过。这是因为整个顶层函数都被优化编译了，并且在这个过程中，把add函数给内联进去了。</p><p>然后再说说<strong>逃逸分析</strong>。V8运用逃逸分析算法，也可以像Java的编译器一样，把从堆中申请的内存优化为从栈中申请（甚至使用寄存器），从而提升性能，并避免垃圾收集带来的消耗。</p><p>不过，JavaScript和Java的对象体系设计毕竟是不一样的。在Java的类里，每个成员变量相对于对象指针的偏移量都是固定的；而JavaScript则在内部用了<strong>隐藏类</strong>来表示对象的内存布局。这也引出V8的另一个有特色的优化主题：<strong>内联缓存</strong>。</p><p>那接下来，我就带你详细了解一下V8的隐藏类和内联缓存机制。</p><h3 id="隐藏类shapes和内联缓存inline-caching"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#隐藏类shapes和内联缓存inline-caching"><span class="icon icon-link"></span></a>隐藏类（Shapes）和内联缓存（Inline Caching）</h3><p>隐藏类，学术上一般叫做Hidden Class，但不同的编译器的叫法也不一样，比如Shapes、Maps，等等。</p><p>**隐藏类有什么用呢？**你应该知道，在JavaScript中，你不需要先声明一个类，才能创建一个对象。你可以随时创建对象，比如下面的示例程序中，就创建了几个表示坐标点的对象：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">point1 = {x:2, y:3};</span></div><div class="token-line"><span class="token plain">    point2 = {x:4, y:5};</span></div><div class="token-line"><span class="token plain">    point3 = {y:7, x:6};</span></div><div class="token-line"><span class="token plain">    point4 = {x:8, y:9, z:10};</span></div></pre></div><p>那么，V8在内部是怎么来存储x和y这些对象属性的呢？</p><p>如果按照Java的内存布局方案，一定是在对象头后面依次存放x和y的值；而如果按照Python的方案，那就需要用一个字典来保存不同属性的值。但显然用类似Java的方案更加节省内存，访问速度也更快。</p><p>所以，V8内部就采用了隐藏类的设计。如果两个对象，有着相同的属性，并且顺序也相同，那么它们就对应相同的隐藏类。</p><p>在上面的程序中，point1和point2就对应着同一个隐藏类；而point3和point4要么是属性的顺序不同，要么是属性的数量不同，对应着另外的隐藏类。</p><p>所以在这里，你就会得到一个<strong>编写高性能程序的要点</strong>：对于相同类型的对象，一定要保证它们的属性数量和顺序完全一致，这样才会被V8当作相同的类型，从而那些基于类型推断的优化才会发挥作用。</p><p>此外，V8还用到了一种叫做<strong>内联缓存</strong>的技术，来<strong>加快对象属性的访问时间</strong>。它的原理是这样的：当V8第一次访问某个隐藏类的属性的时候，它要到隐藏类里，去查找某个属性的地址相对于对象指针的偏移量。但V8会把这个偏移量缓存下来，这样下一次遇到同样的shape的时候，直接使用这个缓存的偏移量就行了。</p><p>比如下面的示例代码，如果对象o是上面的point1或point2，属性x的地址偏移量就是相同的，因为它们对应的隐藏类是一样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function getX(o){</span></div><div class="token-line"><span class="token plain">      return o.x;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了内联优化技术，那么V8只有在第一次访问某个隐藏类的属性时，速度会慢一点，之后的访问效率就跟Java的差不多了。因为Java这样的静态类型的代码，在编译期就可以确定每个属性相对于对象地址的偏移量。</p><p>好，现在你已经了解了TurboFan做优化的一些关键思路。接下来，我们再返回来，重新探讨一下Ignition的运行速度问题。</p><h2 id="提升ignition的速度"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#提升ignition的速度"><span class="icon icon-link"></span></a>提升Ignition的速度</h2><p>最新版本的V8已经不需要多级的编译器了，只需要一个解释器（Ignition）和一个优化编译器（TurboFan）就行。在公开的测试数据中，Ignition的运行速度，已经接近一个基线编译器生成的机器码的速度了，也就是那种没有做太多优化的机器码。</p><p>这听上去似乎不符合常理，毕竟，解释执行怎么能赶得上运行机器码呢？所以，这里一定有一些值得探究的技术原理。</p><p>让我们再来看看Ignition解释执行的原理吧。</p><p>在上一讲中你已经了解到，V8的字节码是很精简的。比如，对于各种加法操作，它只有一个Add指令。</p><p>但是我们知道，Add指令的语义是很复杂的，比如在ECMAScript标准中，就对加法的语义有很多的规定，如数字相加该怎么做、字符串连接该怎么做，等等。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage0b4a0b8cc0fd4ef25512aa4f3b657f5c014a.jpg" alt=""/></p><p>图8：ECMAScript标准中加法操作的语义规则</p><p>这样的话，<strong>V8在解释执行Add指令的时候，就要跳到一个内置的函数去执行，其他指令也是如此。这些内置函数的实现质量，就会大大影响解释器的运行速度。</strong></p><p>那么如果换做你，你会怎么实现这些内置函数呢？</p><p><strong>选择1：用汇编语言去实现</strong>。这样，我们可以针对每种情况写出最优化的代码。但问题是，这样做的工作量很大。因为V8现在已经支持了9种架构的CPU，而要为每种架构编写这些内置功能，都需要敲几万行的汇编代码。</p><p><strong>选择2：用C++去实现</strong>。这是一个不错的选择，因为C++代码最后编译的结果也是很优化的。不过这里也有一个问题：C++有它自己的调用约定，跟V8中JavaScript的调用约定是不同的。</p><p>比如，在调用C++的内置函数之前，解释器要把自己所使用的物理寄存器保护起来，避免被C++程序破坏，在调用完毕以后还要恢复。这使得从解释器到内置函数，以及从内置函数回到解释器，都要做不少的转换工作。你还要写专门的代码，来对标记指针进行转换。而如果要使用V8的对象，那要处理的事情就更多了，比如它要去隐藏类中查找信息，以及能否通过优化实现栈上内存分配，等等。</p><p><strong>那么，我们还有别的选择吗？</strong></p><p>有的。你看，V8已经有了一个不错的优化编译器TurboFan。**既然它能产生很高效的代码，那么我们为什么不直接用TurboFan来生成机器码呢？**这个思路其实是可行的。这可以看做是V8编译器的一种自举能力，用自己的编译器，来生成自己内部要使用的内置函数的目标代码。</p><p>毕竟，TurboFan本来就是要处理标记指针、JavaScript对象的内存表示等这些问题。这个方案还省去了做调用约定的转换的工作，因为本来V8执行的过程中，就要不断在解释执行和运行机器码之间切换，V8内部对栈桢和调用约定的设计，就是要确保这种切换的代价最低。</p><p>在具体实现的时候，编写这些内置函数是用JavaScript调用TurboFan提供的一些宏。这些宏可以转化为TurboFan的IR节点，从而跟TurboFan的优化编译功能无缝衔接。</p><p>好了，分析到这里，你就知道为什么Ignition的运行速度会这么快了：**它采用了高度优化过的内置函数的实现，并且没有调用约定转换的负担。**而一个基线编译器生成的机器码，因为没有经过充分的优化，反倒并没有那么大的优势。</p><p>再补充一点，V8对字节码也提供了一些优化算法。比如，通过优化，可以减少对临时变量的使用，使得代码可以更多地让累加器起到临时变量的作用，从而减少内存访问次数，提高运行效率。如果你有兴趣在这个话题上去做深入研究，可以参考我在文末链接中给出的一篇论文。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>本讲，我围绕运行速度这个主题，给你讲解了V8在TurboFan和Ignition上所采用的优化技术。你需要记住以下几个要点：</p><ul><li>第一，由于JavaScript是动态类型的语言，所以优化的要点，就是推断出函数参数的类型，并形成有针对性的优化代码。</li><li>第二，同Graal一样，V8也使用了Sea of Nodes的IR，而且对V8来说，内联和逃逸优化算法仍然非常重要。我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/257504">解析Graal编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候已经给你介绍过了，所以这一讲并没有详细展开，你可以自己去回顾复习一下。</li><li>第三，V8所采用的内联缓存技术，能够在运行期提高对象属性访问的性能。另外你要注意的是，在编写代码的时候，一定要避免对于相同的对象生成不同的隐藏类。</li><li>第四，Ignition采用了TurboFan来编译内置函数，这种技术非常聪明，既省了工作量，又简化了系统的结构。实际上，在Graal编译器里也有类似的技术，它叫做Snippet，也是用自身的中后端功能来编译内置函数。所以，你会再次发现，多个编译器之间所采用的编译技术，是可以互相印证的。</li></ul><p>这节课的思维导图我同样帮你整理出来了，供你参考和复习：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage94459450db3e9fcba439e249bdcfabd62145.jpg" alt=""/></p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>我们已经学了两种动态类型的语言的编译技术：Python和JavaScript。那我现在问一个开脑洞的问题：如果你要给Python加一个JIT编译器，那么你可以从JavaScript这里借鉴哪些技术呢？在哪些方面，编译器会得到巨大的性能提升？</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/03.真实编译器解析篇/13#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><ol><li>V8的指针压缩技术：<a target="_blank" rel="noopener noreferrer" href="https://v8.dev/blog/pointer-compression">Pointer Compression in V8<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>介绍V8基于推理的优化机制：<a target="_blank" rel="noopener noreferrer" href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8">An Introduction to Speculative Optimization in V8<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>对Ignition字节码做优化的论文：<a target="_blank" rel="noopener noreferrer" href="https://docs.google.com/document/d/1wW_VkkIwhAAgAxLYM0wvoTEkq8XykibDIikGpWH7l1I/edit?ts=570d7131#heading=h.6jz9dj3bnr8t">Register equivalence optimization<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我在GitHub上也放了一份<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/CompilersInPractice/blob/master/v8/Ignition_%20Register%20Equivalence%20Optimization.pdf">拷贝<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理实战/03.真实编译器解析篇/13.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:46:21</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
