<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>37 | 高级特性（二）：揭秘泛型编程的实现机制 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/05.现代语言设计篇/11" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a href="/blog/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a aria-current="page" class="active" href="/blog/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是泛型？" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#什么是泛型"><span>什么是泛型？</span></a></li><li title="泛型的实现" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#泛型的实现"><span>泛型的实现</span></a></li><li title="类型擦除技术" data-depth="3"><a href="/blog/编译原理实战/05.现代语言设计篇/11#类型擦除技术"><span>类型擦除技术</span></a></li><li title="具体化技术（Reification）" data-depth="3"><a href="/blog/编译原理实战/05.现代语言设计篇/11#具体化技术reification"><span>具体化技术（Reification）</span></a></li><li title="基于元编程技术来支持泛型" data-depth="3"><a href="/blog/编译原理实战/05.现代语言设计篇/11#基于元编程技术来支持泛型"><span>基于元编程技术来支持泛型</span></a></li><li title="泛型对类型系统的增强" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#泛型对类型系统的增强"><span>泛型对类型系统的增强</span></a></li><li title="Julia中的泛型和类型计算" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#julia中的泛型和类型计算"><span>Julia中的泛型和类型计算</span></a></li><li title="课程小结" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="2"><a href="/blog/编译原理实战/05.现代语言设计篇/11#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="37--高级特性二揭秘泛型编程的实现机制"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#37--高级特性二揭秘泛型编程的实现机制"><span class="icon icon-link"></span></a>37 | 高级特性（二）：揭秘泛型编程的实现机制</h1><p>你好，我是宫文学。</p><p>对泛型的支持，是现代语言中的一个重要特性。它能有效地降低程序员编程的工作量，避免重复造轮子，写很多雷同的代码。像C++、Java、Scala、Kotlin、Swift和Julia这些语言都支持泛型。至于Go语言，它的开发团队也对泛型技术方案讨论了很久，并可能会在2021年的版本中正式支持泛型。可见，泛型真的是成为各种强类型语言的必备特性了。</p><p>那么，**泛型有哪些特点？在设计和实现上有哪些不同的方案？编译器应该进行什么样的配合呢？**今天这一讲，我就带你一起探讨泛型的实现原理，借此加深你对编译原理相关知识点的认知，让你能够在自己的编程中更好地使用泛型技术。</p><p>首先，我们来了解一下什么是泛型。</p><h2 id="什么是泛型"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#什么是泛型"><span class="icon icon-link"></span></a>什么是泛型？</h2><p>在日常编程中，我们经常会遇到一些代码逻辑，它们除了类型不同，其他逻辑是完全一样的。你可以看一下这段示例代码，里面有两个类，其中一个类是保存Integer的列表，另一个类是保存Student对象的列表。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class IntegerList{</span></div><div class="token-line"><span class="token plain">        List data = new ArrayList();</span></div><div class="token-line"><span class="token plain">        public void add(Integer elem){</span></div><div class="token-line"><span class="token plain">            data.add(elem);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public Integer get(int index){</span></div><div class="token-line"><span class="token plain">            return (Integer) data.get(index);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public class StudentList{</span></div><div class="token-line"><span class="token plain">        List data = new ArrayList();</span></div><div class="token-line"><span class="token plain">        public void add(Student elem){</span></div><div class="token-line"><span class="token plain">            data.add(elem);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public Student get(int index){</span></div><div class="token-line"><span class="token plain">            return (Student) data.get(index);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们都知道，程序员是很不喜欢重复的代码的。像上面这样的代码，如果要为每种类型都重新写一遍，简直会把人逼疯！</p><p>泛型的典型用途是针对集合类型，能够更简单地保存各种类型的数据，比如List、Map这些。在Java语言里，如果用通用的集合类来保存特定类型的对象，就要做很多强制转换工作。而且，我们还要小心地做类型检查。比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">List strList = new ArrayList();       //字符串列表</span></div><div class="token-line"><span class="token plain">    strList.add(&quot;Richard&quot;);</span></div><div class="token-line"><span class="token plain">    String name = (String)strList.get(i); //类型转换</span></div><div class="token-line"><span class="token plain">    for (Object obj in strList){</span></div><div class="token-line"><span class="token plain">      String str = (String)obj;           //类型转换</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    strList.add(Integer.valueOf(1));      //类型错误</span></div></pre></div><p>而Java里的泛型功能，就能完全消除这些麻烦工作，让程序更整洁，并且也可以减少出错机会。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); //字符串列表</span></div><div class="token-line"><span class="token plain">    strList.add(&quot;Richard&quot;);</span></div><div class="token-line"><span class="token plain">    String name = strList.get(i);                   //类型转换</span></div><div class="token-line"><span class="token plain">    for (String str in strList){                    //无需类型转换</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    strList.add(Integer.valueOf(1));                //编译器报错</span></div></pre></div><p>像示例程序里用到的<code>List&lt;String&gt;</code>，是在常规的类型后面加了一个参数，使得这个列表变成了专门存储字符串的列表。如果你再查看一下List和ArrayList的源代码，会发现它们比普通的接口和类的声明多了一个类型参数<code>&lt;E&gt;</code>，而这个参数可以用在接口和方法的内部所有需要类型的地方：变量的声明、方法的参数和返回值、类所实现的接口，等等。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface List&lt;E&gt; extends Collection&lt;E&gt;{</span></div><div class="token-line"><span class="token plain">      E get(int index);</span></div><div class="token-line"><span class="token plain">      boolean add(E e);</span></div><div class="token-line"><span class="token plain">      ... </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以说，泛型就是把类型作为参数，出现在类/接口/结构体、方法/函数和变量的声明中。<strong>由于类型是作为参数出现的，因此泛型也被称作参数化类型。</strong></p><p>参数化类型还可以用于更复杂的情况。比如，你可以使用1个以上的类型参数，像Map就可以使用两个类型参数，一个是key的类型（K），一个是value的类型（V）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface Map&lt;K,V&gt; {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>另外，你还可以对类型参数添加约束条件。比如，你可以要求类型参数必须是某个类型的子类，这是指定了上界（Upper Bound）；你还可以要求类型参数必须是某个类型的一个父类，这是指定了下界（Lower Bound）。实际上，从语言设计的角度来看，你可以对参数施加很多可能的约束条件，比如必须是几个类型之一，等等。</p><p>**基于泛型的程序，由于传入的参数不同，程序会实现不同的功能。这也被叫做一种多态现象，叫做参数化多态（Parametric Polymorphism）。**它跟面向对象中的多态一样，都能让我们编写更加通用的程序。</p><p>好了，现在我们已经了解了泛型的含义了。那么，它们是如何在语言中实现的呢？需要用到什么编译技术？</p><h2 id="泛型的实现"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#泛型的实现"><span class="icon icon-link"></span></a>泛型的实现</h2><p>接下来，我们一起来看一看几种有代表性的语言实现泛型的技术，包括Java、C#、C++等。</p><h3 id="类型擦除技术"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#类型擦除技术"><span class="icon icon-link"></span></a>类型擦除技术</h3><p>**在Java里，泛型是通过类型擦除（Type Erasure）技术来实现的。**前面在分析<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/255034">Java编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时，你就能发现，其实类型参数只存在于编译过程中，用于做类型检查和类型推断。在此之后，这些类型信息就可以被擦除。ArrayList和<code>ArrayList&lt;String&gt;</code>对应的字节码是一样的，在运行时没有任何区别。</p><p>所以，我们可以说，在Java语言里，泛型其实是一种语法糖，有助于减少程序员的编程负担，并能提供额外的类型检查功能。</p><p>除了Java以外，其他基于JVM的语言，比如Scala和Kotlin，其泛型机制基本上都是类型擦除技术。</p><p>**类型擦除技术的优点是实现起来特别简单。**运用我们学过的属性计算、类型检查和推断等相关技术基本就够用了。</p><p>不过类型擦除技术也有一定的<strong>局限性</strong>。</p><p>问题之一，是<strong>它只能适用于引用类型</strong>，也就是对象，而不适用于值类型，也就是Java中的基础数据类型（Primitive Type）。比如，你不能声明一个<code>List&lt;int&gt;</code>，来保存单纯的整型数据，你在列表里只能保存对象化的Integer。而我们学习过Java对象的内存模型，知道一个Integer对象所占的内存，是一个int型基础数据的好几倍，因为对象头要有十几个字节的固定开销。再加上由此引起的对象创建和垃圾收集的性能开销，导致用Java的集合对象来保存大量的整型、浮点型等基础数据是非常不划算的。我们在这种情况下，还是要退回到使用数组才行。</p><p>问题之二，就是因为类型信息在编译期被擦除了，所以<strong>程序无法在运行时使用这些类型信息</strong>。比如，在下面的示例代码中，如果你想要根据传入的类型T创建一个新实例，就会导致编译错误。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public static &lt;T&gt; void append(ArrayList&lt;T&gt; a) {</span></div><div class="token-line"><span class="token plain">      T b= new T(); // 编译错误</span></div><div class="token-line"><span class="token plain">      a.add(b); </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样，由于在运行期没有类型信息，所以如果要用反射机制来调用程序的时候，我们也没有办法像在编译期那样进行类型检查。所以，你完全可以往一个旨在保存String的列表里添加一个Interger对象。而缺少类型检查，可能会导致程序在执行过程中出错。</p><p>另外，还有一些由于类型擦除而引起的问题。比如，在使用参数化类型的情况下，方法的重载（Overload）会失败。再比如，下面的示例代码中，两个foo方法看似参数不同。但如果进行了类型擦除以后，它们就没什么区别，所以是不能共存的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void foo(List&lt;Integer&gt; p) { ... }</span></div><div class="token-line"><span class="token plain">    public void foo(List&lt;Double&gt; p)  { ... }</span></div></pre></div><p>你要注意，不仅仅是Java语言的泛型技术有这样的缺点，其他基于JVM实现的语言也有类似的缺点（比如没有办法在运行时使用参数化类型的信息）。这其实是由于JVM的限制导致的。为了理解这个问题，我们可以看一下基于.NET平台的语言 ，比如C#所采用的泛型技术。C#使用的不是类型擦除技术，而是一种叫做**具体化（reification）**的技术。</p><h3 id="具体化技术reification"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#具体化技术reification"><span class="icon icon-link"></span></a>具体化技术（Reification）</h3><p>说起来，C#语言的设计者，安德斯 · 海尔斯伯格（Anders Hejlsberg），是一位令人尊敬的传奇人物。像我这一代的程序员，差不多都使用过他在DOS操作系统上设计的Pascal编译器。后来他在此基础上，设计出了Delphi，也是深受很多人喜爱的一款开发工具。</p><p>出于对语言设计者的敬佩，虽然我自己从没用C#写过程序，但我从来没有低估过C#的技术。在泛型方面，C#的技术方案成功地避免了Java泛型的那些缺点。</p><p>C#语言编译也会形成IR，然后在.NET平台上运行。在C#语言中，对应于Java字节码的IR被叫做<strong>IL</strong>，是中间语言（Intermediate Language）的缩写。</p><p>我们知道了，在Java的泛型实现中，编译完毕以后类型信息就会被擦除。<strong>而在C#生成的IL中，则保留了类型参数的类型信息</strong>。所以，<code>List&lt;Student&gt;</code>和<code>List&lt;Teacher&gt;</code>是两个完全不同的类型。也因为IL保存了类型信息，因此我们可以在运行时使用这些类型信息，比如根据类型参数创建对象；而且如果通过反射机制来运行C#程序的话，也会进行类型检查。</p><p>还有很重要的一点，就是<strong>C#的泛型能够支持值类型</strong>，比如基础的整型、浮点型数据；再比如，针对<code>List&lt;int&gt;</code>和<code>List&lt;long&gt;</code>，C#的泛型能够真的生成一份完全不同的可运行的代码。它也不需要把值类型转换成对象，从而导致额外的内存开销和性能开销。</p><p>**把参数化类型变成实际的类型的过程，是在运行时通过JIT技术实现的。这就是具体化（Reification）的含义。**把一个参数化的类型，变成一个运行时真实存在的类型，它可以跟非参数化的类型起到完全相同的作用。</p><p>不过，为了支持泛型，其实.NET扩展了C#生成的IL，以便在IL里能够记录参数化类型信息。而JVM则没有改变它的字节码，从而完全是靠编译器来处理泛型。</p><p>好了，现在我们已经见识到了两种不同的泛型实现机制。还有一种泛型实现机制，也是经常被拿来比较的，这就是C++的泛型机制，它的泛型机制依托的是<strong>模板元编程技术</strong>。</p><h3 id="基于元编程技术来支持泛型"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#基于元编程技术来支持泛型"><span class="icon icon-link"></span></a>基于元编程技术来支持泛型</h3><p>在上一讲，我们介绍过C++的模板元编程技术。模板元编程很强大，程序里的很多要素都可以模板化，那么类型其实也可以被模板化。</p><p>你已经知道，元编程技术是把程序本身作为处理对象的。采用C++的模板元编程技术，我们实际上是为每一种类型参数都生成了新的程序，编译后生成的目标代码也是不同的。</p><p>所以，<strong>C++的模板技术也能做到Java的类型擦除技术所做不到的事情</strong>，比如提供对基础数据类型的支持。在C++的标准模板库（STL）中，提供了很多容器类型。它们能像保存对象一样保存像整型、浮点型这样的基础数据类型。</p><p>不过使用模板技术来实现泛型也有一些<strong>缺点</strong>。因为本质上，模板技术有点像宏，它是把程序中某些部分进行替换，来生成新的程序。在这个过程中，<strong>它并不会检查针对参数类型执行的某些操作是否是合法的</strong>。编译器只会针对生成后的程序做检查，并报错。这个时候，错误信息往往是比较模糊的，不太容易定位。这也是模板元编程技术固有的短板。</p><p>究其原因，是模板技术不是单单为了泛型的目的而实现的。不过，如果了解了泛型机制的原理，你会发现，其实可以通过增强C++编译器，来提升它的类型检查能力。甚至，对类型参数指定上界和下界等约束条件，也是可以的。不过这要看C++标准委员会的决定了。</p><p>总的来说，<strong>C++的泛型技术像Java的一样，都是在运行期之前就完成了所有的工作，而不像.NET那样，在运行期针对某个参数化的类型产生具体的本地代码。</strong></p><p>好了，了解了泛型的几种实现策略以后，接下来，我们接着讨论一个更深入的话题：**把类型参数化以后，对于计算机语言的类型系统有什么挑战？**这个问题很重要，因为在语义分析阶段，我们已经知道如何做普通类型的分析和处理。而要处理参数化的类型，我们还必须更加清楚支持参数化以后，类型体系会有什么变化。</p><h2 id="泛型对类型系统的增强"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#泛型对类型系统的增强"><span class="icon icon-link"></span></a>泛型对类型系统的增强</h2><p>在现代语言中，通常会建立一个层次化的类型系统，其中一些类型是另一些类型的子类型。什么是子类型呢？就是在任何一个用到父类型的地方，都可以用其子类型进行替换。比如，Cat是Animal的子类型，在任何用到Animal的地方，都可以用Cat来代替。</p><p>不过，当类型可以带有参数之后，类型之间的关系就变得复杂了。比如说：</p><ul><li><code>Collection&lt;Cat&gt;</code>和<code>List&lt;Cat&gt;</code>是什么关系呢？</li><li><code>List&lt;Animal&gt;</code>和<code>List&lt;Cat&gt;</code>之间又是什么关系呢？</li></ul><p>对于第一种情况，其实它们的类型参数是一样的，都是Cat。而List本来是Collection的子类型，那么<code>List&lt;Cat&gt;</code>也是<code>Collection&lt;Cat&gt;</code>的子类型，我们永远可以用<code>List&lt;Cat&gt;</code>来替换<code>Collection&lt;Cat&gt;</code>。这种情况比较简单。</p><p>但是对于第二种情况，<code>List&lt;Cat&gt;</code>是否是<code>List&lt;Animal&gt;</code>的子类型呢？这个问题就比较难了。不同语言的实现是不一样的。在Java、Julia等语言中，<code>List&lt;Cat&gt;</code>和<code>List&lt;Animal&gt;</code>之间没有任何的关系。</p><p>在由多个类型复合而形成的类型中（比如泛型），复合类型之间的关系随其中的成员类型的关系而变化的方式，分为**不变（Invariance）、协变（Covariance）和逆变（Contravariance）**三种情况。理解清楚这三种变化，对于我们理解引入泛型后的类型体系非常重要，这也是编译器进行正确的类型计算的基础。</p><p>**首先说说不变。**在Java语言中，<code>List&lt;Animal&gt;</code>和<code>List&lt;Cat&gt;</code>之间并没有什么关系，在下面的示例代码中，如果我们把<code>List&lt;Cat&gt;</code>赋值给<code>List&lt;Animal&gt;</code>，编译器会报错。因此，我们说<code>List&lt;T&gt;</code>基于T是不变的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">List&lt;Cat&gt; catList = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">    List&lt;Animal&gt; animalList = catList;  //报错，不是子类型</span></div></pre></div><p>**那么协变是什么呢？**就是复合类型的变化方向，跟成员类型是相同的。我给你举两个在Java语言中关于协变的例子。</p><p>第一个例子。假设Animal有个reproduce()方法，也就是繁殖。而Cat覆盖（Override）了这个方法，但这个方法的返回值是Cat而不是Animal。因为猫肯定繁殖出的是小猫，而不是其他动物。这样，当我们调用Cat.reproduce()方法的时候，就不用对其返回值做强制转换。这个时候，我们说reproduce()方法的返回值与它所在类的类型，是协变的，也就是<strong>一起变化</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Animal{</span></div><div class="token-line"><span class="token plain">        public abstract Animal reproduce();</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Cat extends Animal{</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public Cat reproduce() {  //方法的返回值可以是Animal的子类型</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第二个例子。在Java语言中，数组是协变的。也就是<code>Cat[]</code>其实是<code>Animal[]</code>的子类型，在下面的示例代码中，一个猫的数组可以赋值给一个动物数组。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Cat[] cats = {new Cat(), new Cat()}; //创建Cat数组</span></div><div class="token-line"><span class="token plain">    Animal[] animals = cats;             //赋值给Animal数组</span></div><div class="token-line"><span class="token plain">    animals[0] = new Dog();              //修改第一个元素的值</span></div><div class="token-line"><span class="token plain">    Cat aCat = cats[0];                  //运行时错误</span></div></pre></div><p>但你接下来会看到，Animal数组中的值可以被修改为Dog，这会导致Cat数组中的元素类型错误。至于为什么Java语言要把数组设计为协变的，以及由此导致的一些问题，我们暂且不管它。我们要问的是，<strong><code>List&lt;T&gt;</code>这样的泛型可以变成协变关系吗？</strong></p><p>答案是可以的。我前面也提过，我们可以在类型参数中指定上界。<code>List&lt;Cat&gt;</code>是<code>List&lt;? Extends Animal&gt;</code>的子类型，<code>List&lt;? Extends Animal&gt;</code>的意思，是任何以Animal为祖先的子类。我们可以把一个<code>List&lt;Cat&gt;</code>赋值给<code>List&lt;? Extends Animal&gt;</code>。你可以看一下示例代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">List&lt;Cat&gt; catList = new ArrayList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">    List&lt;? extends Animal&gt; animalList = catList;  //子类型</span></div><div class="token-line"><span class="token plain">    catList.add(new Cat());</span></div><div class="token-line"><span class="token plain">    Animal animal = animalList.get(0);</span></div></pre></div><p>实际上，不仅仅<code>List&lt;Cat&gt;</code>是<code>List&lt;? extends Animal&gt;</code>的子类型，连<code>List&lt;Animal&gt;</code>也是<code>List&lt;? extends Animal&gt;</code>的子类型。你可以自己测试一下。</p><p>**我们再来说说逆变。**逆变的意思是：虽然Cat是Animal的子类型，但包含了Cat的复合类型，竟然是包含了Animal的复合类型的父类型！它们颠倒过来了？</p><p>这有点违反直觉。在真实世界里有这样的例子吗？当然有。</p><p>比如，假设有两个函数，<code>getWeight&lt;Cat&gt;()</code>函数是返回Cat的重量，<code>getWeight&lt;Animal&gt;()</code>函数是返回Animal的重量。你知道，从函数式编程的观点，每个函数也都是有类型的。那么这两个函数，谁是谁的子类型呢？</p><p>实际上，求Animal重量的函数，其实是求Cat重量的函数的子类型。怎么说呢？</p><p>来假设一下。如果你想用一个getTotalWeight()函数，求一群Cat的总重量，你会怎么办呢？你可以把求Cat重量的函数作为参数传进去，这肯定没问题。但是，你也可以把求Animal重量的函数传进去。因为既然它能返回普通动物的重量，那么也一定能返回猫的重量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//伪代码，求Cat的总重量</span></div><div class="token-line"><span class="token plain">    getTotalWeight(List&lt;Cat&gt; cats, function fun)</span></div></pre></div><p>而根据类型理论，<strong>如果类型B能顶替类型A的位置，那么B就是A的子类型</strong>。</p><p>所以，<code>getWeigh&lt;Animal&gt;()</code>反倒是<code>getWeight&lt;Cat&gt;()</code>的子类型，这种情况就叫做逆变。</p><p>总的来说，加入泛型以后，计算机语言的类型体系变得更加复杂了。我们在编写编译器的时候，一定要弄清楚这些变化关系，这样才能执行正确的类型计算。</p><p>那么，在了解了加入泛型以后对类型体系的影响后，我们接着借助Julia语言，来进一步验证一下如何进行正确的类型计算。</p><h2 id="julia中的泛型和类型计算"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#julia中的泛型和类型计算"><span class="icon icon-link"></span></a>Julia中的泛型和类型计算</h2><p>Julia设计了一个精巧的类型体系。这个类型体系有着共同的根，也就是Any。在这个类型层次中，橙色的类型是叶子节点，它们是具体的类型，也就是可以创建具体的实例。而中间层次的节点（蓝色），都是抽象的，主要是用于类型的计算。</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/05.%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E7%AF%87/resourceimage4b384b88f681a305ecf5010606e3b3a68c38.jpg" alt="" title="Julia的类型体系"/></p><p>你在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/264333">第22讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，已经了解到了Julia做函数编译的特点。在编写函数的时候，你可以根本不用指定参数的类型，编译器会根据传入的参数的实际类型，来编译成相应版本的机器码。另外，你也可以为函数编写多个版本的方法，每个版本的参数采用不同的类型。编译器会根据实际参数的类型，动态分派到不同的版本。而<strong>这个动态分派机制，就需要用到类型的计算</strong>。</p><p>比如说，有一个函数foo()，定义了三个版本的方法，其参数分别是没有指定类型（也就是Any）、Real类型和Float64类型。如果参数是Float64类型，那它当然会被分派到第三个方法。如果是Float32类型，那么就会被分派到第二个方法。如果是一个字符串类型呢，则会被分派到第一个方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">julia&gt; function foo(x)          #方法1</span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div><div class="token-line"><span class="token plain">           </span></div><div class="token-line"><span class="token plain">    julia&gt; function foo(x::Real)    #方法2  </span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div><div class="token-line"><span class="token plain">           </span></div><div class="token-line"><span class="token plain">    julia&gt; function foo(x::Float64) #方法3  </span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div></pre></div><p>再进一步，**Julia还支持在定义结构体和函数的时候使用泛型。**比如，下面的一个Point结构中，坐标x和y的类型是参数化的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">julia&gt; struct Point{T}</span></div><div class="token-line"><span class="token plain">               x::T</span></div><div class="token-line"><span class="token plain">               y::T</span></div><div class="token-line"><span class="token plain">           end</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    julia&gt; Point{Float64}</span></div><div class="token-line"><span class="token plain">    Point{Float64}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    julia&gt; Point{Float64} &lt;: Point     #在Julia里，如果一个类型更具体，则&lt;:为真</span></div><div class="token-line"><span class="token plain">    true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    julia&gt; Point{Float64} &lt;: Point{Real} #Invariant</span></div><div class="token-line"><span class="token plain">    false</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    julia&gt; p1 = Point(1.0,2.3)   #创建一个Point实例</span></div><div class="token-line"><span class="token plain">    Point{Float64}(1.0, 2.3)     #自动推断出类型</span></div></pre></div><p>如果我们再为foo()函数添加几个方法，其参数类型分别是Point类型、Point<!-- -->{<!-- -->Real<!-- -->}<!-- -->类型和Point<!-- -->{<!-- -->Float64<!-- -->}<!-- -->类型，那动态分派的算法也必须能够做正确的分派。所以，在这里，我们就必须能够识别出带有参数的类型之间的关系。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">julia&gt; function foo(x::Point)          #方法4</span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div><div class="token-line"><span class="token plain">           </span></div><div class="token-line"><span class="token plain">    julia&gt; function foo(x::Point{Real})    #方法5  </span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div><div class="token-line"><span class="token plain">           </span></div><div class="token-line"><span class="token plain">    julia&gt; function foo(x::Point{Float64}) #方法6  </span></div><div class="token-line"><span class="token plain">               ...</span></div><div class="token-line"><span class="token plain">           end</span></div></pre></div><p>通过以上的示例代码你可以看到，Point<!-- -->{<!-- -->Float64<!-- -->}<!-- --> &lt;: Point，也就是Point<!-- -->{<!-- -->Float64<!-- -->}<!-- -->是Point的子类型。这个关系是有意义的。</p><p><strong>Julia的逻辑是</strong>，Point<!-- -->{<!-- -->Float64<!-- -->}<!-- --> 比Point更具体，能够在程序里替代Point。而Point<!-- -->{<!-- -->Float64<!-- -->}<!-- --> 和Point<!-- -->{<!-- -->Real<!-- -->}<!-- -->之间是没有什么关系的，虽然Float64是Real的子类型。这说明，Point<!-- -->{<!-- -->T<!-- -->}<!-- -->基于T是不变的（Invariant），这跟Java语言的泛型处理是一样的。</p><p>所以，在Julia编译的时候，如果我们给foo()传递一个Point<!-- -->{<!-- -->Float64<!-- -->}<!-- -->参数，那么应该被分派到方法6。而如果传递一个Point<!-- -->{<!-- -->Float32<!-- -->}<!-- -->参数呢？分派算法不会选择方法5，因为Point<!-- -->{<!-- -->Float32<!-- -->}<!-- -->不是Point<!-- -->{<!-- -->Real<!-- -->}<!-- -->的子类型。因此，分配算法会选择方法4，因为Point<!-- -->{<!-- -->Float32<!-- -->}<!-- -->是Point的子类型。</p><p>那么，<strong>如何让Point<!-- -->{<!-- -->T<!-- -->}<!-- -->基于T协变呢</strong>？这样我们就可以针对Real类型写一些通用的算法，让采用Float32、Float16等类型的Point，都按照这个算法去编译了。</p><p>**答案就是需要指定上界。**我们可以把Point<!-- -->{<!-- -->Real<!-- -->}<!-- -->改为Point<!-- -->{<!-- -->&lt;:Real<!-- -->}<!-- -->，它是Point<!-- -->{<!-- -->Float32<!-- -->}<!-- -->、Point<!-- -->{<!-- -->Float16<!-- -->}<!-- -->等的父类型。</p><p>好，总结起来，Julia的泛型和类型计算是很有特点的。泛型提供的参数化多态（Parametric Polymorphism）跟Julia原来的方法多态（Method Polymorphism）很好地融合在了一起，让我们能够最大程度地去编写通用的程序。而被泛型增强后的类型体系，也对动态分派算法提出了更高的要求。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>这一讲，我们学习了泛型这个现代语言中非常重要的特性的实现机制。在实现泛型机制的时候，我们首先必须弄清楚引入泛型以后，对类型体系的影响。你要掌握<strong>不变、协变和逆变</strong>这三个基本概念和它们的应用场景，从而能够正确地用于类型计算的过程中。</p><p>在泛型的具体实现机制上，有<strong>类型擦除、具体化和模板元编程</strong>等不同的方法。好的实现机制应该有能力同时兼顾值类型和复合类型，同时又便于调试。</p><p>按照惯例，我也把本讲的内容总结成了思维导图，供你参考：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98/05.%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E7%AF%87/resourceimagec7d7c7bf4642ebd4a0253b9ec3b174ef71d7.jpg" alt=""/></p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>今天，我想给你留两道思考题，你可以根据你熟悉的语言，选择其一。</p><ul><li>如果你对Java语言比较熟悉，那么针对Java的泛型不支持基础数据类型的问题，你能否想出一种技术方案，来弥补这个短板呢？你思考一下。我在下一讲会借助面向对象的话题，给出一个技术方案。</li><li>而如果你对Go语言有所了解，那么你对Go语言的泛型技术方案会提出什么建议？能否避免已有语言在实现泛型上的短板呢？你也可以参考我在文末给出的Go语言泛型方案的草案，来印证你的想法。</li></ul><p>欢迎在留言区分享你的观点，也非常欢迎你把今天的内容分享给更多的朋友。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理实战/05.现代语言设计篇/11#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><ol><li>Go语言<a target="_blank" rel="noopener noreferrer" href="https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md">泛型方案的草案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li><a target="_blank" rel="noopener noreferrer" href="https://docs.julialang.org/en/v1/manual/types/#Parametric-Types">Julia的泛型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li><a target="_blank" rel="noopener noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/">C#泛型的文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以看看它在运行期是如何支持泛型的，这跟Java有很大的不同。</li></ol></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/编译原理实战/05.现代语言设计篇/11.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
