<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>30 | 后端总结：充分发挥硬件的能力 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理实战/05.现代语言设计篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/编译原理实战/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/编译原理实战/01.课前必读/01"><span>开篇词 | 在真实世界的编译器中游历</span></a></li><li><a href="/blog-base/编译原理实战/01.课前必读/02"><span>学习指南 | 如何学习这门编译原理实战课？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/02.预备知识篇">02.预备知识篇</a><ul><li><a href="/blog-base/编译原理实战/02.预备知识篇/01"><span>01 | 编译的全过程都悄悄做了哪些事情？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/02"><span>02 | 词法分析：用两种方式构造有限自动机</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/03"><span>03 | 语法分析：两个基本功和两种算法思路</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/04"><span>04 | 语义分析：让程序符合语义规则</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/05"><span>05 | 运行时机制：程序如何运行，你有发言权</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/06"><span>06 | 中间代码：不是只有一副面孔</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/07"><span>07 | 代码优化：跟编译器做朋友，让你的代码飞起来</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/08"><span>08 | 代码生成：如何实现机器相关的优化？</span></a></li><li><a href="/blog-base/编译原理实战/02.预备知识篇/09"><span>知识地图 | 一起来复习编译技术核心概念与算法</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇">03.真实编译器解析篇</a><ul><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/01"><span>09 | Java编译器（一）：手写的编译器有什么优势？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/02"><span>10 | Java编译器（二）：语法分析之后，还要做些什么？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/03"><span>11 | Java编译器（三）：属性分析和数据流分析</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/04"><span>12 | Java编译器（四）：去除语法糖和生成字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/05"><span>13 | Java JIT编译器（一）：动手修改Graal编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/06"><span>14 | Java JIT编译器（二）：Sea of Nodes为何如此强大？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/07"><span>15 | Java JIT编译器（三）：探究内联和逃逸分析的算法原理</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/08"><span>16 | Java JIT编译器（四）：Graal的后端是如何工作的？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/09"><span>17 | Python编译器（一）：如何用工具生成编译器？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/10"><span>18 | Python编译器（二）：从AST到字节码</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/11"><span>19 | Python编译器（三）：运行时机制</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/12"><span>20 | JavaScript编译器（一）：V8的解析和编译过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/13"><span>21 | JavaScript编译器（二）：V8的解释器和优化编译器</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/14"><span>22 | Julia编译器（一）：如何让动态语言性能很高？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/15"><span>23 | Julia编译器（二）：如何利用LLVM的优化和后端功能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/16"><span>24 | Go语言编译器：把它当作教科书吧</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/17"><span>25 | MySQL编译器（一）：解析一条SQL语句的执行过程</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/18"><span>26 | MySQL编译器（二）：编译技术如何帮你提升数据库性能？</span></a></li><li><a href="/blog-base/编译原理实战/03.真实编译器解析篇/19"><span>热点问题答疑 | 如何吃透7种真实的编译器？</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/04.期中复习周">04.期中复习周</a><ul><li><a href="/blog-base/编译原理实战/04.期中复习周/01"><span>划重点 | 7种编译器的核心概念与算法</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/02"><span>期中考试 | 这些编译原理知识，你都掌握了吗？</span></a></li><li><a href="/blog-base/编译原理实战/04.期中复习周/03"><span>用户故事 | 易昊：程序员不止有Bug和加班，还有诗和远方</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/05.现代语言设计篇">05.现代语言设计篇</a><ul><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/01"><span>27 | 课前导读：学习现代语言设计的正确姿势</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/02"><span>28 | 前端总结：语言设计也有人机工程学</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/03"><span>29 | 中端总结：不遗余力地进行代码优化</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理实战/05.现代语言设计篇/04"><span>30 | 后端总结：充分发挥硬件的能力</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/05"><span>31 | 运行时（一）：从0到语言级的虚拟化</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/06"><span>32 | 运行时（二）：垃圾收集与语言的特性有关吗？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/07"><span>33 | 并发中的编译技术（一）：如何从语言层面支持线程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/08"><span>34 | 并发中的编译技术（二）：如何从语言层面支持协程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/09"><span>35 | 并发中的编译技术（三）：Erlang语言厉害在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/10"><span>36 | 高级特性（一）：揭秘元编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/11"><span>37 | 高级特性（二）：揭秘泛型编程的实现机制</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/12"><span>38 | 综合实现（一）：如何实现面向对象编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/13"><span>39 | 综合实现（二）：如何实现函数式编程？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/14"><span>40 | 成果检验：方舟编译器的优势在哪里？</span></a></li><li><a href="/blog-base/编译原理实战/05.现代语言设计篇/15"><span>期末答疑与总结 | 再次审视学习编译原理的作用</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/06.结束语">06.结束语</a><ul><li><a href="/blog-base/编译原理实战/06.结束语/01"><span>结束语 | 实战是唯一标准！</span></a></li><li><a href="/blog-base/编译原理实战/06.结束语/02"><span>期末考试 | “编译原理实战课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/编译原理实战/summary">编译原理实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="指令选择算法" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#指令选择算法"><span>指令选择算法</span></a></li><li title="寄存器分配算法" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#寄存器分配算法"><span>寄存器分配算法</span></a></li><li title="编译器后端与语言的设计" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#编译器后端与语言的设计"><span>编译器后端与语言的设计</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#一课一思"><span>一课一思</span></a></li><li title="参考资料" data-depth="2"><a href="/blog-base/编译原理实战/05.现代语言设计篇/04#参考资料"><span>参考资料</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="30--后端总结充分发挥硬件的能力"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#30--后端总结充分发挥硬件的能力"><span class="icon icon-link"></span></a>30 | 后端总结：充分发挥硬件的能力</h1><p>你好，我是宫文学。</p><p>后端的工作，主要是针对各种不同架构的CPU来生成机器码。在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/249261">第8讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我已经对编译器在生成代码的过程中，所做的主要工作进行了简单的概述，你现在应该对编译器的后端工作有了一个大致的了解，也知道了后端工作中的关键算法包括指令选择、寄存器分配和指令排序（又叫做指令调度）。</p><p>那么今天这一讲，我们就借助在第二个模块中解析过的真实编译器，来总结、梳理一下各种编译器的后端技术，再来迭代提升一下原有的认知，并加深对以下这些问题的理解：</p><ul><li>首先，在第8讲中，我只讲了<strong>指令选择</strong>的必要性，但对于如何实现指令选择等步骤，我并没有展开介绍。今天这一讲，我就会带你探索一下指令选择的相关算法。</li><li>其次，关于<strong>寄存器分配算法</strong>，我们探索过的好几个编译器，比如Graal、gc编译器等，采用的都是线性扫描算法，那么这个算法的原理是什么呢？我们一起来探究一下。</li><li>最后，我们再回到<strong>计算机语言设计</strong>的主线上来，一起分析一下不同编译器的后端设计，是如何跟该语言的设计目标相匹配的。</li></ul><p>OK，我们先来了解一下指令选择的算法。</p><h2 id="指令选择算法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#指令选择算法"><span class="icon icon-link"></span></a>指令选择算法</h2><p>回顾一下，我们主要是在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/258162">Graal<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/266379">Go语言<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的编译器中，分析了与指令选择有关的算法。它们都采用了一种模式匹配的DSL，只要找到了符合模式的指令组合，编译器就生成一条低端的、对应于机器码的指令。</p><p>**那为什么这种算法是有效的呢？这种算法的原理是什么呢？都有哪些不同的算法实现？**接下来，我就给你揭晓一下答案。</p><p>我先给你举个例子。针对表达式“a[i]=b”，它是对数组a的第i个元素赋值。假设a是一个整数数组，那么地址的偏移量就是<code>a+4*i</code>，所以，这个赋值表达式用C语言可以写成“<code>*(a+4*i)=b</code>”，把它表达成AST的话，就是下图所示的样子。其中，赋值表达式的左子树的计算结果，是一个内存地址。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea2d3a234b0a6b2bb153f2857989e16106bd3.91d47ab6.jpg" alt=""/></p><p>图1：a[i]=b的AST</p><p>那么，我们要如何给这个表达式生成指令呢？</p><p>如果你熟悉x86汇编，你就会知道，上述语句可以非常简单地表达出来，因为x86的指令对数组寻址做了优化（参见第8讲的内容）。</p><p>不过，这里为了让你更容易理解算法的原理，我设计了一个新的指令集。这个指令集中的每条指令，都对应了一棵AST的子树，我们把它叫做<strong>模式树（Pattern Tree）</strong>。在有的算法里，它们也被叫做<strong>瓦片（Tiling）</strong>。对一个AST生成指令，就是用这样的模式树或瓦片来覆盖整个AST的过程。所以，这样的算法也叫做<strong>基于模式匹配的指令生成算法</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage4be94ba05f685d18635767a7f8f3924b90e9.8ce56133.jpg" alt=""/></p><p>图2：指令集中的指令和对应的模式树</p><p>你可以看到，在图2中，对于每棵模式树，它的根节点是这个指令产生的结果的存放位置。比如，Load_Const指令执行完毕以后，常数会被保存到一个寄存器里。这个寄存器，又可以作为上一级AST节点的操作数来使用。</p><p>图2中的指令包含：把常数和内存中的值加载到寄存器、加法运算、乘法运算等。其中有两个指令是特殊设计的，目的就是为了让你更容易理解接下来要探究的各种算法。</p><p><strong>第一个指令是#4（Store_Offset）</strong>，它把值保存到内存的时候，可以在目的地址上加一个偏移量。你可以认为这是为某些场景做的一个优化，比如你在对象地址上加一个偏移量，就能获得成员变量的地址，并把数值保存到这个地址上。</p><p><strong>第二个指令是#9（Lea）</strong>，它相当于x86指令集中的Lea指令，能够计算一个地址值，特别是能够利用间接寻址模式，计算出一个数组元素的地址。它能通过一条指令完成一个乘法计算和一个加法计算。如果你忘记了Lea指令，可以重新看看第8讲的内容。</p><p>基于上述的指令和模式树，我们就可以尝试来做一下模式匹配，从而选择出合适的指令。<strong>那么都可以采用什么样的算法呢？</strong></p><p><strong>第一个算法，是一种比较幼稚的算法。我们采取深度优先的后序遍历，也就是按照“左子节点-&gt;右子节点-&gt;父节点”的顺序遍历，针对每个节点去匹配上面的模式。</strong></p><ul><li>第1步，采用模式#2，把内存中a的值，也就是数组的地址，加载到寄存器。因为无论加减乘除等任何运算，都是可以拿寄存器作为操作数的，所以做这个决策是很安全的。</li><li>第2步，同上，采用模式#1，把常量4加载到寄存器。</li><li>第3步，采用模式#2，把内存中i的值加载到寄存器。</li><li>第4步，采用模式#8，把两个寄存器的值相乘，得到（4*i）的值。</li><li>第5步，采用模式#5，把两个寄存器的值相加，得到a+4*i的值，也就是a[i]的地址。</li><li>第6步，采用模式#2，把内存中b的值加载到寄存器。</li><li>第7步，采用模式#3，把寄存器中b的值写入a[i]的地址。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage8a5e8afb39c83db4de7c6758f486ca27395e.54c110ea.jpg" alt=""/></p><p>图3：用比较幼稚的算法做模式匹配</p><p>最后形成的汇编代码是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Load_Mem a, R1</span></div><div class="token-line"><span class="token plain">    Load_Const 4, R2</span></div><div class="token-line"><span class="token plain">    Load_Mem i, R3</span></div><div class="token-line"><span class="token plain">    Mul_Reg R2, R3</span></div><div class="token-line"><span class="token plain">    Add_Reg R3, R1</span></div><div class="token-line"><span class="token plain">    Load_Mem b, R2</span></div><div class="token-line"><span class="token plain">    Store R2, (R1)</span></div></pre></div><p>**这种方法，是自底向上的做树的重写。**它的优点是特别简单，缺点是性能比较差。它一共生成了7条指令，代价是19（3+1+3+4+1+3+4）。</p><p>在上述步骤中，我们能看到很多可以优化的地方。比如，4*i这个子表达式，我们是用了3条指令来实现的，总的Cost是1+3+4=8，而如果改成两条指令，也就是使用Mul_mem指令，就不用先把i加载到寄存器，Cost可以是1+6=7。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Load_Const 4, R1</span></div><div class="token-line"><span class="token plain">    Mul_Mem i, R1</span></div></pre></div><p>**第二种方法，是类似Graal编译器所采用的方法，自顶向下的做模式匹配。**比如，当我们处理赋值节点的时候，算法会尽量匹配更多的子节点。因为一条指令包含的子节点越多，那么通过一条指令完成的操作就越多，从而总的Cost就更低。</p><p>所以，算法的大致步骤是这样的：</p><ul><li>第1步，在#3和#4两个模式中做选择的话，选中了#4号。</li><li>第2步，沿着AST继续所深度遍历，其中+号节点第1步被处理掉了，所以现在处理变量a，采用了模式#2，把变量加载到寄存器。</li><li>第3步，处理*节点。这个时候要在#7和#8之间做对比，最后选择了#7，因为它可以包含更多的节点。</li><li>第4步，处理常量4。因为上级节点在这里需要一个寄存器作为操作数，所以我们采用了模式#1，把常量加载到寄存器。</li><li>第5步，处理变量b。这里也要把它加载到寄存器，因此采用了模式#2。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea41ba4aac19471190a449bab1b947ae5711b.5a30a6d2.jpg" alt=""/></p><p>图4：Maximal Munch算法的匹配结果</p><p>到此为止，我们用了5条指令就做完了所有的运算，生成的汇编代码是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Load_Mem a, R1</span></div><div class="token-line"><span class="token plain">    Load_Const 4, R2</span></div><div class="token-line"><span class="token plain">    Mul_Mem R2, i</span></div><div class="token-line"><span class="token plain">    Load_Mem b, R3</span></div><div class="token-line"><span class="token plain">    Store_Offset R3, (R1,R2)</span></div></pre></div><p>这5条指令总的Cost是18（3+1+6+3+5）。</p><p>上述算法的特点，是在每一步都采用了<strong>贪婪策略</strong>，这种算法策略有时候也叫做“Maximal Munch”，意思就是每一步都去咬最大的一口。</p><p>贪婪策略会生成比幼稚的算法更优化的代码，但它不一定是最优的。你看下图中的匹配策略，它也是用了5条指令。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage693b69ffa14568a9f85654a92074458bb43b.5a748fd5.jpg" alt=""/></p><p>图5：最优的匹配策略</p><p>生成的汇编代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Lead_Mem a, R1</span></div><div class="token-line"><span class="token plain">    Load_Mem i, R2</span></div><div class="token-line"><span class="token plain">    Lea (R1,R2,4), R1</span></div><div class="token-line"><span class="token plain">    Load_Mem b, R2</span></div><div class="token-line"><span class="token plain">    Store R2, (R1)</span></div></pre></div><p>这个新的匹配结果，总的Cost是17（3+3+4+3+4），比前一个算法的结果更优化了。那我们用什么算法能得到这样一个结果呢？</p><p>一个思路，是<strong>找出用模式匹配来覆盖AST的所有可能的模式，并找出其中Cost最低的</strong>。你可以采用<strong>暴力枚举</strong>的方法，在每一个节点，去匹配所有可能的模式，从而找出多组解。但显然，这种算法的计算量太大，所需的时间会根据AST的大小呈指数级上升，导致编译速度无法接受。</p><p>所以我们需要找到一个代价更低的算法，这就是<strong>BURS算法</strong>，也就是“自底向上重写系统，Bottom-Up Rewriting System”。在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/258162">HotSpot的C2编译器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，就采用了BURS算法。这个算法采用了<strong>动态规划</strong>（Dynamic Programming）的数学方法来获取最优解，同时保持了较低的算法复杂度。</p><p>**那么，要想理解BURS算法，你就必须要弄懂动态规划的原理。**如果你之前没有学过这个数学方法，请不要紧张，因为动态规划的原理其实是相当简单的。</p><p>我在网上发现了一篇能够简洁地说清楚动态规划的<a target="_blank" rel="noopener noreferrer" href="https://cloud.tencent.com/developer/article/1475703">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它举了一个例子，用最少张的纸币，来凑出某个金额。</p><p>比如说，假设你要凑出15元，怎么做呢？你还是可以继续采用贪婪算法。首先，拿出一张10元的纸币，也就是小于15的最大金额，然后再拿出5元来。这样你用两张纸币就凑出了15这个数值。这个时候，贪婪策略仍然是有效的。</p><p>但是，如果某个奇葩的国家发行的货币，不是按照中国货币的面额，而是发行1、5、11元三种面额的纸币。那么如果你仍然使用贪婪策略，一开始拿出一张11元的纸币，你就还需要再拿出4张1元的，这样就一共需要5张纸币。</p><p>但这显然不是最优解。最优解是只需要三张5元的纸币就可以了，这就像我们用贪婪算法去做指令生成，得到的可能不是最优解，是同样的道理。</p><p>那如何采用动态规划的方法来获取最优解呢？它的思路是这样的，假设我们用f(n)来代表凑出n元钱最少的纸币数，那么：</p><ul><li>当一开始取11元的话，Cost = f(4) + 1；</li><li>当一开始取5元的话，Cost = f(10) + 1；</li><li>当一开始取1元的话，Cost = f(14) + 1。</li></ul><p>所以，我们只需要知道f(4)、f(10)和f(14)哪个值最小就行了。也就是说，f(15)=min(f(4), f(10), f(14)) + 1。 而f(4)、f(10)和f(14)三个值，也可以用同样的方法递归地求出来，最后得到的值分别是4、2、4。所以f(15)=3，这就是最优解。</p><p>这个算法最棒的一点，是整个计算中会遇到的f(14)、f(13)、f(12)、f(11) … f(3)、f(2)这些值，<strong>一旦计算过一遍，就可以缓存下来，不必重复计算，从而让算法的复杂性降低</strong>。</p><p>所以，动态规划的特点，是通过子问题的最优解，得到总的问题的最优解。这种方法，也可以用于生成最优的指令组合。比如，对于示例程序来说，假设f(=)是以赋值运算符为根节点的AST所生成的指令的总的最低Cost，那么：</p><ul><li>当采用#3的时候，Cost = 4 + f(+) + f(b)；</li><li>当采用#4的时候，Cost = 5 + f(a) + f(*) + f(b)。</li></ul><p>所以你能看出，通过动态规划方法，也能像凑纸币一样，求出树覆盖的最优解。</p><p>BURS算法在具体执行的时候，需要进行三遍的扫描。</p><p><strong>第一遍扫描</strong>是自底向上做遍历，也就是后序遍历，识别出每个节点可以进行的转换。我在图6中给你标了出来。以a节点为例，我们可以对它做两个操作，第一个操作是保持一个mem节点不动，第二个操作是按照模式#1把它转换成一个reg节点。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagedd2ddddd87f278c8111d4787756380e08b2d.1b6b1e89.jpg" alt=""/></p><p>图6：识别AST的每个节点可以进行的转换</p><p><strong>第二遍扫描</strong>是自顶向下的，运用动态规划的方法找出最优解。</p><p><strong>第三遍扫描</strong>又是自底向上的，用于生成指令。</p><p>好了，那么到目前为止，你就已经了解了指令生成的算法思路了。这里我再补充几点说明：</p><ul><li>示例中的指令和Cost值，是为了便于你理解算法而设计的。在这个示例中，最优解和最差解的Cost只差了2，也就是大约12%的性能提升。而在实际应用中，优化力度往往会远远大于这个值。</li><li>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/247700">第6讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>探究IR的数据结构时，我提到过有向无环图（DAG），它比起刚才例子中用到的树结构，能够消除一些冗余的子树，从而减少生成的代码量。LLVM里在做指令选择的时候，就是采用了DAG，但算法思路是一样的。</li><li>示例中到的两个算法，贪婪算法和BURS算法，它们花费的时间都与节点数呈线性关系，所以性能都是很高的。其中BURS算法的线性系数更大一点，做指令选择所需的时间也更长一点。</li></ul><p>OK，那么接下来，我们来探究第二个算法，寄存器分配算法。</p><h2 id="寄存器分配算法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#寄存器分配算法"><span class="icon icon-link"></span></a>寄存器分配算法</h2><p>在解析Graal编译器和Go的编译器的时候，我都提到过它们的寄存器分配算法是线性扫描算法。我也提到过，线性扫描算法的性能比较高。</p><p>**那么，线性扫描算法的原理是什么呢？**总的来说，线性扫描算法理解起来其实相当简单。我用一个例子来带你了解下。</p><p>假设我们的程序里有从a到g共7个变量。通过数据流分析中的变量活跃性分析，你其实可以知道每个变量的生存期。现在，我们已知有4个物理寄存器可用，那么我们来看一下要怎么分配这几个物理寄存器。</p><p><strong>在第1个时间段</strong>，a、b、c和d是活跃的，那我们刚好把4个物理寄存器分配给这四个变量就行了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage397539dc35a5b607cd3066017c08d0191975.2e23bc8a.jpg" alt=""/></p><p><strong>在第2个时间段</strong>，a的生存期结束，而一个新的变量e变得活跃，那么我们就把a原来占用的寄存器刚好给到e就可以了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb64ab64ae2b4cfd318f9eeeeaa54ab83984a.7c5a3047.jpg" alt=""/></p><p><strong>在第3个时间段</strong>，我们把c占用的寄存器给到f，目前仍然是使用4个寄存器。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage486348fb912ba5c59f8c04373a91510b5563.7bbfb7c1.jpg" alt=""/></p><p><strong>在第4个时间段</strong>，b的生存期结束。这时候只需要用到3个寄存器。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageca04ca60eb79fedac105f3cbfd6f8c509404.05bfca5f.jpg" alt=""/></p><p><strong>在最后一个时间段</strong>，只有变量d和g是活跃的，占用两个寄存器。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage040a04b2d9a8cyy51a6916cc286b29ea9a0a.9818992a.jpg" alt=""/></p><p>可以看到，在上面这个例子中，所有的变量都可以分配到物理寄存器。而且你也会发现，这个例子中存在多个变量因为生存期是错开的，因此也可以共享同一个寄存器。</p><p>但是，如果没有足够的物理寄存器的话，我们要怎么办呢？那就需要把某个变量溢出到内存里了。也就是说，当用到这个变量的时候，才把这个变量加载到寄存器，或者有一些指令可以直接用内存地址作为操作数。</p><p>给你举另一个例子，我们来看看物理寄存器不足的情况会是什么样子。在这个例子中，我们有三个物理寄存器。</p><p><strong>在第1个时间段</strong>，物理寄存器是够用的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage0bd10b511374c86b9a14c1bec1d52c718cd1.7dcfff99.jpg" alt=""/></p><p><strong>在第2个时间段</strong>，变量d变得活跃，现在有4个活跃变量，所以必须选择一个溢出到内存。我们选择了a。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb8cfb81c0a71067d26f68f6902e26f1040cf.ebfb521e.jpg" alt=""/></p><p><strong>在第3个时间段</strong>，e和f变得活跃，现在又需要溢出一个变量才可以。这次选择了c。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3c883c6f242389253e6f5e9dc43f62a4fa88.b7bf45d9.jpg" alt=""/></p><p><strong>在第4个时间段</strong>，g也变得活跃，这次把d溢出了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagec664c6a906528d9d8331bb7de9b87163cc64.0db3ba3d.jpg" alt=""/></p><p>以上就是**线性扫描算法的思路：线性扫描整个代码，并给活跃变量分配寄存器。如果物理寄存器不足，那么就选择一个变量，溢出到内存中。**你看，是不是很简单？</p><p>在掌握了线性扫描算法的思路以后，我再给你补充一点信息：</p><ul><li>第一，线性扫描算法并不能获得寄存器分配的最优解。所谓最优解，是要让尽量多的操作在寄存器上实现，尽量少地访问内存。因为线性扫描算法并没有去确定一个最优值的目标，所以也就谈不上最优解。</li><li>第二，线性扫描算法可以采用一些策略，让一些使用频率低的变量被溢出，而像高频使用的循环中的变量，就保留在寄存器里。</li><li>第三，还有一些其他提升策略。比如，当存在多余的物理寄存器以后，还可以把之前已经溢出的变量重新复活到寄存器里。</li></ul><p>好了，上述就是线性扫描的寄存器分配算法。另外我们再来复习一下，在第8讲中，我还提到了另一个算法，是图染色算法，这个算法的优化效果更好，但是计算量比较大，会影响编译速度。</p><p>接下来，让我们再回到计算机语言设计的主线上，一起讨论一下编译器的后端与语言设计的关系。</p><h2 id="编译器后端与语言的设计"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#编译器后端与语言的设计"><span class="icon icon-link"></span></a>编译器后端与语言的设计</h2><p>编译器后端的目的，是要能够针对不同架构的硬件来生成目标代码，并尽量发挥硬件的能力。那么为了更好地支持语言的设计，在编译器后端的设计上，我们需要考虑到三个方面的因素。</p><ul><li><strong>平衡编译速度和优化效果</strong></li></ul><p>通常，我们都希望编译后的代码越优化越好。但是，在有些场景下，编译速度也很重要。比如像JVM这样需要即时编译的运行时环境，编译速度就比较重要。这可能就是Graal的指令选择算法和编译器分配算法都比较简单的原因吧。</p><p>Go语言一开始也把编译速度作为一个重要的设计考虑，所以它的后端算法也比较简单。我估计是因为Go语言的发起者（Robert Griesemer、Rob Pike和Ken Tompson）都具有C和C++的背景，甚至Ken Tompson还是C语言的联合发明人，他们都深受编译速度慢之苦。类似浏览器、操作系统这样比较大的软件，即使是用很多台机器做编译，还是需要编译很久。这可能也是他们为什么想让Go的编译速度很快的原因。</p><p>而Julia的设计目标是用于科学计算的，所以其使用场景主要就是计算密集型的。Julia采用了LLVM做后端，做了比较高强度的优化，即使会因此导致运行时由于JIT而引起短暂停顿。</p><ul><li><strong>确定所支持的硬件平台</strong></li></ul><p>确定了一门语言主要运行在什么平台上，那么首先就要支持该平台上的机器码。由于Go语言主要是用于写服务端程序的，而服务端采用的架构是有限的，所以Go语言支持的架构也是有限的。</p><p>硬件平台也影响算法的选择，比如现在很多CPU都支持指令的乱序执行，那你在实现编译器的时候就可以省略指令重排序（指令调度）功能。</p><ul><li><strong>设计后端DSL</strong></li></ul><p>虽然编译器后端要支持多种硬件，但我们其实会希望算法是通用的。所以，各个编译器通常会提供一种DSL，去描述硬件的特征，从而自动生成针对这种硬件的代码。</p><p>在Graal中，我们看到了与指令选择有关的注解，在Go的编译器中，我们也看到了对IR进行转换的DSL，而LLVM则提供了类似的机制。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>今天这一讲，我把后端的两个重要的算法拿出来给你单独介绍了一下，并一起讨论了后端技术策略与计算机语言的关系。你需要记住这几个知识点：</p><ul><li><strong>关于指令选择</strong>：从IR生成机器码（或LIR），通常是AST或DAG中的多个节点对应一条指令，所以你要找到一个最佳的组合，把整个AST或DAG覆盖住，并且要找到一个较优的或最优的解。其中，你还要熟悉贪婪算法和动态规划这两种不同的算法策略，这两种算法不仅仅会用于指令选择，还会用于多种场景。理解了这两种算法之后，就会给你的工具库添加两个重要的工具。</li><li><strong>关于寄存器分配</strong>：线性扫描算法比较简单。不过在一些技术点上我们去深入挖掘一下，其实会发现还挺有意思的。比如，当采用SSA格式的IR的时候，寄存器分配算法会有什么不同，等等。你可以参考看看文末我给出的资料。</li><li><strong>关于编译器后端的设计</strong>：我们要考虑编译速度和优化程度的平衡，要考虑都能支持哪些硬件。因为要支持多种硬件，通常要涉及后端的DSL，以便让算法尽量中立于具体的硬件架构。</li></ul><p>我把本讲的知识点也整理成了思维导图，供你复习和参考：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage829382c8e25b80368f16cfb2173b4f00a193.55b484ca.jpg" alt=""/></p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>动态规划算法是这节课的一个重要知识点。在学过了这个知识点以后，你能否发现它还可以被用于解决哪些问题？欢迎分享你的经验和看法。</p><h2 id="参考资料"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理实战/05.现代语言设计篇/04#参考资料"><span class="icon icon-link"></span></a>参考资料</h2><ul><li>对动态规划方法的理解，我建议你读一下<a target="_blank" rel="noopener noreferrer" href="https://cloud.tencent.com/developer/article/1475703">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，通俗易懂。</li><li>在《编译原理之美》的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/158315">第29讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有对寄存器分配算法中的图染色算法的介绍，你可以去参考一下。</li><li>这两篇关于线性扫描算法的经典论文，你可以去看一下：<a target="_blank" rel="noopener noreferrer" href="http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf">论文1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，<a target="_blank" rel="noopener noreferrer" href="https://dash.harvard.edu/bitstream/1/34325454/1/tr-21-97.pdf">论文2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>这篇文章介绍了针对<a target="_blank" rel="noopener noreferrer" href="http://cgo.org/cgo2010/talks/cgo10-ChristianWimmer.pdf">SSA格式的IR的线性扫描算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，值得一看。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理实战/05.现代语言设计篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
