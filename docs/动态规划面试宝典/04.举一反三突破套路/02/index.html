<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>12｜动态规划新问题2：攻破最大子数组问题 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/04.举一反三突破套路/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="不重叠的子数组之和" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#不重叠的子数组之和"><span>不重叠的子数组之和</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#算法问题分析"><span>算法问题分析</span></a></li><li title="分析写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#分析写出状态转移方程"><span>分析写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#编写代码进行求解"><span>编写代码进行求解</span></a></li><li title="最大子数组之积" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#最大子数组之积"><span>最大子数组之积</span></a></li><li title="分析并写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#分析并写出状态转移方程"><span>分析并写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#编写代码进行求解-1"><span>编写代码进行求解</span></a></li><li title="另一种求解方法" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#另一种求解方法"><span>另一种求解方法</span></a></li><li title="攻破子数组问题的解题模板" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#攻破子数组问题的解题模板"><span>攻破子数组问题的解题模板</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12动态规划新问题2攻破最大子数组问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#12动态规划新问题2攻破最大子数组问题"><span class="icon icon-link"></span></a>12｜动态规划新问题2：攻破最大子数组问题</h1><p>你好，我是卢誉声。</p><p>在“动态规划的套路”模块和上一课中，我们已经讨论了最典型的简单子数组问题，这其中包括：</p><ol><li>回文子串个数；</li><li>最大子数组之和；</li><li>最长连续递增序列。</li></ol><p>但是，在实际的技术面试环节，如果涉及到动态规划的子数组问题，那么面试官往往会根据经典问题，给出一些有所变化的问题。和上节课类似，为了能够熟练解决所有常见的子数组问题及其各类变化，在本课中，我将会为你讲解一些子数组问题的变种，作出问题的扩展，深挖该类型面试问题的解法。</p><p>最后，我还会给出攻破子数组的解题模板。由于是经验总结，因此在 90% 以上的情况下这个模板（套路）都是可行的，它足以应对你可能遇到的这类面试问题。</p><p>按照惯例，在开始今天的内容前，你可以关注一下：<strong>相较于简单的动归子数组问题（如“最长连续递增序列”问题），接下来的题目有何区别。有哪些东西是可以提取出来成为解题模板的？</strong></p><p>现在，就让我们带着这个关注点，来开始今天的学习吧。</p><h2 id="不重叠的子数组之和"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#不重叠的子数组之和"><span class="icon icon-link"></span></a>不重叠的子数组之和</h2><p>还记得什么是动态规划问题中的子数组问题吧！我先简单概括一下。所谓子数组模型，一般就是从一个序列中寻找满足条件的子数组或者相关的扩展。而这类问题的特点就是答案是连续的子串，而非上一课中的子序列。</p><p>对于子数组问题，你应该已经跨过了基本解题的门槛。现在，让我们先来看第一个“面试级别”的子数组问题——不重叠的子数组之和，先看一下问题描述。</p><p>问题：给定一个整数数组 $nums$ 和一个整数 $k$，找出 $k$ 个不重叠子数组使得它们的和最大。每个子数组的数字在数组中的位置应该是连续的。返回最大的和。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入: nums = [1, 2, 3, 4]，k = 1</span></div><div class="token-line"><span class="token plain">    输出: 10</span></div><div class="token-line"><span class="token plain">    解释: 1 + 2 + 3 + 4 = 10</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入: nums = [-1, 4, -2, 3, -2, 3]，k = 2</span></div><div class="token-line"><span class="token plain">    输出: 8</span></div><div class="token-line"><span class="token plain">    解释: 4 + (3 + -2 + 3) = 8</span></div></pre></div><h3 id="算法问题分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#算法问题分析"><span class="icon icon-link"></span></a>算法问题分析</h3><p>其实，这个问题相当于<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/292667">第8课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中“最大子数组之和”的威力加强版。在之前讲解的求最大子数组之和问题时，我们只需要简单地求出和最大的子数组；而这里需要求解的是，找出 $k$ 个不重叠的子数组，使得整体的和最大。因此，从思路上看这两个问题之间肯定存在某种关系。</p><p>首先，我们可以初步判断这个问题是一个最优化的问题，而且一定是满足重叠子问题、无后效性和最优子结构，我们就不在这里做具体分析了。希望你可以根据我们之前分析问题的方法，来分析一下该问题，看它是否符合动态规划问题的特征。</p><p>现在，我们直接开始讲到底如何使用动态规划来解决这个问题。</p><h3 id="分析写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#分析写出状态转移方程"><span class="icon icon-link"></span></a>分析写出状态转移方程</h3><p>解决动态规划问题早已成为套路，我们直接拿套路来解题吧！</p><p>第一步，分析<strong>初始化状态</strong>。首先，如果这个问题里，数组的长度 &lt; 子数组的数量 $k$。那么，由于数组无法被分解为 $k$ 个子数组（每个子数组要至少包含一个元素吧）。因此，这种情况是没有结果的。</p><p>而如果数组长度 = 子数组的数量 $k$。那么，在这种情况下，我们只能将整个数组分解为 $k$ 个子数组，其中每个元素单独组成一个子数组。此时，最大之和其实就是数组中所有元素之和。这就是我们的初始化状态，也就是边界条件。</p><p>第二步，我们来看一下<strong>状态参数</strong>。首先，我们要记住的是，**但凡是子数组问题，数组的索引肯定是我们的一个状态参数！**这是因为，我们需要不断移动数组的索引，在更小的数组的基础上求解出更大数组的解。</p><p>但是只有这个参数就足够了吗？恐怕还不够，因为我们还有另一个需要衡量的因素，就是子数组的数量 $k$。因此，我们可以先假定状态参数中包含：数组的索引 $i$ 和子数组的数量 $k$。</p><p>第三步，我们需要来看怎么定义状态存储（备忘录）$DP$ 的格式。在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/292667">第8课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>最大子数组之和问题中，我们曾定义了一个备忘录 $DP[i]$，表示以 $i$ 为结束位置的最大子数组之和。但在不重叠的子数组之和问题中，有两个状态参数，分别是数组的索引 $i$ 和子数组的数量 $k$。因此，这个类似的问题就需要定义一个数组 $DP[i][j]$ 表示将数组的前 $i$ 个元素划分为 $j$ 个子数组时的最优解。</p><p>这个时候我们需要再思考一下。对于原问题来说，其真正的最优解中最后一个子数组的最后一个元素，并不一定是 $i$ 这个元素，有这么几种情况：</p><ol><li>舍弃第 $i$ 个元素，将前 $i-1$ 个元素划分为 $j$个数组；</li><li>选取第 $i$ 个元素，将前 $i-1$ 个元素划分为 $j$ 个数组；而当前元素加入第 $j$ 个数组。在这种情况下有一个特殊要求，即第 $i-1$ 个元素必须在第 $j$ 个数组中，这样第 $i$ 个元素才能加入进去；否则，不连续的元素不能放在一个子数组中（我们在计算子数组问题，前提就是要“连续”）；</li><li>选取第 $i$ 个元素，将前 $i-1$ 个元素划分为 $j-1$ 个数组；而当前元素自己成为第 $j$ 个数组。</li></ol><p>我们需要特别注意上面的第二点，由于无法确保 $DP[i][j]$ 中的第 $i$ 个元素一定在第 $j$ 个数组中。因此，我们需要再定义一个备忘录 <strong>$M[i][j]$，表示将数组的前 $i$ 个元素划分为 $j$ 个子数组，并且第 i 个元素一定在第 j 个数组中时的最优解。</strong></p><p>对于整个求解过程，你可以参考以下<strong>计算方向</strong>示意图。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea02ca0e76ccfeca1ce37de52b180f80eb82c.b04aab14.png" alt=""/></p><p>从示意图中可以看出，这里有两个状态备忘录，分别是 $dp$（对应$DP[i][j]$）和 $m$（对应$M[i][j]$）。从这个案例可以看出，当动态规划问题稍微复杂一些的时候，我们会创建多个备忘录，而且备忘录之间的求解过程是相互关联的。</p><p>好了，万事俱备。有了以上分析之后，现在我们可以写出状态转移方程了。</p><p>$$DP[i][j]=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>DP[i-1][j-1]+nums[i] \ , i ==j \\\<br/>max(DP[i-1][j], M[i][j]) \ , i &gt; j<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>$$M[i][j]=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>M[i-1][j-1]+nums[i] \ , i == j \\\<br/>max(M[i-1][j], DP[i-1][j-1]) + nums[i] \ , i &gt; j<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>我们定义了两个状态转移方程，首先定义了 $DP[i][j]$ 的状态转移方程，然后定义了 $M[i][j]$ 的状态转移方程。这两个备忘录相互依赖、缺一不可。</p><h3 id="编写代码进行求解"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#编写代码进行求解"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>现在，我先给出该问题的算法求解代码，然后再做一些解释。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int maxSubArray(int[] nums, int k) {</span></div><div class="token-line"><span class="token plain">        int n = nums.length;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        int[][] m = new int[n+1][k+1];</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[n+1][k+1];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt;= n; i ++) { // 初始化状态</span></div><div class="token-line"><span class="token plain">            for (int j = 0; j &lt;= k; j ++) {</span></div><div class="token-line"><span class="token plain">                 m[i][j] = 0;</span></div><div class="token-line"><span class="token plain">                 dp[i][j] = 0;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt;= n; i++) { // 决策过程</span></div><div class="token-line"><span class="token plain">            for (int j = Math.min(i,  k); j &gt; 0; j--){</span></div><div class="token-line"><span class="token plain">                if(i == j){</span></div><div class="token-line"><span class="token plain">                    m[i][j] = m[i-1][j-1] + nums[i-1];</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + nums[i-1];</span></div><div class="token-line"><span class="token plain">                } else{</span></div><div class="token-line"><span class="token plain">                    m[i][j] = Math.max(m[i-1][j], dp[i-1][j-1]) + nums[i-1];</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = Math.max(dp[i-1][j], m[i][j]);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return dp[n][k]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int MaxSubArray(std::vector&lt;int&gt; nums, int k) {</span></div><div class="token-line"><span class="token plain">        int n = static_cast&lt;int&gt;(nums.size());</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        int m[n+1][k+1];</span></div><div class="token-line"><span class="token plain">        int dp[n+1][k+1];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt;= n; i ++) { // 初始化状态</span></div><div class="token-line"><span class="token plain">            for (int j = 0; j &lt;= k; j ++) {</span></div><div class="token-line"><span class="token plain">                m[i][j] = 0;</span></div><div class="token-line"><span class="token plain">                dp[i][j] = 0;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt;= n; i++) { // 决策过程</span></div><div class="token-line"><span class="token plain">            for (int j = min(i,  k); j &gt; 0; j--){</span></div><div class="token-line"><span class="token plain">                if(i == j){</span></div><div class="token-line"><span class="token plain">                    m[i][j] = m[i-1][j-1] + nums[i-1];</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + nums[i-1];</span></div><div class="token-line"><span class="token plain">                } else{</span></div><div class="token-line"><span class="token plain">                    m[i][j] = max(m[i-1][j], dp[i-1][j-1]) + nums[i-1];</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = max(dp[i-1][j], m[i][j]);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return dp[n][k]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在代码中，为了代码的统一，我定义的缓冲区长度是 (n+1) * (k+1)，这么做便于处理边界情况。接着，我们将所有备忘录的值都初始化为 0。</p><p>接下来，就开始循环操作即决策过程。这里需要注意的是，$j$ 是从最大到 0 倒推的。然后，在每次循环的时候，检查 $i$ 和 $j$ 的大小关系。由于 $j$ 的初始值是 $min(i, k)$，必然有 $j ≤ i$。所以，这里无需处理 $j &gt; i$ 的情况。</p><p>当 $i == j$ 时，说明子数组的数量等于整个数组的长度。因此，每个元素都是一个单独的数组，所以状态存储（备忘录） $dp$ 和 $m$ 的值都是 $i-1$ 个数的结果 ➕ 当前数字。</p><p>由于我们的备忘录长度是 $n+1$，循环开始的时候下标是 1。所以，这里需要用 $i-1$ 来从 $nums$ 数组中取对应的元素。细节是魔鬼！你一定要注意。</p><p>当 $i != j$ 时，通过 $m[i-1][j]$ 和 $dp[i-1][j-1]$ 得到前 $i-1$ 个数字的最优解。 然后，将当前数字放入子数组中，因此，需要再加上当前元素得到前 $n$ 个元素的最优解。而这个解是存放在 $m$ 数组中的。</p><p>最后，我们需要考虑前 $i$ 个数字的最优解是否会包含第 $i$ 个数字：</p><ol><li>如果包含，那么 $m[i][j]$ 就是前 $i$ 个数字的最优解；</li><li>如果不包含，那么 $dp[i-1][j]$ 就是前 $i$ 个数字的最优解。</li></ol><p>因此，这里我们用 $max$ 函数取了一下两者最大值，作为前 $i$ 个元素的最优解。</p><h2 id="最大子数组之积"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#最大子数组之积"><span class="icon icon-link"></span></a>最大子数组之积</h2><p>我们再来看一个问题，这个问题其实也“最大子数组之和”问题的一个变种。先看一下问题的具体描述。</p><p>问题：给定一个整数数组 $nums$（由正整数和负整数组成），请你找出数组中乘积最大的子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入: nums = [2, 8, -2, 4]</span></div><div class="token-line"><span class="token plain">    输出: 16</span></div><div class="token-line"><span class="token plain">    解释: 子数组 [2, 8] 有最大乘积 16。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入: nums = [-2, 0, -1]</span></div><div class="token-line"><span class="token plain">    输出: 0</span></div><div class="token-line"><span class="token plain">    解释: 结果只能为 0，不能为 2。因为 [-2,-1] 不是子数组，是子序列，它们不是连续的。</span></div></pre></div><h3 id="分析并写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#分析并写出状态转移方程"><span class="icon icon-link"></span></a>分析并写出状态转移方程</h3><p>这个问题的基本模型，与求最大子数组之和的问题非常类似，只不过将求和变成了求乘积。因此，我们可以初步判断这个问题是一个最优化的问题，而且一定是满足重叠子问题、无后效性和最优子结构的。</p><p>同样的，你可以自己根据我们之前分析问题的套路，来分析一下该问题是否满足使用动态规划求解的特征。</p><p>现在，我们直接用动归解题模板，来讲解该如何使用动态规划来解决这个问题，你可以关注一下该问题的求解与最大子数组之和的区别在哪里。</p><p>第一步，分析<strong>初始化状态</strong>。我们考察一下原问题中的边界条件，当数组索引为 0 的时候，这个时候 $dp[0] = nums[0]$。这是因为，当 $i = 0$ 时这个子数组只能包含数组的第 0 项。</p><p>第二步，确定<strong>状态参数</strong>。就像前面我说的那样：只要是子数组问题，数组的索引肯定是我们的一个状态参数。因为我们需要不断移动数组的索引，不断在原来的最大数组的基础上和当前第 $i$ 个元素相乘，在更小的数组的基础上求解出更大数组的解，因此数组的位置 $i$ 肯定是一个参数。</p><p>Hmmm… 看起来这个问题跟求最大子数组之和的问题没什么区别嘛。显然，这里有坑，问题没有表面上看起来那么容易。我们仔细思考一下，求乘积与求和不一样的地方是什么？<strong>如果某次乘上的数字是负数</strong>，那么得到的结果很有可能会从最大变成最小，或者从最小变成最大！</p><p>因此，我们需要考虑正负数的问题，创建两个 $DP$ 数组，作为存储状态以做状态转移，分别为 dp_max[n] 和 dp_min[n]。当迭代到当前的数字为负数时，需要对调 dp_max[i-1] 和 dp_min[i-1]，即 swap(dp_max[i-1], dp_min[i-1])。这是因为，当前这个负数 nums[i] 乘以上一个数后，最大的会变成最小的，而最小的会变成最大的。那么就在乘之前将它们俩对调。</p><p>这样一来，求乘积之后的结果就仍然是正确的：dp_max[i] 维护的仍然是当前最大值，dp_min[i] 维护的是当前最小值。</p><p>最后，由于原问题要求的是最大值。因此，每次迭代将 res 与 dp_max[i] 做比较，用 max 函数取最大值。最终，res 就是原问题所需的答案。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage9da99d1193621c5580208afe2eabf213cfa9.08e26829.png" alt=""/></p><p>以上状态转移图中，有一个现象值得关注。那就是在第三轮迭代时， dp_max[1] 和 dp_min[1] 的值做了交换。</p><p>这是因为 nums[2] 对应的数字 -2 为负数，因此在迭代前做了数字的交换。当前这个负数乘以上一个数后，最大的会变成最小的，而最小的会变成最大的。那么就在乘之前将它们俩对调。</p><p>$$DP_<!-- -->{<!-- -->max<!-- -->}<!-- -->[i] = max \<!-- -->{<!-- --> nums[i], \ DP_<!-- -->{<!-- -->max<!-- -->}<!-- -->[i-1] * nums[i] \<!-- -->}<!-- -->$$</p><h3 id="编写代码进行求解-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#编写代码进行求解-1"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>这个问题最后的状态转移比较简单，我直接给出求解代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int getMaxProduct(int[] nums) {</span></div><div class="token-line"><span class="token plain">    	int n = nums.length; if (0 == n) { return 0; }</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	int[] dp_max = new int[n]; Arrays.fill(dp_max, 0);</span></div><div class="token-line"><span class="token plain">    	int[] dp_min = new int[n]; Arrays.fill(dp_min, 0);</span></div><div class="token-line"><span class="token plain">    	</span></div><div class="token-line"><span class="token plain">    	dp_max[0] = nums[0]; // 初始化状态</span></div><div class="token-line"><span class="token plain">    	dp_min[0] = nums[0];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	int res = nums[0];</span></div><div class="token-line"><span class="token plain">    	for (int i = 1; i &lt; n; i++) { // 决策过程</span></div><div class="token-line"><span class="token plain">    		if (nums[i] &lt; 0) {</span></div><div class="token-line"><span class="token plain">    			int temp = dp_max[i-1];</span></div><div class="token-line"><span class="token plain">    			dp_max[i-1] = dp_min[i-1];</span></div><div class="token-line"><span class="token plain">    			dp_min[i-1] = temp;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		dp_max[i] = Math.max(nums[i], dp_max[i-1] * nums[i]);</span></div><div class="token-line"><span class="token plain">    		dp_min[i] = Math.min(nums[i], dp_min[i-1] * nums[i]);</span></div><div class="token-line"><span class="token plain">    		res = Math.max(res, dp_max[i]);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return res; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetMaxProduct(std::vector&lt;int&gt;&amp; nums) {</span></div><div class="token-line"><span class="token plain">    	int n = static_cast&lt;int&gt;(nums.size()); if (0 == n) { return 0; }</span></div><div class="token-line"><span class="token plain">    	int dp_max[n], dp_min[n];</span></div><div class="token-line"><span class="token plain">    	memset(dp_max, 0, sizeof(dp_max));</span></div><div class="token-line"><span class="token plain">    	memset(dp_min, 0, sizeof(dp_min));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	dp_max[0] = nums[0]; // 初始化状态</span></div><div class="token-line"><span class="token plain">    	dp_min[0] = nums[0];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	int res = nums[0];</span></div><div class="token-line"><span class="token plain">    	for (int i = 1; i &lt; n; i++) { // 决策过程</span></div><div class="token-line"><span class="token plain">    		if (nums[i] &lt; 0) { std::swap(dp_max[i-1], dp_min[i-1]); }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		dp_max[i] = max(nums[i], dp_max[i-1] * nums[i]);</span></div><div class="token-line"><span class="token plain">    		dp_min[i] = min(nums[i], dp_min[i-1] * nums[i]);</span></div><div class="token-line"><span class="token plain">    		res = max(res, dp_max[i]);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return res; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="另一种求解方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#另一种求解方法"><span class="icon icon-link"></span></a>另一种求解方法</h3><p>在上面的方法中，我们充分利用了原问题的特点，用了一个“交换”的技巧实现了问题的求解。但事实上，这个问题还能用别的方法求解，也就是更加贴近于解题模板的方法。接下来，我们就来看看重新设计备忘录后的另一种解法。</p><p>现在按照套路来解决这个动态规划问题。</p><p>首先，这种解法的<strong>初始化状态</strong>和<strong>状态参数</strong>跟上面的解法完全相同。我们从“负数”这个问题开始重新进行分析。</p><p>我们需要仔细思考一下，求乘积和求和不一样的地方是，<strong>如果某次乘上的数字是负数</strong>，那么得到的结果很有可能会从最大变成最小，或者从最小变成最大！</p><p>因此我们需要考虑，如果第 $i$ 个数字为负数，而到第 $i-1$ 个位置的最小值也是负数，那么相乘之后很有可能变成最大值。所以我们的状态参数还要加上一个 $j$（1 或 2），<strong>$DP[i][0]$ 表示数组前 $i$ 个元素的最大乘积，$DP[i][1]$ 表示数组前 $i$ 个元素的最小乘积</strong>。</p><p>接着，我们需要来看怎么定义状态转移方程和备忘录的格式。根据我们的状态参数，我们的备忘录 $DP[i][j]$ 是一个二维数组。其中 $j$ 的维度是 2，$DP[i][0]$ 表示数组前 $i$ 个元素的最大乘积；$DP[i][1]$ 表示数组前 $i$ 个元素的最小乘积。</p><p>在这种情况下，$DP[i][0]$ 可能有下面三种情况：</p><ol><li>结果为 $nums[i]$ 自身，不和其它元素相乘；</li><li>正数，则要乘以 $DP[i-1][0]$，也就是前 $i-1$ 个元素的乘积最大值，这样才能得到<strong>最大值</strong>；</li><li>负数，则要乘以 $DP[i-1][1]$，也就是前 $i-1$ 个元素的乘积最小值，这样才能得到<strong>最大值</strong>。</li></ol><p>最后，从这三个值中取最大值即可。同理，$DP[i][1]$ 也可能有三种情况：</p><ol><li>结果为 $nums[i]$ 自身，不和其它元素相乘；</li><li>正数，肯定要乘以 $DP[i-1][1]$，也就是前 $i-1$ 个元素的乘积最小值，这样才能得到<strong>最小值；</strong></li><li>负数，肯定要乘以 $dp[i-1][0]$，也就是前 $i-1$ 个元素的乘积最大值，这样才能得到<strong>最小值。</strong></li></ol><p>最后，从这三个值中取最小值即可。整个状态转移过程就如下图所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage1b5d1b93a244d66e3013308ced57c0d9db5d.800105eb.png" alt=""/></p><p>从图中可以看到，$DP[3][0]$ 需要根据 $DP[2][0] * nums[3]$、$DP[2][1] * nums[3]$ 和 $nums[3]$ 综合判定，最后取最大值。</p><p>基于以上分析，我们就可以写出状态转移方程了。</p><p>$$DP[i][j]=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>max(dp[i−1][0]∗nums[i],dp[i−1][1]∗nums[i],nums[i]) \ , j = 0 \\\<br/>min(dp[i−1][0]∗nums[i],dp[i−1][1]∗nums[i],nums[i]) \ , j = 1 \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>从这个解法和状态转移方程，我们可以看出，其实我们在状态存储（备忘录）上多创建了一个维度来记录下来数字是正数还是负数。本质上，跟前一种解法的思路是相同的，只不过具体求解方法不同。希望你在求解动归问题的时候，通过练习实现灵活运用。</p><p>按照惯例，下面给出第二种解法的算法求解代码，然后稍作解释。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public int getMaxProduct(int[] nums) {</span></div><div class="token-line"><span class="token plain">        int n = nums.length;</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[n][2];</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i ++) { // 初始化状态</span></div><div class="token-line"><span class="token plain">            dp[i][0] = nums[i];</span></div><div class="token-line"><span class="token plain">            dp[i][1] = nums[i];</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i ++) { // 决策求解</span></div><div class="token-line"><span class="token plain">            dp[i][0] = Math.max(dp[i - 1][0] * nums[i], Math.max(nums[i], dp[i - 1][1] * nums[i]));</span></div><div class="token-line"><span class="token plain">            dp[i][1] = Math.min(dp[i - 1][1] * nums[i], Math.min(nums[i], dp[i - 1][0] * nums[i]));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        int ans = dp[0][0];</span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i ++) { ans = Math.max(ans, dp[i][0]); }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return ans; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetMaxProduct(vector&lt;int&gt; nums) {</span></div><div class="token-line"><span class="token plain">        int n = static_cast&lt;int&gt;(nums.size());</span></div><div class="token-line"><span class="token plain">        int dp[n][2];</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i ++) { // 初始化状态</span></div><div class="token-line"><span class="token plain">            dp[i][0] = nums[i];</span></div><div class="token-line"><span class="token plain">            dp[i][1] = nums[i];</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i ++) { // 决策求解</span></div><div class="token-line"><span class="token plain">            dp[i][0] = max(dp[i-1][0] * nums[i], max(nums[i], dp[i-1][1] * nums[i]));</span></div><div class="token-line"><span class="token plain">            dp[i][1] = min(dp[i-1][1] * nums[i], min(nums[i], dp[i-1][0] * nums[i]));</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        int ans = dp[0][0];</span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i ++) { ans = max(ans, dp[i][0]); }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return ans; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上代码中，我们首先创建了一个二维数组作为该动态规划解法的备忘录。然后，把最大值数组和最小值数组的各个位置赋予初值，也就是第 $i$ 个元素，处理边界情况。</p><p>接下来，执行循环。我们每次都会处理最小值数组和最大值数组，求以 $i$ 结尾的数组的最小乘积和最大乘积。最后，从所有的最大乘积中返回最大值。</p><h2 id="攻破子数组问题的解题模板"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#攻破子数组问题的解题模板"><span class="icon icon-link"></span></a>攻破子数组问题的解题模板</h2><p>一般人会说，子数组问题并没有一个统一的模板，很多问题还是需要具体问题具体分析。但是，我们已经做过这么多题目了，其实已经隐约发现了其中的套路。</p><p>首先，所有动态规划领域中的子数组问题，基本都需要遍历原来的数组，使用数组元素下标作为子问题的<strong>状态参数</strong>。除此之外，在更复杂的问题中，我们可能还会使用更多的状态参数。一般来说，如果不考虑空间复杂度优化，那么一般有几个状态参数，备忘录就要用几维数组。</p><p>举个例子，如果只有数组元素的下标作为状态参数，那么我们只需要使用<strong>一维数组 $DP[i]$</strong> 作为备忘录；如果除了数组元素下标，还需要第二个状态参数 $j$（假设有这么一个参数），那么就需要使用<strong>二维数组 $DP[i][j]$</strong> 作为备忘录；如果再不济碰到三个参数（技术面试一般不会到这个程度）就需要三维数组 … 以此类推。</p><p>按照解题套路，确定了初始化状态、状态参数，就需要写出状态转移方程，也就是决策代码，基本模板如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int Solution(std::vector&lt;int&gt;&amp; nums) {</span></div><div class="token-line"><span class="token plain">      int n = nums.size(); if (n == 0) { return 0; }</span></div><div class="token-line"><span class="token plain">      int dp[n]; </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 请你注意，这里需要根据具体问题，做初始化状态</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; n; i ++) {</span></div><div class="token-line"><span class="token plain">        initialize(dp, i);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 状态转移与决策</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; n; i++) { // 决策   </span></div><div class="token-line"><span class="token plain">        dp[i] = 最值函数(dp[i], dp[i - 1] + ...);     </span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return get_result(dp);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最值函数指的是像 $min$、 $max$ 这样的求最值函数。在复杂的问题中，这个最值函数也会变得非常复杂，一般如果有一个状态参数就需要一层循环，有两个状态参数就需要两层循环。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>动态规划中的子数组问题看起来比较类似，但其实很多题目需要我们举一反三、灵活处理。当然这些问题都脱离不开本课结尾提到的解题模板。</p><p>解决这些问题的关键在于分析出除了数组索引之外还存在什么状态参数，一旦能够找到合适的状态参数，所有的子数组问题就迎刃而解了。所以我们需要多做练习，才能熟练解决类似的子数组问题。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>在本课中，我讲解了如何处理乘积最大子数组问题。但其实这个问题无论是时间复杂度还是空间复杂度都有可以提升的空间，请思考一下如何降低这个问题的时间复杂度和空间复杂度，并给出解决方案。</p><p>欢迎留言和我分享你的想法，我们一同交流！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/04.举一反三突破套路/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
