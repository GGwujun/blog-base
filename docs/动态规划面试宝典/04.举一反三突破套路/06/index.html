<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>16｜课程回顾与总结（下） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/04.举一反三突破套路/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="经典的动态规划问题" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#经典的动态规划问题"><span>经典的动态规划问题</span></a></li><li title="1. 背包问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#1-背包问题"><span>1. 背包问题</span></a></li><li title="2. 路径问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#2-路径问题"><span>2. 路径问题</span></a></li><li title="3. 跳跃游戏" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#3-跳跃游戏"><span>3. 跳跃游戏</span></a></li><li title="4. 其它问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#4-其它问题"><span>4. 其它问题</span></a></li><li title="动态规划的优化" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#动态规划的优化"><span>动态规划的优化</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="16课程回顾与总结下"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#16课程回顾与总结下"><span class="icon icon-link"></span></a>16｜课程回顾与总结（下）</h1><p>你好，我是卢誉声。今天我们来继续课程总结，重点回顾几类经典的动态规划问题，并尝试使用我们的解题框架去解决它们。这几类问题我们前面都详细讲过，再带你巩固一遍。</p><h2 id="经典的动态规划问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#经典的动态规划问题"><span class="icon icon-link"></span></a>经典的动态规划问题</h2><p>动态规划的问题主要分为三类：</p><ol><li>求最优解（最大值和最小值）：从一系列方案中寻找最优解决方案；</li><li>求方案总数：计算满足要求的解决方案的数量；</li><li>求可行性（True或False）：确定提出的问题是否存在可行方案。</li></ol><p>下面我们分别来看看这几类问题的代表性问题。</p><h3 id="1-背包问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#1-背包问题"><span class="icon icon-link"></span></a>1. 背包问题</h3><p>首先我们来看下背包问题，背包问题是一类非常经典的最优化问题，一般都是希望得到背包可以容纳的最大物品价值，是<strong>求最优解</strong>的问题代表。</p><p>背包问题有很多类，常见的背包问题有<strong>0-1背包</strong>、<strong>完全背包</strong>、<strong>多重背包</strong>等，再多就是在这些问题上的变种和延伸。但是无论是什么问题，基本都逃不过一个标准的题目描述模板。</p><p>问题：给你一个可放总重量为 W 的背包和 N 个物品，对每个物品，有重量 w 、价值 v 和数量3个属性，那么第 i 个物品的重量为 w[i]，价值为 v[i]，数量为k[i]（k≥1）。现在让你用这个背包装物品，问这个背包最多能装的价值是多少？</p><p>让我们来将几类背包问题对号入座，套入这个模板里面。</p><p>首先是<strong>0-1背包</strong>，所谓0-1背包就是每个物品最多只能选择1个，所以要不选择 0 个，要不选择 1 个，因此我们称之为0-1背包。所以0-1背包也就是说所有物品的数量 k[i] 都为 1。</p><p>接着是<strong>完全背包</strong>，所谓完全背包就是每个物品的数量都是无限的，这种情况下我们可以认为物品的数量 k[i] 都是正无穷，或者认为 k[i] 最大值为 W/w[i]，其中 W 是背包的容量，w[i] 是物品的重量，背包里的物品数量是不可能大于 W/w[i] 的。</p><p>最后就是<strong>多重背包</strong>，所谓多重背包就是给予每个物品固定的数量，也就是指定了 k[i]。这也就是问题模板本身。</p><p>所以无论是0-1背包还是完全背包，其实都是<strong>多重背包的特例</strong>，只要我们知道背包问题的模板是什么样子，然后就可以知道解决所有背包问题的套路。</p><p>下面我们根据动态规划解题框架来给出背包问题的解题框架。</p><p>首先，我们确定<strong>初始化状态</strong>。当背包的容量为 0 时肯定无法选择物品，此时物品数量为 0，同时如果压根儿就没有物品可选，那么自然背包的重量也为 0。也就是当没有物品时重量为 0；而重量为 0 时显然物品数量也为 0。</p><p>接着，我们确定<strong>状态参数</strong>，也就是会影响我们进行决策的变量：</p><ul><li>背包内物品的数量 N 在增加，它是一个变量；</li><li>同时，背包还能装下的重量 W 在减少，它也是一个变量。</li></ul><p>因此，当前背包内的物品数量 N 和背包还能装下的重量 W 就是这个动态规划问题的状态参数。</p><p>然后，我们再来看如何进行<strong>决策</strong>。这里的区别，由于每种物品的数量为k[i]，因此我们可以将同一种物品多次放入背包。</p><p>因此，对于第 tn 种物品，我们有 k 种选择（其中 0 ≤ k[tn] * w[tn] ≤ W）：我们可以从 0 开始，拿第 0 件、第 1 件、第 2 件……直到第 (W / w[tn]) 件物品为止。然后在这么多子问题下，选择最优的那一种情况。</p><p>所以，我们可以看出，背包问题决策的核心在于，针对一种物品，它需要考察拿不同数量的情况下的最优解。也就是针对当前物品，应放入多少件当前物品，价值最大。</p><p>最后，动态规划是需要一个<strong>备忘录</strong>来加速算法的。由于有两个状态参数，因此我们考虑使用二维数组来存储子问题的答案。跟之前一样，为了通用起见，我将其命名为 DP[tn][rw]，它的含义是：背包容量还剩 rw 时，放入前 tn 种物品时的最大价值。</p><p>现在，我们根据解题分析写出通用的背包状态转移方程。它是这样的：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, tn&lt;=0\\\<br/>0, rw&lt;=0\\\<br/>DP(tn-1,rw), rw&lt;w[tn]\\\<br/>max\<!-- -->{<!-- --> DP(tn-1,rw-k*w[tn])+k*v[tn] \<!-- -->}<!-- -->,(0\leqq k \leqq min(k[tn], rw/w[tn]))<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>我们对号入座，根据这个通用的状态转移方程来看看0-1背包和完全背包的状态转移方程。</p><p>首先是0-1背包，在0-1背包中 k[tn] 固定为 1，因此如果将 k[tn] 替换为 1，方程可以简化为：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, tn&lt;=0\\\<br/>0, rw&lt;=0\\\<br/>DP(tn-1,rw), rw&lt;w[tn]\\\<br/>max\<!-- -->{<!-- --> DP(tn-1,rw-k*w[tn])+k*v[tn] \<!-- -->}<!-- -->,(0\leqq k \leqq min(1, rw/w[tn])) \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>同时，由于 k 其实只有两种取值，一种是 0，一种是 1。如果 k 为 0，表示不放入该物品，因此 DP(tn,rw) 的结果为 DP(tn-1,rw)，如果 k 为 1，表示放入该物品，因此 DP(tn,rw) 的结果为DP(tn-1, rw-w[tn])+v[tn]，我们需要从中取最大值，因此 DP(tn,rw) 的最终结果就是两者最大值，所以最后方程可以被简化成如下所示：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, &amp; tn&lt;=0\\\<br/>0, &amp; rw&lt;=0\\\<br/>DP(tn-1,rw), &amp; rw&lt;w[tn]\\\<br/>max(DP(tn-1,rw-w[tn])+v[tn], DP(tn-1, rw)), &amp; otherwise \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>接下来是完全背包问题。完全背包问题中只不过将k[i]变成了无穷大，对整个方程并没有什么其它影响，因此我们可以直接将状态转移方程改写为：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, tn&lt;=0\\\<br/>0, rw&lt;=0\\\<br/>DP(tn-1,rw), rw&lt;w[tn]\\\<br/>max\<!-- -->{<!-- --> DP(tn-1,rw-k*w[tn])+k*v[tn] \<!-- -->}<!-- -->,(0\leqq k \leqq rw/w[tn])<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>这里只是将方程中k的最大值调整为 rw/w[tn]，这是因为每个物品有无穷多个，所以到底最多能放下多少物品取决于背包的剩余重量除以物品重量。背包的模板代码如下所示。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bag(int[] w, int[] v, int[] k, int N, int W) {</span></div><div class="token-line"><span class="token plain">      // 创建备忘录</span></div><div class="token-line"><span class="token plain">      int[][] dp = new int[N+1][W+1];</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 初始化状态</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }</span></div><div class="token-line"><span class="token plain">      for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 遍历每一件物品</span></div><div class="token-line"><span class="token plain">      for (int tn = 1; tn &lt; N + 1; tn++) { </span></div><div class="token-line"><span class="token plain">        // 背包容量有多大就还要计算多少次</span></div><div class="token-line"><span class="token plain">        for (int rw = 1; rw &lt; W + 1; rw++) { </span></div><div class="token-line"><span class="token plain">          dp[tn][rw] = dp[tn-1][rw];</span></div><div class="token-line"><span class="token plain">          int maxK = Math.min(k[tn], rw / w[tn]);</span></div><div class="token-line"><span class="token plain">          // 根据rw尝试放入多次物品，从中找出最大值，作为当前子问题的最优解</span></div><div class="token-line"><span class="token plain">          for (int k = 0; k &lt;= maxK; k++) {</span></div><div class="token-line"><span class="token plain">            dp[tn][rw] = Math.max(dp[tn][rw], dp[tn-1][rw-k*w[tn]] + k*v[tn]);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return dp[N][W];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int DP(const std::vector&lt;int&gt;&amp; w, const std::vector&lt;int&gt;&amp; v, const std::vector&lt;int&gt;&amp; k, int N, int W) {</span></div><div class="token-line"><span class="token plain">      int dp[N+1][W+1]; // 创建备忘录</span></div><div class="token-line"><span class="token plain">      memset(dp, 0, sizeof(dp)); </span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 初始化状态</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }</span></div><div class="token-line"><span class="token plain">      for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 遍历每一件物品</span></div><div class="token-line"><span class="token plain">      for (int tn = 1; tn &lt; N + 1; tn++) { </span></div><div class="token-line"><span class="token plain">        // 背包容量有多大就还要计算多少次</span></div><div class="token-line"><span class="token plain">        for (int rw = 1; rw &lt; W + 1; rw++) { </span></div><div class="token-line"><span class="token plain">          dp[tn][rw] = dp[tn-1][rw];</span></div><div class="token-line"><span class="token plain">          int maxK = min(k[tn], rw / w[tn]);</span></div><div class="token-line"><span class="token plain">          // 根据rw尝试放入多次物品，从中找出最大值，作为当前子问题的最优解</span></div><div class="token-line"><span class="token plain">          for (int k = 0; k &lt;= maxK; k++) {</span></div><div class="token-line"><span class="token plain">            dp[tn][rw] = max(dp[tn][rw], dp[tn-1][rw-k*w[tn]] + k*v[tn]);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return dp[N][W];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>至于如何通过这个模板得到0-1背包和完全背包代码，就要看你能不能理解整个模板的思路，举一反三自己写出实际的代码了。</p><h3 id="2-路径问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#2-路径问题"><span class="icon icon-link"></span></a>2. 路径问题</h3><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/293536">第10课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中介绍的路径问题是求解总方案数量的经典代表问题。我们回顾一下这个问题的内容和描述。</p><p>问题：一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“开始” ），机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角（在下图中标记为“结束”）。问总共有多少条不同的路径？</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89%E7%AA%81%E7%A0%B4%E5%A5%97%E8%B7%AF/resourceimagefe7dfebf34cda01dc250ce99796855f0a87d.png" alt=""/></p><p>上图是一个7 * 3的网格，我们希望知道从起点到终点能有多少条不同的路径。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：m = 3, n = 2</span></div><div class="token-line"><span class="token plain">    输出： 3 </span></div><div class="token-line"><span class="token plain">    解释: 从左上角开始，总共有 3 条路径可以到达右下角：</span></div><div class="token-line"><span class="token plain">    1. 向右 -&gt; 向右 -&gt; 向下</span></div><div class="token-line"><span class="token plain">    2. 向右 -&gt; 向下 -&gt; 向右</span></div><div class="token-line"><span class="token plain">    3. 向下 -&gt; 向右 -&gt; 向右</span></div></pre></div><p>首先确定<strong>初始化状态</strong>。从原问题可以看出，初始化状态是网格的第一行和第一列。网格的第一行永远只能从左侧的格子往前走，第一列永远只能从上方的格子向下走。由于我们只能向右或向下走，因此，第一行和第一列的格子永远只能存在 1 条路径。</p><p>接着确定<strong>状态参数</strong>。原问题的状态参数其实就是格子的行数和列数，只要知道行数 i 和列数 j 就能知道这个格子的路径数量。因此，我们得到两个状态参数，分别是代表行数的 i 和代表列数的 j。</p><p>然后就要进行<strong>状态存储</strong>。这里我们的状态存储空间是一个二维数组 <strong>DP[i][j]，表示第 i 行、第 j 列的路径数量</strong>。你可以通过以下图示加深理解。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/04.%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89%E7%AA%81%E7%A0%B4%E5%A5%97%E8%B7%AF/resourceimage9c4d9c29ce7cd99036b2d1960c46ba5d064d.png" alt=""/></p><p>从表格中我们可以看出，第一行和第一列是格子的序号。其中填写了 1 的格子，就是初始状态，深色的格子就是DP[i][j]，表示第 i 行、第 j 列的路径数量。我们可以计算一下，这个格子的路径数量是 DP[i-1][j] + DP[i][j-1]。</p><p>现在一切就绪，我们来写<strong>状态转移方程</strong>。</p><p>$$DP(i, j)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>DP[i-1][j] + DP[i][j-1], &amp; if \ i\ne0\ or\ j\ne0 \\\<br/>1, &amp; i=0\ and\ j=0<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>这个状态转移方程由初始状态和后续的状态转移构成。当 i 和 j 为 0 时（假定格子从 0 开始而不是 1 开始），函数结果就是 1；否则，就是 DP[i- 1][j] + DP[i][j-1]。</p><p>现在可以根据状态转移方程写出代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getPathCount(int m, int n) {</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[m][n];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; } </span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetPathCount(int m, int n) {</span></div><div class="token-line"><span class="token plain">        int dp[m][n];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; }</span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/293536">第10课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我还提到了考虑障碍物的路径规划问题，大家可以去回顾一下，和不带障碍物的问题的解决方案其实没有本质区别。</p><h3 id="3-跳跃游戏"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#3-跳跃游戏"><span class="icon icon-link"></span></a>3. 跳跃游戏</h3><p>前面我们回顾了最优解和方案总数的代表性问题，现在我们再回顾一下可行性问题（True或False）。这类问题其实一般涵盖在第一类和第二类的问题解决思路中，我们完全可以通过问题的转化，将其它类型的问题转化成求可行性问题。</p><p>现在我们看一下学习过的代表性问题——跳跃游戏。</p><p>题目：给出一个非负整数数组 A，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。判断你是否能到达数组的最后一个位置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：A = [2, 3, 1, 1, 6]</span></div><div class="token-line"><span class="token plain">    输出： True</span></div><div class="token-line"><span class="token plain">    解释: 我们可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span></div></pre></div><p>首先确定<strong>初始化状态</strong>。这个问题的初始化状态就是 0 这个位置。因为这个位置是出发点，因此肯定可以到达，所以我们可以将其初始化成 True。而对其它位置，则可以根据状态转移方程来计算得出。</p><p>接着确定<strong>状态参数</strong>，只有数组的位置是变化的，因此状态参数就是当前位置 i。</p><p>然后是状态存储，由于只有一个状态参数，因此我们可以使用一维数组 <strong>DP[i] 来表示能否从出发点到达位置 i</strong>。</p><p>最后确定<strong>状态转移与决策</strong>。如果我们想要知道能否到达位置 i，就需要逐个看前面的位置，判定能否从位置 i-1、i-2、i-3 ... 跳到位置 i 上。然后，再看 i-1 这个位置是否能够到达。</p><p>通过以上分析，我们就可以给出状态转移方程的定义了。</p><p>$$DP[i]=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>True, &amp; i = 0 \\\<br/>(DP[j] = true)\ and\ (max(A[j]+j) \geq i), &amp; i \ne 0\ and\ j &lt; i \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>代码如下所示，具体代码以及解释可以参见<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/293536">第10课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public boolean canJump(int[] nums) {</span></div><div class="token-line"><span class="token plain">        int n = nums.length;</span></div><div class="token-line"><span class="token plain">        if (n &lt;= 1) { return true; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        boolean[] dp = new boolean[n];</span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i++) { dp[i] = false; }</span></div><div class="token-line"><span class="token plain">        dp[0] = true;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span></div><div class="token-line"><span class="token plain">            for (int j = 0; j &lt; i; j++) { // j &lt; i</span></div><div class="token-line"><span class="token plain">                if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {</span></div><div class="token-line"><span class="token plain">                    dp[i] = true;</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bool canJump(vector&lt;int&gt;&amp; nums) {</span></div><div class="token-line"><span class="token plain">          int n = nums.size();</span></div><div class="token-line"><span class="token plain">          if (n &lt;= 1) { return true; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          bool dp[n]; memset(dp, 0, sizeof(dp));</span></div><div class="token-line"><span class="token plain">          dp[0] = true; // 初始化状态</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          for (int i = 1; i &lt; n; i++) {</span></div><div class="token-line"><span class="token plain">              for (int j = 0; j &lt; i; j++) { // j &lt; i</span></div><div class="token-line"><span class="token plain">                  if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {</span></div><div class="token-line"><span class="token plain">                      dp[i] = true;</span></div><div class="token-line"><span class="token plain">                      break;</span></div><div class="token-line"><span class="token plain">                  }</span></div><div class="token-line"><span class="token plain">              }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          return dp[n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="4-其它问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#4-其它问题"><span class="icon icon-link"></span></a>4. 其它问题</h3><p>除了上面提到的几类代表性问题，还有两类问题是需要你重点关注的，分别是子数组问题和子序列问题。</p><p>所谓子数组问题，就是从一个数组中寻找满足条件，并可以得到最优结果的一个最长的子数组序列的问题，子数组序列一定是求一个连续的序列。</p><p>而子序列问题要更复杂一些，因为子数组问题是连续的，而子序列问题是不连续的。比如说字符串 &quot;I wanna keep a giraffe in my backyard&quot; 的一种子序列就可以是 &quot;Igbackd&quot;。因此子序列问题往往比子数组问题更加难以找到头绪。</p><p>关于子数组问题我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/292667">第8课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/295396">第12课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>有非常详细的讲解，子序列问题我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/293232">第9课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/294300">第11课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中做了详细的陈述，希望你可以重点学习一下这几节课的内容，牢固掌握这些常见的动态规划题型。</p><p>剩下还有各种各样的动态规划问题就需要大家自己在各类 OJ（Online Judge）网站上多多练习，然后积累经验，让自己可以更加熟练地解决面试中可能出现的动态规划问题了。</p><h2 id="动态规划的优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#动态规划的优化"><span class="icon icon-link"></span></a>动态规划的优化</h2><p>我们现在回归并总结一下动态规划的优化问题。</p><p>动态规划的最终目的是降低问题解决方案的时间复杂度，动态规划在缩小问题规模的同时，通过备忘录记录已经求解过的子问题的解，利用备忘录避免对同一个子问题的重复计算，从而减少了冗余。但动态规划往往仍然存在冗余。主要包括求解无用的子问题，对结果无意义的引用等等。</p><p>根据动态规划的状态转移方程分析套路，动态规划的时间复杂度受到三个因素影响：</p><ul><li>状态总数；</li><li>每个状态转移的状态数；</li><li>每次状态转移的时间。</li></ul><p>时间复杂度 = 状态总数 * 每个状态转移的状态数 * 每次状态转移的时间。</p><p>因此，我们通常就会通过减少状态总数、减少每个状态转移的状态数或者减少每次状态转移的时间，来进一步优化动态规划的时间复杂度。</p><p>另一方面，我们知道动态规划是一种利用空间换取时间的方法，所以对空间复杂度的优化也是重中之重。影响空间复杂度的因素主要包括状态总数和每个状态需要存储的数据数量。因此我们一般会从状态总数和存储数据数量这两方面进行优化。</p><p>这里我们会发现，如果我们能够减少状态总数，一般可以同时减少时间复杂度和空间复杂度，就可以一箭双雕，这就是我们常说的状态压缩。因此我们在初步解决一个问题后会进一步分析问题的状态参数是否冗余，一旦有冗余就需要进行处理，最后得到比较低的时间复杂度和空间复杂度。</p><p>除了这些方法，还有一些常用的技巧会用在空间复杂度优化上，比如常见的就是滚动数组，简而言之，一个问题求解的时候可能只会依赖于其前 k 个子问题，这种情况下我们的备忘录就只需要永远保留 k+1 项的结果，然后通过滚动数组的方式利用备忘录。我们在做很多问题优化的时候都使用了这种技巧，你可以回顾一下。</p><p>但是无论如何，动态规划的优化是比写出基础的动态规划方程更难的能力，因此需要大家做每一道动态规划题目的时候都尽量去思考问题是否适用于动态规划，是否有多余的状态参数，状态存储空间是否能压缩等等，只有遇到过更多的问题，积累了更多经验，才能在面试中游刃有余。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>动态规划思想是如今技术面试当中特别爱考察的一类重要问题，它出现在技术面中的比重与日俱增。因此，我们有必要有针对性地攻破这一难关，特别是系统的经验总结，外加适当强度的练习。</p><p>我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/296625">第14课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>总结了刷题指南，希望你能够沿着本专栏的整体思路，去尝试解决那些问题。你最终一定会发现，所有的问题都能够追溯到我为你总结的解题模板上去。刷题的目的在于灵活运用动归解题模板，养成解题思路和习惯，那么你的目标、我的目标，就都达成了。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>除了我今天为你勾勒出的动态规划知识点总结外，你觉得还有什么知识点是值得关注的？不妨谈谈你的心得体会。</p><p>期待你的留言。如果今天的内容对你有所帮助，也欢迎把文章分享给你身边的朋友，邀请他一起练习！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/04.举一反三突破套路/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:07:52</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
