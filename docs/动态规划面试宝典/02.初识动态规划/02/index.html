<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>02 | 暴力递归：当贪心失效了怎么办？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/02.初识动态规划/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="从最优化问题到递归" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#从最优化问题到递归"><span>从最优化问题到递归</span></a></li><li title="最优化问题的本质" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#最优化问题的本质"><span>最优化问题的本质</span></a></li><li title="枚举与递归：最优组合的求解策略" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#枚举与递归最优组合的求解策略"><span>枚举与递归：最优组合的求解策略</span></a></li><li title="递归与问题表达" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#递归与问题表达"><span>递归与问题表达</span></a></li><li title="从斐波那契数列说起" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#从斐波那契数列说起"><span>从斐波那契数列说起</span></a></li><li title="使用递归求解斐波那契数列" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#使用递归求解斐波那契数列"><span>使用递归求解斐波那契数列</span></a></li><li title="使用递归求解硬币问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#使用递归求解硬币问题"><span>使用递归求解硬币问题</span></a></li><li title="深入理解递归" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#深入理解递归"><span>深入理解递归</span></a></li><li title="堆栈与递归的状态存储" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#堆栈与递归的状态存储"><span>堆栈与递归的状态存储</span></a></li><li title="递归与回溯" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#递归与回溯"><span>递归与回溯</span></a></li><li title="树形结构与深度优先搜索" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#树形结构与深度优先搜索"><span>树形结构与深度优先搜索</span></a></li><li title="通过穷举法从所有的解中得到最优解" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#通过穷举法从所有的解中得到最优解"><span>通过穷举法从所有的解中得到最优解</span></a></li><li title="暴力递归的问题与优化" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#暴力递归的问题与优化"><span>暴力递归的问题与优化</span></a></li><li title="性能问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#性能问题"><span>性能问题</span></a></li><li title="可读性与调试问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#可读性与调试问题"><span>可读性与调试问题</span></a></li><li title="优化暴力递归：剪枝与优化" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#优化暴力递归剪枝与优化"><span>优化暴力递归：剪枝与优化</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="02--暴力递归当贪心失效了怎么办"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#02--暴力递归当贪心失效了怎么办"><span class="icon icon-link"></span></a>02 | 暴力递归：当贪心失效了怎么办？</h1><p>你好，我是卢誉声。</p><p>上一课我们学习了贪心算法，提出了硬币找零的问题，发现了贪心算法的局限性。与此同时，我还提出了一个重要概念，那就是局部最优与整体最优的概念，即最优化问题。今天，我们就从最优化问题开始聊起，引出学习动态规划时的另一重要概念：递归。</p><p>我们之前说过，贪心算法是求解整体最优的真正思路源头，这是为什么我们要在这门课程的一开始从贪心算法讲起。现在，你应该已经意识到贪心算法是有局限性的，它只能在局部最优的思想下工作，<strong>那么当贪心算法失效了怎么办？</strong></p><p>接下来我们就带着这个问题，开始学习今天的内容：递归！看看它能否更进一步地解决我们遇到的棘手问题，从整体最优的角度来解决算法问题。</p><h2 id="从最优化问题到递归"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#从最优化问题到递归"><span class="icon icon-link"></span></a>从最优化问题到递归</h2><p>贪心算法失效的很大一个原因在于它明显的局限性：它几乎只考虑局部最优解。所谓局部最优，就是只考虑当前的最大利益，既不向前多看一步，也不向后多看一步，导致每次都只用当前阶段的最优解。</p><p>因此在绝大多数情况下，贪心算法不能得到整体最优解，但它的解是最优解的一个很好近似。同时，也是所有讨论最优化问题的核心基础。</p><p>既然无法通过贪心算法达到整体最优，我们就得换一个思路了：我们得从整体最优的层面上解决这个难缠的算法问题。那么从何说起呢？我认为你应该先理解最优化问题的本质，然后再把这个思考扩展到递归问题上。话不多说，我们这就开始吧！</p><h3 id="最优化问题的本质"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#最优化问题的本质"><span class="icon icon-link"></span></a>最优化问题的本质</h3><p>所谓最优化问题，就是指在某些约束条件下，决定可选择的变量应该取何值，使所选定的目标函数达到最优的问题。</p><p>从数学意义上说，最优化方法是一种求极值的方法，即在一组约束为等式或不等式的条件下，使系统的目标函数达到极值，即最大值或最小值。</p><p>如果只是从概念上来看最优化问题真的是玄而又玄，所以在上一课中我用了硬币找零的例子，引出了最优化的概念，以便你理解。</p><p>在数学里一切都是函数，现在我们先把这个问题用函数形式来表示。为了易于理解，下面我们不会使用向量。</p><p>我们假定需要给出$y$元硬币，硬币面额是5元和3元，求出需要的最少硬币数量。所谓的最少硬币数量就是5元硬币和3元硬币的总数，假定5元硬币数量为$x_<!-- -->{<!-- -->0<!-- -->}<!-- -->$，3元硬币数量为$x_<!-- -->{<!-- -->1<!-- -->}<!-- -->$，那么用函数表示就是：</p><p>$$f(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->, x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)=x_<!-- -->{<!-- -->0<!-- -->}<!-- -->+x_<!-- -->{<!-- -->1<!-- -->}<!-- -->$$</p><p>这就是所谓的“目标函数”。</p><p>但是这个函数现在是没有任何限制的，我们希望对此进行约束，使得5元硬币和3元硬币的面值综合为$y$。为此我们需要给出一个约束：</p><p>$$5x_<!-- -->{<!-- -->0<!-- -->}<!-- -->+3x_<!-- -->{<!-- -->1<!-- -->}<!-- -->=y$$</p><p>这个时候我们的问题就变成了，当满足这个约束条件的时候，求解函数中的变量$x_<!-- -->{<!-- -->0<!-- -->}<!-- -->$和$x_<!-- -->{<!-- -->1<!-- -->}<!-- -->$，使得目标函数$f(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->, x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)$的取值最小。如果用数学的描述方法来说的话，就是下面这样：</p><p>$$<!-- -->{<!-- -->\arg\min<!-- -->}<!-- -->_<!-- -->{<!-- -->(x_0,x_1)\in S<!-- -->}<!-- --> (x_0+x_1)$$</p><p>这个就是我们常见的$argmin$表示方式。它的意思是：当$(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->, x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)$属于$S$这个集合的时候，希望知道$x_<!-- -->{<!-- -->0<!-- -->}<!-- --> + x_<!-- -->{<!-- -->1<!-- -->}<!-- -->$的最小值是多少。其中$S$集合的条件就是上面的约束。</p><p>所以最优化问题在我们生活中是非常普遍的，只不过大多数问题可能都像硬币找零问题这样看起来普普通通，概念其实是不难理解的。</p><p>回到硬币找零这个问题上。由于$(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->, x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)$都是离散的值，因此所有满足上述约束的$(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->, x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)$组合，就是我们最终所求的集合！而这个最优化问题的本质就是：从所有满足条件的组合$(x_<!-- -->{<!-- -->0<!-- -->}<!-- -->,x_<!-- -->{<!-- -->1<!-- -->}<!-- -->)$中找出一个组合，使得$x_<!-- -->{<!-- -->0<!-- -->}<!-- -->+x_<!-- -->{<!-- -->1<!-- -->}<!-- -->$的值最小。</p><p>所以，你会发现在这种离散型的最优化问题中，本质就是从所有满足条件的组合（能够凑出$y$元）中选择出使得我们的目标函数（所有硬币数量之和）最小的那个组合。而这个所谓满足条件的组合不就是$argmin$公式中的那个集合$S$吗？</p><p>因此，这种离散型的最优化问题就是去所有满足条件的组合里找出最优解的组合。我曾多次提到的<strong>局部最优</strong>就是在一定条件下的最优解，而<strong>整体最优</strong>就是我们真正希望得到的最优解。</p><p>那么我们的视角就转到另一边了：如何去找到这个最优解呢？</p><h3 id="枚举与递归最优组合的求解策略"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#枚举与递归最优组合的求解策略"><span class="icon icon-link"></span></a>枚举与递归：最优组合的求解策略</h3><p>如果想得到最优组合，那么最简单直接的方法肯定就是<strong>枚举</strong>。枚举就是直接求出所有满足条件的组合，然后看看这些组合是否能得到最大值或者最小值。</p><p>在硬币找零问题中，假设现在需要给出25元的硬币，有两种组合，分别是(5, 0)和(2, 5)，也就是5个5元硬币，或者2个5元硬币加上5个3元硬币，那么硬币数量最小的组合肯定就是(5, 0)。</p><p>所以最简单的方法就是找出所有满足条件的组合，也就是上面两个组合，然后去看这些组合中的最优解。</p><p>枚举本身很简单，就是把所有组合都遍历一遍即可。可现在问题就是，<strong>如何得到这些组合呢？</strong></p><p>这就需要我们通过一些策略来生成所有满足条件的组合。而<strong>递归</strong>正是得到这些组合的方法。在解决问题前，我们先回顾一下递归问题的本质。</p><h2 id="递归与问题表达"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#递归与问题表达"><span class="icon icon-link"></span></a>递归与问题表达</h2><p>我们可以看出，其实最优化问题使用递归来处理是非常清晰的，递归是搜索组合的一种非常直观的思路。</p><p>当我在稍后的课程里讨论动态规划时，你就会发现所有问题都需要被描述成递归的形式来讨论。</p><p>所以我们有必要先巩固一下递归的概念。首先是在数学中我们怎么去用递归描述一个问题，然后是如何用递归描述最优化问题的解法。</p><h3 id="从斐波那契数列说起"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#从斐波那契数列说起"><span class="icon icon-link"></span></a>从斐波那契数列说起</h3><p>严格来说，斐波那契数列问题不是最优化问题，但它能很好地展示递归的概念。我们先来看一下斐波那契数列的问题描述。</p><p>问题：斐波那契数通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和：</p><p>$$F(n)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0,n=0\\\<br/>1,n=1\\\<br/>F(n-1)+F(n-2),n&gt;1<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例 1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：2</span></div><div class="token-line"><span class="token plain">    输出：1</span></div><div class="token-line"><span class="token plain">    解释：F(2) = F(1) + F(0) = 1 + 0 = 1。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例 2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：3</span></div><div class="token-line"><span class="token plain">    输出：2</span></div><div class="token-line"><span class="token plain">    解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span></div></pre></div><p>很多人在解算法面试问题的时候有一种倾向性，那就是使用迭代而非递归来求解问题。我先不说这样的倾向性正确与否，那么我们就按照这个偏好来解一下（即斐波那契数列的循环解法）。</p><p>Java实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int fibonacci(int n) {</span></div><div class="token-line"><span class="token plain">        int[] resolution = {0, 1}; // 解的数组</span></div><div class="token-line"><span class="token plain">        if(n &lt; 2) { return resolution[n]; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int i = 1;</span></div><div class="token-line"><span class="token plain">        int fib1 = 0, fib2 = 1, fib = 0;</span></div><div class="token-line"><span class="token plain">        while(i &lt; n) {</span></div><div class="token-line"><span class="token plain">            fib = fib1 + fib2;</span></div><div class="token-line"><span class="token plain">            fib1 = fib2;</span></div><div class="token-line"><span class="token plain">            fib2 = fib;</span></div><div class="token-line"><span class="token plain">            i++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return fib; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int Fibonacci(int n) {</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; resolution = {0, 1}; // 解的数组</span></div><div class="token-line"><span class="token plain">        if(n &lt; 2) { return resolution[n]; }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        int i = 1;</span></div><div class="token-line"><span class="token plain">        int fib1 = 0, fib2 = 1, fib = 0;</span></div><div class="token-line"><span class="token plain">        while(i &lt; n) {</span></div><div class="token-line"><span class="token plain">        	fib = fib1 + fib2;</span></div><div class="token-line"><span class="token plain">        	fib1 = fib2;</span></div><div class="token-line"><span class="token plain">        	fib2 = fib;</span></div><div class="token-line"><span class="token plain">        	i++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return fib; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>嗯，这样的解法固然没错，但是它几乎脱离了题设的数学表达形式。在这道题目中，出题者“刻意”地写出了求解斐波那契数列的函数表达式，这其中有没有什么别的含义或原因呢？</p><p>当然有了，这个函数表达式很好地反应出了计算机科学中常见的算法形式：递归。 下面，就让我们来看看斐波那契数列与递归之间的关系。</p><h3 id="使用递归求解斐波那契数列"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#使用递归求解斐波那契数列"><span class="icon icon-link"></span></a>使用递归求解斐波那契数列</h3><p>事实上，斐波那契数列的数学形式就是递归的，我在这里直接贴出其递归形式的算法代码，你就能很清楚地看出这一点。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int Fibonacci(int n) {</span></div><div class="token-line"><span class="token plain">      if (0 == n || 1 == n) { return n; }</span></div><div class="token-line"><span class="token plain">      if(n &gt; 1) { return Fibonacci(n - 1) + Fibonacci(n - 2); }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      return 0; // 如果输入n有误，则返回默认值</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>递归形式的求解几乎就是简单的把题设中的函数表达式照搬过来，因此我们说从数学意义上讲，递归更直观，且易于理解。</p><h3 id="使用递归求解硬币问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#使用递归求解硬币问题"><span class="icon icon-link"></span></a>使用递归求解硬币问题</h3><p>你可以看出，理解递归并不难，现在我们要把这种思路套用到求解硬币的问题上来。话不多说，我在这里直接贴出使用递归求解硬币问题的代码实现。</p><p>Java实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void getMinCountsHelper(int total, int[] values, ArrayList&lt;Integer&gt; currentCounts, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinations) {</span></div><div class="token-line"><span class="token plain">        if (0 == total) { // 如果余额为0，说明当前组合成立，将组合加入到待选数组中</span></div><div class="token-line"><span class="token plain">            combinations.add(new ArrayList&lt;Integer&gt;(currentCounts));</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int valueLength = values.length;</span></div><div class="token-line"><span class="token plain">        for (int i = 0;  i &lt; valueLength; i ++) { // 遍历所有面值</span></div><div class="token-line"><span class="token plain">            int currentValue = values[i];</span></div><div class="token-line"><span class="token plain">            if (currentValue &gt; total) { // 如果面值大于当前总额，直接跳过</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 否则在当前面值数量组合上的对应位置加1</span></div><div class="token-line"><span class="token plain">            ArrayList&lt;Integer&gt; newCounts = new ArrayList&lt;Integer&gt;(currentCounts);</span></div><div class="token-line"><span class="token plain">            newCounts.set(i, newCounts.get(i)+1);</span></div><div class="token-line"><span class="token plain">            int rest = total - currentValue;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            getMinCountsHelper(rest, values, newCounts, combinations); // 求解剩余额度所需硬币数量</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int getMinimumHelper(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinations) {</span></div><div class="token-line"><span class="token plain">        // 如果没有可用组合，返回-1</span></div><div class="token-line"><span class="token plain">        if (0 == combinations.size()) { return -1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int minCount = Integer.MAX_VALUE;</span></div><div class="token-line"><span class="token plain">        for (ArrayList&lt;Integer&gt; counts : combinations) {</span></div><div class="token-line"><span class="token plain">            int total = 0; // 求当前组合的硬币总数</span></div><div class="token-line"><span class="token plain">            for (int count : counts) { total += count; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 保留最小的</span></div><div class="token-line"><span class="token plain">            if (total &lt; minCount) { minCount = total; }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return minCount;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int getMinCountOfCoins() {</span></div><div class="token-line"><span class="token plain">        int[] values = { 5, 3 }; // 硬币面值的数组</span></div><div class="token-line"><span class="token plain">        int total = 11; // 总值</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ArrayList&lt;Integer&gt; initialCounts = new ArrayList&lt;&gt;(Collections.nCopies(values.length, 0)); // 初始值(0,0)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; coinCombinations = new ArrayList&lt;&gt;(); // 存储所有组合</span></div><div class="token-line"><span class="token plain">        getMinCountsHelper(total, values, initialCounts, coinCombinations); // 求解所有组合（不去重）</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        return getMinimumHelper(coinCombinations); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void GetMinCountsHelper(int total, const std::vector&lt;int&gt;&amp; values, std::vector&lt;int&gt; currentCounts, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; combinations) {</span></div><div class="token-line"><span class="token plain">        if (!total) { // 如果余额为0，说明当前组合成立，将组合加入到待选数组中</span></div><div class="token-line"><span class="token plain">            combinations.push_back(currentCounts);</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int valueLength = values.size();</span></div><div class="token-line"><span class="token plain">        for (int i = 0;  i &lt; valueLength; i ++) { // 遍历所有面值</span></div><div class="token-line"><span class="token plain">            int currentValue = values[i];</span></div><div class="token-line"><span class="token plain">            if (currentValue &gt; total) { // 如果面值大于当前总额，直接跳过</span></div><div class="token-line"><span class="token plain">                continue;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 否则在当前面值数量组合上的对应位置加1</span></div><div class="token-line"><span class="token plain">            std::vector&lt;int&gt; newCounts = currentCounts;</span></div><div class="token-line"><span class="token plain">            newCounts[i] ++;</span></div><div class="token-line"><span class="token plain">            int rest = total - currentValue;</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            GetMinCountsHelper(rest, values, newCounts, combinations); // 求解剩余额度所需硬币数量</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int GetMinimumHelper(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; combinations) {</span></div><div class="token-line"><span class="token plain">        // 如果没有可用组合，返回-1</span></div><div class="token-line"><span class="token plain">        if (!combinations.size()) { return -1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int minCount = INT_MAX;</span></div><div class="token-line"><span class="token plain">        for (const std::vector&lt;int&gt;&amp; counts : combinations) {</span></div><div class="token-line"><span class="token plain">            int total = 0; // 求当前组合的硬币总数</span></div><div class="token-line"><span class="token plain">            for (int count : counts) { total += count; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 保留最小的</span></div><div class="token-line"><span class="token plain">            if (total &lt; minCount) { minCount = total; }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return minCount;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int GetMinCountOfCoins() {</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; values = { 5, 3 }; // 硬币面值的数组</span></div><div class="token-line"><span class="token plain">        int total = 11; // 总值</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; initialCounts(values.size(), 0); // 初始值(0,0)</span></div><div class="token-line"><span class="token plain">        std::vector&lt;std::vector&lt;int&gt;&gt; coinCombinations; // 存储所有组合</span></div><div class="token-line"><span class="token plain">        GetMinCountsHelper(total, values, initialCounts, coinCombinations); // 求解所有组合（不去重）</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return GetMinimumHelper(coinCombinations); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你从代码里可以看出，这里的操作被明确分成了两步：</p><ol><li>求解所有满足条件的组合；</li><li>从组合中选出总和最小的组合。如果找不到满足条件的组合那么就返回-1。</li></ol><p>我们也可以将这两步合并成一步来解决，就像下面这段代码。</p><p>Java实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getMinCountsHelper(int total, int[] values) {</span></div><div class="token-line"><span class="token plain">        // 如果余额为0，说明当前组合成立，将组合加入到待选数组中</span></div><div class="token-line"><span class="token plain">        if (0 == total) { return 0; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int valueLength = values.length;</span></div><div class="token-line"><span class="token plain">        int minCount = Integer.MAX_VALUE;</span></div><div class="token-line"><span class="token plain">        for (int i = 0;  i &lt; valueLength; i ++) { // 遍历所有面值</span></div><div class="token-line"><span class="token plain">            int currentValue = values[i];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果当前面值大于硬币总额，那么跳过</span></div><div class="token-line"><span class="token plain">            if (currentValue &gt; total) { continue; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            int rest = total - currentValue; // 使用当前面值，得到剩余硬币总额</span></div><div class="token-line"><span class="token plain">            int restCount = getMinCountsHelper(rest, values);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果返回-1，说明组合不可信，跳过</span></div><div class="token-line"><span class="token plain">            if (restCount == -1) { continue; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            int totalCount = 1 + restCount; // 保留最小总额</span></div><div class="token-line"><span class="token plain">            if (totalCount &lt; minCount) { minCount = totalCount; }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 如果没有可用组合，返回-1</span></div><div class="token-line"><span class="token plain">        if (minCount == Integer.MAX_VALUE) { return -1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return minCount; // 返回最小硬币数量</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int getMinCountOfCoinsAdvance() {</span></div><div class="token-line"><span class="token plain">        int[] values = { 3, 5 }; // 硬币面值的数组</span></div><div class="token-line"><span class="token plain">        int total = 11; // 总值</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return getMinCountsHelper(total, values); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetMinCountsHelper(int total, const std::vector&lt;int&gt;&amp; values) {</span></div><div class="token-line"><span class="token plain">        // 如果余额为0，说明当前组合成立，将组合加入到待选数组中</span></div><div class="token-line"><span class="token plain">        if (!total) { return 0; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int valueLength = values.size();</span></div><div class="token-line"><span class="token plain">        int minCount = INT_MAX;</span></div><div class="token-line"><span class="token plain">        for (int i = 0;  i &lt; valueLength; i ++) { // 遍历所有面值</span></div><div class="token-line"><span class="token plain">            int currentValue = values[i];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果当前面值大于硬币总额，那么跳过</span></div><div class="token-line"><span class="token plain">            if (currentValue &gt; total) { continue; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            int rest = total - currentValue; // 使用当前面值，得到剩余硬币总额</span></div><div class="token-line"><span class="token plain">            int restCount = GetMinCountsHelper(rest, values);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            // 如果返回-1，说明组合不可信，跳过</span></div><div class="token-line"><span class="token plain">            if (restCount == -1) { continue; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            int totalCount = 1 + restCount; // 保留最小总额</span></div><div class="token-line"><span class="token plain">            if (totalCount &lt; minCount) { minCount = totalCount; }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 如果没有可用组合，返回-1</span></div><div class="token-line"><span class="token plain">        if (minCount == INT_MAX) { return -1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return minCount; // 返回最小硬币数量</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int GetMinCountOfCoinsAdvance() {</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; values = { 5, 3 }; // 硬币面值的数组</span></div><div class="token-line"><span class="token plain">        int total = 11; // 总值</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return GetMinCountsHelper(total, values); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，每一次递归返回的值，都是后续组合之和的最小值。它不再存储所有的组合，直到回退到递归的顶层。</p><p>这样可以极大节省存储空间，这是处理递归问题的通用方法。一般来说，你都应该用这种算法处理方式来解递归问题。</p><h2 id="深入理解递归"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#深入理解递归"><span class="icon icon-link"></span></a>深入理解递归</h2><p>在了解了递归的概念、问题的描述方式和解决问题方法后，我想让你来思考这样一个问题：<strong>为什么递归能帮助我们解决最优化问题？</strong></p><h3 id="堆栈与递归的状态存储"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#堆栈与递归的状态存储"><span class="icon icon-link"></span></a>堆栈与递归的状态存储</h3><p>在计算机中，实现递归必须建立在堆栈的基础上，这是因为每次递归调用的时候我们都需要把当前函数调用中的局部变量保存在某个特定的地方，等到函数返回的时候再把这些局部变量取出来。</p><p>而用于保存这些局部变量的地方也就是堆栈了。</p><p>因此，你可以看到递归可以不断保存当前求解状态并进入下一层次的求解，并在得到后续阶段的解之后，将当前求解状态恢复并与后续求解结果进行合并。</p><p>在硬币找零问题中，我们可以放心的在函数中用循环不断遍历，找出当前面值硬币的可能数量。而无需用其它方法来存储当前或之前的数据。</p><p>得益于递归，我们通过堆栈实现了状态存储，这样的代码看起来简单、清晰明了。在本节课稍后的内容中，在我讲到递归树的求解组合空间时，你会更清晰地认识到堆栈和状态存储带来的价值！</p><h3 id="递归与回溯"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#递归与回溯"><span class="icon icon-link"></span></a>递归与回溯</h3><p>在求解最优化问题的时候，我们经常会用到<strong>回溯</strong>这个策略。</p><p>上一课中，我们已经提到过回溯的思想。在硬币找零这个问题里，具体说就是如果遇到已经无法求解的组合，那么我们就往回退一步，修改上一个面值的硬币数量，然后再尝试新的组合。</p><p>递归这种形式，正是赋予了回溯这种可以回退一步的能力：它通过堆栈保存了上一步的当前状态。</p><p>因此，如果想要用回溯的策略来解决问题，那么递归应该是你的首选方法。所以说，回溯在最优化问题中有多么重要，递归也就有多么重要。</p><h3 id="树形结构与深度优先搜索"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#树形结构与深度优先搜索"><span class="icon icon-link"></span></a>树形结构与深度优先搜索</h3><p>为了理解递归，我在这里用合适的结构来描述递归的求解过程。这种结构正是计算机数据结构中的树。如下图所示：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage1570154a4b0fdb8e467428fb3e06b14a3d70.00a8a0ee.jpg" alt=""/></p><p>你可以从中看到形象的递归求解过程，每个节点的 /（斜线）左边表示当前节点使用的硬币面值，右边表示使用面值后的余额。图中的蓝色节点就表示我们目前得到的解。</p><p>递归的过程的确就是一个树形结构，而递归也就是一个深度优先搜索的过程，先找到下一步的解，然后再回退，如此往复。</p><p>所以我们可以这样理解递归：作为一个算法解决方案，它采用了深度优先搜索的策略，去搜索所有可能的组合，并得到最优解的最优化问题。</p><p>如果在每个节点上加上当前这个节点求得的组合结果，就可以用递归树表示<strong>求解的组合空间</strong>：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagee763e721d6a000637746a8d0ea223151b563.2881d078.jpg" alt=""/></p><h3 id="通过穷举法从所有的解中得到最优解"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#通过穷举法从所有的解中得到最优解"><span class="icon icon-link"></span></a>通过穷举法从所有的解中得到最优解</h3><p>从上图中我们可以发现，每个节点都存储了一个当前求解过程中的组合，和后续节点的组合合并到一起形成完整的答案。</p><p>而真正的求解组合，就是把所有余额为0的组合拿出来，经过去重之后得到的结果。</p><p>所以，你可以看到求解的组合就蕴含在这个递归的树形结算的节点空间中，这也就是为什么递归策略是行之有效的：我们可以通过穷举法从所有的解中得到最优解！</p><h2 id="暴力递归的问题与优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#暴力递归的问题与优化"><span class="icon icon-link"></span></a>暴力递归的问题与优化</h2><p>从上一课介绍的贪心算法，到我在这里跟你讲的暴力递归法，看起来硬币找零问题有了一个稳定且行之有效的解题思路。</p><p>但这就足够了吗？哈哈，显然不是。因为这样的穷举法效率实在低下，不仅如此，这样的代码可读性低且调试困难。我在这里给你具体分析一下。</p><h3 id="性能问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#性能问题"><span class="icon icon-link"></span></a>性能问题</h3><p>暴力递归的最后一个特点就是穷举（都叫暴力，你说是不是）。如果我们只使用朴素的递归思路解题，就需要通过递归来暴力穷举出所有的组合，而且我们穷举的不只是组合，还是所有可能得到目标组合的组成路径！</p><p>这个在上面的图中我们可以看到，同样是求解(2, 5)这个组合，图中有多少种路径？这还只是25元和两种面值的情况。如果求解的金额和面值数量增加，那么我们可以看到这个树会以非常难以置信的方式增长，那么带来的性能问题就是灾难性的。</p><p>如果你仔细观察一下，就会发现这个树会随着总额的增加呈现指数形式的增长。对于这种事情，我们难以接受。</p><p>因此，递归只是让问题可以求解，但是如果数据规模过大的时候暴力递归会引发极大的性能问题。</p><h3 id="可读性与调试问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#可读性与调试问题"><span class="icon icon-link"></span></a>可读性与调试问题</h3><p>虽然递归在数学意义上非常直观，但是如果问题过于复杂，一般是无法直接画出上面我画的那棵求解树的。</p><p>有画求解树的时候，我们可以想出我们的求解过程是怎么进行的，但如果求解树的分支极多，那么很多人就很难继续在脑海中模拟出整个求解过程了。</p><p>因此，一旦程序出现bug，当你想尝试去调试的时候，就会发现这样的代码几乎没有调试的可能性。这种问题在数据规模很大的情况下尤为明显。</p><p>那么针对性能低下、代码可读性降低和调试问题，我们有什么办法去解决吗？有，听我给你讲下面的内容。</p><h3 id="优化暴力递归剪枝与优化"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#优化暴力递归剪枝与优化"><span class="icon icon-link"></span></a>优化暴力递归：剪枝与优化</h3><p>你可以从前面的图中看到，这棵树中有很多分支是完全相同的：起码从理论上讲最终只有两个组合。但是这棵树到达同一种组合的路径却非常多，所以优化递归的思路其实就是如何减少搜索的分支数量。</p><p>分支数量减少了，递归效率也就高了。这就是所谓的<strong>剪枝</strong>优化。对于优化方法，这里我提供两种思路给你。</p><p><strong>1. 参考贪心算法</strong></p><p>第一种思路是仿照贪心算法，从整个搜索策略上来调整。也就是说，你要考虑这个问题的性质，即面值大的硬币用得足够多，那么这个组合的硬币总数肯定就最小。</p><p>所以在每一次递归时，我们不应该暴力地搜索所有的面值，而应该从面值最大的硬币着手，不断尝试大面值硬币的最大情况。</p><p>如果无法满足条件再减少一个，再递归搜索。最后的代码就跟我在上一课中写给你的回溯代码一样，即通过贪心这种思路结合递归实现一种组合搜索。</p><p>殊途同归啊！我们从递归的角度重新解释了这个算法问题，而且代码实现也是一样的。</p><p><strong>2. 从解空间图解释</strong></p><p>除了参考贪心算法的思想，我们还可以从解空间的角度来解释这个问题。</p><p>请你注意观察一下：在解空间的图中，只要是余额相同的情况下，后面的搜索路径是完全一致的！</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage77d0776fe3739110beba2a538103775e3ed0.21101027.jpg" alt=""/></p><p>我在图中圈出的两个部分就是重复的搜索路径。因为余额都是12元，所以后续的求解路径和结果完全相同。</p><p>这是一个重要线索，在这个硬币求解问题中，当余额相同的时候，最优解是确定的。那么你想想看，如果能够避免相同余额下的重复搜索过程，那么算法执行速度是不是可以加快了？</p><p>这就是我在上一课中提到过的<strong>重叠子问题</strong>。</p><p>你可以把求解12元的硬币数量理解成求解25元的硬币数量的一个子问题。在求解25元硬币过程中，会有很多种情况都要求解12元硬币的最优解。我们把这类会出现重复求解的子问题称之为重叠子问题。</p><p>显然，这就是我们可以优化的出发点。至于如何进行优化，则需要用比较多的篇幅讨论，在下一节课中，我会跟你细谈这个问题。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>今天我们学习了最优化问题的本质，即从所有满足条件的组合里找出最优解的组合。贪心算法只能解决<strong>局部最优</strong>问题，而我们的最终目标是解决<strong>整体最优</strong>问题（即最优解）。</p><p>自然地，<strong>枚举</strong>是获得最优解的理想方法。而<strong>递归</strong>可以帮助我们获得所有可能答案的组合。递归形式的求解几乎就是简单地把题设中的函数表达式照搬过来，它相较于迭代来说更直观，且易于理解。</p><p>但暴力递归有着十分明显的缺陷，存在性能低下、可读性低和调试困难等问题。为此，我们提出了剪枝与优化这两种方法：</p><ol><li>利用预设条件减少搜索路径，优化最优组合搜索方案（硬币的优化）；</li><li>利用重叠子问题，避免重叠子问题的计算。</li></ol><p>因此，在面试问题中，考虑贪心算法和递归是我们求解问题时思考的重要方向。很多面试问题已经可以使用这两种算法来解决了。</p><p>但在稍复杂的面试问题面前，我们还需要借助于更高级的手段：备忘录和动态规划。而重叠子问题是理解这些高级手段的基础，下节课我会具体来讲。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/02#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>今天我讲了递归求解最优解问题的思路，并强调了回溯的重要性。那如何通过编程，求出所有有效的括号组合呢？（设输入是有几组括号，输出是所有有效的括号组合）</p><p>欢迎留言和我分享你的答案，我会第一时间给你反馈。如果今天的内容对你有所启发，也欢迎把它分享给你身边的朋友，邀请他一起学习！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/02.初识动态规划/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:20:46</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
