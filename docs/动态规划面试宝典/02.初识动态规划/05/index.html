<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>05｜面试即正义第一期：什么样的问题应该使用动态规划？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/02.初识动态规划/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="动态规划是一种思想" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#动态规划是一种思想"><span>动态规划是一种思想</span></a></li><li title="动态规划问题的典型特点" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#动态规划问题的典型特点"><span>动态规划问题的典型特点</span></a></li><li title="求“最”优解问题（最大值和最小值）" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求最优解问题最大值和最小值"><span>求“最”优解问题（最大值和最小值）</span></a></li><li title="求可行性（True或False）" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求可行性true或false"><span>求可行性（True或False）</span></a></li><li title="求方案总数" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求方案总数"><span>求方案总数</span></a></li><li title="进一步确认是否为动态规划问题" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#进一步确认是否为动态规划问题"><span>进一步确认是否为动态规划问题</span></a></li><li title="数据不可排序（Unsortable）" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#数据不可排序unsortable"><span>数据不可排序（Unsortable）</span></a></li><li title="数据不可交换（Non-swapable）" data-depth="3"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#数据不可交换non-swapable"><span>数据不可交换（Non-swapable）</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="05面试即正义第一期什么样的问题应该使用动态规划"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#05面试即正义第一期什么样的问题应该使用动态规划"><span class="icon icon-link"></span></a>05｜面试即正义第一期：什么样的问题应该使用动态规划？</h1><p>你好，我是卢誉声。</p><p>作为“初识动态规划”模块的最后一课，今天我们不谈具体的解决方案了，我们来聊聊面试相关的话题，做个总结，也为我们后面的深入学习打下一个良好的基础。</p><p>那说起动态规划，我不知道你有没有这样的困扰，在掌握了一些基础算法和数据结构之后，碰到一些较为复杂的问题还是无从下手，面试时自然也是胆战心惊。如果我说动态规划是个玄幻的问题其实也不为过。究其原因，我觉得可以归因于这样两点：</p><ul><li>你对动态规划相关问题的套路和思想还没有完全掌握；</li><li>你没有系统地总结过究竟有哪些问题可以用动态规划解决。</li></ul><p>知己知彼，你想把动态规划作为你的面试武器之一，就得足够了解它；而应对面试，总结、归类问题其实是个不错的选择，这在我们刷题的时候其实也能感觉得到。</p><p>那么今天，我们就针对以上两点，系统地谈一谈究竟什么样的问题可以用动态规划来解。相信这节课过后，你就能有针对性地攻克难关了，无论是面试还是工程实践都能做到有的放矢。</p><h2 id="动态规划是一种思想"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#动态规划是一种思想"><span class="icon icon-link"></span></a>动态规划是一种思想</h2><p>动态规划算法，这种叫法我想你应该经常听说。嗯，从道理上讲这么说我觉得也没错，首先动态规划它不是数据结构，这一点毋庸置疑，并且严格意义上来说它就是一种算法。但更加准确或者更加贴切的提法应该是说动态规划是一种思想。</p><p><strong>那什么是思想？算法和思想又有什么区别呢？</strong></p><p>一般来说，我们都会把算法和数据结构放一起来讲，这是因为它们之间密切相关，而算法也往往是在特定数据结构的基础之上对解题方案的一种严谨的总结。</p><p>比如说，在一个乱序数组的基础上进行排序，这里的数据结构指的是什么呢？很显然是数组，而算法则是所谓的排序。至于排序算法，你可以考虑使用简单的冒泡排序或效率更高的快速排序方法等等来解决问题。</p><p>没错，你应该也感觉到了，算法是一种简单的经验总结和套路。那什么是思想呢？相较于算法，思想更多的是指导你我来解决问题。</p><p>比如说，在解决一个复杂问题的时候，我们可以先将问题简化，先解决简单的问题，再解决难的问题，那么这就是一种指导解决问题的思想。另外，我们常说的分治也是一种简单的思想，当然它在诸如归并排序或递归算法当中会常常被提及。</p><p>而动态规划就是这样一个指导我们解决问题的思想：**你需要利用已经计算好的结果来推导你的计算，即大规模问题的结果是由小规模问题的结果运算得来的。**这句话对于你充分理解动态规划的基本原理十分重要，希望你能记下来。</p><p>简单理解的话，你可以这样认为：<strong>算法是一种经验总结，而思想则是用来指导我们解决问题的。</strong></p><p>既然动态规划是一种思想，那它实际上就是一个比较抽象的概念了，也很难和实际的问题关联起来。所以说，弄清楚什么样的问题可以使用动态规划来解，就显得十分重要了。</p><h2 id="动态规划问题的典型特点"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#动态规划问题的典型特点"><span class="icon icon-link"></span></a>动态规划问题的典型特点</h2><p>在前几课中，我们已经基本了解了动态规划的基本概念，从贪心算法、暴力递归再到最后的动态规划解法，我们比较完美地解决了提出的问题。在这个过程中，你有没有想过这些问题为什么可以用动态规划来解决？是别人这么做我也要这么做吗？别人的经验又是从何而来？</p><p>事实上，动态规划是运筹学上的一种最优化方法，只不过在算法问题上应用广泛。接下来我们就深挖一层，看看动归问题所具备的一些特点。</p><h3 id="求最优解问题最大值和最小值"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求最优解问题最大值和最小值"><span class="icon icon-link"></span></a>求“最”优解问题（最大值和最小值）</h3><p>除非你碰到的问题是简单到找出一个数组中最大的值这样，对这种问题来说，你可以对数组进行排序，然后取数组头或尾部的元素，如果觉得麻烦，你也可以直接遍历得到最值。不然的话，你就得考虑使用动态规划来解决这个问题了。这样的问题一般都会让你求最大子数组、求最长递增子数组、求最长递增子序列或求最长公共子串、子序列等等。不知道你发现没有，这些问题里都包含一个“最”字，如果出现了这个字，那么你就该警惕它是否是动归问题。那具体怎么判断呢？</p><p>既然是要求最值，不妨先想一下核心问题是什么。其实在真的解决最值问题的时候，你应该按照这样的思考顺序来解决问题：</p><ul><li>优先考虑使用贪心算法的可能性；</li><li>然后是暴力递归进行穷举（但这里的数据规模不大）；</li><li>还是不行呢？选择动态规划！</li></ul><p>你也看到了，求解动态规划的核心问题其实就是穷举。那么因为我们要求最值，就肯定要把所有可行的答案穷举出来，然后在其中找最值就好了嘛。你看，动态规划也不过如此，就两个字：<strong>穷举</strong>。</p><p>当然了，动态规划问题也不会这么简单了事，我们还需要考虑待解决的问题是否存在重叠子问题、最优子结构等特性。我们已经在前面的课程中讲清楚了重叠子问题，而对于最优子结构，我会在后续的内容中继续给你讲清楚。</p><p>清楚了特点，那根据我的经验，绝大多数面试者其实还是很难在第一时间针对具体问题采取明确的行动：这个问题到底该不该用动态规划思想来解呢？</p><p>我在这里列出几道常见的经典面试题，如果你遇到它们了，不要犹豫，使用动态规划来解。这样不仅目标明确，而且会在面试时给面试官留下极为深刻的印象（这一讲我们只是分析下题目，后面的课程中会涵盖所有问题的解法，并归纳总结解题套路）。</p><p><strong>1. 乘积最大子数组</strong></p><p>问题：给你一个整数数组 numbers，找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），返回该子数组的乘积。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: [2,7,-2,4]</span></div><div class="token-line"><span class="token plain">    输出: 14</span></div><div class="token-line"><span class="token plain">    解释: 子数组 [2,7] 有最大乘积 14。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    输入: [-5,0,3,-1]</span></div><div class="token-line"><span class="token plain">    输出: 3</span></div><div class="token-line"><span class="token plain">    解释: 结果不能为 15, 因为 [-5,3,-1] 不是子数组，是子序列。</span></div></pre></div><p>首先，很明显这个题目当中包含一个“最”字，使用动态规划求解的概率就很大。这个问题的目的就是从数组中寻找一个最大的连续区间，确保这个区间的乘积最大。由于每个连续区间可以划分成两个更小的连续区间，而且大的连续区间的结果是两个小连续区间的乘积，因此这个问题还是求解满足条件的最大值，同样可以进行问题分解，而且属于求最值问题。同时，这个问题与求最大连续子序列和比较相似，唯一的区别就是你需要在这个问题里考虑正负号的问题，其它就相同了。</p><p><strong>2. 最长回文子串</strong></p><p>问题：给定一个字符串s，找到s中最长的回文子串。你可以假设s的最大长度为1000。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: &quot;babad&quot;</span></div><div class="token-line"><span class="token plain">    输出: &quot;bab&quot;</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    输入: &quot;cbbd&quot;</span></div><div class="token-line"><span class="token plain">    输出: &quot;bb&quot;</span></div></pre></div><p>这个问题依然包含一个“最”字，同样由于求解的最长回文子串肯定包含一个更短的回文子串，因此我们依然可以使用动态规划来求解这个问题。</p><p><strong>3. 最长上升子序列</strong></p><p>问题：给定一个无序的整数数组，找到其中最长上升子序列的长度。可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    输入: [10,9,2,5,3,7,66,18]</span></div><div class="token-line"><span class="token plain">    输出: 4</span></div><div class="token-line"><span class="token plain">    解释: 最长的上升子序列是 [2,3,7,66]，它的长度是 4。</span></div></pre></div><p>这个问题依然是一个最优解问题，假设我们要求一个长度为5的字符串中的上升自序列，我们只需要知道长度为4的字符串最长上升子序列是多长，就可以根据剩下的数字确定最后的结果。</p><h3 id="求可行性true或false"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求可行性true或false"><span class="icon icon-link"></span></a>求可行性（True或False）</h3><p>接下来我们再来看另一种可能的动态规划问题。</p><p>如果有这样一个问题，让你判断是否存在一条总和为x的路径（如果找到了，就是True；如果找不到，自然就是False），或者让你判断能否找到一条符合某种条件的路径，那么这类问题都可以归纳为求可行性问题，并且可以使用动态规划来解。比如我们前面课程中提到的找零钱问题，是不是就很好地说明了这一点？</p><p><strong>1. 凑零兑换问题</strong></p><p>问题：给你 k 种面值的硬币，面值分别为 c1, c2 … ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: c1=1, c2=2, c3=5, c4=7, amount = 15</span></div><div class="token-line"><span class="token plain">    输出: 3</span></div><div class="token-line"><span class="token plain">    解释: 11 = 7 + 7 + 1。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    输入: c1=3, amount =7</span></div><div class="token-line"><span class="token plain">    输出: -1</span></div><div class="token-line"><span class="token plain">    解释: 3怎么也凑不到7这个值。</span></div></pre></div><p>这个问题显而易见，如果不可能凑出我们需要的金额（即amount），最后算法需要返回-1，否则输出可能的硬币数量。这是一个典型的求可行性的动态规划问题。</p><p><strong>2. 字符串交错组成问题</strong></p><p>问题：给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: s1=&quot;aabcc&quot;,s2 =&quot;dbbca&quot;,s3=&quot;aadbbcbcac&quot;</span></div><div class="token-line"><span class="token plain">    输出: true</span></div><div class="token-line"><span class="token plain">    解释: 可以交错组成。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    输入: s1=&quot;aabcc&quot;,s2=&quot;dbbca&quot;,s3=&quot;aadbbbaccc&quot;</span></div><div class="token-line"><span class="token plain">    输出: false</span></div><div class="token-line"><span class="token plain">    解释:无法交错组成。</span></div></pre></div><p>这个问题稍微有点复杂，但是我们依然可以通过子问题的视角，首先求解s1中某个长度的子字符串是否由s2和s3的子字符串交错组成，直到求解整个s1的长度为止，也可以看成一个包含子问题的最值问题。</p><h3 id="求方案总数"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#求方案总数"><span class="icon icon-link"></span></a>求方案总数</h3><p>除了求最值与可行性之外，求方案总数也是比较常见的一类动态规划问题。比如说给定一个数据结构和限定条件，让你计算出一个方案的所有可能的路径，那么这种问题就属于求方案总数的问题。我在这里介绍几个典型例子，帮助你理解。</p><p><strong>1.硬币组合问题</strong></p><p>问题：英国的英镑硬币有 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), 和 £2 (200p)。比如我们可以用以下方式来组成2英镑：1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p。问题是一共有多少种方式可以组成n英镑? 注意不能有重复，比如 1英镑+2个50P 和 50P+50P+1英镑是一样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: 2</span></div><div class="token-line"><span class="token plain">    输出: 73682</span></div></pre></div><p>这个问题本质还是求满足条件的组合，只不过这里不需要求出具体的值或者说组合，只需要计算出组合的数量即可。</p><p><strong>2.路径规划问题</strong></p><p>问题：一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，共有多少路径？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: 2 2</span></div><div class="token-line"><span class="token plain">    输出: 2</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入: 3 3</span></div><div class="token-line"><span class="token plain">    输出: 6</span></div></pre></div><p>这个问题还是一个求满足条件的组合数量的问题，只不过这里的组合变成了路径的组合。我们可以先求出长宽更小的网格中的所有路径，然后再在一个更大的网格内求解更多的组合。这和硬币组合的问题相比没有什么本质区别。</p><p>这里有一个规律或者说现象需要强调，那就是求方案总数的动态规划问题一般都指的是求“一个”方案的所有具体形式。如果是求“所有”方案的具体形式，那这种肯定不是动态规划问题，而是使用传统递归来遍历出所有方案的具体形式。</p><p>为什么这么说呢？因为你需要把所有情况枚举出来，大多情况下根本就没有重叠子问题给你优化。即便有，你也只能使用备忘录对遍历进行一个简单加速。但本质上，这类问题不是动态规划问题。接下来你就会看到这样的例子，你可以找找区别在哪里。</p><h2 id="进一步确认是否为动态规划问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#进一步确认是否为动态规划问题"><span class="icon icon-link"></span></a>进一步确认是否为动态规划问题</h2><p>从前面我所说来看，如果你碰到了求最值、求可行性或者是求方案总数的问题的话，那么这个问题就八九不离十了，你基本可以确定它就需要使用动态规划来解。但这里还有一些极具迷惑性的问题，你需要格外注意。</p><h3 id="数据不可排序unsortable"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#数据不可排序unsortable"><span class="icon icon-link"></span></a>数据不可排序（Unsortable）</h3><p>假设我们有一个无序数列，希望求出这个数列中最大的两个数字之和。很多初学者刚刚学完动态规划会走火入魔到看到最优化问题就想用动态规划来求解，嗯，那么这样应该也是可以的吧……不，等等，这个问题不是简单做一个排序或者做一个遍历就可以求解出来了吗？所以学完动态规划后，你一定要注意，遇到这些简单的问题不要把事情变得更复杂了。先考虑一下能不能通过排序来简化问题，如果不能，才极有可能是动态规划问题。还是看个例子。</p><p><strong>最小的k个数</strong></p><p>问题：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    输入：arr = [3,2,1], k = 2</span></div><div class="token-line"><span class="token plain">    输出：[1,2] 或者 [2,1]</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    输入：arr = [0,1,2,1], k = 1</span></div><div class="token-line"><span class="token plain">    输出：[0]</span></div></pre></div><p>我们发现虽然这个问题也是求“最”值，但其实只要通过排序就能解决，所以我们应该用排序、堆等算法或者数据结构来解决，而不应该用动态规划。</p><h3 id="数据不可交换non-swapable"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#数据不可交换non-swapable"><span class="icon icon-link"></span></a>数据不可交换（Non-swapable）</h3><p>还有一类问题，可以归类到我们总结的几类问题里去，但是不存在动态规划要求的重叠子问题（比如经典的八皇后问题），那么这类问题就无法通过动态规划求解。这种情况需要避免被套进去。</p><p><strong>全排列</strong></p><p>问题：给定一个没有重复数字的序列，返回其所有可能的全排列。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    输入: [1,2,3]</span></div><div class="token-line"><span class="token plain">    输出:</span></div><div class="token-line"><span class="token plain">    [</span></div><div class="token-line"><span class="token plain">      [1,2,3],</span></div><div class="token-line"><span class="token plain">      [1,3,2],</span></div><div class="token-line"><span class="token plain">      [2,1,3],</span></div><div class="token-line"><span class="token plain">      [2,3,1],</span></div><div class="token-line"><span class="token plain">      [3,1,2],</span></div><div class="token-line"><span class="token plain">      [3,2,1]</span></div><div class="token-line"><span class="token plain">    ]</span></div></pre></div><p>这个问题虽然是求组合，但没有重叠子问题，更不存在最优化的要求，因此可以使用回溯处理，并不是动态规划的用武之地。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>今天，我们一起探讨了动态规划问题的本质，更准确或更加严谨地说，动态规划是一种指导我们解决问题的思想。</p><p>接着我们列出了辨别一个算法问题是否该使用动态规划来解的五大特点：</p><ol><li>求最优解问题（最大值和最小值）；</li><li>求可行性（True或False）；</li><li>求方案总数；</li><li>数据结构不可排序（Unsortable）；</li><li>算法不可使用交换（Non-swappable）。</li></ol><p>如果面试题目出现这些特征，那么在90%的情况下你都能断言它就是一个动归问题。</p><p>当然了，就像我前面所讲的，你还需要考虑这个问题是否包含重叠子问题与最优子结构，在这个基础之上你就可以99%断言它是否为动归问题，并且也顺势找到了大致的解题思路，我会在后面的课程中继续跟你探讨这些问题，彻底解决你的疑惑。</p><p>通过上述这几个鲜明的特点，相信你能够在将来迅速地判断出问题是否为动态规划类问题，并使用对应的思想和套路来应对算法或面试问题。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/02.初识动态规划/05#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><ol><li><p>除了我在这里列出的动态规划特点以外，你觉得还有哪些类别的问题应该进行归纳总结？能否把你见过的或认为是动态规划的算法留在评论区，并分析一下它们又属于哪些类别。</p></li><li><p>我在前面提到过子数组与子序列的问题，请你思考一下，这两种情况有什么区别？</p></li></ol><p>欢迎留言和我分享，我会第一时间给你反馈。如果今天的内容让你对动态规划的用法有了进一步的了解，也欢迎把它分享给你身边的朋友，邀请他一起学习！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/02.初识动态规划/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:07:30</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
