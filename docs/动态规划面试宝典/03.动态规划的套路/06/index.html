<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>加餐｜买卖股票：常见且必考的动态规划面试题 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/03.动态规划的套路/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="买卖股票问题" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#买卖股票问题"><span>买卖股票问题</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#算法问题分析"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#写出状态转移方程"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#编写代码进行求解"><span>编写代码进行求解</span></a></li><li title="攻破买卖股票问题的解题模板" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#攻破买卖股票问题的解题模板"><span>攻破买卖股票问题的解题模板</span></a></li><li title="经过经验总结的解题模板" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#经过经验总结的解题模板"><span>经过经验总结的解题模板</span></a></li><li title="对解题模板进行分析" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#对解题模板进行分析"><span>对解题模板进行分析</span></a></li><li title="写出解题模板的状态转移方程" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#写出解题模板的状态转移方程"><span>写出解题模板的状态转移方程</span></a></li><li title="实例化解题模板" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#实例化解题模板"><span>实例化解题模板</span></a></li><li title="课程总结" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/06#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="加餐买卖股票常见且必考的动态规划面试题"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#加餐买卖股票常见且必考的动态规划面试题"><span class="icon icon-link"></span></a>加餐｜买卖股票：常见且必考的动态规划面试题</h1><p>你好，我是卢誉声。</p><p>上一课我们介绍了动态规划面试问题中求方案总数和求可行性这两大类问题的通用解法，解题模版如下：</p><ol><li>根据特征判断是否用动态规划来解；</li><li>确定初始化状态和状态参数；</li><li>确定状态存储数组（即备忘录）；</li><li>写出关键的状态转移方程；</li><li>编写代码进行求解。</li></ol><p>这样的解题模版（套路）是可以复用的，希望你能牢牢记住。今天，作为一节加餐课，我想给你介绍另一种常考的面试问题：买卖股票。这种问题的变种比较多，但依然可以用上述解题模版来解决所有买卖股票的问题，从而做到一通百通。</p><h2 id="买卖股票问题"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#买卖股票问题"><span class="icon icon-link"></span></a>买卖股票问题</h2><p>在技术面试环节，如果考察动态规划问题的话，那么买卖股票就是一类常考且经典的问题。这类问题一般来说属于求最优解（最大值和最小值）的范畴，下面我们看看这个问题到底是怎样的。</p><h3 id="算法问题分析"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#算法问题分析"><span class="icon icon-link"></span></a>算法问题分析</h3><p>问题：给定一个数组，它的第 $i$ 个元素是一支给定的股票在第 $i$ 天的价格。请你设计一个算法来计算你所能获取的最大利润，你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：[3, 3, 5, 0, 0, 3, 1, 4]</span></div><div class="token-line"><span class="token plain">    输出：6</span></div><div class="token-line"><span class="token plain">    解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3 - 0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4 - 1 = 3 。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：[1, 2, 3, 4, 5]</span></div><div class="token-line"><span class="token plain">    输出：4</span></div><div class="token-line"><span class="token plain">    解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。需要注意的是，你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例3：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：[7, 6, 4, 3, 1] </span></div><div class="token-line"><span class="token plain">    输出：0 </span></div><div class="token-line"><span class="token plain">    解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span></div></pre></div><p>可能对大部分人来说，第一眼看到这道题都没有什么思路——这个问题里存在什么可以提取的最优子结构吗？我来给你分析一下。</p><p>我们假设，一支股票某天在某种条件下（在前一天赚取的利润确定的情况下，这些条件肯定会影响我们的决策，因此暂时不考虑具体的条件到底是什么）已经赚取了利润。那么当天的利润是依赖于其前一天某些条件下的利润，所以这里存在重复计算问题，也就是会有<strong>重叠子问题</strong>。</p><p>而对于这支股票，前一天的利润会影响后一天的利润，反之是不会有影响的，那么这里<strong>无后效性</strong>的条件也满足了。</p><p>最后考虑一下，原问题要求解的是：最后一天结束时，一共赚取了多少利润。每天结束时，赚得的总利润 = 前一天赚取的总利润 ➕ 当天的决策（是否卖出或者买入股票），到这里我们终于嗅到了<strong>最优子结构</strong>的味道。</p><p>现在，我们有了一个大致的思路：这是一个可以使用动态规划求解的问题。现在，再来看一下这个问题的状态转移方程到底是什么？</p><h3 id="写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#写出状态转移方程"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>首先，我们要确定<strong>初始化状态</strong>，思考一下有哪些边界情况。</p><ol><li>第一种边界情况是：如果当天结束时没有持股，而且到当天结束时从未卖出过股票，这种情况利润肯定为 0；</li><li>第二种边界情况是：当天持股，而且卖出过两次股票，这种情况是不存在的，这也就是我们的终止条件。</li></ol><p>然后，可以看出这个问题的<strong>状态参数</strong>之一是天数（变量），也就是当前是第几天，毕竟没有天数也就没有我们的子问题。</p><p>根据前面的分析，得知问题的形式是前一天赚取的总利润 ➕ 当天的决策——也就是在当天结束时是否持有这支股票，以及我们当天买卖当前这支股票（每支股票最多只能买卖两次），进而确定当天结束时赚取的总利润。</p><p>现在我们得知，在每一天结束时的总利润取决于以下三个因素：</p><ol><li>前一天赚取的总利润；</li><li>当天结束时是否持有股票；</li><li>当天是否买进或者卖出股票。</li></ol><p>此时，由于买卖股票是有次数限制的，即只能有2次。因此，对于第三个因素，我们需要进一步具体化才能做出决策——未卖出过股票、卖出过一次股票和卖出过两次股票。</p><p>所以，这里我们就找出了三个状态参数，它们决定了某一天结束时得到的总利润，分别是：</p><ol><li>天数；</li><li>当天结束时是否持有股票；</li><li>股票卖出的次数。</li></ol><p>根据这三个状态参数（因素），再结合前一天赚取的总利润，就可以得到当前这一天这个状态下的最优解了。只不过前一天赚取的总利润肯定也会受到这三个参数的影响。为此，还需要根据当天的参数来思考前一天的参数有哪些可能性，才能知道使用前一天哪种状态下的总利润（毕竟有三个参数）。</p><p>经过上面对状态参数的分析，我们可以知道状态存储空间，即备忘录是一个三维数组 <strong>$DP[i][j][k]$，表示在第 $i$ 天，是否持有（其中 $j$ 为 0 表示未持有，1 表示持有）以及卖出了几次（其中 $k$ 为 0 表示卖出 0 次，1 表示卖出 1 次，2 表示卖出 2 次）股票的情况下，最大利润是多少。</strong></p><p>基于以上分析，我们就可以写出<strong>状态转移方程</strong>了。</p><p>$$DP(i, j, k)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, &amp; case1: j=0\ and\ k=0 \\\<br/>max(DP[i-1][1][0]+p[i], DP[i-1][0][1]), &amp; case2: j=0\ and\ k=1 \\\<br/>max(DP[i-1][1][1]+p[i], DP[i-1][0][2]), &amp; case3: j=0\ and\ k=2 \\\<br/>max(DP[i-1][0][0]-p[i], DP[i-1][1][0]), &amp; case4: j=1\ and\ k=0 \\\<br/>max(DP[i-1][0][1]-p[i], DP[i-1][1][1]), &amp; case5: j=1\ and\ k=1 \\\<br/>-INF, &amp; case5: j=1\ and\ k=2 \<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>这个状态转移方程比较复杂，需要进一步解释。</p><ol><li><p>初始化状态，如果当天未持股，而且到当天结束时从未卖出过股票，利润必定为 0。</p></li><li><p>如果当日结束时未持股，卖出过 1 次股票。那么在这种情况下，可能是今天卖出；也可能是之前卖出的，所以当天的利润可能存在两种情况。同时，我们需要从这两种情况中取最大值作为当天的最大利润：</p></li></ol><blockquote><p>a. 股票是当天卖出的；<br/>b. 股票是前一天卖出的（前一天肯定是未持股状态，而且已经卖出过 1 次股票）。</p></blockquote><ol start="3"><li>如果当日结束时未持股，卖出过 2 次股票。那么在这种情况下，可能是今天卖出；也可能是之前卖出的，所以当天的利润可能存在两种情况。同时，我们需要从这两种情况中取最大值作为当天的最大利润：</li></ol><blockquote><p>a. 股票是当天卖的；<br/>b. 股票是前一天已经卖出的（前一天肯定是未持股状态，而且已经卖出过 2 次股票）。</p></blockquote><ol start="4"><li>如果当日结束时持股，未卖出过股票。那么在这种情况下，可能是今天买进；也可能是之前买进的，所以当天的利润可能存在两种情况：</li></ol><blockquote><p>a. 股票是当天买进的；<br/>b. 股票是前一天已经买进的（前一天肯定是持股状态，而且从未卖出过股票）；<br/>因此，当天的最大利润就是从这两种情况中取最大值。需要注意的是，由于这里是买进股票的情况，所以如果当日买进了股票，那么利润需要减去当天的股票价值。</p></blockquote><ol start="5"><li>如果当日结束时持股，卖出过 1 次股票。那么在这种情况下，可能是今天买进；也可能是之前买进的，所以当天的利润可能存在两种情况：</li></ol><blockquote><p>a. 股票是当天买进的；<br/>b. 股票是前一天已经买进的（前一天肯定是持股状态，而且卖出过 1 次股票）；<br/>因此，当天的最大利润就是从这两种情况中取最大值。需要注意的是，由于这里是买进股票的情况，所以如果当日买进了股票，那么利润需要减去当天的股票价值。</p></blockquote><ol start="6"><li>如果当日结束后持有股票，卖出过 2 次股票。这种情况不存在，直接设置为 -INF （代码中要做对应的处理）。</li></ol><p>分析完毕，需要注意的情况比较多。你也会发现考察这类问题时，需要细心，不要遗漏掉原问题给出的条件，同时要注意卖出和买进之间的关系。</p><h3 id="编写代码进行求解"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#编写代码进行求解"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>写出该问题的状态转移方程，我们的工程就完成一大半了。现在，我给出求解该问题的代码实现。</p><p>Java实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getMaxStock(int[] prices) {</span></div><div class="token-line"><span class="token plain">        int m = prices.length;</span></div><div class="token-line"><span class="token plain">        int dp[][][] = new int[m][2][3];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 处理第一天</span></div><div class="token-line"><span class="token plain">        // 假设第一天没有买入</span></div><div class="token-line"><span class="token plain">        dp[0][0][0] = 0;</span></div><div class="token-line"><span class="token plain">        dp[0][0][1] = 0;</span></div><div class="token-line"><span class="token plain">        dp[0][0][2] = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 第一天不可能已卖出</span></div><div class="token-line"><span class="token plain">        dp[0][1][0] = -prices[0];</span></div><div class="token-line"><span class="token plain">        dp[0][1][1] = -prices[0];</span></div><div class="token-line"><span class="token plain">        dp[0][1][2] = -prices[0];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 处理后续日期</span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) {</span></div><div class="token-line"><span class="token plain">            dp[i][0][0] = 0;</span></div><div class="token-line"><span class="token plain">            dp[i][0][1] = Math.max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);</span></div><div class="token-line"><span class="token plain">            dp[i][0][2] = Math.max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][0] = Math.max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][1] = Math.max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][2] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return Math.max(dp[m - 1][0][1], dp[m - 1][0][2]); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetMaxStock(const vector&lt;int&gt;&amp; prices) {</span></div><div class="token-line"><span class="token plain">        int m = prices.size();</span></div><div class="token-line"><span class="token plain">        int dp[m][2][3];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 处理第一天</span></div><div class="token-line"><span class="token plain">        // 假设第一天没有买入</span></div><div class="token-line"><span class="token plain">        dp[0][0][0] = 0;</span></div><div class="token-line"><span class="token plain">        dp[0][0][1] = 0;</span></div><div class="token-line"><span class="token plain">        dp[0][0][2] = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 第一天不可能已卖出</span></div><div class="token-line"><span class="token plain">        dp[0][1][0] = -prices[0];</span></div><div class="token-line"><span class="token plain">        dp[0][1][1] = -prices[0];</span></div><div class="token-line"><span class="token plain">        dp[0][1][2] = -prices[0];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 处理后续日期</span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) {</span></div><div class="token-line"><span class="token plain">            dp[i][0][0] = 0;</span></div><div class="token-line"><span class="token plain">            dp[i][0][1] = max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);</span></div><div class="token-line"><span class="token plain">            dp[i][0][2] = max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][0] = max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][1] = max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]);</span></div><div class="token-line"><span class="token plain">            dp[i][1][2] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return max(dp[m - 1][0][1], dp[m - 1][0][2]); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过比较状态转移方程和代码实现，我们发现实现股票买卖问题的代码还是比较容易的。基本上，就是照搬状态转移方程中的状态转移定义。</p><h2 id="攻破买卖股票问题的解题模板"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#攻破买卖股票问题的解题模板"><span class="icon icon-link"></span></a>攻破买卖股票问题的解题模板</h2><p>在讨论了具体的买卖股票问题之后，你就会发现，买卖股票问题的条件设定比较灵活多变（比如问题中可能限定只能买卖一次，卖出一次之后可能需要等待一定时间才能买入），也就是有交易冷冻期，每次交易需要支付手续费等。稍作修改就可以变成另一道题。</p><p>因此，我们说买卖股票问题是一类容易考察的问题，我们很有必要提炼出攻破该类问题的解题模板（套路）。</p><h3 id="经过经验总结的解题模板"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#经过经验总结的解题模板"><span class="icon icon-link"></span></a>经过经验总结的解题模板</h3><p>我们可以这样描述买卖股票类型的问题。</p><p>给定一个数组，它的第 $i$ 个元素是一支给定的股票在<strong>第 $i$ 天</strong>的价格。设计一个算法来计算你所能获取的最大利润，你最多可以<strong>完成 $k$ 笔交易</strong>。附加条件是：</p><ol><li>每次卖出股票<strong>之后 $t$ 天内</strong>你无法进行任何交易，同时买入股票的时候会<strong>收取 $c$ 元的交易手续费</strong>；</li><li>你不能同时参与多笔交易，即你必须在再次购买前出售掉之前的股票。</li></ol><h3 id="对解题模板进行分析"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#对解题模板进行分析"><span class="icon icon-link"></span></a>对解题模板进行分析</h3><p>相比于前面我讲的具体的买卖股票问题，这个解题模板里多了这么几个要素：</p><ol><li>最多 2 笔交易变成了 $k$ 笔交易；</li><li>多了一个交易冻结期限制，即 $t$ 天之内无法进行任何交易；</li><li>买入股票可能需要交易手续费，即卖出股票的时候需要支付额外的费用。</li></ol><p>这几个因素产生的影响有：</p><ol><li>原本需要计算的是 2 次交易的最优解，现在需要求 $k$ 次交易的最优解；</li><li>原本只需要在前一天的基础上进行决策，现在由于存在冻结期 $t$。因此，卖出或买进股票时需要在冻结期之前进行决策，而不是前一天；</li><li>由于多了手续费 $c$，因此买入股票的时候需要扣掉手续费。</li></ol><p>从表面上看，解题模板比上面的问题更复杂。但如果仔细思考一下，其实整个问题的框架并没有什么实质性变化。</p><p>待解的问题依然是：确定每天结束时的最大利润。但是，由于原问题里多了一个交易冻结期 $t$ 的限制。因此，我们需要考虑的问题就变多了：不仅要在前一天的基础上做出决策，还需要考虑冻结期的时间。</p><p>至于 $k$ 笔交易和手续费 $c$，则不影响整个问题的解题框架。</p><p>在解题模板中，由于待解问题的核心不变，所以重叠子问题、无后效性和最优子结构，则与之前的问题没有变化，因此不再赘述。</p><h3 id="写出解题模板的状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#写出解题模板的状态转移方程"><span class="icon icon-link"></span></a>写出解题模板的状态转移方程</h3><p>对于解题模板中多出来的这些因素，都不会影响状态参数。因此状态参数没有发生变化，分别是：</p><ol><li>天数；</li><li>当天结束时是否持有股票；</li><li>股票卖出的次数。</li></ol><p>接着，我们来考虑状态存储，即备忘录的设计问题。由于现在交易次数上限从 2 次变成了 $k$ 次，因此状态存储空间需要改变。</p><p>在前面的具体买卖股票问题中，交易次数的上限是 2 次。那时，状态存储空间是三维数组 $DP[i][2][3]$，其中第三个维度表示股票卖出次数。那么，如果交易上限变成 $k$ 次，状态转移数组就变成了 <strong>$DP[i][j][k+1]$，表示在第 $i$ 天，是否持有（其中 $j$ 为 0 表示未持有，1 表示持有）以及卖出了几次（其中 $k$ 为 0 表示卖出 0 次，1 表示卖出 1 次，2 表示卖出 2 次 … 以此类推）股票的情况下，最大利润是多少。</strong></p><p>此外，我们还要考虑一下，求解这个问题存在哪些边界情况：</p><ol><li>第一种边界情况没有变化：如果当天结束时没有持股而且到当天结束时从未卖出过股票，这种情况利润肯定为0；</li><li>第二种边界情况发生了变化：由于交易次数限制从 2 次变成了 $k$ 次，因此这里边界变成：当天持股，而且卖出过 $k$ 次股票，而对于情况不存在的，利润设定为负无穷（实际情况下可能需要在编写代码时进行调整）。</li></ol><p>我们发现这个问题的状态参数基本没有发生改变，只有交易上限 $k$ 影响了状态存储和初始化参数。现在，给出状态转移方程。</p><p>$$DP(i, j, k)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, &amp; case1: j=0\ and\ k=0 \\\<br/>max(DP[i-1][1][k-1]+p[i], DP[i-1][0][k]), &amp; case2: j=0\ and\ k&lt;=k_<!-- -->{<!-- -->max<!-- -->}<!-- --> \\\<br/>max(DP[i-1-t][0][k]-p[i]-c, DP[i-1][1][k]), &amp; case4: j=1\ and\ k&lt;k_<!-- -->{<!-- -->max<!-- -->}<!-- --> \\\<br/>-INF, &amp; case5: j=1\ and\ k=k_<!-- -->{<!-- -->max<!-- -->}<!-- --> \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>同理，这个状态转移方程比较复杂。因此，我这里对其作出解释。</p><ol><li><p>初始化状态，如果当天未持股，而且到当天结束时从未卖出过股票，利润必定为0。</p></li><li><p>如果当日结束时未持股，卖出过 $k$ 次股票。那么在这种情况下，可能是今天卖出；也可能是之前卖出的，所以当天的利润可能存在两种情况。同时，我们需要从这两种情况中取最大值作为当天的最大利润：</p></li></ol><blockquote><p>a. 股票是当前卖出的（前一天肯定是持股状态，而且已经卖出过 $k-1$ 次股票）；<br/>b. 股票是前一天已经卖出的（前一天肯定是未持股状态，而且已经卖出过 $k$ 次股票）。</p></blockquote><ol start="3"><li>如果当日结束时持股，卖出过 $k$ 次股票。那么在这种情况下，可能是今天买进；也可能是之前买进的，所以当天的利润可能存在两种情况。同时，我们需要从这两种情况中取最大值作为当天的最大利润：</li></ol><blockquote><p>a. 股票是当天买进的（前 $t+1$ 天肯定是持股状态，而且已经卖出过 $k-1$ 次股票），这里需要考虑 $t$ 天的冻结期，$t$ 天之内无法交易的，所以上一个状态是 $(1+t)$ 天之前，而不是 1 天前；<br/>b. 股票是前一天已经买进的（前一天肯定是持股状态，而且卖出过1次股票）；<br/>因此，当天的最大利润就是从这两种情况中取最大值。需要注意的是，由于这里是买进股票的情况。所以，如果当日买进了股票，那么利润需要减去当天的股票价值。另外，由于我们可能涉及 $c$ 元的手续费，因此这里买入的时候需要扣去 $c$ 元的手续费，相当于股票的购入价格上升。</p></blockquote><ol start="4"><li>如果当日结束后持有股票，卖出过 $K_<!-- -->{<!-- -->max<!-- -->}<!-- -->$ 次股票，这种情况不存在，直接设置为 INF（编码时需要考虑这个怎么处理）。</li></ol><p>这样我们就能求出最后一天的最优解了。其实，冻结期 $t$ 和 $c$ 元手续费只影响了问题中的部分参数，比如冻结期 $t$ 影响了在买入股票时的状态转移参数（从 -1 变成了$-(1+t)$）；而手续费 $c$ 则影响了买入股票时的成本（多减去了 $c$ 元）；而最大售出次数则影响了边界条件。</p><h3 id="实例化解题模板"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#实例化解题模板"><span class="icon icon-link"></span></a>实例化解题模板</h3><p>现在，我们看一个实例化解题模板后的具体问题。</p><p>问题是这样的：给定一个数组，它的第 $i$ 个元素是一支给定的股票在<strong>第 $i$ 天</strong>的价格。请你设计一个算法来计算你所能获取的最大利润。你最多可以<strong>完成 3 笔交易</strong>。附加条件是：</p><ol><li>每次买入股票的时候会<strong>收取 2 元的交易手续费</strong>；</li><li>你不能同时参与多笔交易，即你必须在再次购买前出售掉之前的股票。</li></ol><p>根据前面的分析得知，<strong>状态参数</strong>有三个：天数、当天结束时是否持有股票、股票卖出的次数。对状态存储，即备忘录来说 <strong>$DP[i][2][4]$ 表示在第 $i$ 天，是否持有以及卖出了几次股票（最多 3 笔交易）的情况下，最大利润是多少。</strong></p><p>在写出状态转移方程前，再考虑一下初始化状态：</p><ol><li>第一种边界情况：如果当天结束时没有持股而且到当天结束时从未卖出过股票，这种情况利润肯定为 0；</li><li>第二种边界情况：当天持股，而且卖出过3次股票，这种情况不存在的，利润设定为 -INF（实际情况下可能需要编码时调整）。</li></ol><p>最后，我们根据以上信息给出了状态转移方程：</p><p>$$DP(i, j, k)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, &amp; case1: j=0\ and\ k=0 \\\<br/>max(DP(i-1,1,k-1)+p[i], DP(i-1,0,k)), &amp; case2: j=0\ and\ k&lt;=3 \\\<br/>max(DP(i-1,0,k)-p[i]-2, DP(i-1,1,k)), &amp; case4: j=1\ and\ k&lt;3 \\\<br/>-INF, &amp; case5: j=1\ and\ k=3 \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>这里，我们把最大次数 $K_<!-- -->{<!-- -->max<!-- -->}<!-- -->$ 替换成了 3，把冻结期 $t$ 替换成 0，把手续费 $c$ 替换成 2。通过买卖股票的解题模板，我们就能非常轻松地解决这些问题了。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>鉴于我们刚刚已经总结了解题模版，这里就不再赘述了。最后再啰嗦一句吧，其实很多动态规划问题就像我们处理股票问题的框架一样，很多类似的题目都可以通过总结分析，直接套用模板，效果会非常好！你不妨多去试试。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/06#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>你能否写出通用的买卖股票的代码实现。另外，请你思考一下是否存在时间或空间复杂度优化的可能性？</p><p>期待你的分享，任何问题欢迎来留言区一起讨论！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/动态规划面试宝典/03.动态规划的套路/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
