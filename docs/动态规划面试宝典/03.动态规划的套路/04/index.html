<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>09｜子序列问题：详解重要的一大类动态规划问题 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/03.动态规划的套路/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a aria-current="page" class="active" href="/blog/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是子序列问题？" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#什么是子序列问题"><span>什么是子序列问题？</span></a></li><li title="最长回文子序列" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#最长回文子序列"><span>最长回文子序列</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#算法问题分析"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#写出状态转移方程"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#编写代码进行求解"><span>编写代码进行求解</span></a></li><li title="最长公共子序列" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#最长公共子序列"><span>最长公共子序列</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#算法问题分析-1"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#写出状态转移方程-1"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#编写代码进行求解-1"><span>编写代码进行求解</span></a></li><li title="课程总结" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog/动态规划面试宝典/03.动态规划的套路/04#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09子序列问题详解重要的一大类动态规划问题"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#09子序列问题详解重要的一大类动态规划问题"><span class="icon icon-link"></span></a>09｜子序列问题：详解重要的一大类动态规划问题</h1><p>你好，我是卢誉声。</p><p>我们曾在上一课中提到，有两类重要的动态规划问题需要掌握，其中一个是子数组问题，另一个是子序列问题。今天，我们将深入讲解动态规划中的另一个经典问题，即子序列问题。</p><p>相较于子数组问题而言，子序列问题要更复杂一些，这是由子序列的特性决定的。不过有一点比较类似，那就是我们仍然需要小心定义备忘录结构和其对应值的含义。</p><p>你应该注意到了，我们把子数组问题和子序列问题放在一块儿讲，这意味着它们之间是有联系的。因此，在开始今天的课程前，我提出这样一个问题：<strong>子数组和子序列问题在求解时有什么异同呢？</strong></p><p>接下来就让我们带着这个问题，开始今天的学习之旅吧。</p><h2 id="什么是子序列问题"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#什么是子序列问题"><span class="icon icon-link"></span></a>什么是子序列问题？</h2><p>类似的，我们要明确一下什么是动态规划中的子序列问题。首先，相较于子数组问题而言，子序列问题要更复杂一些。这是因为，子数组问题是连续的，而子序列问题是不连续的。比如说字符串 “I wanna keep a giraffe in my backyard” 的一种子序列就可以是 “Igbackd”。</p><p>因此，你可以看到，子序列不再要求答案是一个连续的串。即便用穷举的思路求解问题，我们都不一定知道该从何下手解决。特别的，当涉及到两个数组或字符串作为输入的情况时，如果没有处理经验，真的不容易想到解法。</p><p>其次，一个字符串的子序列，是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。举个例子，“ace” 是 “abcde” 的子序列，但是 “aec” 就不是 “abcde” 的子序列。</p><p>再次，如果一个问题涉及以下特征，那么它大概率需要使用动态规划来进行求解：</p><ol><li>题目涉及子序列；</li><li>问题符合动归典型特征，特别是求“最”优解问题（最大值和最小值）；</li><li>题目的答案是题设数组的子序列，或者来源于子序列。</li></ol><p>其实，一旦技术面试问题涉及子序列，你都几乎不需要考虑动态规划以外的解法了。为什么这么说呢？你考虑一下，一个数组或字符串子序列的组合数肯定是指数级别的，如果想依赖纯粹的穷举来进行求解，从时间复杂度上看，几乎没有求解的可能性。</p><p>所以啊，我们虽然说动态规划中的子序列问题是经典动归问题，但它不同于0-1背包这种经典问题，事实上它并不好解决。不过我们都学到这了，你应该坚信再难的动归问题都应该有模板可以应对。</p><p>没错，今天就让我们用两个经典的案例，来找出解决子序列问题的思路。</p><h2 id="最长回文子序列"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#最长回文子序列"><span class="icon icon-link"></span></a>最长回文子序列</h2><p>如果问题含有最长子序列这样的提法，那么它一定是动态规划问题。现在，先让我们一起来看一看最长“回文”子序列问题的描述。</p><p>问题：给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：&quot;asssasms&quot;</span></div><div class="token-line"><span class="token plain">    输出：5</span></div><div class="token-line"><span class="token plain">    解释：一个可能的最长回文子序列为 &quot;sssss&quot;，另一种可能的答案是 &quot;asssa&quot;。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：&quot;abba&quot;</span></div><div class="token-line"><span class="token plain">    输出：4</span></div><div class="token-line"><span class="token plain">    解释：有三个子序列满足题设要求：&quot;aa&quot;、&quot;bb&quot; 和 &quot;abba&quot;，因此答案为 4。</span></div></pre></div><h3 id="算法问题分析"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#算法问题分析"><span class="icon icon-link"></span></a>算法问题分析</h3><p>还记得在解决回文子串时给出的那个简单例子么？我们当时有提到过 “子数组问题的特征是答案也必须是连续的”。显然，子序列问题的特征发生了变化，它的答案可以是连续的，也可以是不连续的。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimagebbb2bbec56f66358506ba5952efc9c0293b2.png" alt=""/></p><p>我现在输入的字符串是 “abca”，那么 “aca” 是原问题的答案吗？在子数组问题中不是；但现在，“aca” 是原问题的答案了。</p><p>我在前面曾提到过涉及子序列的问题基本上全部都是动态规划问题。那么这个问题符合动态规划问题的特征吗？我们来看一下：</p><ol><li>重叠子问题：在穷举的过程中肯定存在重复计算的问题。这是因为各种排列组合间肯定存在重叠子问题的情况；</li><li>无后效性：对不是最长的回文子序列来说，它一定被包含在更长的回文子序列中。而更长的回文子序列不会包含在较短的回文子序列中，依赖是单向的；</li><li>最优子结构：对整个字符串，其最长的回文子序列肯定包含了更短长度字符串中的回文子序列，因此子问题可以递归求解。</li></ol><p>既然是动归问题，接下来我们看看该如何写出状态转移方程吧。</p><h3 id="写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#写出状态转移方程"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>首先，我们先来确定<strong>初始化状态</strong>。从问题的示例就可以看出（当然也很容易想到），单个字符一定是它自己的回文。</p><p>接着，再来确定<strong>状态参数</strong>。跟回文子串问题类似，我们需要确定子序列的位置：一个是起始位置，另一个是结束位置。在算法的执行过程中，起始和结束位置是变化的，因此它们是状态参数。</p><p>既然有两个状态，我们用二维数组来定义备忘录。设 <strong>$DP[i][j]$，其对应的值是字符串 $i…j$ 中最长回文子序列的长度</strong>。你可能会问，为何要这样设计备忘录的定义呢？我们曾在讲解子数组问题时讨论了 “备忘录定义对编写代码的影响”，这里的影响其实并不直接是代码，主要影响的是状态转移方程的设计（因为有了状态转移方程，才能编写代码嘛）。</p><p>现在让我们回到动态规划问题的本质问题上来。动态规划是数学归纳法的一种很好的体现，即如何从已知的答案推导出未知的部分。回到最长回文子序列问题上来，如果知道了 $s[i+1 … j-1]$ 中最长回文子序列的长度（即 $DP[i+1][j-1]$），我们能通过它推导出 $s[i … j]$ 中最长回文子序列的长度（即 $DP[i][j]$）吗？</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimage034603732428e6aa1e2880d7c2b50dcf7546.png" alt=""/></p><p>根据以上决策示意图，我们显然可以通过 $DP[i+1][j-1]$ 求出 $DP[i][j]$。这是因为状态转移是连续的，我们可以通过向左移动一位或向右移动一位，得到更大规模子问题的答案。</p><p>那么让状态转移的<strong>决策</strong>是什么呢？其实这里的决策跟回文子串问题类似，当前子问题的答案就是通过前面的子问题 ➕ 当前的决策推导出来的。</p><p>而当前的<strong>决策</strong>就是：计算出向子问题的两边分别扩充一个元素后得到的答案。你可以参考示意图来更好地理解这个状态转移过程。</p><p>一切就绪了，现在就可以给出回文子串问题的状态转移方程了。我们仍然把字符串当作数组来访问，并考虑当 $s[i] == s[j]$ 和 $s[i] != s[j]$ 两种情况进行讨论：</p><ol><li>如果 $s[i] == s[j]$（示意图是相等的），那么 $DP[i][j] = 2 + DP[i+1][j-1]$；</li><li>如果 $s[i] != s[j]$，就意味着 $s[i]$ 和 $s[j]$ 是不可能同时出现在 $s[i … j]$ 的最⻓回文子序列中的。这时我们该怎么做？这里需要进一步作出决策。</li></ol><p>既然 $s[i] != s[j]$，我们可以考虑把 $s[i]$ 和 $s[j]$ 分别放入 $s[i+1 … j-1]$ 中试试，这样就会产生两个子状态，其中状态A：$s[i … j-1]$；状态B：$s[i+1 … j]$。接着，再看看哪个子串产生的回文子序列更⻓，即 max(状态A, 状态B)。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimage27ea276bf4ed8234cef82cd2125a5e7955ea.png" alt=""/></p><p>这个过程可以用以上示意图进行描述。在示意图中，状态A：$DP[0][4] = 5$；状态B：$DP[1][5] = 4$。因此，这里通过决策后得到的状态应该是 max(状态A, 状态B) = 5。</p><p>$$DP(i, j)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>2 + DP[i+1][j-1],\ s[i]==s[j]\\\<br/>max(DP[i+1][j], DP[i][j-1]),\ s[i] \ne s[j]<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><h3 id="编写代码进行求解"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#编写代码进行求解"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>所有先决条件都解决了，现在我们来看一下如何用动归来求解此问题，我直接给出代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getLongestPalindromeSubseq(String s) {</span></div><div class="token-line"><span class="token plain">        int n = s.length(); if (0 == n) return 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[n][n]; </span></div><div class="token-line"><span class="token plain">        for (int[] row : dp) { Arrays.fill(row, 0); }</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i++) dp[i][i] = 1; // 初始化状态</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = n-1; i &gt;= 0; i--) {</span></div><div class="token-line"><span class="token plain">            for (int j = i+1; j &lt; n; j++) {</span></div><div class="token-line"><span class="token plain">                if (s.charAt(i)==s.charAt(j)) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = 2 + dp[i+1][j-1];</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]); // 作出进一步决策</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[0][n-1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetLongestPalindromeSubseq(string s) {</span></div><div class="token-line"><span class="token plain">        int n = static_cast&lt;int&gt;(s.size());</span></div><div class="token-line"><span class="token plain">        if (0 == n) return 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int dp[n][n]; memset(dp, 0, sizeof(dp));</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i++) dp[i][i] = 1; // 初始化状态</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = n-1; i &gt;= 0; i--) {</span></div><div class="token-line"><span class="token plain">            for (int j = i+1; j &lt; n; j++) {</span></div><div class="token-line"><span class="token plain">                if (s[i]==s[j]) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = 2 + dp[i+1][j-1];</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]); // 作出进一步决策</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[0][n-1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在代码实现中，我们先进行了初始化状态的操作，将备忘录初始化为全 0 （编程习惯）。此外，单个字符一定是它自己的回文，因此备忘录中的对角线都是 1。</p><p>除此之外，你有没有发现这里对字符串迭代的顺序作了特别处理？没错，这是刻意为之的。为什么我们需要这样迭代字符串呢？这就涉及到了动态规划的计算方向问题了。</p><p>这是我们第一次在专栏中提出<strong>计算方向</strong>的概念，这是彻底理解动态规划问题的重中之重。如果你仔细阅读了之前课程中的状态转移图，你就会发现，我曾多次在图中用红色的箭头标出状态转移的方向。</p><p>事实上，那就是计算方向了，只不过对于我们之前遇到的问题来说，都是从左上到右下进行计算的。</p><p>对于回文子序列问题来说，根据备忘录的定义，由于我们最终需要的答案存放在 $DP[0][n-1]$中，因此需要从最右下角反向推导：$DP[i][j]$ 需要的是其左侧 $DP[i][j-1]$、左下角 $DP[i+1][j-1]$ 以及正下方 $DP[i+1][j]$ 的值来满足上述状态转移方程。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimagedbc5dbdedd4d624cb7aa6bb734c15a2f0bc5.png" alt=""/></p><p>按照图片所展示的，$DP[0][7]$ 是根据 $DP[0][6]$、$DP[1][6]$ 和 $DP[1][7]$ 推导出来的。</p><p>当前子问题的计算，需要依赖于哪些更小的子问题推导出来呢？寻找这个线索，你应该能够找出备忘录上的计算方向。</p><p>如果你还没有完全理解计算方向这个问题，也不需要担心，在后续的课程中我们还会遇到这个问题，而且还有专题去彻底讲清楚计算方向这个概念。</p><h2 id="最长公共子序列"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#最长公共子序列"><span class="icon icon-link"></span></a>最长公共子序列</h2><p>刚才我们有提到过，当涉及到两个数组或字符串作为输入的情况时，问题会变得比较复杂。而最长公共子序列（Longest Common Subsequence，LCS）问题就需要从两个字符串中寻找公共子序列。让我们来看看这个问题的描述。</p><p>问题：给定两个字符串 $text1$ 和 $text2$，返回这两个字符串的最长公共子序列的长度。若这两个字符串没有公共子序列，则返回 0。其中：</p><ul><li>1 ≤ text1.length ≤ 1000；</li><li>1 ≤ text2.length ≤ 1000；</li><li>输入的字符串只含有小写英文字符。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：text1 = &quot;abcde&quot;, text2 = &quot;ade&quot; </span></div><div class="token-line"><span class="token plain">    输出：3  </span></div><div class="token-line"><span class="token plain">    解释：最长公共子序列是 &quot;ade&quot;，它的长度为 3。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2:</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span></div><div class="token-line"><span class="token plain">    输出：0</span></div><div class="token-line"><span class="token plain">    解释：显然，两个字符串没有公共子序列，返回 0。</span></div></pre></div><h3 id="算法问题分析-1"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#算法问题分析-1"><span class="icon icon-link"></span></a>算法问题分析</h3><p>一般来说，在处理多个字符串的动态规划问题时，如果用数组作为备忘录的基本数据结构，那么它的维度则跟字符串的个数是线性相关的，即有几个字符串待解决，我们就创建几维的数组。当然也有例外，有些问题可能是将多个字符串进行合并，然后达到降维的目的。</p><p>一个数组或字符串子序列的组合数肯定是指数级别的。如果想依赖纯粹的穷举来进行求解，从时间复杂度上看，几乎没有求解的可能性。因此我们几乎可以“武断”地判断该问题需使用动态规划来进行求解。</p><p>你可以根据我们多次提到的判断方法，来判断该问题是否满足重叠子问题、无后效性和最优子结构这几个特征。然后，再接着往下看。</p><p>在这个问题中，我们需要创建一个二维数组作为我们的备忘录来存储中间计算的状态。既然已经确定了是二维数组，那么我们该如何理解备忘录的定义呢？</p><p>由于这个问题较为复杂，需要一些技巧，因此我在这里先给出备忘录的定义，解完题目之后我们再倒回来理解为何要这样设计。</p><h3 id="写出状态转移方程-1"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#写出状态转移方程-1"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>现在，我直接给出最长公共子序列问题的备忘录定义。<strong>$DP[i][j]$ 表示的是 $text1[0 … i]$ 和 $text2[0 … j]$ 的最长公共子序列的长度</strong>。</p><p>如果我们以示例 1 中的输入作为例子，就可以画出备忘录。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimage1e641e4f673ac02e7c69e97f0b5dde46f564.png" alt=""/></p><p>其中红色箭头展示了状态转移的<strong>计算方向</strong>。从图中可以得知，$DP[2][4] = 2$，其含义是 “ad”（即 $text2[0 … 2]$）和 “abcd”（即 $text1[0 … 4]$）的最长公共子序列的长度；$DP[3][5] = 3$ 即 “ade”（即 $text2[0 … 3]$）和 “abcde”（即 $text1[0 … 5]$）的最长公共子序列的长度，即原问题的答案。</p><p>通过上图的展示，你可能会产生一个疑问，那就是为何要设计一个空字符作为计算开始的位置。这其实是<strong>初始化状态</strong>的一部分。当两个字符的其中一个为空串，或同时为空串时，原问题的答案肯定是 0。显然，一个字符串与空串的公共子序列肯定是空的。与此同时，这样的设计还能让真正的字符串迭代拥有能够推导计算的初始化值。</p><p>接着，我们再来看<strong>状态参数</strong>。根据前面的描述，我们用变量 $i$ 和变量 $j$ 描述了整个问题的求解空间，备忘录是基于二维数组构建的。因此，我们的状态参数就是变量 $i$ 和变量 $j$。</p><p>最后，我们该如何<strong>决策</strong>状态的转移？对于 $text1$ 和 $text2$ 这两个字符串中的每个字符 $text1[i]$ 和 $text2[j]$，其实只有两种选择：</p><ol><li>$text1[i-1] == text2[j-1]$，即当前遍历的两个字符在最长公共子序列中，此时 $DP[i][j] = 1 + DP[i-1][j-1]$；</li><li>$text1[i-1] != text2[j-1]$，即当前遍历的两个字符<strong>至少有一个不在</strong>最长公共子序列中。仿照最长回文子序列的处理方法，由于两个字符至少有一个不在，因此我们需要丢弃一个。因此在不等的情况下，需要进一步作出决策。</li></ol><p>由于我们要求的是最长公共子序列，因此哪个子问题的答案比较长，就留下谁：$max(DP[i-1][j]$, $DP[i][j-1]$)。通过以上线索，我们得出了求解该问题的状态转移方程。</p><p>$$DP(i, j)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>dp[i][j] = 1 + dp[i-1][j-1],\ text1[i]==text2[j]\\\<br/>max(dp[i-1][j], dp[i][j-1]),\ text1[i] \ne text2[j]<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><h3 id="编写代码进行求解-1"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#编写代码进行求解-1"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>我直接给出状态转移方程对应的求解代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getLongestCommonSubsequence(String text1, String text2) {</span></div><div class="token-line"><span class="token plain">        int m = text1.length(), n = text2.length();</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[m + 1][n + 1];</span></div><div class="token-line"><span class="token plain">        for (int[] row: dp) { Arrays.fill(row, 0); }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int j = 1; j &lt;= n; j++) {</span></div><div class="token-line"><span class="token plain">            for (int i = 1; i &lt;= m; i++) {</span></div><div class="token-line"><span class="token plain">                if (text2.charAt(j - 1) == text1.charAt(i - 1)) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m][n];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetLongestCommonSubsequence(string text1, string text2) {</span></div><div class="token-line"><span class="token plain">        int m = text1.size(), n = text2.size();</span></div><div class="token-line"><span class="token plain">        int dp[m+1][n+1]; memset(dp, 0, sizeof(dp)); // 多一行一列为了 i, j=1 时有 base value</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int j = 1; j &lt;= n; j++) {</span></div><div class="token-line"><span class="token plain">            for (int i = 1; i &lt;= m; i++) {</span></div><div class="token-line"><span class="token plain">                if (text2[j-1]==text1[i-1]) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i-1][j-1] + 1;</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m][n];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在代码中，我们先进行了初始化状态的操作，将备忘录初始化为全 0 （编程习惯）。</p><p>接着，我们分别遍历两个字符串，外层循环遍历第一个字符串，从 1 开始到 n（第一个字符串长度）为止；内层循环遍历第二个字符串，从 1 开始到 m（第二个字符串长度）为止。</p><p>每次先比较一下两个字符串的当前字符：</p><ol><li>如果当前字符相同，那么说明当前遍历的两个字符均在最长公共子序列中，因此需要将当前序列长度加 1。由于之前的序列长度在 $dp[i-1][j-1]$，因此结果是 $dp[i-1][j-1] + 1$；</li><li>如果当前字符不同，我们需要从之前的序列中选取一个最大的，也就是从 $dp[i-1][j]$ 和 $dp[i][j-1]$ 中取最大值。</li></ol><p>求解结束后，原问题的答案存储在 $dp[m][n]$ 中。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>动态规划领域中，所谓子序列问题，就是从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列；而对子数组问题，则是从给定的序列中提取连续的序列。</p><p>所以，子序列问题往往比子数组问题要复杂一些，因为求解的子问题可能不是连续的字符串。但是，对于动态规划来说，处理问题的思路往往是不变的，其实只是换一种思路去寻找子问题罢了。</p><p>从我们分析的两个问题中基本可以看出子序列问题的处理模板，在子序列问题中由于暴力求解的代价更高，因此动态规划带来的价值也就更高。对于全面总结的处理子序列问题的动归套路，我会在下一个模块中进行讲解。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog/动态规划面试宝典/03.动态规划的套路/04#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>对于这一课讲解的最长公共子序列问题，我们对最直接的解决方案进行了讲解。但实际上，代码还可以作出进一步优化。请你思考一下，如何优化这个方案的时间复杂度和空间复杂度？并给出改进后的算法代码。</p><p>欢迎留言和我分享你的想法，我们一同交流！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/动态规划面试宝典/03.动态规划的套路/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
