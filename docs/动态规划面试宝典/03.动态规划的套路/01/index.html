<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06 | 0-1背包：动态规划的Hello World - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/03.动态规划的套路/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="0-1 背包问题" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#0-1-背包问题"><span>0-1 背包问题</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#算法问题分析"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#写出状态转移方程"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#编写代码进行求解"><span>编写代码进行求解</span></a></li><li title="0-1 背包问题的延伸" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#0-1-背包问题的延伸"><span>0-1 背包问题的延伸</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#算法问题分析-1"><span>算法问题分析</span></a></li><li title="转化成动态规划问题" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#转化成动态规划问题"><span>转化成动态规划问题</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#写出状态转移方程-1"><span>写出状态转移方程</span></a></li><li title="通用的动态规划" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#通用的动态规划"><span>通用的动态规划</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06--0-1背包动态规划的hello-world"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#06--0-1背包动态规划的hello-world"><span class="icon icon-link"></span></a>06 | 0-1背包：动态规划的Hello World</h1><p>你好，我是卢誉声。从今天开始，我们正式进入动态规划套路模块。</p><p>不知道你是否跟我有过相似的经历，那就是提起动态规划，最先想到的就是背包问题。事实上，背包问题分很多种，大多数人首先遇到的一般是背包中的0-1背包问题。</p><p>因此，我把这个问题称作 Hello World，这跟我们学习一门新的编程语言十分相似。它很经典，又极具代表性，能很好地展示动态规划思想，对于你掌握动态规划面试题来说，也十分有帮助。</p><p>在“初识动态规划”模块中，相信你已经对动态规划问题有了一个比较全面的认识和了解。今天，就让我们用一用前面所学的解题思路，其实就是把总结出来的套路，套用在0-1背包问题上，看看能不能解决这道题。</p><p>那在开始前呢，我还是先提出一个简单的问题，那就是：**为什么将它称作0-1背包问题，0-1代表什么？**你不妨带着这个小问题，来学习今天的内容。</p><h2 id="0-1-背包问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#0-1-背包问题"><span class="icon icon-link"></span></a>0-1 背包问题</h2><p>我们先来看看0-1背包问题的描述。</p><p>问题：给你一个可放总重量为 $W$ 的背包和 $N$ 个物品，对每个物品，有重量 $w$ 和价值 $v$ 两个属性，那么第 $i$ 个物品的重量为 $w[i]$，价值为 $v[i]$。现在让你用这个背包装物品，问最多能装的价值是多少？</p><p>示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：W = 5, N = 3</span></div><div class="token-line"><span class="token plain">         w = [3, 2, 1], v = [5, 2, 3]</span></div><div class="token-line"><span class="token plain">    输出：8</span></div><div class="token-line"><span class="token plain">    解释：选择 i=0 和 i=2 这两件物品装进背包。它们的总重量 4 小于 W，同时可以获得最大价值 8。</span></div></pre></div><h3 id="算法问题分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#算法问题分析"><span class="icon icon-link"></span></a>算法问题分析</h3><p>这个问题的描述和示例都比较简单，而且容易理解。当遇到这样一个问题时，你该从哪里下手呢？</p><p>如果你是一个动态规划老手，当然就能一眼看出这是个动态规划问题。但如果你是第一次接触，也不用担心，接下来我就带着你判断一下。</p><p>按照我之前给你说过的思路，先看问题是怎么问的：“最多能装的价值的多少？”注意这里有一个“最”字，遇到这种问题我们应该最先想到什么呢？没错，贪心算法。那么贪心算法的局部最优能解决我们的问题吗？</p><p>事实上不太能，因为如果按照贪心算法来解的话，我们很难得到整体最优解。举个简单的例子，按照示例给出的输入，如果我们先选择 $i=0$ 和 $ i=1$ 的物品，那么总重量正好是$W=5$，但这不是最优解，因为总价值才 $7$。因此，为了获得整体最优解，我们该怎么办呢？显然就是穷举。</p><p>在后续的课程中，我会与你分享更多面试实战题目。届时你就会发现，当问题复杂到一定程度后，穷举真的不是一件容易的事。因此，我们优先考虑使用动态规划来解决这个问题。那么该问题满足动态规划的特征吗？我在这列举出来，你对照看一下：</p><ol><li>重叠子问题：对于0-1背包问题来说，即便我们不画出求解树，也能很容易看出在穷举的过程中存在重复计算的问题。这是因为各种排列组合间肯定存在重叠子问题的情况；</li><li>无后效性：当我们选定了一个物品后，它的重量与价值就随即确定了，后续选择的物品不会对当前这个选择产生副作用。因此，该问题无后效性；</li><li>最优子结构：当我们选定了一个物品后，继续做决策时，我们是可以使用之前计算的重量和价值的，也就是说后续的计算可以通过前面的状态推导出来。因此，该问题存在最优子结构。</li></ol><h3 id="写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#写出状态转移方程"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>现在，我们确定了这是一个动态规划问题。接下来，让我们一起看看如何写出动态规划算法的核心，即状态转移方程。还记得之前总结的动态规划求解框架（或者说套路）吗？</p><p>首先，我们先来确定初始化状态。任何穷举算法（包括递归在内）都需要一个终止条件，这个所谓的终止条件，就是我们在动态规划解法当中的最初子问题，因此我们将其称作<strong>初始化状态</strong>。</p><p>在0-1背包中，这个终止条件是什么呢？显然，当背包的容量为 0 或者物品的数量为 0 时要终止执行。如果体现在代码上，就是当物品总数为 0 时重量为 0；而重量为 0 时显然物品数量也为 0。</p><p>接着，在什么情况下，会导致计算过程中不断逼近上面提到的初始化状态呢？其实题目中已经给出了答案。我们从背包的角度看待这个问题，将物品放入背包时：</p><ol><li>背包内物品的数量 $N$ 在增加，它是一个变量；</li><li>同时，背包还能装下的重量 $W$ 在减少，它也是一个变量。</li></ol><p>因此，当前背包内的物品数量 $N$ 和背包还能装下的重量 $W$ 就是这个动态规划问题的<strong>状态参数</strong>。</p><p>然后，我们再来看如何进行<strong>决策</strong>。在0-1背包问题中，我们的决策无非就是该不该把当前这个物品放入背包中：如果将该物品放入背包，子问题的答案是多少；如果没有放入，子问题的答案又是多少。</p><p>我们曾说过，通常情况下，状态转移方程的参数就是状态转移过程中的变量，即状态参数。而函数的返回值就是答案，在这里就是最大价值。因此，我们从上面两种决策情况中取最优解，即 max (放入该物品, 不放入该物品)。</p><p>在确定了初始化状态、状态参数和决策后，我们就可以开始尝试写状态转移方程了。由于这是我们第一次正式面对动归问题，我会先把递归形式的状态转移过程描述出来，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/* </span></div><div class="token-line"><span class="token plain">     * tn: traversed n，即已经遍历过的物品；</span></div><div class="token-line"><span class="token plain">     * rw: reserved w，即背包还能容量的重量。</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    DP(int tn, int rw) {</span></div><div class="token-line"><span class="token plain">      // 当遍历完所有物品时，就该返回 0 了，因为没有物品也就没有价值了</span></div><div class="token-line"><span class="token plain">      if tn &lt; 0</span></div><div class="token-line"><span class="token plain">        return 0</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 当背包还能容纳的重量已经小于当前物品的重量时，显然这个物品不能放入背包</span></div><div class="token-line"><span class="token plain">      if rw &lt; w[tn]</span></div><div class="token-line"><span class="token plain">        return DP(tn - 1, rw)</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 作出决策，该不该放入物品：</span></div><div class="token-line"><span class="token plain">      //   1. 放入：那么价值是 DP(tn - 1, rw - w[tn])；</span></div><div class="token-line"><span class="token plain">      //   2. 不放入：那么价值是 DP(tn - 1, rw)。</span></div><div class="token-line"><span class="token plain">      return max(DP(tn - 1, rw), DP(tn - 1, rw - w[tn]) + v[tn])</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>顺着这个思路，我把状态转移方程给写出来，它是这样的：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, tn&lt;=0\\\<br/>0, rw&lt;=0\\\<br/>DP(tn-1,rw), rw&lt;w[tn]\\\<br/>max(DP(tn-1,rw), DP(tn-1,rw-w[tn])+v[tn])),rw&gt;=w[tn]<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>现在，我们有了针对0-1背包问题的完整状态转移方程，可以开始编写代码了。</p><h3 id="编写代码进行求解"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#编写代码进行求解"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>但在编写代码前，还有一个小问题需要解决，就是我们需要为动态规划代码准备一个备忘录，来存储计算过的子问题答案。那么这个备忘录的数据结构应该是什么样的呢？</p><p>从前面的分析可以看出，状态转移方程中有两个状态参数，并通过这两个状态参数确定了一个子问题的答案。因此，我们可以使用一个二维数组作为备忘录。</p><p>为了通用起见，我将其命名为$DP[tn][rw]$，其中行代表的是 $tn$，表示第几个物品；列代表的是$rw$，表示背包还能容纳的重量。这个索引组合（比如$DP[2][3]$）对应位置的值，就是这个子问题的答案，表示当背包还能容纳 3 的重量时，放入前 2 件物品的最大价值。</p><p>所有先决条件都解决了，现在来看一下如何用标准的动归解法来求解此问题，我直接给出代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int dp(int[] w, int[] v, int N, int W) {</span></div><div class="token-line"><span class="token plain">        // 创建备忘录</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[N+1][W+1];</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }</span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">        for (int tn = 1; tn &lt; N + 1; tn++) { // 遍历每一件物品</span></div><div class="token-line"><span class="token plain">    		for (int rw = 1; rw &lt; W + 1; rw++) { // 背包容量有多大就还要计算多少次</span></div><div class="token-line"><span class="token plain">        		if (rw &lt; w[tn]) {</span></div><div class="token-line"><span class="token plain">        			// 当背包容量小于第tn件物品重量时，只能放入前tn-1件</span></div><div class="token-line"><span class="token plain">        			dp[tn][rw] = dp[tn-1][rw];</span></div><div class="token-line"><span class="token plain">        		} else {</span></div><div class="token-line"><span class="token plain">                    // 当背包容量还大于第tn件物品重量时，进一步作出决策</span></div><div class="token-line"><span class="token plain">        			dp[tn][rw] = Math.max(dp[tn-1][rw], dp[tn-1][rw-w[tn]] + v[tn]);</span></div><div class="token-line"><span class="token plain">        		}</span></div><div class="token-line"><span class="token plain">        	}</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return dp[N][W];</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int solveDP() {</span></div><div class="token-line"><span class="token plain">      int N = 3, W = 5; // 物品的总数，背包能容纳的总重量</span></div><div class="token-line"><span class="token plain">      int[] w = {0, 3, 2, 1}; // 物品的重量</span></div><div class="token-line"><span class="token plain">      int[] v = {0, 5, 2, 3}; // 物品的价值</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return dp(w, v, N, W); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int DP(const std::vector&lt;int&gt;&amp; w, const std::vector&lt;int&gt;&amp; v, int N, int W) {</span></div><div class="token-line"><span class="token plain">      int dp[N+1][W+1]; memset(dp, 0, sizeof(dp)); // 创建备忘录</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 初始化状态</span></div><div class="token-line"><span class="token plain">      for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }</span></div><div class="token-line"><span class="token plain">      for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      for (int tn = 1; tn &lt; N + 1; tn++) { // 遍历每一件物品</span></div><div class="token-line"><span class="token plain">        for (int rw = 1; rw &lt; W + 1; rw++) { // 背包容量有多大就还要计算多少次</span></div><div class="token-line"><span class="token plain">          if (rw &lt; w[tn]) {</span></div><div class="token-line"><span class="token plain">            // 当背包容量小于第tn件物品重量时，只能放入前tn-1件</span></div><div class="token-line"><span class="token plain">            dp[tn][rw] = dp[tn-1][rw];</span></div><div class="token-line"><span class="token plain">          } else {</span></div><div class="token-line"><span class="token plain">            // 当背包容量还大于第tn件物品重量时，进一步作出决策</span></div><div class="token-line"><span class="token plain">            dp[tn][rw] = max(dp[tn-1][rw], dp[tn-1][rw-w[tn]] + v[tn]);</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return dp[N][W];</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int DPSol() {</span></div><div class="token-line"><span class="token plain">      int N = 3, W = 5; // 物品的总数，背包能容纳的总重量</span></div><div class="token-line"><span class="token plain">      std::vector&lt;int&gt; w = {0, 3, 2, 1}; // 物品的重量</span></div><div class="token-line"><span class="token plain">      std::vector&lt;int&gt; v = {0, 5, 2, 3}; // 物品的价值</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      return DP(w, v, N, W); // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们几乎照搬了状态转移方程描述的内容到代码里，因此这段代码通俗易懂。</p><p>首先，我们定义了两个数组，其中 $w$ 用来表示物品的重量，而 $v$ 用来表示物品的价值。这里需要注意的是，每个数组的第 0 项都是 0。由于小于 0 的值对应的都应该是 0，因此我们可以通过这个方法来省去冗余的 if 判断逻辑。</p><p>我们已经定义了备忘录即 $DP[tn][rw]$ 数组的含义：当背包还能装 $rw$ 重量的物品，放入了前 $tn$ 件物品时的最大价值。接下来，我们再依据状态转移方程的定义来<strong>初始化状态</strong>：</p><ol><li>创建一个大小为 N+1 / W+1 的二维数组，并将所有位置初始化为0；</li><li>初始化状态，即前面提到的穷举的终止条件，把所有的 $dp[0][i]$ 和 $dp[j][0]$ 全部都设置为 0。</li></ol><p>接着，进入编写函数主体循环的阶段，让我们看看每一次循环中是如何做<strong>决策</strong>的：</p><ol><li>主循环分为两层，第 1 层遍历所有物品，也就是尝试放入每个物品；第 2 层遍历背包容量，也就是假定当前背包容量是 $rw$ 的时候，求在背包容量为$rw$时，放入当前物品的最大价值；</li><li>如果背包容量小于当前物品价值，那么这个时候最大价值也就是当前容量不变，使用上一个物品的最大价值即可；</li><li>如果背包容量大于当前物品价值，那么这个时候最大价值也就是从以下两个决策中挑选：</li></ol><blockquote><p>a. 放入这个物品前的最大价值 + 当前物品价值和作为答案；<br/>b. 不放入这个物品时，当前容量的最大价值作为答案。</p></blockquote><p>我在下面的表格中，用箭头画出了容量为 5 时的求解路径。你可以参照这个求解路径来加深对代码的理解。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF/resourceimageafd0afbe718a68b8a1f89c42c259a75ca7d0.png" alt=""/></p><p>在面试过程中，如果能养成对编写代码重审的习惯，也是可以加分的。因此，在我们实现完决策逻辑后，再对代码做些基本的检查，就可以“交卷”了。</p><h2 id="0-1-背包问题的延伸"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#0-1-背包问题的延伸"><span class="icon icon-link"></span></a>0-1 背包问题的延伸</h2><p>事实上，由于0-1背包问题过于经典，在真正的算法面试环节，如果涉及动态规划问题时，基本不会让你直接解决这个问题，而是让你解决这个问题的变种。</p><p>因此，我们有必要对0-1背包问题做一个延伸，来看看如何把一个看似陌生的动态规划问题转化成0-1背包问题来进行求解。</p><h3 id="算法问题分析-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#算法问题分析-1"><span class="icon icon-link"></span></a>算法问题分析</h3><p>我们先来看看问题的描述。</p><p>问题：有一堆石头，每块石头的重量都是正整数。每次从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x ≤ y$。那么粉碎的可能结果如下：</p><ol><li>如果 $x$ 与 $y$ 相等，那么两块石头都会被完全粉碎；</li><li>否则，重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头的新重量为 $y - x$。</li></ol><p>最后，最多只会剩下一块石头。返回此时石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：[1, 2, 1, 7, 9, 4]</span></div><div class="token-line"><span class="token plain">    输出：</span></div><div class="token-line"><span class="token plain">    解释：Round 1: (2, 4) -&gt; 2, 数组变成 [1, 1, 7, 9, 2]</span></div><div class="token-line"><span class="token plain">         Round 2: (7, 9) -&gt; 2, 数组变成 [1, 1, 2, 2]</span></div><div class="token-line"><span class="token plain">         Round 3: (2, 2) -&gt; 0, 数组变成 [1, 1]</span></div><div class="token-line"><span class="token plain">         Round 4: (1, 1) -&gt; 0, 数组为空，返回 0</span></div></pre></div><p>如果你是第一次遇见这个问题，那么你很可能跟绝大多数人（包括我在内）一样一脸茫然，一上来就没有什么思路。这其实很正常，事实上动态规划的面试题有规可循，总共就那么几种，见过了，以后就知道了。</p><p>我们先来读一下题目，最后的问题中包含了“最”字，这时你就应该小心了。同时，这个题目显然需要通过排列组合的方式从所有可能组合中找到最优解，因此会涉及穷举，如果涉及穷举，就很有可能涉及重叠子问题。</p><p>我刚才在0-1背包中使用了一个模版化的分析方法，我建议你在这里对此问题进行类似的分析。分析后你就会发现，这应该是一个动态规划问题。</p><h3 id="转化成动态规划问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#转化成动态规划问题"><span class="icon icon-link"></span></a>转化成动态规划问题</h3><p>现在，我们就来讲一下到底如何将其转化为动态规划问题。</p><p>首先，请你观察一下上面提供的示例。在示例中，第一步组合 2 和 4，求出 (4 - 2) = 2；第二步组合 7 和 9，求出 (9 - 7) = 2；第三步组合 2 和 2，求出 (2 - 2) = 0；最后第四步组合 1 和 1，同样得 0。我们把这个过程组合成一个式子，它看起来是这样的：</p><p>$$1-(1-((4-2)-(9-7)))$$</p><p>如果解开这些括号，就可以得到 1 - 4 + 2 + 9 - 7 - 1。再做一下简单的变换，就可以得到如下式子：</p><p>$$1 + 2 + 9 - 1 - 4 - 7$$</p><p>这个时候，我们可以把这个公式分成两组，一组是从数组中挑选出几个数字相加；然后，将另外几个数字相减，求两个数字的差。最后确保这个差最小。</p><p>从直觉上来说，如何确保两组数字之差最小呢？</p><p>我们可以看到如果一组数字接近所有数字之和的 1/2，那么两组数字之差肯定越小，比如上面的示例中所有数字之和是 24，所以一组数字是 12，另一组数字也是 12，最后肯定能得到最小值0。</p><p>现在，假设有一个背包，背包的容量是 12（24/2）。接着，我们有一堆的物品，重量分别是 [1, 2, 1, 7, 9, 4]，注意我们设它的价值与重量相同。现在我们希望选出的物品放到背包里的价值最大，这样一来，我们就可以把这个题目转化成0-1背包问题了。</p><h3 id="写出状态转移方程-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#写出状态转移方程-1"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>那么，动态规划部分的状态转移方程就和0-1背包问题中的一样，如下所示：</p><p>$$DP(tn, rw)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>0, tn&lt;=0\\\<br/>0, rw&lt;=0\\\<br/>DP(tn-1,rw), rw&lt;w[tn]\\\<br/>max=(DP(tn-1,rw), DP(tn-1,rw-w[tn])+v[tn])),rw&gt;=w[tn]<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>看到了吧！我们巧妙地把这个看似让人蒙圈的问题成功转化成了一个标准的0-1背包问题，而且能够直接复用我们所学的内容。</p><p>万事俱备后就是编写代码，由于状态转移方程与0-1背包问题如出一辙，因此我们这里就省略编码这一环节了。</p><h2 id="通用的动态规划"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#通用的动态规划"><span class="icon icon-link"></span></a>通用的动态规划</h2><p>在上一个模块“初识动态规划”中，我们曾经介绍了一种经过经验总结的动态规划解题框架（或者说是套路）。其实当时，我并未给出比较严格的框架，作为补充完善动态规划理论的重要一环，我们很有必要学习、掌握通用的动态规划的框架。</p><p>我们已经知道，一个动态规划问题是指它可以从大问题中找到无后效性的重叠子问题。所谓无后效行是指，其子问题不会双向依赖，只会单向依赖。否则，我们就无法确保子问题处理后，更大的问题一定能取到子问题的解。</p><p>现在，我们准备对动态规划问题进行泛化统一建模，如果用数学语言描述就如下公式所示：</p><p>$$f(x)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>d(x), x \in V_<!-- -->{<!-- -->I<!-- -->}<!-- -->\\\<br/>g(\<!-- -->{<!-- -->v(f(s(x,c)),c)\<!-- -->}<!-- -->),c \in values(x)<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>我们该怎么理解这个公式呢？首先，我们需要考虑一些边界情况，如果输入向量 $x$，那么在边界组合 $V_<!-- -->{<!-- -->I<!-- -->}<!-- -->$ 中，用一个边界函数 $d(x)$ 直接返回 $f(x)$ 的值，就不需要再划分子问题了。比如在0-1背包问题中，当 $tn$ 或 $rw$ 小于等于 0 时，这个值就是 0。</p><p>否则，说明这是一个可以划分子问题的问题，那么我们就需要从可选组合 $values$ 中取出用于划分子问题的备选值。需要牢记的是，在复杂问题中这个 $values$ 可能不是一个一成不变的组合，它会随着当前状态 $x$ 变化而变化。</p><p>接着，我们对每一个备选值 $c$（与上面的 $x$ 类似，同样可能是一个向量），通过函数 $s(x, c)$ 求得当前备选值的子问题的 $x$, $c$。然后，通过 $f(s(x, c))$ 得到这个子问题的结果。</p><p>再接着，我们通过子问题 $v(f(s(x, c)), c)$ 的结果和当前备选值 $c$，来求得当前问题的解。因为我们有一系列的备选值 $c$，因此会得到一个当前问题的求解集合。</p><p>最后，我们通过最优化函数 $g(t)$ 进行求解。比如原问题是求最小值，那么 $g(t)$ 就是 $min(t)$；如果是求最大值，那么就是 $max(t)$。这两种是最为常见的函数，我们在前面的例题当中也都见过了。</p><p>这样一来，我们就可以把所有的问题都套入这个框架，写出对应的状态转移方程了。</p><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>现在让我们回到这节课开头提出的那个问题，那就是0-1背包问题中的 0 和 1 代表的到底是什么呢？</p><p>其实，你可以看到在整个算法计算过程中，每次我们只能做两种选择：</p><ol><li>放入当前物品；</li><li>不放入当前物品。</li></ol><p>如果我们对这个问题稍作修改：每个物品有一定的数量（注意不止一个），同时还允许在背包中反复放入多个相同的物品，那么这个问题就变成了每个物品应该放几个。</p><p>我们可以看到0-1背包就是这种问题的一个子集，相当于每个物品都只有 1 个的背包问题！如果从放入数量的角度来看，放入当前物品就相当于当前的物品放入了 1 个，不放入当前物品就相当于放入了 0 个。</p><p>所以，这就是为什么这个背包问题被称为0-1背包的根本原因。</p><p>充分理解0-1背包的解题思路，对全面掌握背包问题来说至关重要。我会在下一节课为你讲解泛化的背包问题，并给出衍生的面试问题讨论，帮助你攻破背包问题难关。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/01#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>在这节课中，我们介绍了0-1背包问题的延伸，提出了一个“粉碎石头”的问题。现在，请你按照求解0-1背包问题的思路，全面分析一下这个问题，然后写出求解的代码。</p><p>不知道你今天的收获如何呢？如果感觉已经掌握了解题思路，不妨也去考考你们的同事或者朋友吧，刚好也有机会复述一遍今天所学。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/03.动态规划的套路/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:07:30</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
