<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>10｜面试即正义第二期：常见的动态规划面试题串烧 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/动态规划面试宝典/03.动态规划的套路/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读">01.课前必读</a><ul><li><a href="/blog-base/动态规划面试宝典/01.课前必读/01"><span>开篇词｜为什么大厂都爱考动态规划？</span></a></li><li><a href="/blog-base/动态规划面试宝典/01.课前必读/02"><span>导读｜动态规划问题纷繁复杂，如何系统学习和掌握它？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划">02.初识动态规划</a><ul><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/01"><span>01 | 硬币找零问题：从贪心算法说起</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/02"><span>02 | 暴力递归：当贪心失效了怎么办？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/03"><span>03 | 备忘录：如何避免递归中的重复计算？</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/04"><span>04 | 动态规划：完美解决硬币找零</span></a></li><li><a href="/blog-base/动态规划面试宝典/02.初识动态规划/05"><span>05｜面试即正义第一期：什么样的问题应该使用动态规划？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/03.动态规划的套路">03.动态规划的套路</a><ul><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/01"><span>06 | 0-1背包：动态规划的Hello World</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/02"><span>07｜完全背包：深入理解背包问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/03"><span>08｜子数组问题：从解决动归问题套路到实践解题思路</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/04"><span>09｜子序列问题：详解重要的一大类动态规划问题</span></a></li><li><a aria-current="page" class="active" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05"><span>10｜面试即正义第二期：常见的动态规划面试题串烧</span></a></li><li><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/06"><span>加餐｜买卖股票：常见且必考的动态规划面试题</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路">04.举一反三突破套路</a><ul><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/01"><span>11｜动态规划新问题1：攻破最长递增子序列问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/02"><span>12｜动态规划新问题2：攻破最大子数组问题</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/03"><span>13｜动态规划算法设计的关键：最优子结构与状态依赖</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/04"><span>14｜面试即正义第三期：刷题指南，熟能生巧</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/05"><span>15｜课程回顾与总结（上）</span></a></li><li><a href="/blog-base/动态规划面试宝典/04.举一反三突破套路/06"><span>16｜课程回顾与总结（下）</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/05.结束语">05.结束语</a><ul><li><a href="/blog-base/动态规划面试宝典/05.结束语/01"><span>结束语｜在我家的后院养长颈鹿</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/02"><span>有奖征集倒计时3天！你填写毕业问卷了吗？</span></a></li><li><a href="/blog-base/动态规划面试宝典/05.结束语/03"><span>结课问卷获奖用户名单</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/06.期末测试">06.期末测试</a><ul><li><a href="/blog-base/动态规划面试宝典/06.期末测试/01"><span>期末测试｜有关动态规划，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog-base/动态规划面试宝典/summary">动态规划面试宝典</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="简单的路径规划" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#简单的路径规划"><span>简单的路径规划</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解"><span>编写代码进行求解</span></a></li><li title="带障碍的路径规划" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#带障碍的路径规划"><span>带障碍的路径规划</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析-1"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程-1"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解-1"><span>编写代码进行求解</span></a></li><li title="跳跃游戏" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#跳跃游戏"><span>跳跃游戏</span></a></li><li title="算法问题分析" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析-2"><span>算法问题分析</span></a></li><li title="写出状态转移方程" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程-2"><span>写出状态转移方程</span></a></li><li title="编写代码进行求解" data-depth="3"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解-2"><span>编写代码进行求解</span></a></li><li title="课程总结" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#课程总结"><span>课程总结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10面试即正义第二期常见的动态规划面试题串烧"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#10面试即正义第二期常见的动态规划面试题串烧"><span class="icon icon-link"></span></a>10｜面试即正义第二期：常见的动态规划面试题串烧</h1><p>你好，我是卢誉声。</p><p>在前面的课程中，我们使用动态规划解题模板（套路），解决了多种类型的动态规划算法问题。这其中包括背包问题、子数组问题和子序列问题等，它们绝大多数都属于求最优解（最大值和最小值）类型的问题。</p><p>除此之外，我们还需要掌握另外两大类型的动归问题，它们分别是求方案总数以及求可行性（True或False）。虽然这两类动归问题的提法不同，但我们仍然可以使用之前总结的动态规划解题模板（套路），只需稍作调整就可以了。</p><p>那这样的话，我们今天的课程目标也就非常清晰了，就是把这两类典型的动态规划问题弄明白。现在，就让从最简单的题目开始吧！</p><h2 id="简单的路径规划"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#简单的路径规划"><span class="icon icon-link"></span></a>简单的路径规划</h2><p>路径规划问题是十分常见的动态规划面试问题，这类问题通常都是模拟现实中的路径规划。一般来说，它会给你一个指定的图，以及与图相对应的约定条件，然后让你计算出路径的总数或最优路径等。我们一般把这种问题归类到求方案总数这一类别中。</p><p>现在，我们来看下最简单的路径规划问题。</p><h3 id="算法问题分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析"><span class="icon icon-link"></span></a>算法问题分析</h3><p>问题：一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“开始” ），机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角（在下图中标记为“结束”）。问总共有多少条不同的路径？</p><p><img src="/images/httpsstatic001geekbangorgresourceimage1051105a1f11f948e5d61d7d61c01184a251.png" alt=""/></p><p>比如上图是一个7 * 3的网格，我们希望知道从起点到终点能有多少条不同的路径。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：m = 3, n = 2</span></div><div class="token-line"><span class="token plain">    输出： 3 </span></div><div class="token-line"><span class="token plain">    解释: 从左上角开始，总共有 3 条路径可以到达右下角：</span></div><div class="token-line"><span class="token plain">    1. 向右 -&gt; 向右 -&gt; 向下</span></div><div class="token-line"><span class="token plain">    2. 向右 -&gt; 向下 -&gt; 向右</span></div><div class="token-line"><span class="token plain">    3. 向下 -&gt; 向右 -&gt; 向右</span></div></pre></div><p>当遇到一个问题时，我们先要确定这个问题能否使用动态规划来进行求解，那就看一下该问题是否满足动归问题的三大特征吧。这个你应该非常熟悉了！</p><ol><li>重叠子问题：显然，求方案总数必定涉及穷举，那么在穷举过程中就难以避免出现重叠子问题的计算。比如说，格子 (4, 3) 的路径数量和格子 (3, 4) 的路径数量肯定都会依赖于格子 (3, 3) 的路径数量。因此，如果我们要求格子 (3, 3) 的路径数量，那么在求解格子 (4, 3) 和格子 (3, 4) 的时候，就不需要进行重复计算了；</li><li>无后效性：然后判断该问题是否是无后效性的。由于我们的机器人只能向下或者向右走，因此格子的路径数量求解是单向的，所以子问题肯定是无后效性的；</li><li>最优子结构：由于这个问题中机器人每次只能向右或者向下走一步，因此如果要产生不同的路径肯定从当前格子的上方下来，或者从当前格子的左侧过来，所以第 (m, n) 个格子的路径数量就是第 (m-1, n) 个格子的路径数量加上第 (m, n-1) 个格子的路径数量，所以这里存在所谓的最优子结构。</li></ol><p>通过以上判断，我们得知该问题可以利用动态规划思想来进行求解。</p><h3 id="写出状态转移方程"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>现在，我们来看看如何写出该问题的状态转移方程。</p><p>参照我们已经反复使用过的解题模板，先要确定<strong>初始化状态</strong>。从原问题可以看出，初始化状态是网格的第一行和第一列。网格的第一行永远只能从左侧的格子往前走，第一列永远只能从上方的格子向下走。由于我们只能向右或向下走，因此，第一行和第一列的格子永远只能存在 1 条路径。</p><p>接着，确定<strong>状态参数</strong>。原问题的状态参数其实就是格子的行数和列数，只要知道行数 $i$ 和列数 $j$ 就能知道这个格子的路径数量。因此，我们得到两个状态参数，分别是代表行数的 $i$ 和代表列数的 $j$。</p><p>那么，在确定了初始化状态和状态参数后，就要进行状态存储。这里我们的状态存储空间是一个二维数组 <strong>$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量</strong>。你可以通过以下图示加深理解。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage6b426b72fc1c072beac66904c7ebbd864542.png" alt=""/></p><p>从表格中我们可以看出，第一行和第一列是格子的序号。其中填写了 1 的格子，就是初始状态，深色的格子就是$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量。我们可以计算一下，这个格子的路径数量是 $DP[i-1][j] + DP[i][j-1]$。</p><p>现在一切就绪，我们来写<strong>状态转移方程</strong>。</p><p>$$DP(i, j)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>DP[i-1][j] + DP[i][j-1], &amp; if \ i\ne0\ or\ j\ne0 \\\<br/>1, &amp; i=0\ and\ j=0<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>我们可以这么理解这个状态转移方程：它由初始状态和后续的状态转移构成。当 $i$ 和 $j$ 为 0 时（假定格子从 0 开始而不是 1 开始），函数结果就是 1；否则，就是 $DP[i- 1][j] + DP[i][j-1]$。</p><h3 id="编写代码进行求解"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>对于这个简单的路径规划问题，我们可以用状态转移方程直接写出算法代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getPathCount(int m, int n) {</span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[m][n];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; } </span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetPathCount(int m, int n) {</span></div><div class="token-line"><span class="token plain">        int dp[m][n];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = 1; }</span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="带障碍的路径规划"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#带障碍的路径规划"><span class="icon icon-link"></span></a>带障碍的路径规划</h2><p>刚才讲到的路径规划问题，属于“简单”的路径规划，那在实际的面试中呢，往往不会那么简单。或者说，面试官会在你给出上述解答后，提高问题难度，然后再考察你的应变能力。</p><p>为了防止这种情况发生，同时也是学习动归必修的内容。现在，我们来看一看带障碍的路径规划问题该如何求解。</p><h3 id="算法问题分析-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析-1"><span class="icon icon-link"></span></a>算法问题分析</h3><p>问题：一个机器人位于一个 m * n 网格的左上角 （起始点在下图中标记为“开始” ）。机器人每次只能向下或者向右移动一步，现在机器人试图达到网格的右下角（在下图中标记为“结束”）。考虑网格中有障碍物，那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="/images/httpsstatic001geekbangorgresourceimage6b726b23f87fedec91b2e27ca6935576ab72.png" alt=""/></p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：</span></div><div class="token-line"><span class="token plain">    [ </span></div><div class="token-line"><span class="token plain">      [0, 0, 0], </span></div><div class="token-line"><span class="token plain">      [0, 1, 0], </span></div><div class="token-line"><span class="token plain">      [0, 0, 0] </span></div><div class="token-line"><span class="token plain">    ]</span></div><div class="token-line"><span class="token plain">    输出: 2</span></div><div class="token-line"><span class="token plain">    解释：3 * 3 网格的正中间有一个障碍物。</span></div><div class="token-line"><span class="token plain">    从左上角到右下角一共有 2 条不同的路径：</span></div><div class="token-line"><span class="token plain">    1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span></div><div class="token-line"><span class="token plain">    2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span></div></pre></div><p>显然，这个问题要比前面的问题复杂一些，在网格中加入了障碍物这一要素，也就是说有些格子是无法通行的，那么这个时候应该如何求解呢？</p><p>我们静下心来仔细想想，其实这个问题并没有产生本质变化。待求的子问题还是第 (m, n) 格子的不同路径总数。唯一的区别在于，其中一些格子有障碍物，无法通行。因此，对这些格子来说，其路径总数就是 0。</p><p>所以，重叠子问题、无后效性和最优子结构跟上一个问题是相同的。</p><h3 id="写出状态转移方程-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程-1"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>虽然基本的子问题没变，但是由于问题产生了变化，因此状态转移方程肯定会有所改变。</p><p>首先，我们还是确定<strong>初始化状态</strong>。依然先考虑网格的第一行和第一列，第一行永远只能从左侧的格子往前走；第一列永远只能从上方的格子往下走。由于我们只能向右或向下走，所以第一行和第一列的格子永远只能存在 1 条路径。但是，我们还需要再考虑那些有障碍的格子，对这些格子来说，它们的路径总数应该是 0 而不是 1。</p><p>由于该问题的基本计算规则没有发生变化。因此，<strong>状态参数</strong>依然是格子的行数和列数，我们只要知道了行数 $i$ 和列数 $j$ 就能知道这个格子的路径数量。</p><p>同理可得，状态存储空间依然是一个二维数组 <strong>$DP[i][j]$，表示第 $i$ 行、第 $j$ 列的路径数量</strong>。你可以参考上一个问题的表格，来加深对备忘录的理解。</p><p>好了，现在就是重头戏了，写出我们的<strong>状态转移方程</strong>。这个时候我们需要注意：对这些存在障碍的格子，它们的状态需要设为 0。为此，我们得到了以下状态转移方程：</p><p>$$DP(i, j)=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>1, &amp; i=0\ and\ j=0\ and\ u(i,j)=0 \\\<br/>0, &amp; u(i,j)=1 \\\<br/>DP[i-1][j] + DP[i][j-1] &amp; otherwise<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><p>从公式中可以得知，u(i, j) 表示格子 (i, j) 的编码：1 为有障碍物，0 为无障碍物。因此，当 u(i, j) 为 1 的时候，$DP[i][j] = 0$；否则的话，状态转移函数就跟上一个问题没有区别。</p><h3 id="编写代码进行求解-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解-1"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>写好状态转移方程后，我直接给出算法代码的实现。</p><p>Java实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int getPathCountWithBlocks(int[][] v) {</span></div><div class="token-line"><span class="token plain">        int m = v.length;</span></div><div class="token-line"><span class="token plain">        int n = v[0].length;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int[][] dp = new int[m][n];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = v[i][0] == 1 ? 0 : 1; }</span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = v[0][j] == 1 ? 0 : 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                if (v[i][j] == 1) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = 0;</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int GetPathCount(const vector&lt;vector&lt;int&gt;&gt;&amp; v) {</span></div><div class="token-line"><span class="token plain">        int m = v.size();</span></div><div class="token-line"><span class="token plain">        int n = v[0].size();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        int dp[m][n]; memset(dp, 0, sizeof(dp));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; m; i ++) { dp[i][0] = v[i][0] ? 0 : 1; }</span></div><div class="token-line"><span class="token plain">        for (int j = 0; j &lt; n; j ++) { dp[0][j] = v[0][j] ? 0 : 1; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; m; i ++) { // 状态转移过程</span></div><div class="token-line"><span class="token plain">            for (int j = 1; j &lt; n; j ++) {</span></div><div class="token-line"><span class="token plain">                if (v[i][j]) {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = 0;</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[m - 1][n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>通过以上讲解，你会发现：即便原问题增加了障碍物，我们求解问题的基本思路也没怎么发生变化，只是在初始化状态时多考虑了一下有障碍物这种情况。</p><h2 id="跳跃游戏"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#跳跃游戏"><span class="icon icon-link"></span></a>跳跃游戏</h2><p>接下来我们看看求可行性问题（True或False），这是最后一类我们“可能”还未触及的动归问题。我为什么要说可能呢？这是因为我们完全可以通过问题的转化，将其他类型的问题转化成求可行性问题。</p><p>比如我们在早期讨论的硬币找零问题，当时我们要求的是：最少需要几枚硬币凑出总金额。但那个问题显然存在无法用硬币凑出解的情况（至于这种情况，原问题要求返回 -1）。因此，如果我们把原问题修改成：你能否用用最少的硬币凑出总金额？这样就变成了一个求可行性问题了。</p><p>当然，除了上述的情况外，有些面试题目也会直接提出求可行性的问题。对于这类问题，**我们只需要知道某个问题是否可以被解决即可。**既然说到这了，就让我们来看一下跳跃游戏这个常考的题目吧。</p><p>题目：给出一个非负整数数组 A，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。判断你是否能到达数组的最后一个位置。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例1：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：A = [2, 3, 1, 1, 6]</span></div><div class="token-line"><span class="token plain">    输出： True</span></div><div class="token-line"><span class="token plain">    解释: 我们可以先跳 1 步，从位置 0 到达位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span></div></pre></div><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">示例2：</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输入：A = [4, 2, 1, 0, 0, 6]</span></div><div class="token-line"><span class="token plain">    输出： False</span></div><div class="token-line"><span class="token plain">    解释: 无论从开头怎么跳跃，你最多都只能到达位置 3 或位置 4，但这两个位置的最大跳跃长度是 0，所以你永远不可能到达最后一个位置。</span></div></pre></div><h3 id="算法问题分析-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#算法问题分析-2"><span class="icon icon-link"></span></a>算法问题分析</h3><p>这个问题其实很简单，每个数字表示了跳跃距离的可能性，这就涉及到了排列组合的问题。因此，我们可以考虑使用穷举来解该问题。但显然穷举不是一个好的面试问题的答案，因此，我们考虑使用动态规划来进行求解。</p><p>我们就按照动态规划的解题套路来分析一下，先来判断该问题是否满足动态规划特征。</p><ol><li>重叠子问题：这个问题肯定存在重叠子问题，比如求能否到达 $i$ 和 $i-1$ 这两个位置，那么肯定都需要确定 $i-2$ 这个位置的答案。因此，必定存在重叠子问题；</li><li>无后效性：该问题明显也无后效性，只有后续的子问题依赖于前面的子问题；</li><li>最优子结构：该问题是否存在最优子结构呢？当我们在一个位置的时候，我们可以知道最远可以跳到什么位置。因此，如果我们想要知道能否到达位置 $i$，就需要逐个看前面的位置，判定能否从 $i-1$、$i-2$、$i-3$ … 的位置跳到位置 $i$ 上。然后，再看 $i-1$ 这个位置是否能够到达，因此肯定存在最优子结构。</li></ol><p>好了，判断过后我们知道这个问题可以使用动态规划的状态转移方程来进行求解。现在，让我们来看一看如何写出这个状态转移方程吧。</p><h3 id="写出状态转移方程-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#写出状态转移方程-2"><span class="icon icon-link"></span></a>写出状态转移方程</h3><p>首先，我们要考虑<strong>初始化状态</strong>。这个问题的初始化状态就是 0 这个位置。因为这个位置是出发点，因此肯定可以到达，所以我们可以将其初始化成 True。而对其他位置，则可以根据状态转移方程来计算得出。</p><p>接着，<strong>状态参数</strong>也比较容易看出，只有数组的位置是变化的，因此状态参数就是当前位置 $i$。</p><p>由于只有一个状态参数，因此我们可以使用一维数组 <strong>$DP[i]$ 来表示能否从出发点到达位置 $i$</strong>。</p><p>那么，状态转移方程中的<strong>决策</strong>是什么呢？就像前面所说的，如果我们想要知道能否到达位置 $i$，就需要逐个看前面的位置，判定能否从位置 $i-1$、$i-2$、$i-3$ … 跳到位置 $i$ 上。然后，再看 $i-1$ 这个位置是否能够到达。</p><p>通过以上分析，我们就可以给出状态转移方程的定义了。</p><p>$$DP[i]=\left\<!-- -->{<!-- -->\begin<!-- -->{<!-- -->array<!-- -->}<!-- -->{<!-- -->c<!-- -->}<br/>True, &amp; i = 0 \\\<br/>(DP[j] = true)\ and\ (max(A[j]+j) \geq i), &amp; i \ne 0\ and\ j &lt; i \\\<br/>\end<!-- -->{<!-- -->array<!-- -->}<!-- -->\right.$$</p><h3 id="编写代码进行求解-2"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#编写代码进行求解-2"><span class="icon icon-link"></span></a>编写代码进行求解</h3><p>有了状态转移方程，求解代码也就不难了。按照惯例，我直接给出求解代码。</p><p>Java 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public boolean canJump(int[] nums) {</span></div><div class="token-line"><span class="token plain">        int n = nums.length;</span></div><div class="token-line"><span class="token plain">        if (n &lt;= 1) { return true; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        boolean[] dp = new boolean[n];</span></div><div class="token-line"><span class="token plain">        // 初始化状态</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; n; i++) { dp[i] = false; }</span></div><div class="token-line"><span class="token plain">        dp[0] = true;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (int i = 1; i &lt; n; i++) {</span></div><div class="token-line"><span class="token plain">            for (int j = 0; j &lt; i; j++) { // j &lt; i</span></div><div class="token-line"><span class="token plain">                if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {</span></div><div class="token-line"><span class="token plain">                    dp[i] = true;</span></div><div class="token-line"><span class="token plain">                    break;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return dp[n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>C++ 实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bool canJump(vector&lt;int&gt;&amp; nums) {</span></div><div class="token-line"><span class="token plain">          int n = nums.size();</span></div><div class="token-line"><span class="token plain">          if (n &lt;= 1) { return true; }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          bool dp[n]; memset(dp, 0, sizeof(dp));</span></div><div class="token-line"><span class="token plain">          dp[0] = true; // 初始化状态</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          for (int i = 1; i &lt; n; i++) {</span></div><div class="token-line"><span class="token plain">              for (int j = 0; j &lt; i; j++) { // j &lt; i</span></div><div class="token-line"><span class="token plain">                  if (dp[j] &amp;&amp; j + nums[j] &gt;= i) {</span></div><div class="token-line"><span class="token plain">                      dp[i] = true;</span></div><div class="token-line"><span class="token plain">                      break;</span></div><div class="token-line"><span class="token plain">                  }</span></div><div class="token-line"><span class="token plain">              }</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          return dp[n - 1]; // 输出答案</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="课程总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#课程总结"><span class="icon icon-link"></span></a>课程总结</h2><p>以上就是求方案总数类型问题，以及求可行性类型问题的解法了。</p><p>事实上，我们完全可以通过转化其它类型的问题，来得到求可行性类型的动态规划问题。比如说，在带障碍的路径规划中，我们求的是路径总数。但是，当我将题目改一下：问能否从起点移动到终点？这样就变成了求可行性的问题。</p><p>我们依然在遵循之前给出的动态规划解题模板来求解问题。首先，根据重叠子问题、无后向性和最优子结构来确定能否用动态规划解题。然后，再确定初始化状态、状态参数，接着确定状态存储数组（即备忘录），最终写出关键的状态转移方程。</p><p>一旦写出状态转移方程，我们的问题就解决掉一大半了。你可以按照这种思路，自己去尝试解决一些实际的面试问题，从而加深你对解题模板的利用和理解。过程中如果遇到困难，欢迎随时在留言区中提出。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/动态规划面试宝典/03.动态规划的套路/05#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>这节课我们学习了路径规划的解法，那么在带障碍的路径规划问题的基础上，我再为每条边设定一个长度（也就是不同格子之间行进的距离是不同的），此时该如何求出从起点到终点的最大长度呢？</p><p>欢迎留言和我分享你的答案，我会第一时间给你反馈。如果今天的内容对你有所启发，也欢迎把文章分享给你身边的朋友，邀请他一起学习！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/动态规划面试宝典/03.动态规划的套路/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:33:22</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
