<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03 | 换个角度解决问题：服务端推送技术 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全栈工程师修炼指南/02.第一章网络协议和web接口/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读">01.课前必读</a><ul><li><a href="/blog/全栈工程师修炼指南/01.课前必读/01"><span>开篇词 | 从成长角度看，为什么你应该成为全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/02"><span>学习路径 | 怎样成为一名优秀的全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/03"><span>导读 | 如何学习这个专栏？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口">02.第一章网络协议和Web接口</a><ul><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/01"><span>01 | 网络互联的昨天、今天和明天：HTTP 协议的演化</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/02"><span>02 | 为HTTP穿上盔甲：HTTPS</span></a></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03"><span>03 | 换个角度解决问题：服务端推送技术</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/04"><span>04 | 工整与自由的风格之争：SOAP和REST</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/05"><span>05 | 权衡的艺术：漫谈Web API的设计</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/06"><span>06 | 特别放送：北美大厂如何招聘全栈工程师？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界">03.第二章欢迎来到MVC的世界</a><ul><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/01"><span>07 | 解耦是永恒的主题：MVC框架的发展</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02"><span>08 | MVC架构解析：模型（Model）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/03"><span>09 | MVC架构解析：视图（View）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/04"><span>10 | MVC架构解析：控制器（Controller）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/05"><span>11 | 剑走偏锋：面向切面编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/06"><span>12 | 唯有套路得人心：谈谈Java EE的那些模式</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/07"><span>13 | 特别放送：选择比努力更重要</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端">04.第三章从后端到前端</a><ul><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/01"><span>14 | 别有洞天：从后端到前端</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/02"><span>15 | 重剑无锋，大巧不工：JavaScript面向对象</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/03"><span>16 | 百花齐放，百家争鸣：前端MVC框架</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/04"><span>17 | 不一样的体验：交互设计和页面布局</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/05"><span>18 | 千言万语不及一幅画：谈谈数据可视化</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06"><span>19 | 打开潘多拉盒子：JavaScript异步编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/07"><span>20 | 特别放送：全栈团队的角色构成</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化">05.第四章数据持久化</a><ul><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/01"><span>21 | 赫赫有名的双刃剑：缓存（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/02"><span>22 | 赫赫有名的双刃剑：缓存（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/03"><span>23 | 知其然，知其所以然：数据的持久化和一致性</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/04"><span>24 |  尺有所短，寸有所长：CAP和数据存储技术选择</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/05"><span>25 | 设计数据持久层（上）：理论分析</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/06"><span>26 | 设计数据持久层（下）：案例介绍</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/07"><span>27 |  特别放送：聊一聊代码审查</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践">06.第五章寻找最佳实践</a><ul><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/01"><span>28 | Ops三部曲之一：配置管理</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/02"><span>29 | Ops三部曲之二：集群部署</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/03"><span>30 | Ops三部曲之三：测试和发布</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/04"><span>31 | 防人之心不可无：网站安全问题窥视</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/05"><span>32 | 和搜索引擎的对话：SEO的原理和基础</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/06"><span>33  | 特别放送：聊一聊程序员学英语</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题">07.第六章专题</a><ul><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/01"><span>34 | 网站性能优化（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/02"><span>35 | 网站性能优化（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/03"><span>36 | 全栈开发中的算法（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/04"><span>37 | 全栈开发中的算法（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/05"><span>38 | 分页的那些事儿</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/06"><span>39 | XML、JSON、YAML比较</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/07"><span>40 | 全栈衍化：让全栈意味着更多</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾">08.全栈回顾</a><ul><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾/01"><span>全栈回顾 | 成为更好的全栈工程师！</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/09.加餐">09.加餐</a><ul><li><a href="/blog/全栈工程师修炼指南/09.加餐/01"><span>好书荐读：小众书也有看头儿</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/10.期末测试">10.期末测试</a><ul><li><a href="/blog/全栈工程师修炼指南/10.期末测试/01"><span>期末测试 | 对于全栈的内容，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/summary">全栈工程师修炼指南</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Pull 模型的问题" data-depth="2"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#pull-模型的问题"><span>Pull 模型的问题</span></a></li><li title="服务端推送技术" data-depth="2"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#服务端推送技术"><span>服务端推送技术</span></a></li><li title="1. Comet" data-depth="3"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#1-comet"><span>1. Comet</span></a></li><li title="2. WebSocket" data-depth="3"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#2-websocket"><span>2. WebSocket</span></a></li><li title="3. 更多推送技术" data-depth="3"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#3-更多推送技术"><span>3. 更多推送技术</span></a></li><li title="总结思考" data-depth="2"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#总结思考"><span>总结思考</span></a></li><li title="扩展阅读" data-depth="2"><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#扩展阅读"><span>扩展阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--换个角度解决问题服务端推送技术"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#03--换个角度解决问题服务端推送技术"><span class="icon icon-link"></span></a>03 | 换个角度解决问题：服务端推送技术</h1><p>你好，我是四火。</p><p>今天我们继续和 HTTP“过不去”。在上一讲，我们讲到了 HTTP 在安全传输方面的局限，并介绍了怎样使用经过 TLS 加密的 HTTPS 连接来解决这样的弊端。</p><p>今天，我要给你讲讲传统 HTTP的另一个在交互模式上的局限，就是只能由客户端主动发起消息传递，而服务端只能被动响应消息的局限，并介绍它的解决办法。</p><h2 id="pull-模型的问题"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#pull-模型的问题"><span class="icon icon-link"></span></a>Pull 模型的问题</h2><p>让我们来思考这样一个场景，假设你设计了一款网页版的即时聊天工具，现在你使用浏览器打开了聊天页面，正在和朋友愉快地聊天。这时有朋友给你发送了一条消息，可是由于 HTTP 本身机制的限制，服务端无法主动推送消息，告知浏览器上的聊天页面“你有一条消息”，进而影响到了消息的即时送达。那么，这个问题怎么解决？</p><p>你可能会立即想到<strong>轮询（Poll）</strong>，比如浏览器每隔十秒钟去问一下服务端是不是有新消息不就完了嘛。这看起来是个好思路，但明显存在这样两个问题：</p><ul><li>消息还是不够即时。换言之，假如正好在某次询问之后服务器收到了消息，那么这条消息的获取延迟可能达到至少十秒。</li><li>大量的请求-响应，带宽和服务器资源浪费。如果你开着聊天工具页面一个小时，除了这一条消息，却没有进一步的聊天行为，于是按照每十秒发送一次请求计算，一共发起了 360 次请求，而其中居然只有 1 次返回了聊天消息是有实际意义的。</li></ul><p>显然，轮询这个方案不好。说到底，其实我们并没有抛开对 HTTP 的已有印象，从问题本身出发去思考解决问题的最佳方式，而是潜意识地受限于 HTTP 的传统交互模式，考虑其中的变通方法。</p><p>在进一步分析之前，我们先来看两个容易弄混的概念：Pull 和 Poll。</p><p>“Pull”指的是去主动发起行为获取消息，一般在客户端/服务器（C/S，Client/Server）或浏览器/服务器（B/S，Browser/Server）交互中，客户端或浏览器主动发起的网络请求数据的行为。</p><p>而“Poll”，尽管在某些场景下也和 Pull 通用了，但在计算机网络的领域里，通常把它解释为“轮询”，或者“周期性查询”，在 Pull 的基础上增加了“周期性”的概念，这也是它和 Pull 相比最本质的区别。</p><p>相应地，和 Pull 行为相对的，从服务端主动发起，发送数据到客户端的行为叫做“Push”。Push 相比 Pull 而言，具备这样两个明显的优势：</p><ul><li><strong>高效性</strong>。如果没有更新发生，就不会有任何更新消息推送的动作，即每次消息推送都发生在确确实实的更新事件之后，都是有意义的，不会出现请求和响应的资源浪费。</li><li><strong>实时性</strong>。事件发生后的第一时间即可触发通知操作，理论上不存在任何可能导致通知延迟的硬伤。</li></ul><p>可是，有趣的是，事实上 Pull 的应用却远比 Push 更广泛，特别是在分布式系统中。这里有多个原因，其中很重要的一条是：</p><p>服务端不需要维护客户端的列表，不需要知晓客户端的情况，不需要了解客户端查询的策略。<strong>这有助于把服务端从对客户端繁重的管理工作中解放出来，而成为无状态的简单服务，变得具备幂等性（idempotent，指执行多次和执行一次的结果一样），更容易横向扩展。</strong></p><p>尤其在分布式系统中，状态经常成为毒药，有了状态，就不得不考虑状态的保存、丢失、一致性等问题，因此这种无状态往往可以很大程度地简化系统的设计。</p><h2 id="服务端推送技术"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#服务端推送技术"><span class="icon icon-link"></span></a>服务端推送技术</h2><p>有了这些基础知识，我们就可以来谈谈实际的服务端推送技术了，这些都从一定程度上解决了 HTTP 传统方式 Pull 的弊端。</p><h3 id="1-comet"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#1-comet"><span class="icon icon-link"></span></a>1. Comet</h3><p>严格说，Comet 是一种 Web 应用客户端和服务端交互的模型，它有几种服务端推送的具体实现，但是，它们的大致原理是一样的：<strong>客户端发送一个普通的 HTTP 请求到服务端以后，服务端不像以往一样在处理后立即返回数据，而是保持住连接不释放，每当有更新事件发生，就使用分块传输的方式返回数据</strong>（如果你忘记了块传输的方式，请回看 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134752">[第1讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</p><p>若干次数据返回以后可以完成此次请求响应过程（分块传输返回长度为0的块，表示传输结束），等待客户端下一次请求发送。这种过程看起来也属于轮询，但是每个周期可包含多次服务端数据返回，因而也被形象地称为“长轮询”（Long Polling）。</p><p>在服务端推送技术中，Comet 最大的好处是，它 100% 由 HTTP 协议实现，当然，分块传输要求 HTTP 至少是 1.1 版本。但也正因为这点，它也存在一些弊端，比如，客户端必须在服务端结束当次传输后才能向服务端发送消息；HTTP 协议限制了它在每次请求和响应中必须携带完整的头部，这在一定程度上也造成了浪费（这种为了传输实际数据而使用的额外开销叫做 overhead）。</p><p>下面我给出了一个 Comet 实现的示例图。浏览器在发出 1 号请求要求数据，连接保持，接着陆续收到几个不同大小的响应数据，并且最后一个大小为0，浏览器被告知此次传输完成。过了一会儿，浏览器又发出 2 号请求，开始第二轮的类似交互。</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8CWeb%E6%8E%A5%E5%8F%A3/resourceimagef19df148cfbe65a6a0e98214095c46e0169d.png" alt=""/></p><p>在 Comet 方式下，<strong>看起来服务端有了推送行为，其实只是对于客户端请求有条件、讲时机的多次返回</strong>，因此我们把它称为服务端“假 Push”。</p><h3 id="2-websocket"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#2-websocket"><span class="icon icon-link"></span></a>2. WebSocket</h3><p>HTML 5 规范定义了 WebSocket 协议，它可以通过 HTTP 的端口（或者 HTTPS 的端口）来完成，从而最大程度上对 HTTP 协议通透的防火墙保持友好。但是，<strong>它是真正的双向、全双工协议，也就是说，客户端和服务端都可以主动发起请求，回复响应，而且两边的传输都互相独立。</strong></p><p>和上文的 Comet 不同，WebSocket 的服务端推送是完全可以由服务端独立、主动发起的，因此它是服务端的“真 Push”。</p><p>WebSocket 是一个可谓“科班出身”的二进制协议，也没有那么大的头部开销，因此它的传输效率更高。同时，和 HTTP 不一样的是，它是一个带有状态的协议，双方可以约定好一些状态，而不用在传输的过程中带来带去。而且，WebSocket 相比于 HTTP，它没有同源的限制，服务端的地址可以完全和源页面地址无关，即不会出现臭名昭著的浏览器“跨域问题”。</p><p>另外，它和我们之前学习的加密传输也丝毫不冲突，由于它在网络分层模型中位于 TLS 上方，因此他可以使用和 HTTP 一样的加密方式传输：</p><blockquote><p>HTTP → WS<br/>HTTPS → WSS</p></blockquote><p>最后，最有意思的事情在于，和我们之前的认识不同，WebSocket 是使用 HTTP 协议“升级”的方法来帮助建立连接的，下面我们动手来试一试。</p><p>首先，我们需要找到一个可以支持 WebSocket 测试的网站，比如 websocket.org，然后我们将使用 Chrome 的网络工具来捕获和显示通过浏览器发送和接收的消息。如果这是你第一次使用 Chrome 的开发者工具，那么你需要好好熟悉它了，因为它将在你今后全栈的道路上派上大用场。</p><p>使用 Chrome 打开 <a target="_blank" rel="noopener noreferrer" href="https://www.websocket.org/echo.html">Echo Test<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 页面，在这里你可以发送建立一个 WebSocket 连接。但是别急，我们先打开 Chrome 的开发者工具，并选中 Network 标签，接着点击左上角的清除按钮，把已有页面加载的网络消息清除掉，以获得一个清爽的网络报文监视界面：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8CWeb%E6%8E%A5%E5%8F%A3/resourceimageeaaeea65ac03047615ba8aafe1d7118d5dae.png" alt=""/></p><p>接着，确保页面上建立 WebSocket 连接的对端地址和传递的信息都已经填写，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Location:</span></div><div class="token-line"><span class="token plain">    wss://echo.websocket.org</span></div><div class="token-line"><span class="token plain">    Message:</span></div><div class="token-line"><span class="token plain">    Rock it with HTML5 WebSocket</span></div></pre></div><p>于是就可以点击“Connect”按钮了，旁边的日志框将出现“CONNECTED”字样，同时，Chrome 开发者工具将捕获这样的请求（如果在开发者工具中网络监视界面上，选中消息的消息头处于“parsed”展示模式，你需要点击 Request Headers 右侧的 “view source” 链接来查看原始消息头）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">GET wss://echo.websocket.org/?encoding=text HTTP/1.1</span></div><div class="token-line"><span class="token plain">    Host: echo.websocket.org</span></div><div class="token-line"><span class="token plain">    Origin: https://www.websocket.org</span></div><div class="token-line"><span class="token plain">    Connection: Upgrade</span></div><div class="token-line"><span class="token plain">    Upgrade: websocket</span></div><div class="token-line"><span class="token plain">    Sec-WebSocket-Version: 13</span></div><div class="token-line"><span class="token plain">    Sec-WebSocket-Key: xxx</span></div><div class="token-line"><span class="token plain">    ... (省略其它 HTTP 头)</span></div></pre></div><p>好，你可以看到，这是一个普普通通的 HTTP GET 请求，但是 URL 是以加密连接“wss”开头的，并且有几个特殊的 HTTP 头：Origin 指出了请求是从哪个页面发起的，Connection: Upgrade 和 Upgrade: websocket 这两个表示客户端要求升级 HTTP 协议为 WebSocket。</p><p>好，再来看响应，消息的头部为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">HTTP/1.1 101 Web Socket Protocol Handshake</span></div><div class="token-line"><span class="token plain">    Connection: Upgrade</span></div><div class="token-line"><span class="token plain">    Sec-WebSocket-Accept: xxx</span></div><div class="token-line"><span class="token plain">    Upgrade: websocket</span></div><div class="token-line"><span class="token plain">    ... (省略其它 HTTP 头)</span></div></pre></div><p>嗯，返回码是 101，描述是“Web Socket Protocol Handshake”，并且，它确认了连接升级为“websocket”的事实。</p><h3 id="3-更多推送技术"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#3-更多推送技术"><span class="icon icon-link"></span></a>3. 更多推送技术</h3><p>到这里，我已经介绍了几种服务端的推送技术，事实上还有更多，但是，<strong>如果你依次了解以后认真思考，就会发现，这些原理居然都在某种程度上和我介绍的 Comet 和 WebSocket 这两种类似，有的甚至来自于它们。</strong></p><p>这些技术包括：</p><ul><li>SSE，即 Server-Sent Events，又叫 EventSource，是一种已被写入 HTML 5 标准的服务端事件推送技术，它允许客户端和服务端之间建立一个单向通道，以让服务端向客户端单方向持续推送事件消息；</li><li>为了提高性能，HTTP/2 规范中新添加的服务端推送机制，我们在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/134752">[第 01 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中提到过，并在该讲的扩展阅读中有它的原理介绍；</li><li>WebRTC，即 Web Real-Time Communication，它是一个支持网页进行视频、语音通信的协议标准，不久前已被加入 W3C 标准，最新的 Chrome 和 Firefox 等主流浏览器都支持；</li><li>还有一些利用浏览器插件和扩展达成的服务端推送技术，比如使用 Flash 的 XMLSocket，比如使用 Java 的 Applet，但这些随着 HTML 5 的普及，正慢慢被淘汰。</li></ul><p>你看，通过学习一两个典型的技术，再拓展开，去类比了解和分析思考同一领域内的其它技术，就能掌握到最核心的东西，这就是我推荐的一种学习全栈技术的方式。</p><h2 id="总结思考"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#总结思考"><span class="icon icon-link"></span></a>总结思考</h2><p>今天我们从 HTTP 的交互局限性引出了网络交互中 Pull 和 Push 的两大模型，比较了它们的优劣。服务端 Push 的方式具备高效性和实时性的优势，而客户端 Pull 的方式令服务端免去状态的维护，从根本上简化了系统。</p><p>之后我们以 Comet 和 WebSocket 为重点，介绍了服务端推送的不同方式，尤其是用了实际抓包分析，介绍了通过 HTTP “升级”的方式来建立 WebSocket 连接的原理。</p><p>今天学习得怎样呢？来看这样两个问题：</p><ul><li>文中介绍了 Push 和 Pull 在原理上的不同，在你的实际项目中，是否应用了 Push 或 Pull 的模型呢？</li><li>文中介绍了 Push 比 Pull 具备高效性和实时性的优势，而 Pull 比 Push 则具备使得服务变得无状态的优势，除了最重要的这几个，你还能说出更多它们各自的优势吗？</li></ul><p>今天的内容就到这里。以 HTTP 协议为核心，介绍网络协议的三讲文章已经更新完毕了，你是否对于全栈技术本身，还有适合自己的学习方法，有了新的理解呢？欢迎留言和我讨论。</p><h2 id="扩展阅读"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03#扩展阅读"><span class="icon icon-link"></span></a>扩展阅读</h2><ul><li>文中提到了跨域问题，如果感兴趣，推荐你阅读 MDN 的 <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP访问控制（CORS）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇文章。</li><li>TutorialsPoint 的 <a target="_blank" rel="noopener noreferrer" href="https://www.tutorialspoint.com/websockets/">WebSocket 系统教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，对于本文介绍的 WebSocket 协议，需要进一步了解的一个好去处。</li><li>关于 HTTP Update 头的 <a target="_blank" rel="noopener noreferrer" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42">RFC 2616 协议片段<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和 WebSocket 的 <a target="_blank" rel="noopener noreferrer" href="https://tools.ietf.org/html/rfc6455">RFC 6445<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你也许对响应和请求中的其它 HTTP 头心存疑问，和之前介绍的 HTTP 的 RFC 协议一样，你通常不需要仔细阅读，但它是对协议有问题时的最终去处。</li><li><a target="_blank" rel="noopener noreferrer" href="https://www.html5rocks.com/en/tutorials/eventsource/basics/">Stream Updates with Server-Sent Events<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，一篇非常好的介绍 SSE 基础，和同类技术比较优劣，并给出代码示例的文章；如果你对 WebRTC 感兴趣，那么可以先看看这个<a target="_blank" rel="noopener noreferrer" href="http://io13webrtc.appspot.com/#1">胶片<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，再阅读这篇基础知识 <a target="_blank" rel="noopener noreferrer" href="https://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started with WebRTC<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全栈工程师修炼指南/02.第一章网络协议和Web接口/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
