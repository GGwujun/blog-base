<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>08 | MVC架构解析：模型（Model）篇 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读">01.课前必读</a><ul><li><a href="/blog/全栈工程师修炼指南/01.课前必读/01"><span>开篇词 | 从成长角度看，为什么你应该成为全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/02"><span>学习路径 | 怎样成为一名优秀的全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/03"><span>导读 | 如何学习这个专栏？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口">02.第一章网络协议和Web接口</a><ul><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/01"><span>01 | 网络互联的昨天、今天和明天：HTTP 协议的演化</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/02"><span>02 | 为HTTP穿上盔甲：HTTPS</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03"><span>03 | 换个角度解决问题：服务端推送技术</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/04"><span>04 | 工整与自由的风格之争：SOAP和REST</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/05"><span>05 | 权衡的艺术：漫谈Web API的设计</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/06"><span>06 | 特别放送：北美大厂如何招聘全栈工程师？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界">03.第二章欢迎来到MVC的世界</a><ul><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/01"><span>07 | 解耦是永恒的主题：MVC框架的发展</span></a></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02"><span>08 | MVC架构解析：模型（Model）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/03"><span>09 | MVC架构解析：视图（View）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/04"><span>10 | MVC架构解析：控制器（Controller）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/05"><span>11 | 剑走偏锋：面向切面编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/06"><span>12 | 唯有套路得人心：谈谈Java EE的那些模式</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/07"><span>13 | 特别放送：选择比努力更重要</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端">04.第三章从后端到前端</a><ul><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/01"><span>14 | 别有洞天：从后端到前端</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/02"><span>15 | 重剑无锋，大巧不工：JavaScript面向对象</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/03"><span>16 | 百花齐放，百家争鸣：前端MVC框架</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/04"><span>17 | 不一样的体验：交互设计和页面布局</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/05"><span>18 | 千言万语不及一幅画：谈谈数据可视化</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06"><span>19 | 打开潘多拉盒子：JavaScript异步编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/07"><span>20 | 特别放送：全栈团队的角色构成</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化">05.第四章数据持久化</a><ul><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/01"><span>21 | 赫赫有名的双刃剑：缓存（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/02"><span>22 | 赫赫有名的双刃剑：缓存（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/03"><span>23 | 知其然，知其所以然：数据的持久化和一致性</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/04"><span>24 |  尺有所短，寸有所长：CAP和数据存储技术选择</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/05"><span>25 | 设计数据持久层（上）：理论分析</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/06"><span>26 | 设计数据持久层（下）：案例介绍</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/07"><span>27 |  特别放送：聊一聊代码审查</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践">06.第五章寻找最佳实践</a><ul><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/01"><span>28 | Ops三部曲之一：配置管理</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/02"><span>29 | Ops三部曲之二：集群部署</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/03"><span>30 | Ops三部曲之三：测试和发布</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/04"><span>31 | 防人之心不可无：网站安全问题窥视</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/05"><span>32 | 和搜索引擎的对话：SEO的原理和基础</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/06"><span>33  | 特别放送：聊一聊程序员学英语</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题">07.第六章专题</a><ul><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/01"><span>34 | 网站性能优化（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/02"><span>35 | 网站性能优化（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/03"><span>36 | 全栈开发中的算法（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/04"><span>37 | 全栈开发中的算法（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/05"><span>38 | 分页的那些事儿</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/06"><span>39 | XML、JSON、YAML比较</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/07"><span>40 | 全栈衍化：让全栈意味着更多</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾">08.全栈回顾</a><ul><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾/01"><span>全栈回顾 | 成为更好的全栈工程师！</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/09.加餐">09.加餐</a><ul><li><a href="/blog/全栈工程师修炼指南/09.加餐/01"><span>好书荐读：小众书也有看头儿</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/10.期末测试">10.期末测试</a><ul><li><a href="/blog/全栈工程师修炼指南/10.期末测试/01"><span>期末测试 | 对于全栈的内容，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/summary">全栈工程师修炼指南</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="概念" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#概念"><span>概念</span></a></li><li title="贫血模型和充血模型" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#贫血模型和充血模型"><span>贫血模型和充血模型</span></a></li><li title="内部层次划分" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#内部层次划分"><span>内部层次划分</span></a></li><li title="CQRS 模式" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#cqrs-模式"><span>CQRS 模式</span></a></li><li title="总结思考" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#总结思考"><span>总结思考</span></a></li><li title="扩展阅读" data-depth="2"><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#扩展阅读"><span>扩展阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08--mvc架构解析模型model篇"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#08--mvc架构解析模型model篇"><span class="icon icon-link"></span></a>08 | MVC架构解析：模型（Model）篇</h1><p>你好，我是四火。</p><p>在上一讲中，我们了解了 MVC 这个老而弥坚的架构模式，而从这一讲开始，连同第 09、10 讲共计 3 篇，我将分别展开介绍 MVC 三大部分内容。今天我要讲的就是第一部分——模型（Model）。</p><h2 id="概念"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#概念"><span class="icon icon-link"></span></a>概念</h2><p>首先我们要了解的是，我们总在谈“模型”，那到底什么是模型？</p><p>简单说来，<strong>模型就是当我们使用软件去解决真实世界中各种实际问题的时候，对那些我们关心的实际事物的抽象和简化</strong>。比如我们在软件系统中设计“人”这个事物类型的时候，通常只会考虑姓名、性别和年龄等一些系统用得着的必要属性，而不会把性格、血型和生辰八字等我们不关心的东西放进去。</p><p>更进一步讲，我们会谈领域模型（Domain Model）。“领域”两个字显然给出了抽象和简化的范围，不同的软件系统所属的领域是不同的，比如金融软件、医疗软件和社交软件等等。如今领域模型的概念包含了比其原本范围定义以外更多的内容，<strong>我们会更关注这个领域范围内各个模型实体之间的关系</strong>。</p><p>MVC 中的“模型”，说的是“模型层”，它正是由上述的领域模型来实现的，可是当我们讲这一层的时候，它包含了模型上承载的实实在在的业务数据，还有不同数据间的关联关系。因此，<strong>我们在谈模型层的时候，有时候会更关心领域模型这一抽象概念本身，有时候则会更关心数据本身</strong>。</p><h2 id="贫血模型和充血模型"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#贫血模型和充血模型"><span class="icon icon-link"></span></a>贫血模型和充血模型</h2><p>第一次听到“贫血模型”“充血模型”这两个词的时候，可能你就会问了，什么玩意儿？领域模型还有贫血和充血之说？</p><p>其实，这两兄弟是 Martin Fowler 造出来的概念。要了解它们，得先知道这里讲的“血”是什么。</p><p>这里的“血”，就是逻辑。它既包括我们最关心的业务逻辑，也包含非业务逻辑 。因此，**贫血模型（Anemic Domain Model），意味着模型实体在设计和实现上，不包含或包含很少的逻辑。**通常这种情况下，逻辑是被挪了出去，由其它单独的一层代码（比如这层代码是“Service”）来完成。</p><p>严格说起来，贫血模型不是面向对象的，因为对象需要数据和逻辑的结合，这也是贫血模型反对者的重要观点之一。如果主要逻辑在 Service 里面，这一层对外暴露的接口也在 Service 上，那么事实上它就变成了面向“服务”的了，而模型实体，实际只扮演了 Service API 交互入参出参的角色，或者从本质上说，它只是遵循了一定封装规则的容器而已。</p><p>**这时的模型实体，不包含逻辑，但包含状态，而逻辑被解耦到了无状态 Service 中。**既然没有了状态，Service 中的方法，就成为过程式代码的了。请注意，不完全面向对象并不代表它一定“不好”，事实上，在互联网应用设计中，贫血模型和充血模式都有很多成功的使用案例，且非常常见。</p><p>比如这样的一个名为 Book 的类：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Book {</span></div><div class="token-line"><span class="token plain">        private int id;</span></div><div class="token-line"><span class="token plain">        private boolean onLoan;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public int getId() {</span></div><div class="token-line"><span class="token plain">            return this.id;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public void setId(int id) {</span></div><div class="token-line"><span class="token plain">            this.id = id;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public boolean isOnLoan() {</span></div><div class="token-line"><span class="token plain">            return this.loan;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        public void setOnLoan(boolean onLoan) {</span></div><div class="token-line"><span class="token plain">            this.onLoan = onLoan;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以看到，它并没有任何实质上的逻辑在里面，方法也只有简单的 getters 和 setters 等属性获取和设置方法，它扮演的角色基本只是一个用作封装的容器。</p><p>那么真正的逻辑，特别是业务逻辑在哪里呢？有这样一个 Service：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class BookService {</span></div><div class="token-line"><span class="token plain">        public Book lendOut(int bookId, int userId, Date date) { ... }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个 lendOut 方法表示将书从图书馆借出，因此它需要接收图书 id 和 用户 id。在实现中，可能需要校验参数，可能需要查询数据库，可能需要将从数据源获得的原始数据装配到返回对象中，可能需要应用过滤条件，这里的内容，就是逻辑。</p><p>现在，我们再来了解一下充血模型（Rich Domain Model）。<strong>在充血模型的设计中，领域模型实体就是有血有肉的了，既包含数据，也包含逻辑，具备了更高程度的完备性和自恰性</strong>，并且，充血模型的设计才是真正面向对象的。在这种设计下，我们看不到 XXXService 这样的类了，而是通过操纵有状态的模型实体类，就可以达到数据变更的目的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Book {</span></div><div class="token-line"><span class="token plain">        private int id;</span></div><div class="token-line"><span class="token plain">        private boolean onLoan;</span></div><div class="token-line"><span class="token plain">        public void lendOut(User user, Date date) { ... }</span></div><div class="token-line"><span class="token plain">        ... // 省略属性的获取和设置方法</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这种方式下，lendOut 方法不再需要传入 bookId，因为它就在 Book 对象里面存着呢；也不再需要传出 Book 对象作为返回值，因为状态的改变直接反映在 Book 对象内部了，即 onLoan 会变成 true。</p><p>也就是说，Book 的行为和数据完完全全被封装的方法控制起来了，中间不会存在不应该出现的不一致状态，因为任何改变状态的行为只能通过 Book 的特定方法来进行，而它是可以被设计者严格把控的。</p><p>而在贫血模型中就做不到这一点，一是因为数据和行为分散在两处，二是为了在 Service 中能组装模型，模型实体中本不该对用户开放的接口会被迫暴露出来，于是整个过程中就会存在状态不一致的可能。</p><p>但是请注意，**无论是充血模型还是贫血模型，它和 Model 层做到何种程度的解耦往往没有太大关系。**比如说这个 lendOut 方法，在某些设计中，它可以拆分出去。对于贫血模型来说，它并非完全属于 BookService，可以拿到新建立的“借书关系”的服务中去，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class LoanService {</span></div><div class="token-line"><span class="token plain">        public Loan add(int bookId, int userId, Date date) { ... }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样一来，借书的关系就可以单独维护了，借书行为发生的时候，Book 和 User 两个实体对应的数据都不需要发生变化，只需要改变这个借书关系的数据就可以了。对于充血模型来说，一样可以做类似拆分。</p><h2 id="内部层次划分"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#内部层次划分"><span class="icon icon-link"></span></a>内部层次划分</h2><p>软件的耦合和复杂性问题往往都可以通过分层解决，模型层内部也一样，但是我们需要把握其中的度。**层次划分过多、过细，并不利于开发人员严格遵从和保持层次的清晰，也容易导致产生过多的无用样板代码，从而降低开发效率。**下面是一种比较常见的 Model 层，它是基于贫血模型的分层方式。</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0MVC%E7%9A%84%E4%B8%96%E7%95%8C/resourceimagef646f6e1b220a80716532ac6dd54cb1b9f46.png" alt=""/></p><p>在这种划分方式下，每一层都可以调用自身所属层上的其它类，也可以调用自己下方一层的类，但是不允许往上调用，即依赖关系总是“靠上面的层”依赖着“靠下面的层”。最上面三层是和业务模型实体相关的，而最下面一层是基础设施服务，和业务无关。从上到下，我把各层依次简单介绍一下：</p><ul><li>第一层 Facade，提供粗粒度的接口，逻辑上是对 Service 功能的组合。有时候由于事务需要跨多个领域模型的实体控制，那就适合放在这里。举例来说，创建用户的时候，我们同时免费赠送一本电子书给用户，我们既要调用 UserService 去创建用户对象，也要调用 SubscriptionService 去添加一条订购（赠送）记录，而这两个属于不同 Service 的行为需要放到一处 Facade 类里面做统一事务控制。在某些较小系统的设计里面，Service 和 Facade 这两层是糅合在一起的。</li><li>第二层 Service，前面已经介绍了，通常会存放仅属于单个领域模型实体的操作。</li><li>第三层数据访问层，在某些类型的数据访问中需要，比如关系型数据库，这里存放数据库字段和模型对象之间的 ORM（Object-Relational Mapping，对象关系映射）关系。</li><li>第四层基础设施层，这一层的通用性最好，必须和业务无关。某些框架会把基础设施的工作给做了，但有时候也需要我们自己实现。比如 S3Service，存放数据到亚马逊的分布式文件系统。</li></ul><h2 id="cqrs-模式"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#cqrs-模式"><span class="icon icon-link"></span></a>CQRS 模式</h2><p>你也许听说过数据库的读写分离，其实，在模型的设计中，也有类似读写分离的机制，其中最常见的一种就叫做 CQRS（Command Query Responsibility Segregation，命令查询职责分离）。</p><p>一般我们设计的业务模型，会同时被用作读（查询模式）和写（命令模式），但是，实际上这两者是有明显区别的，在一些业务场景中，我们希望这两者被分别对待处理，那么这种情况下，CQRS 就是一个值得考虑的选项。</p><p>为什么要把命令和查询分离？我举个例子来说明吧，比如这样的贫血模型：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class Book {</span></div><div class="token-line"><span class="token plain">        private long id;</span></div><div class="token-line"><span class="token plain">        private String name;</span></div><div class="token-line"><span class="token plain">        private Date publicationDate;</span></div><div class="token-line"><span class="token plain">        private Date creationDate;</span></div><div class="token-line"><span class="token plain">        ... // 省略其它属性和 getter/setter 方法</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么，相应地，就有这样一个 BookService：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class BookService {</span></div><div class="token-line"><span class="token plain">        public Book add(Book book);</span></div><div class="token-line"><span class="token plain">        public Pagination&lt;Book&gt; query(Book book);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个接口提供了两个方法：</p><p>一个叫做 add 方法，接收一个 book 对象，这个对象的 name 和 publicationDate 属性会被当做实际值写入数据库，但是 id 会被忽略，因为 id 是数据库自动生成的，具备唯一性，creationDate 也会被忽略，因为它也是由数据库自动生成的，表示数据条目的创建时间。写入数据库完成后，返回一个能够反映实际写入库中数据的 Book 对象，它的 id 和 creationDate 都填上了数据库生成的实际值。</p><p>你看，这个方法，实际做了两件事，一件是插入数据，即写操作；另一件是返回数据库写入的实际对象，即读操作。</p><p>另一个方法是 query 方法，用于查询，这个 Book 入参，被用来承载查询参数了 。比方说，如果它的 author 值为“Jim”，表示查询作者名字为“Jim”的图书，返回一个分页对象，内含分页后的结果列表。</p><p>但这个方法，其实有着明显的问题。这个问题就是，查询条件的表达，并不能用简单的业务模型很好地表达。换言之，这个模型 Book，能用来表示写入，却不适合用来表示查询。为什么呢？</p><p>比方说，你要查询出版日期从 2018 年到 2019 年之间的图书，你该怎么构造这个 Book 对象？很难办对吧，因为 Book 只能包含一个 publicationDate 参数，这种“难办”的本质原因，是模型的不匹配，即这个 Book 对象根本就不适合用来做查询调用的模型。</p><p>在清楚了问题以后，解决方法 CQRS 就自然而然产生了。<strong>简单来说，CQRS 模式下，模型层的接口分为且只分为两种：</strong></p><ul><li><strong>命令（Command），它不返回任何结果，但会改变数据的状态。</strong></li><li><strong>查询（Query），它返回结果，但是不会改变数据的状态。</strong></li></ul><p>也就是说，它把命令和查询的模型彻底分开了。上面的例子 ，使用 CQRS 的方式来改写一下，会变成这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class BookService {</span></div><div class="token-line"><span class="token plain">        public void add(Book book);</span></div><div class="token-line"><span class="token plain">        public Pagination&lt;Book&gt; query(Query bookQuery);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看，在 add 操作的时候，不再有返回值；而在 query 操作的时候，入参变成了一个 Query 对象，这是一个专门的“查询对象”，查询对象里面可以放置多个查询条件，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Query bookQuery = new Query(Book.class);</span></div><div class="token-line"><span class="token plain">    query.addCriteria(Criteria.greaterThan(&quot;publicationDate&quot;, date_2018));</span></div><div class="token-line"><span class="token plain">    query.addCriteria(Criteria.lessThan(&quot;publicationDate&quot;, date_2019));</span></div></pre></div><p>读到这里，不知道你有没有联想到这样两个知识点：</p><p>第一个知识点，在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/136795">[第 04 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 我们学习 REST 风格的时候，我们把 HTTP 的请求从两个维度进行划分，是否幂等，以及是否安全。<strong>按照这个角度来考量，CQRS 中的命令，可能是幂等的（例如对象更新），也可能不是幂等的（例如对象创建），但一定是不安全的；CQRS 中的查询，一定是幂等的，且一定是安全的。</strong></p><p>第二个知识点，在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/140196">[第 07 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 我们学习 MVC 的一般化，其中的“第二种”典型情况时，Controller 会调用 Model 层的，执行写入操作；而 View 层会调用 Model 层，执行只读操作——看起来这不就是最适合 CQRS 的一种应用场景吗？</p><p>所以说，技术确实都是相通的。</p><h2 id="总结思考"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#总结思考"><span class="icon icon-link"></span></a>总结思考</h2><p>今天我们详细剖析了 MVC 架构中 Model 层的方方面面，并结合例子理解了贫血模型和充血模型的概念和特点，还介绍了一种典型的模型层的内部层次划分方法，接着介绍了 CQRS 这种将命令和查询行为解耦开的模型层设计方式。</p><p>其中，贫血模型和充血模型的理解是这一讲的重点，这里我再强调一下：</p><ul><li>贫血模型，逻辑从模型实体中剥离出去，并被放到了无状态的 Service 层中，于是状态和逻辑就被解耦开了；</li><li>充血模型，它既包含数据，也包含逻辑，具备了更高程度的完备性和自恰性。</li></ul><p>最后，我来提两个问题，一同检验下今天的学习成果吧：</p><ul><li>请回想一下，在你经历过的项目中，使用过什么 MVC 框架，Model 层的代码是遵循贫血模型还是充血模型设计的？</li><li>在文中应用 CQRS 模式的时候，add 方法不再返回 Book 对象，这样一来，方法调用者就无法知道实际插入的 Book 对象的 id 是什么，就无法在下一步根据 id 去数据库查询出这个 Book 对象了。那么，这个问题该怎么解决呢？</li></ul><p>好，今天的内容就到这里，有余力还可以了解下扩展阅读的内容。有关今天的知识点，如果你在实际的工作经历中遇到过，其实是非常适合拿来一起比较的。可以谈谈你在这方面的经验，也可以分享你的不同理解，期待你的想法！</p><h2 id="扩展阅读"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02#扩展阅读"><span class="icon icon-link"></span></a>扩展阅读</h2><ul><li><a target="_blank" rel="noopener noreferrer" href="https://martinfowler.com/bliki/AnemicDomainModel.html">AnemicDomainModel<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，Martin Fowler 写的批评贫血模型的文章，他自己提出了贫血和充血的概念，因此我们可以到概念的源头去，看看他做出批评的理由是什么。</li><li>【基础】在模型层我们经常会和数据库打交道，SQL 是这部分的基础，如果你完全不了解 SQL，可以阅读 W3school 上的 <a target="_blank" rel="noopener noreferrer" href="https://www.w3school.com.cn/sql/index.asp">SQL 基础教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（左侧目录中的基础教程，内容简短）。</li><li>文中提到了查询对象（Query Object），这其实是一种常见的设计模式，文中举例说明了是怎么使用的，但是，如果你想知道它是怎么实现的，可以阅读 <a target="_blank" rel="noopener noreferrer" href="https://www.sourcecodeexamples.net/2018/04/query-object-pattern.html">Query Object Pattern<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这篇文章，上面有很好的例子。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全栈工程师修炼指南/03.第二章欢迎来到MVC的世界/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
