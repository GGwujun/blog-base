<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | 打开潘多拉盒子：JavaScript异步编程 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全栈工程师修炼指南/04.第三章从后端到前端/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读">01.课前必读</a><ul><li><a href="/blog/全栈工程师修炼指南/01.课前必读/01"><span>开篇词 | 从成长角度看，为什么你应该成为全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/02"><span>学习路径 | 怎样成为一名优秀的全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/03"><span>导读 | 如何学习这个专栏？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口">02.第一章网络协议和Web接口</a><ul><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/01"><span>01 | 网络互联的昨天、今天和明天：HTTP 协议的演化</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/02"><span>02 | 为HTTP穿上盔甲：HTTPS</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03"><span>03 | 换个角度解决问题：服务端推送技术</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/04"><span>04 | 工整与自由的风格之争：SOAP和REST</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/05"><span>05 | 权衡的艺术：漫谈Web API的设计</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/06"><span>06 | 特别放送：北美大厂如何招聘全栈工程师？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界">03.第二章欢迎来到MVC的世界</a><ul><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/01"><span>07 | 解耦是永恒的主题：MVC框架的发展</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02"><span>08 | MVC架构解析：模型（Model）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/03"><span>09 | MVC架构解析：视图（View）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/04"><span>10 | MVC架构解析：控制器（Controller）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/05"><span>11 | 剑走偏锋：面向切面编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/06"><span>12 | 唯有套路得人心：谈谈Java EE的那些模式</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/07"><span>13 | 特别放送：选择比努力更重要</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端">04.第三章从后端到前端</a><ul><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/01"><span>14 | 别有洞天：从后端到前端</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/02"><span>15 | 重剑无锋，大巧不工：JavaScript面向对象</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/03"><span>16 | 百花齐放，百家争鸣：前端MVC框架</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/04"><span>17 | 不一样的体验：交互设计和页面布局</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/05"><span>18 | 千言万语不及一幅画：谈谈数据可视化</span></a></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06"><span>19 | 打开潘多拉盒子：JavaScript异步编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/07"><span>20 | 特别放送：全栈团队的角色构成</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化">05.第四章数据持久化</a><ul><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/01"><span>21 | 赫赫有名的双刃剑：缓存（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/02"><span>22 | 赫赫有名的双刃剑：缓存（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/03"><span>23 | 知其然，知其所以然：数据的持久化和一致性</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/04"><span>24 |  尺有所短，寸有所长：CAP和数据存储技术选择</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/05"><span>25 | 设计数据持久层（上）：理论分析</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/06"><span>26 | 设计数据持久层（下）：案例介绍</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/07"><span>27 |  特别放送：聊一聊代码审查</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践">06.第五章寻找最佳实践</a><ul><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/01"><span>28 | Ops三部曲之一：配置管理</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/02"><span>29 | Ops三部曲之二：集群部署</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/03"><span>30 | Ops三部曲之三：测试和发布</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/04"><span>31 | 防人之心不可无：网站安全问题窥视</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/05"><span>32 | 和搜索引擎的对话：SEO的原理和基础</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/06"><span>33  | 特别放送：聊一聊程序员学英语</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题">07.第六章专题</a><ul><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/01"><span>34 | 网站性能优化（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/02"><span>35 | 网站性能优化（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/03"><span>36 | 全栈开发中的算法（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/04"><span>37 | 全栈开发中的算法（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/05"><span>38 | 分页的那些事儿</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/06"><span>39 | XML、JSON、YAML比较</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/07"><span>40 | 全栈衍化：让全栈意味着更多</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾">08.全栈回顾</a><ul><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾/01"><span>全栈回顾 | 成为更好的全栈工程师！</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/09.加餐">09.加餐</a><ul><li><a href="/blog/全栈工程师修炼指南/09.加餐/01"><span>好书荐读：小众书也有看头儿</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/10.期末测试">10.期末测试</a><ul><li><a href="/blog/全栈工程师修炼指南/10.期末测试/01"><span>期末测试 | 对于全栈的内容，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/summary">全栈工程师修炼指南</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="1. 用 Promise 优化嵌套回调" data-depth="2"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#1-用-promise-优化嵌套回调"><span>1. 用 Promise 优化嵌套回调</span></a></li><li title="2. 用生成器来实现协程" data-depth="2"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#2-用生成器来实现协程"><span>2. 用生成器来实现协程</span></a></li><li title="3. 异步错误处理" data-depth="2"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#3-异步错误处理"><span>3. 异步错误处理</span></a></li><li title="Promise 的异常处理" data-depth="3"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#promise-的异常处理"><span>Promise 的异常处理</span></a></li><li title="async/await 下的异常处理" data-depth="3"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#asyncawait-下的异常处理"><span>async/await 下的异常处理</span></a></li><li title="总结思考" data-depth="2"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#总结思考"><span>总结思考</span></a></li><li title="扩展阅读" data-depth="2"><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#扩展阅读"><span>扩展阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--打开潘多拉盒子javascript异步编程"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#19--打开潘多拉盒子javascript异步编程"><span class="icon icon-link"></span></a>19 | 打开潘多拉盒子：JavaScript异步编程</h1><p>你好，我是四火。</p><p>我们在本章伊始的 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/145875">[第 14 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中初步学习了 JavaScript 的事件驱动模型，体会到了思维模式的转变，也建立起了异步编程的初步概念。在本章最后一讲，我们将深入异步编程，继续探讨其中的关键技术。</p><p>异步编程就像是一个神秘的宝盒，看起来晶莹剔透，可一旦使用不当，就会是带来灾难的潘多拉盒子，状态混乱，难以维护。希望在这一讲之后，你可以了解更多的关于 JavaScript 在异步编程方面的高级特性，从而习惯并写出可靠的异步代码。</p><h2 id="1-用-promise-优化嵌套回调"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#1-用-promise-优化嵌套回调"><span class="icon icon-link"></span></a>1. 用 Promise 优化嵌套回调</h2><p>假如我们需要写这样一段代码，来模拟一只小狗向前奔跑，它一共跑了 3 次，奔跑的距离分别为 1、2、3，每次奔跑都要花费 1 秒钟时间：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">setTimeout(</span></div><div class="token-line"><span class="token plain">      () =&gt; {</span></div><div class="token-line"><span class="token plain">        console.log(1);</span></div><div class="token-line"><span class="token plain">        setTimeout(</span></div><div class="token-line"><span class="token plain">          () =&gt; {</span></div><div class="token-line"><span class="token plain">            console.log(2);</span></div><div class="token-line"><span class="token plain">            setTimeout(</span></div><div class="token-line"><span class="token plain">              () =&gt; {</span></div><div class="token-line"><span class="token plain">                console.log(3);</span></div><div class="token-line"><span class="token plain">              },</span></div><div class="token-line"><span class="token plain">              1000</span></div><div class="token-line"><span class="token plain">            );</span></div><div class="token-line"><span class="token plain">          },</span></div><div class="token-line"><span class="token plain">          1000</span></div><div class="token-line"><span class="token plain">        );</span></div><div class="token-line"><span class="token plain">      },</span></div><div class="token-line"><span class="token plain">      1000</span></div><div class="token-line"><span class="token plain">    );</span></div></pre></div><p>你看，我们用了 3 次 setTimeout，每次都接受两个参数，第一个参数是一个函数，用以打印当前跑的距离，以及递归调用奔跑逻辑，第二个参数用于模拟奔跑耗时 1000 毫秒。这个问题其实代表了实际编程中一类很常见的 JavaScript 异步编程问题。例如，使用 Ajax 方式异步获取一个请求，在得到返回的结果后，再执行另一个 Ajax 操作。</p><p>现在，请你打开 Chrome 开发者工具中的控制台，运行一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">3693</span></div><div class="token-line"><span class="token plain">    1</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    3</span></div></pre></div><p>第一行是 setTimeout 返回的句柄，由于控制台运行的关系，系统会把最后一行执行的返回值打印出来，因此它可以忽略。除此之外，结果恰如预期，每一行的打印都间隔了一秒，模拟了奔跑的效果。</p><p>但是，这个代码似乎不太“好看”啊，繁琐而且冗长，易理解性和可维护性显然不过关，代码的状态量在这种情况下很难预测和维护。就如同同步编程世界中常见的“<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81">面条代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Spaghetti Code）”一样，这样“坏味道”的代码在异步编程的世界中其实也很常见，且也有个专有称呼——“金字塔厄运”（Pyramid of Doom，嵌套结构就像金字塔一样）。</p><p>到这里，不知你会不会想，能不能把重复的逻辑抽取出来呢？具体说，就是这个 setTimeout 方法相关的代码。于是，我们可以抽取公用逻辑，定义一个 run 方法，接受两个参数，一个是当前跑动距离，第二个是回调方法，用于当前跑完以后，触发下一次跑动的行为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var run = (steps, callback) =&gt; {</span></div><div class="token-line"><span class="token plain">      setTimeout(</span></div><div class="token-line"><span class="token plain">        () =&gt; {</span></div><div class="token-line"><span class="token plain">          console.log(steps);</span></div><div class="token-line"><span class="token plain">          callback();</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        1000</span></div><div class="token-line"><span class="token plain">      );</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    run(1, () =&gt; {</span></div><div class="token-line"><span class="token plain">      run(2, () =&gt; {</span></div><div class="token-line"><span class="token plain">        run(3, () =&gt; {});</span></div><div class="token-line"><span class="token plain">      });</span></div><div class="token-line"><span class="token plain">    });</span></div></pre></div><p>嗯，代码确实清爽多了。可是，看着这嵌套的三个 run，我觉得这并没有从本质上解决问题，只是代码简短了些，嵌套调用依然存在。</p><p>每当我们开始写这样反复嵌套回调的代码时，我们就应该警醒，我们是否在创造一个代码维护上的坑。那能不能使用某一种优雅的方式来解决这个问题呢？</p><p>有！它就是 Promise，并且从 ES6 开始，JavaScript 原生支持，不再需要第三方的库或者自己实现的工具类了。</p><p>**Promise，就如同字面意思“承诺”一样，定义在当前，但行为发生于未来。**它的构造方法中接受一个函数（如果你对这种将函数作为参数的方式传入还不习惯，请回看 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/145878">[第 15 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对函数成为一等公民的介绍），并且这个函数接受 resolve 和 reject 两个参数，前者在未来的执行成功时会被调用，后者在未来的执行失败时会被调用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var run = steps =&gt; </span></div><div class="token-line"><span class="token plain">      () =&gt; </span></div><div class="token-line"><span class="token plain">        new Promise((resolve, reject) =&gt; {</span></div><div class="token-line"><span class="token plain">          setTimeout(</span></div><div class="token-line"><span class="token plain">            () =&gt; {</span></div><div class="token-line"><span class="token plain">              console.log(steps);</span></div><div class="token-line"><span class="token plain">              resolve(); // 一秒后的未来执行成功，需要调用</span></div><div class="token-line"><span class="token plain">            },</span></div><div class="token-line"><span class="token plain">            1000</span></div><div class="token-line"><span class="token plain">          );</span></div><div class="token-line"><span class="token plain">        });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Promise.resolve()</span></div><div class="token-line"><span class="token plain">      .then(run(1))</span></div><div class="token-line"><span class="token plain">      .then(run(2))</span></div><div class="token-line"><span class="token plain">      .then(run(3));</span></div></pre></div><p>正如代码所示，这一次我们让 run() 方法返回一个函数，这个函数执行的时候会返回一个 Promise 对象。这样，这个 Promise 对象，并不是在程序一开始就初始化的，而是在未来的某一时刻，前一步操作完成之后才会得到执行，这一点非常关键，并且这是一种<strong>通过给原始代码添加函数包装的方式实现了这里的“定义、传递、但不执行”的要求。</strong></p><p>这样做就是把实际的执行逻辑使用一个临时函数包装起来再传递出去，以达到延迟对该逻辑求值的目的，这种方式有一个专有名字 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Thunk">Thunk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它是一种在 JavaScript 异步编程的世界中很常见的手段（JavaScript 中有时 Thunk 特指用这种技术来将多参数函数包装成单参数函数，这种情况我们在此不讨论）。换言之，上面代码例子中的第二行，绝不可省略，一些刚开始学写异步编程的程序员朋友，就很容易犯这个错误。</p><p>另外，这里我还使用了两个小技巧来简化代码：</p><ul><li>一个是 () =&gt; <!-- -->{<!-- --> return xxx; <!-- -->}<!-- --> 可以被简化为 () =&gt; xxx；</li><li>另一个是使用 Promise.resolve() 返回一个已经执行成功的空操作，从而将所有后续执行的 run 方法都可以以统一的形式放到调用链里面去。</li></ul><p>现在，使用 run() 方法的代码调用已经格外地简单而清晰了。在 Promise 的帮助下，通过这种方式，用了几个 then 方法，实现了逻辑在前一步成功后的依次执行。于是，<strong>嵌套的金字塔厄运消失了，变成了直观的链式调用</strong>，这是异步编程中一个非常常见的优化。</p><p>如果我们乘胜追击，进一步考虑，上面那个 run() 方法明显不够直观，能不能以某种方式优化调整一下？</p><p>能！代码看起来复杂的原因是引入了 setTimeout，而我们使用 setTimeout 只是为了“等一下”，来模拟小狗奔跑的过程。这个“等一下”的行为，实际是有普遍意义的。在 JavaScript 这样的非阻塞代码中，不可能通过代码的方式让代码实际执行的时候真的“等一下”，但是，我们却可以使用异步的方式让代码看起来像是执行了一个“等一下”的操作。我们定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var wait = ms =&gt;</span></div><div class="token-line"><span class="token plain">      new Promise(resolve =&gt; setTimeout(resolve, ms));</span></div></pre></div><p>有了 wait 的铺垫，我们把原本奔跑的 setTimeout 使用更为直观的 wait 函数来替换，一下子就让 run 的实现清晰了很多：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var run = steps =&gt; </span></div><div class="token-line"><span class="token plain">      () =&gt; wait(1000).then(() =&gt; { console.log(steps); });</span></div></pre></div><p>你看，这个例子，再加上前面的 then 调用链的例子，你是否看出，<strong>利用 Promise，我们似乎神奇地把“异步”代码变成“同步”的了</strong>。其实，代码执行并没有真正地变成同步，但是代码却“看起来”像是同步代码，而同步和顺序执行的逻辑对于人的大脑更为友好。</p><p>经过这样的重构以后，再次执行刚才的 3 次奔跑调用，我们得到了一样的结果。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Promise.resolve()</span></div><div class="token-line"><span class="token plain">      .then(run(1))</span></div><div class="token-line"><span class="token plain">      .then(run(2))</span></div><div class="token-line"><span class="token plain">      .then(run(3));</span></div></pre></div><p>嗯，看起来我们已经做到极致了，代码也已经很清楚了，大概没有办法再改写和优化了吧？不！其实我们还有继续操作的办法。也许我应该说，居然还有。</p><p>在 ES7 中，async/await 的语法糖被引入。通过它，我们可以进一步优化代码的写法，让异步编程越来越像同步编程，也越来越接近人大脑自然的思维。</p><ul><li>async 用于标记当前的函数为异步函数；</li><li>await 用于表示它的后面要返回一个 Promise 对象，在这个 Promise 对象得到异步结果以后，再继续往下执行。</li></ul><p>考虑一下上面的 run 方法，现在我们可以把它改写成 async/await 的形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var run = async steps =&gt; {</span></div><div class="token-line"><span class="token plain">      await wait(1000);</span></div><div class="token-line"><span class="token plain">      console.log(steps);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看，代码看起来就和同步的没有本质区别了，等待 1000 毫秒以后，打印 steps。</p><p>接着，如果我们执行下面的代码（如果你不是在 Chrome 的控制台执行，你可以把下面三行代码放到任意一个 async 函数中去执行，效果是一样的）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">await run(1);</span></div><div class="token-line"><span class="token plain">    await run(2);</span></div><div class="token-line"><span class="token plain">    await run(3);</span></div></pre></div><p>我们得到了一样的结果。这段代码看起来也和顺序、同步执行的代码没有区别了，虽然，实际的运行依然是前面你看到的异步调用，这里的效果只是 async/await 语法糖为程序员创造的一个美好的假象。</p><p>纵观这个小狗奔跑的问题，我们一步一步把晦涩难懂的嵌套回调代码，优化成了易读、易理解的“假同步”代码。聪明的程序员总在努力地创造各种工具，去<strong>改善代码异步调用的表达能力，但是越是深入，就越能发现，最自然的表达，似乎来自于纯粹的同步代码。</strong></p><h2 id="2-用生成器来实现协程"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#2-用生成器来实现协程"><span class="icon icon-link"></span></a>2. 用生成器来实现协程</h2><p><strong>协程，Coroutine，简单说就是一种通用的协作式多任务的子程序，它通过任务执行的挂起与恢复，来实现任务之间的切换。</strong></p><p>这里提到的“协作式”，是一种多任务处理的模式，它和“抢占式”相对。如果是协作式，每个任务处理的逻辑必须主动放弃执行权（挂起），将继续执行的资源让出来给别的任务，直到重新获得继续执行的机会（恢复）；而抢占式则完全将任务调度交由第三方，比如操作系统，它可以直接剥夺当前执行任务的资源，分配给其它任务。</p><p>我们知道，创建线程的开销比进程小，而协程通常完全是在同一个线程内完成的，连线程切换的代价都免去了，因此它在资源开销方面更有优势。</p><p>JavaScript 的协程是通过生成器来实现的，执行的主流程在生成器中可以以 yield 为界，进行协作式的挂起和恢复操作，从而在外部函数和生成器内部逻辑之间跳转，而 JavaScript 引擎会负责管理上下文的切换。</p><p>首先我们来认识一下 JavaScript 和迭代有关的两个协议，它们是我们后面学习生成器的基础：</p><ul><li>第一个是可迭代协议，它允许定义对象自己的迭代行为，比如哪些属性方法是可以被 for 循环遍历到的；</li><li>第二个是迭代器协议，它定义了一种标准的方法来依次产生序列的下一个值（next() 方法），如果序列是有限长的，并且在所有的值都产生后，将有一个默认的返回值。</li></ul><p>接着我就可以介绍生成器（Generator）了。在 JavaScript 中，生成器对象是由生成器函数 function* 返回，且符合“可迭代协议”和“迭代器协议”两者。function* 和 yield 关键字通常一起使用，yield 用来在生成器的 next() 方法执行时，标识生成器执行中断的位置，并将 yield 右侧表达式的值返回。见下面这个简单的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function* IdGenerator() {</span></div><div class="token-line"><span class="token plain">      let index = 1;</span></div><div class="token-line"><span class="token plain">      while (true)</span></div><div class="token-line"><span class="token plain">        yield index++;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var idGenerator = IdGenerator();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    console.log(idGenerator.next());</span></div><div class="token-line"><span class="token plain">    console.log(idGenerator.next());</span></div></pre></div><p>这是一个 id 顺序生成的生成器，初始 index 为 1，每次调用 next() 来获取序列的下一个数值，并且 index 会自增 1。从代码中我们可以看到，这是一个无限的序列。</p><p>执行上述代码，我们将得到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{value: 1, done: false}</span></div><div class="token-line"><span class="token plain">    {value: 2, done: false}</span></div></pre></div><p>每次返回的对象里面，value 的值就是生成的 id，而 done 的值表示这个序列是否结束。</p><p>你看，以往我们说起遍历的时候，脑海里总会第一时间想起某个容器，某个数据集合，但是，有了生成器以后，我们就可以对更为复杂的逻辑进行迭代。</p><p>生成器可不是只能往外返回，还能往里传值。具体说，yield 右侧的表达式会返回，但是在调用 next() 方法时，入参会被替代掉 yield 及右侧的表达式而参与代码运算。我们将上面的例子小小地改动一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">function* IdGenerator() {</span></div><div class="token-line"><span class="token plain">      let index = 1, factor = 1;</span></div><div class="token-line"><span class="token plain">      while (true) {</span></div><div class="token-line"><span class="token plain">        factor = yield index; // 位置①</span></div><div class="token-line"><span class="token plain">        index = yield factor * index; // 位置②</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，这是生成器的定义，其调用代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var calculate = (idGenerator) =&gt; {</span></div><div class="token-line"><span class="token plain">      console.log(idGenerator.next());</span></div><div class="token-line"><span class="token plain">      console.log(idGenerator.next(1));</span></div><div class="token-line"><span class="token plain">      console.log(idGenerator.next(2));</span></div><div class="token-line"><span class="token plain">      console.log(idGenerator.next(3));</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    calculate(IdGenerator());</span></div></pre></div><p>在往下阅读以前，你能不能先想一想，这个 calculate 方法的调用，会产生怎样的输出？</p><p>好，我来解释一下整个过程。现在这个 id 生成器每个循环节可以通过 yield 返回两次，我把上述执行步骤解释一下（为了便于说明代码位置，在生成器代码中我标记了“位置①”和“位置②”，请对应起来查看）：</p><ul><li>调用 next()，位置①的 yield 右侧的 index 返回，因此值为 1；</li><li>调用 next(1)，实参为 1，它被赋值给位置①的 factor，参与位置②的 yield 右侧的表达式计算，得到 1；</li><li>调用 next(2)，实参为 2，它被赋值给位置②的 index，由于 while 循环的关系，位置①的 yield 右侧的 index 返回，因此得到 2；</li><li>调用 next(3)，实参为 3，它被赋值给位置①的 factor，参与位置②的 yield 右侧的表达式计算，3 * 2 得到 6。</li></ul><p>使用图来表示，就是这样子：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%88%B0%E5%89%8D%E7%AB%AF/resourceimage664966e19715cc976a6870f73e2a8d34bb49.png" alt=""/></p><p>从图中你应该可以理解，通过生成器来实现 JavaScript 协程的原理了。本质上来说，**生成器将一个完整的方法执行通过 yield 拆分成了多个部分，并且每个部分都可以有输入输出，整个过程就是一个简单的状态机。**它和其它函数一起，以反复挂起和恢复的方式一段一段地将任务完成。</p><p>最后，结果输出如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">{value: 1, done: false}</span></div><div class="token-line"><span class="token plain">    {value: 1, done: false}</span></div><div class="token-line"><span class="token plain">    {value: 2, done: false}</span></div><div class="token-line"><span class="token plain">    {value: 6, done: false}</span></div></pre></div><h2 id="3-异步错误处理"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#3-异步错误处理"><span class="icon icon-link"></span></a>3. 异步错误处理</h2><p>错误处理是所有编程范型都必须要考虑的问题，在使用 JavaScript 进行异步编程时，也不例外。你可能会有这样一个疑问，如果我们不做特殊处理，会怎样呢？且看下面的代码，我先定义一个必定会失败的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var fail = () =&gt; {</span></div><div class="token-line"><span class="token plain">      setTimeout(() =&gt; {</span></div><div class="token-line"><span class="token plain">        throw new Error(&quot;fail&quot;);</span></div><div class="token-line"><span class="token plain">      }, 1000);</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>然后调用一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">console.log(1);</span></div><div class="token-line"><span class="token plain">    try {</span></div><div class="token-line"><span class="token plain">      fail();</span></div><div class="token-line"><span class="token plain">    } catch (e) {</span></div><div class="token-line"><span class="token plain">      console.log(&quot;captured&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    console.log(2);</span></div></pre></div><p>在 Chrome 开发者工具的控制台中执行一下，我们将看到 1 和 2 的输出，并在 1 秒钟之后，获得一个“Uncaught Error”的错误打印，注意观察这个错误的堆栈：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Uncaught Error: fail</span></div><div class="token-line"><span class="token plain">        at &lt;anonymous&gt;:3:11</span></div><div class="token-line"><span class="token plain">        at e (lizard-service-vendor.2b011077.js:1)</span></div><div class="token-line"><span class="token plain">    	(anonymous)	@	VM261:3</span></div><div class="token-line"><span class="token plain">    	e	@	lizard-service-vendor.2b011077.js:1</span></div><div class="token-line"><span class="token plain">    	setTimeout (async)		</span></div><div class="token-line"><span class="token plain">    	(anonymous)	@	lizard-service-vendor.2b011077.js:1</span></div><div class="token-line"><span class="token plain">    	fail	@	VM261:2</span></div><div class="token-line"><span class="token plain">    	(anonymous)	@	VM296:3</span></div></pre></div><p>我们看到了其中的 setTimeout (async) 这样的字样，表示着这是一个异步调用抛出的堆栈，但是，“captured” 这样的字样也并未打印，因为母方法 fail() 本身的原始顺序执行并没有失败，这个异常的抛出是在回调行为里发生的。</p><p>从上面的例子可以看出，对于异步编程来说，我们需要使用一种更好的机制来捕获并处理可能发生的异常。</p><h3 id="promise-的异常处理"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#promise-的异常处理"><span class="icon icon-link"></span></a>Promise 的异常处理</h3><p>还记得上面介绍的 Promise 吗？它除了支持 resolve 回调以外，还支持 reject 回调，前者用于表示异步调用顺利结束，而后者则表示有异常发生，中断调用链并将异常抛出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var exe = (flag) =&gt;</span></div><div class="token-line"><span class="token plain">      () =&gt; new Promise((resolve, reject) =&gt; {</span></div><div class="token-line"><span class="token plain">        console.log(flag);</span></div><div class="token-line"><span class="token plain">        setTimeout(() =&gt; { flag ? resolve(&quot;yes&quot;) : reject(&quot;no&quot;); }, 1000);</span></div><div class="token-line"><span class="token plain">      });</span></div></pre></div><p>上面的代码中，flag 参数用来控制流程是顺利执行还是发生错误。在错误发生的时候，no 字符串会被传递给 reject 函数，进一步传递给调用链：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Promise.resolve()</span></div><div class="token-line"><span class="token plain">      .then(exe(false))</span></div><div class="token-line"><span class="token plain">      .then(exe(true));</span></div></pre></div><p>你看，上面的调用链，在执行的时候，第二行就传入了参数 false，它就已经失败了，异常抛出了，因此第三行的 exe 实际没有得到执行，你会看到这样的执行结果：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">false</span></div><div class="token-line"><span class="token plain">    Uncaught (in promise) no</span></div></pre></div><p>这就说明，通过这种方式，调用链被中断了，下一个正常逻辑 exe(true) 没有被执行。</p><p>但是，有时候我们需要捕获错误，而继续执行后面的逻辑，该怎样做？这种情况下我们就要在调用链中使用 catch 了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Promise.resolve()</span></div><div class="token-line"><span class="token plain">      .then(exe(false))</span></div><div class="token-line"><span class="token plain">      .catch((info) =&gt; { console.log(info); })</span></div><div class="token-line"><span class="token plain">      .then(exe(true));</span></div></pre></div><p>这种方式下，异常信息被捕获并打印，而调用链的下一步，也就是第四行的 exe(true) 可以继续被执行。我们将看到这样的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">false</span></div><div class="token-line"><span class="token plain">    no</span></div><div class="token-line"><span class="token plain">    true</span></div></pre></div><h3 id="asyncawait-下的异常处理"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#asyncawait-下的异常处理"><span class="icon icon-link"></span></a>async/await 下的异常处理</h3><p>利用 async/await 的语法糖，我们可以像处理同步代码的异常一样，来处理异步代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var run = async () =&gt; {</span></div><div class="token-line"><span class="token plain">      try {</span></div><div class="token-line"><span class="token plain">        await exe(false)();</span></div><div class="token-line"><span class="token plain">        await exe(true)();</span></div><div class="token-line"><span class="token plain">      } catch (e) {</span></div><div class="token-line"><span class="token plain">        console.log(e);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    run();</span></div></pre></div><p>简单说明一下 ，定义一个异步方法 run，由于 await 后面需要直接跟 Promise 对象，因此我们通过额外的一个方法调用符号 () 把原有的 exe 方法内部的 Thunk 包装拆掉，即执行 exe(false)() 或 exe(true)() 返回的就是 Promise 对象。在 try 块之后，我们使用 catch 来捕捉。运行代码，我们得到了这样的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">false</span></div><div class="token-line"><span class="token plain">    no</span></div></pre></div><p>这个 false 就是 exe 方法对入参的输出，而这个 no 就是 setTimeout 方法 reject 的回调返回，它通过异常捕获并最终在 catch 块中输出。就像我们所认识的同步代码一样，第四行的 exe(true) 并未得到执行。</p><h2 id="总结思考"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#总结思考"><span class="icon icon-link"></span></a>总结思考</h2><p>今天我们结合实例学习了 JavaScript 异步编程的一些方法，包括使用 Promise 或 async/await 来改善异步代码，使用生成器来实现协程，以及怎样进行异步错误处理等等。其中，Promise 相关的使用是需要重点理解的内容，因为它的应用性非常普遍。</p><p>现在，我来提两个问题：</p><ul><li>在你的项目中，是否使用过 JavaScript 异步编程，都使用了和异步编程有关的哪些技术呢？</li><li>ES6 和 ES7 引入了很多 JavaScript 的高级特性和语法糖，包括这一讲提到的部分。有程序员朋友认为，这些在项目中的应用，反而给编程人员的阅读和理解造成了困扰，增加了学习曲线，还不如不用它们，写“简单”的 JavaScript 语法。对此，你怎么看？</li></ul><p>在本章我们学习了基于 Web 的全栈技术中，前端相关的部分，希望这些内容能够帮到你，在前端这块土地上成长为更好的工程师。同时，在这一章我们学到了很多套路和方法，请回想一下，并在未来的工作中慢慢应用和体会，它们都是可以应用到软件其它领域的设计和编码上的。在第四章，我们会将目光往后移，去了解了解持久化的世界，希望现在的你依然充满干劲！</p><h2 id="扩展阅读"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06#扩展阅读"><span class="icon icon-link"></span></a>扩展阅读</h2><ul><li>对于今天学习的 Promise，你可以在 MDN 的<a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 一文中读到更为详尽的介绍；第二个是生成器，生成器实际上功能很强大，它甚至可以嵌套使用，你也可以参见 <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">MDN 的示例教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li><li>如果你想快速浏览 ES6 新带来的 JavaScript 高级特性，我推荐你浏览 <a target="_blank" rel="noopener noreferrer" href="http://es6.ruanyifeng.com/">ECMAScript 6 入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，从中挑选你感兴趣的内容阅读。</li><li><a target="_blank" rel="noopener noreferrer" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">Async-Await ≈ Generators + Promises<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这篇文章介绍了生成器、Promise 和 async/await 之间的关系，读完你就能明白“为什么我们说 async/await 是生成器和 Promise 的语法糖”，感兴趣的朋友可以阅读，想阅读中文版的可以参见<a target="_blank" rel="noopener noreferrer" href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2">这个翻译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全栈工程师修炼指南/04.第三章从后端到前端/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
