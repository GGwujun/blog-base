<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>36 | 全栈开发中的算法（上） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全栈工程师修炼指南/07.第六章专题/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读">01.课前必读</a><ul><li><a href="/blog/全栈工程师修炼指南/01.课前必读/01"><span>开篇词 | 从成长角度看，为什么你应该成为全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/02"><span>学习路径 | 怎样成为一名优秀的全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/03"><span>导读 | 如何学习这个专栏？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口">02.第一章网络协议和Web接口</a><ul><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/01"><span>01 | 网络互联的昨天、今天和明天：HTTP 协议的演化</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/02"><span>02 | 为HTTP穿上盔甲：HTTPS</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03"><span>03 | 换个角度解决问题：服务端推送技术</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/04"><span>04 | 工整与自由的风格之争：SOAP和REST</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/05"><span>05 | 权衡的艺术：漫谈Web API的设计</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/06"><span>06 | 特别放送：北美大厂如何招聘全栈工程师？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界">03.第二章欢迎来到MVC的世界</a><ul><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/01"><span>07 | 解耦是永恒的主题：MVC框架的发展</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02"><span>08 | MVC架构解析：模型（Model）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/03"><span>09 | MVC架构解析：视图（View）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/04"><span>10 | MVC架构解析：控制器（Controller）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/05"><span>11 | 剑走偏锋：面向切面编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/06"><span>12 | 唯有套路得人心：谈谈Java EE的那些模式</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/07"><span>13 | 特别放送：选择比努力更重要</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端">04.第三章从后端到前端</a><ul><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/01"><span>14 | 别有洞天：从后端到前端</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/02"><span>15 | 重剑无锋，大巧不工：JavaScript面向对象</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/03"><span>16 | 百花齐放，百家争鸣：前端MVC框架</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/04"><span>17 | 不一样的体验：交互设计和页面布局</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/05"><span>18 | 千言万语不及一幅画：谈谈数据可视化</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06"><span>19 | 打开潘多拉盒子：JavaScript异步编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/07"><span>20 | 特别放送：全栈团队的角色构成</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化">05.第四章数据持久化</a><ul><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/01"><span>21 | 赫赫有名的双刃剑：缓存（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/02"><span>22 | 赫赫有名的双刃剑：缓存（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/03"><span>23 | 知其然，知其所以然：数据的持久化和一致性</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/04"><span>24 |  尺有所短，寸有所长：CAP和数据存储技术选择</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/05"><span>25 | 设计数据持久层（上）：理论分析</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/06"><span>26 | 设计数据持久层（下）：案例介绍</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/07"><span>27 |  特别放送：聊一聊代码审查</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践">06.第五章寻找最佳实践</a><ul><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/01"><span>28 | Ops三部曲之一：配置管理</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/02"><span>29 | Ops三部曲之二：集群部署</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/03"><span>30 | Ops三部曲之三：测试和发布</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/04"><span>31 | 防人之心不可无：网站安全问题窥视</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/05"><span>32 | 和搜索引擎的对话：SEO的原理和基础</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/06"><span>33  | 特别放送：聊一聊程序员学英语</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/07.第六章专题">07.第六章专题</a><ul><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/01"><span>34 | 网站性能优化（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/02"><span>35 | 网站性能优化（下）</span></a></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/07.第六章专题/03"><span>36 | 全栈开发中的算法（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/04"><span>37 | 全栈开发中的算法（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/05"><span>38 | 分页的那些事儿</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/06"><span>39 | XML、JSON、YAML比较</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/07"><span>40 | 全栈衍化：让全栈意味着更多</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾">08.全栈回顾</a><ul><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾/01"><span>全栈回顾 | 成为更好的全栈工程师！</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/09.加餐">09.加餐</a><ul><li><a href="/blog/全栈工程师修炼指南/09.加餐/01"><span>好书荐读：小众书也有看头儿</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/10.期末测试">10.期末测试</a><ul><li><a href="/blog/全栈工程师修炼指南/10.期末测试/01"><span>期末测试 | 对于全栈的内容，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/summary">全栈工程师修炼指南</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="流量控制系统中的算法" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#流量控制系统中的算法"><span>流量控制系统中的算法</span></a></li><li title="简化问题" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#简化问题"><span>简化问题</span></a></li><li title="简单计数" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#简单计数"><span>简单计数</span></a></li><li title="从固定窗口到滑动窗口" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#从固定窗口到滑动窗口"><span>从固定窗口到滑动窗口</span></a></li><li title="时间队列" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#时间队列"><span>时间队列</span></a></li><li title="细化控制粒度" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#细化控制粒度"><span>细化控制粒度</span></a></li><li title="漏桶算法" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#漏桶算法"><span>漏桶算法</span></a></li><li title="令牌桶算法" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#令牌桶算法"><span>令牌桶算法</span></a></li><li title="总结思考" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#总结思考"><span>总结思考</span></a></li><li title="选修课堂：Diffie–Hellman 密钥交换" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#选修课堂diffiehellman-密钥交换"><span>选修课堂：Diffie–Hellman 密钥交换</span></a></li><li title="密钥计算过程" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#密钥计算过程"><span>密钥计算过程</span></a></li><li title="质数和模幂运算" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#质数和模幂运算"><span>质数和模幂运算</span></a></li><li title="扩展阅读" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/03#扩展阅读"><span>扩展阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="36--全栈开发中的算法上"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#36--全栈开发中的算法上"><span class="icon icon-link"></span></a>36 | 全栈开发中的算法（上）</h1><p>你好，我是四火。</p><p>在本专栏中，我们已经接触到了全栈开发中的一些算法了。在这一讲和下一讲中，我又精心挑选了几个比较重要的。**和单纯地从数学角度去介绍算法不同，我想结合几个全栈开发中实际、典型的问题场景，向你介绍这几个相关的重要算法。**毕竟，我们关心的算法，其实就是可以解决实际问题的方法的一种数学抽象。</p><p>希望通过这两讲的学习，你能理解这些算法。除了理解算法原理本身，我们更要抓住它们的用途和算法自身的巧妙之处。今天我们来讲其中的第一个典型的问题场景——流量控制。</p><h2 id="流量控制系统中的算法"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#流量控制系统中的算法"><span class="icon icon-link"></span></a>流量控制系统中的算法</h2><p>对于全栈工程师来说，无论是网站，还是其它 Web 应用，一旦对外商用，就要考虑流量控制的问题。因此我们往往需要设计使用单独的流量控制模块，我们来看下面这样的一个问题。</p><p>假如说，我们现在需要给一组 Web API 设计一个流量控制系统，以避免请求对系统的过度冲击，对于任意一个用户账户 ID，每一个 API 都要满足下面所有的要求：</p><ul><li>每分钟调用不能超过一万次；</li><li>每小时调用不能超过十万次；</li><li>每天调用不能超过一百万次；</li><li>每周调用不能超过一千万次；</li><li>……</li></ul><p>在继续往下阅读之前，请你先从算法和数据结构的角度思考，你觉得该怎么设计这个流量控制系统呢？</p><h3 id="简化问题"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#简化问题"><span class="icon icon-link"></span></a>简化问题</h3><p>在解决实际问题的时候，我们面临的问题往往是复杂的、多样的，因此，我们可以<strong>考虑能不能先简化问题，再来尝试映射到某一个数学模型上。那些先不考虑的复杂条件，有的可能就是可以忽略掉的，而有的则是为了思路的清晰。一开始我们可以先忽略，有了解题的方法原型以后，再逐步加回来考虑。</strong></p><p>那就这个问题而言，我可以做如下的简化：</p><ul><li>有大量的用户账户 ID，但是我们现在只考虑某一个特定的账户 ID，反正其它账户 ID 的做法也是一样的；</li><li>这里面有多个 Web API，但是我们可以只考虑其中特定的一个 API，反正其它 API 也是类似的；</li><li>这里面有多条规则，但是我们可以只考虑其中的一个规则，即“每分钟调用不能超过一万次”，至于其它的规则，原理上也是一样的。</li><li>为了简化问题，在这里我们也暂不考虑并发、分布式、线程安全等问题。</li></ul><p>好，现在问题就简单多了，当我们把这个简化了的问题解决了之后，我们再引入多个用户 ID、多个 API和多条规则这样的维度：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class RateLimiter {</span></div><div class="token-line"><span class="token plain">        public boolean isAllowed() {</span></div><div class="token-line"><span class="token plain">            ... // 当每分钟调用不超过 10000 次，就返回 true，否则返回 false</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="简单计数"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#简单计数"><span class="icon icon-link"></span></a>简单计数</h3><p>好，最先进入脑海的是采用简单计数的办法，我们给 RateLimiter 一个起始时间的时间戳。如果当前时间在距离起始时间一分钟以内，我们就看当前已经放进来了多少个请求，如果是 10000 个以内，就允许访问，否则就拒绝访问；如果当前时间已经超过了起始时间一分钟，就更新时间戳，并清零计数器。参考代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class RateLimiter {</span></div><div class="token-line"><span class="token plain">        private long start = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">        private int count = 0;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public boolean isAllowed() {</span></div><div class="token-line"><span class="token plain">            long now = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            if (now-start &gt; 60*1000) {</span></div><div class="token-line"><span class="token plain">                start = now - (now-start)%(60*1000); // 所在时间窗口的起始位置</span></div><div class="token-line"><span class="token plain">                count = 0;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            if (count &lt; 10000) {</span></div><div class="token-line"><span class="token plain">                count++;</span></div><div class="token-line"><span class="token plain">                return true;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return false;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这样这个问题似乎就得到了解决。<strong>可是，刚才我们在解决问题的时候，似乎“擅自”强化了一个条件……</strong></p><h3 id="从固定窗口到滑动窗口"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#从固定窗口到滑动窗口"><span class="icon icon-link"></span></a>从固定窗口到滑动窗口</h3><p>这个条件就是“固定时间窗口”。</p><p>举个例子，从 3:00 到 3:01 这一分钟时间内，假如系统收到了 9000 个请求，而在 3:01 到 3:02 这接着的一分钟内，系统也收到了 9000 个请求，二者都满足要求。但是，这是我们给了一个假定的增强条件——固定时间窗口，而得到的结论。</p><p>假如说前面这 9000 个请求都分布在 3:00:30 到 3:01:00 之间，后面这 9000 个请求都分布在 3:01:00 到 3:01:30 之间，即从 3 点 00 分 30 秒 到 3 点 01 分 30 秒这一分钟内，系统居然接纳了 9000 + 9000 = 18000 个请求。因此，如果我们考虑的是“滑动时间窗口”，这显然违背了我们的每分钟一万次最大请求量的规则。请看下图：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage2d1b2d376db8e707852fc10d21530837fa1b.png" alt=""/></p><p>因此，相较来说，更实际的情况下，我们是要支持滑动时间窗口，也就是任意一分钟的时间窗口内，都要满足小于 10000 请求量的规则。看来，简单计数法需要改进。</p><h3 id="时间队列"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#时间队列"><span class="icon icon-link"></span></a>时间队列</h3><p>**对于滑动窗口的问题，我们经常要引入队列来解决问题。**因为队列的特点是先进先出，一头进，另一头出，而很多滑动窗口的问题，恰恰需要这个特性，这个问题也不例外。</p><p>假如我们维护一个最近时间戳的队列，这个队列长度不能超过 10000，那么，当新的请求到来的时候，我们只需要找到从“当前时间减 1 分钟”到“当前时间”这样一个滑动窗口区间。如果队列的尾部有任何存储的时间戳在这个区间之外（一分钟以前），那我们就把它从队列中拿掉。如果队列长度小于 10000，那么这个新的请求的时间戳就可以入队列，允许请求访问；反之，则不允许请求访问。请看下图：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage80e08002fa4ef1491a6ec8fd32d504e9bae0.png" alt=""/></p><p>这个过程，参考代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class RateLimiter {</span></div><div class="token-line"><span class="token plain">        private Queue&lt;Long&gt; queue = new LinkedList&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public boolean isAllowed() {</span></div><div class="token-line"><span class="token plain">            long now = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            while (!queue.isEmpty() &amp;&amp; queue.peek() &lt; now-60*1000) {</span></div><div class="token-line"><span class="token plain">                // 如果请求已经是在一分钟以前了，忽略</span></div><div class="token-line"><span class="token plain">                queue.remove();</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            if (queue.size() &lt; 10000) {</span></div><div class="token-line"><span class="token plain">                queue.add(now);</span></div><div class="token-line"><span class="token plain">                return true;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return false;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以看到，这个算法从时间消耗上看，颇为高效，但是在支持滑动窗口的同时，我们也能看到，付出的代价是一个数量级上相当于窗口宽度的空间复杂度，其实它就是这个队列的空间消耗，在这里队列最大长度就是 10000。</p><p>如果我们允许队列的长度较大，队列造成的空间消耗和单个处理请求的最大时间消耗就可能会成为问题，我们能优化一下吗？</p><p>能。那么这种情况下，<strong>一种“妥协”的办法就是，队列中的每个元素，不再是实际请求精确到毫秒的时间戳，而是特定某一秒中包含的请求数目</strong>，比如队列的其中一个元素表示 3:00:01 到 3:00:02 之间对应有 150 个请求。用这种方法，对于上述这个一分钟内流量限制的问题，我们可以把队列长度严格控制在 60（因为是 60 秒），每个元素都表示特定某一秒中的请求数目。当然，这个方法损失的是时间窗口毫秒级的精度。而这，就是我们控制时间窗口队列的长度所采用的一种较为常见的优化方式，它虽<strong>损失了精度，但却降低了空间复杂度</strong>。</p><p>好，规则已经做到严格匹配了，可是在实际应用中，在很多情况下，这还是有问题。为什么呢？</p><h3 id="细化控制粒度"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#细化控制粒度"><span class="icon icon-link"></span></a>细化控制粒度</h3><p>这要从流量控制的动机说起，<strong>我们建立流量控制这个系统的目的，是为了避免对于系统的冲击，而无论使用固定窗口，还是滑动窗口，根据当前的规则，我们都只能限定这个一分钟窗口内的流量符合要求，却不能做到更细粒度的控制。</strong></p><p>举个极端的例子，一分钟内这一万个请求，如果均匀地分布在这一分钟的窗口中，系统很可能就不会出问题；但如果这一万个请求，全部集中在最开始的一秒钟内，系统就压垮了，这样的流量控制就没有起到有效的防御作用了。</p><p>那好，如果我们要做到系统可以接受的更细的粒度。举例来说，如果我们可以做到按秒控制，那么继续按照 10000 个/分钟来计算的话，这个限制就可以换算成不要超过 10000/60 ≈ 167 个/秒。</p><h3 id="漏桶算法"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#漏桶算法"><span class="icon icon-link"></span></a>漏桶算法</h3><p>漏桶（Leaky Bucket）算法就是可以带来更细粒度控制的限流算法，它的粒度取决于系统所支持的准确最小时间间隔，比如毫秒。</p><p>你可以想象一个有缺漏的桶，无论我们怎样往里面放水（发送请求），水都有可能以两种方式从桶中排出来：</p><ul><li>从漏口往外流，如果桶中有水，这个流速是一定的（这就是<strong>系统满载时，限流的流速</strong>）；</li><li>注水太快，水从桶中溢出（这就是<strong>请求被拒绝了，限流效果产生</strong>）。</li></ul><p>另外，由于请求的最小单位是一个，因此桶的大小不得小于 1。我们要求请求发送的速度不得小于漏水的速度，但我们更多时候会设置一定的桶容量，这就意味着系统允许一定程度的富余以应对突发量。这个桶大小，也就是突发量，被称为 burst。</p><p>于是，我们每次都可以根据流速以及上一次的流量检测时间，获知在考虑漏水的情况下，如果接纳当前请求，那么桶中将达到怎样的水位，是否会超过 burst。如果不超过，就允许此次访问，反之拒绝。参考代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class RateLimiter {</span></div><div class="token-line"><span class="token plain">        private float leakingRate = 10000f/60/1000; // 每一毫秒能够漏掉的水</span></div><div class="token-line"><span class="token plain">        private float remaining = 0; // 桶中余下的水</span></div><div class="token-line"><span class="token plain">        private float burst = 10000;  // 桶容量</span></div><div class="token-line"><span class="token plain">        private long lastTime = System.currentTimeMillis(); // 最近一次流量检测时间</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        public boolean isAllowed() {</span></div><div class="token-line"><span class="token plain">            long now = System.currentTimeMillis();</span></div><div class="token-line"><span class="token plain">            remaining = Math.max(0, remaining - (now-lastTime)*leakingRate); // 如果漏完了，余下的就是0，不能出现负数</span></div><div class="token-line"><span class="token plain">            lastTime = now;</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            if (remaining+1 &lt;= burst) {</span></div><div class="token-line"><span class="token plain">                remaining++;</span></div><div class="token-line"><span class="token plain">                return true;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return false;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从复杂度上你也可以看到，我们通过变量 remaining 记录每一个请求到达的时刻，桶中水的余量，整个空间复杂度是常量级的。当然了，我们的控制已经不是针对“一分钟规则”了，控制粒度上更加细化，更符合我们对系统保护的实际要求，因此这个方法的应用更广。</p><h3 id="令牌桶算法"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#令牌桶算法"><span class="icon icon-link"></span></a>令牌桶算法</h3><p>还有一种和漏桶算法本质上一致，但是实现上有所不同的方法，叫做令牌桶（Token Bucket）算法。说它们实现上不同是因为，漏桶是不断往外漏水，看能不能把陆续到来的请求给消耗掉；而令牌桶呢，则是在令牌桶内会定期放入令牌，每一个请求到来，都要去令牌桶内取令牌，取得了才可以继续访问系统，否则就会被流量控制系统拒绝掉。</p><p>就像我们的问题，每 60*1000/10000 = 6 毫秒就要向令牌桶内放置一个令牌。和前面的漏桶算法一样，我们并不一定要真的建立一个放入令牌的线程来做这个放入令牌的工作，而是使用和上面类似的算法，在请求到来的时候，根据上次剩余的令牌数和上次之后流逝的时间，计算当前桶内是否还有完整的一张令牌，如果没有令牌，就拒绝请求，否则允许请求。因此，从这个角度说，漏桶和令牌桶这二者在思想本质上是一致的。</p><h2 id="总结思考"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#总结思考"><span class="icon icon-link"></span></a>总结思考</h2><p>今天我通过一个常见的流量控制系统，向你介绍了全栈开发中几个典型的算法，包括基于固定时间窗口的简单计数法，滑动时间窗口的队列法，还有实际应用中更为常见的漏桶算法和令牌桶算法。希望通过今天的学习，你已经理解了它们的工作原理。</p><p>现在我来提两个问题吧：</p><ul><li>漏桶算法我给出了示例代码，而具有一定相似性的令牌桶算法我没有给出示例代码，如果你理解了这两者，能否写出令牌桶算法的代码呢？</li><li>为了简化问题，我在一开始的时候讲了，我们不考虑并发的问题。现在，如果我们把上面无论哪一种算法的代码，改成支持多个线程并发访问的情形，即要求保证线程安全，你觉得需要对代码做怎样的修改呢？</li></ul><h2 id="选修课堂diffiehellman-密钥交换"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#选修课堂diffiehellman-密钥交换"><span class="icon icon-link"></span></a>选修课堂：Diffie–Hellman 密钥交换</h2><p>我们在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/135864">[第 02 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中介绍 HTTPS 加密的时候，提到了 Pre-master Secret 生成的方式，其中一种就是 Diffie–Hellman 密钥交换这一算法的变种（如有遗忘，请回看），但是，我们并没有讲其中加密具体的算法原理。那么，下面我就来看一下 Diffie–Hellman 密钥交换，这个常见的 HTTPS 加密算法，是怎样做到<strong>正向计算简单、逆向求解困难</strong>，来保证安全性的。</p><h3 id="密钥计算过程"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#密钥计算过程"><span class="icon icon-link"></span></a>密钥计算过程</h3><p>Diffie–Hellman 密钥交换是一种在非保护信道中安全地创建共享密钥方法，它的出现在如今众所周知的 RSA 算法发明之前。现在让我们来玩一个角色扮演游戏，假设你要和我进行通信，我们就来使用这种办法安全地创建共享密钥：</p><ul><li>通信的你和我都协议商定了质数 p 和另一个底数 g；</li><li>你呢，先生成一个只有你自己知道的随机整数 a，并将结果 A = gᵃ mod p 发给我；</li><li>我呢，也生成一个只有我自己知道的随机整数 b，并将结果 B = gᵇ mod p 发给你；</li><li>你根据我发过来的 B，计算得到 s = Bᵃ mod p；</li><li>我根据你发过来的 A，计算得到 s’ = Aᵇ mod p。</li></ul><p>这个过程用简单的图示来表示就是：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage6d3c6d40d7bcf10858022fabf9c492626b3c.png" alt=""/></p><p>你看，整个过程中，**只有 a、b 这两个数分别是你和我各自知道并保密的，而其它交换的数据全部都是公开的。**对于你来说，已经有了 a，又得到我传过来的 B，于是你算出了 s；对于我来说，已经有了 b，又得到了你传过来的 A，于是我算出了 s’。</p><p>有趣的是，经过计算，你得到的 s 和我得到的 s’，这两个数总是相等的，既然相等，那这个值也就可以用作你我之间通信的对称密钥了。也就是说，**通信双方分别算得了相等的密钥，这也就避免了密钥传递的风险。**可是，为什么 s 和 s’ 它们是相等的呢？</p><h3 id="质数和模幂运算"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#质数和模幂运算"><span class="icon icon-link"></span></a>质数和模幂运算</h3><p>因为，g 的 a 次方再 b 次方，等于 g 的 b 次方再 a 次方，即便每次幂运算后加上 p 来取模，也不影响最后结果的相等性，换言之：</p><p><strong>gᵃᵇ mod p = (gᵃ mod p)ᵇ mod p = (gᵇ mod p)ᵃ mod p</strong></p><p>上面这样的，先求幂，再取模的运算，我们把它简单称为“模幂运算”。在实际应用中，g 可以取一个比较小的数，而 a、b 和 p，都要取非常大的数，而且 p 往往会取一个“极大”的质数——因为质数在此会具备这样一个重要性质，模幂运算结果会在小于 p 的非负整数中均匀分布；而另外一个原因是，由于 g 的 a 次方或 b 次方会非常大，需要一个“上限”，一个使得生成的数无论是传输还是存储都能够可行的方法。<strong>因此大质数 p 的取模运算被用来设定上限并将大数化小，且保持原有的逆向求解困难性。</strong></p><p>说到逆向求解的困难性，这是根据数学上<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0">离散对数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>求解的特性所决定的，具体说来，就是这样一个模幂等式：</p><p><strong>gᵃ mod p = A</strong></p><p>从难度上看，该式具有如下三个特性：</p><ul><li>特性 ①：已知 g、a 和 p，求 A 容易；</li><li>特性 ②：已知 g、p 和 A，求 a 困难；</li><li>特性 ③：已知 a、p 和 A，求 g 也困难。</li></ul><p>正好，Diffie–Hellman 密钥交换利用了其中的特性 ① 和特性 ②。比如 a 是超过 100 位的正整数，而 p 则达到了 300 位，那么在这种情况下，如果有恶意的攻击者，得到了 g、p，截获了 A，但是他根据这些信息，考虑我们前面介绍的公式 A = gᵃ mod p，在现有科技能达到的算力下，几乎是无法求解出其中的 a 来的。无法知道 a，无法进而求得对称密钥 s（因为 s 需要通过 Bᵃ mod p 求得），这就起到了加密的作用，这也是 Diffie–Hellman 密钥交换能够实现的原理。</p><h2 id="扩展阅读"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/03#扩展阅读"><span class="icon icon-link"></span></a>扩展阅读</h2><ul><li>【基础】文中我提到了算法的时间复杂度和空间复杂度，这是属于算法的基础知识。如果不太熟悉的话可以阅读一下这个<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95#%E5%A4%8D%E6%9D%82%E5%BA%A6">词条<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，以及<a target="_blank" rel="noopener noreferrer" href="https://zhuanlan.zhihu.com/p/50479555">这篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文章，而在<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%97%E8%A1%A8">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>则有常见算法的时间复杂度列表。</li><li>选修课堂中介绍的 Diffie–Hellman 密钥交换利用了模幂公式的“正向计算简单，逆向求解困难”这一特点，这个特点非常重要，还有一个相关的技术 RSA 也利用了这一特点。本来我是把 RSA 加密技术的原理介绍和 Diffie–Hellman 密钥交换放在一起讲述的，但是经过仔细斟酌，我觉得 RSA 涉及到的数学知识稍多，整体理解起来明显偏难，因此为了专栏内容和难度的一致性，我忍痛把它拿出去了，并放在了我自己的博客上，感兴趣的话可以<a target="_blank" rel="noopener noreferrer" href="https://www.raychase.net/5698">移步阅读<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li></ul><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage118b1181246bbd51ce348d5729696d1dc28b.jpg" alt="unpreview"/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全栈工程师修炼指南/07.第六章专题/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
