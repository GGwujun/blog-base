<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>35 | 网站性能优化（下） - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/全栈工程师修炼指南/07.第六章专题/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读">01.课前必读</a><ul><li><a href="/blog/全栈工程师修炼指南/01.课前必读/01"><span>开篇词 | 从成长角度看，为什么你应该成为全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/02"><span>学习路径 | 怎样成为一名优秀的全栈工程师？</span></a></li><li><a href="/blog/全栈工程师修炼指南/01.课前必读/03"><span>导读 | 如何学习这个专栏？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口">02.第一章网络协议和Web接口</a><ul><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/01"><span>01 | 网络互联的昨天、今天和明天：HTTP 协议的演化</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/02"><span>02 | 为HTTP穿上盔甲：HTTPS</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/03"><span>03 | 换个角度解决问题：服务端推送技术</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/04"><span>04 | 工整与自由的风格之争：SOAP和REST</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/05"><span>05 | 权衡的艺术：漫谈Web API的设计</span></a></li><li><a href="/blog/全栈工程师修炼指南/02.第一章网络协议和web接口/06"><span>06 | 特别放送：北美大厂如何招聘全栈工程师？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界">03.第二章欢迎来到MVC的世界</a><ul><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/01"><span>07 | 解耦是永恒的主题：MVC框架的发展</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/02"><span>08 | MVC架构解析：模型（Model）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/03"><span>09 | MVC架构解析：视图（View）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/04"><span>10 | MVC架构解析：控制器（Controller）篇</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/05"><span>11 | 剑走偏锋：面向切面编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/06"><span>12 | 唯有套路得人心：谈谈Java EE的那些模式</span></a></li><li><a href="/blog/全栈工程师修炼指南/03.第二章欢迎来到mvc的世界/07"><span>13 | 特别放送：选择比努力更重要</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端">04.第三章从后端到前端</a><ul><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/01"><span>14 | 别有洞天：从后端到前端</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/02"><span>15 | 重剑无锋，大巧不工：JavaScript面向对象</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/03"><span>16 | 百花齐放，百家争鸣：前端MVC框架</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/04"><span>17 | 不一样的体验：交互设计和页面布局</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/05"><span>18 | 千言万语不及一幅画：谈谈数据可视化</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/06"><span>19 | 打开潘多拉盒子：JavaScript异步编程</span></a></li><li><a href="/blog/全栈工程师修炼指南/04.第三章从后端到前端/07"><span>20 | 特别放送：全栈团队的角色构成</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化">05.第四章数据持久化</a><ul><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/01"><span>21 | 赫赫有名的双刃剑：缓存（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/02"><span>22 | 赫赫有名的双刃剑：缓存（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/03"><span>23 | 知其然，知其所以然：数据的持久化和一致性</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/04"><span>24 |  尺有所短，寸有所长：CAP和数据存储技术选择</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/05"><span>25 | 设计数据持久层（上）：理论分析</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/06"><span>26 | 设计数据持久层（下）：案例介绍</span></a></li><li><a href="/blog/全栈工程师修炼指南/05.第四章数据持久化/07"><span>27 |  特别放送：聊一聊代码审查</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践">06.第五章寻找最佳实践</a><ul><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/01"><span>28 | Ops三部曲之一：配置管理</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/02"><span>29 | Ops三部曲之二：集群部署</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/03"><span>30 | Ops三部曲之三：测试和发布</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/04"><span>31 | 防人之心不可无：网站安全问题窥视</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/05"><span>32 | 和搜索引擎的对话：SEO的原理和基础</span></a></li><li><a href="/blog/全栈工程师修炼指南/06.第五章寻找最佳实践/06"><span>33  | 特别放送：聊一聊程序员学英语</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/07.第六章专题">07.第六章专题</a><ul><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/01"><span>34 | 网站性能优化（上）</span></a></li><li><a aria-current="page" class="active" href="/blog/全栈工程师修炼指南/07.第六章专题/02"><span>35 | 网站性能优化（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/03"><span>36 | 全栈开发中的算法（上）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/04"><span>37 | 全栈开发中的算法（下）</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/05"><span>38 | 分页的那些事儿</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/06"><span>39 | XML、JSON、YAML比较</span></a></li><li><a href="/blog/全栈工程师修炼指南/07.第六章专题/07"><span>40 | 全栈衍化：让全栈意味着更多</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾">08.全栈回顾</a><ul><li><a href="/blog/全栈工程师修炼指南/08.全栈回顾/01"><span>全栈回顾 | 成为更好的全栈工程师！</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/09.加餐">09.加餐</a><ul><li><a href="/blog/全栈工程师修炼指南/09.加餐/01"><span>好书荐读：小众书也有看头儿</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/10.期末测试">10.期末测试</a><ul><li><a href="/blog/全栈工程师修炼指南/10.期末测试/01"><span>期末测试 | 对于全栈的内容，你掌握了多少呢？</span></a></li></ul></li><li><a href="/blog/全栈工程师修炼指南/summary">全栈工程师修炼指南</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="产品和架构调整" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#产品和架构调整"><span>产品和架构调整</span></a></li><li title="1. 同步变异步" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-同步变异步"><span>1. 同步变异步</span></a></li><li title="2. 远程变本地" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-远程变本地"><span>2. 远程变本地</span></a></li><li title="3. 页面静态化" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-页面静态化"><span>3. 页面静态化</span></a></li><li title="后端和持久层优化" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#后端和持久层优化"><span>后端和持久层优化</span></a></li><li title="1. 串行变并行" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-串行变并行"><span>1. 串行变并行</span></a></li><li title="2. 数据库索引创建" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-数据库索引创建"><span>2. 数据库索引创建</span></a></li><li title="3. 数据库表拆分" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-数据库表拆分"><span>3. 数据库表拆分</span></a></li><li title="4. 悲观锁变乐观锁" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#4-悲观锁变乐观锁"><span>4. 悲观锁变乐观锁</span></a></li><li title="前端和网络层优化" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#前端和网络层优化"><span>前端和网络层优化</span></a></li><li title="1. 减少请求次数" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-减少请求次数"><span>1. 减少请求次数</span></a></li><li title="2. 减少渲染次数" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-减少渲染次数"><span>2. 减少渲染次数</span></a></li><li title="3. 减少 JavaScript 阻塞" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-减少-javascript-阻塞"><span>3. 减少 JavaScript 阻塞</span></a></li><li title="4. 文本消息压缩" data-depth="3"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#4-文本消息压缩"><span>4. 文本消息压缩</span></a></li><li title="总结思考" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#总结思考"><span>总结思考</span></a></li><li title="扩展阅读" data-depth="2"><a href="/blog/全栈工程师修炼指南/07.第六章专题/02#扩展阅读"><span>扩展阅读</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="35--网站性能优化下"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#35--网站性能优化下"><span class="icon icon-link"></span></a>35 | 网站性能优化（下）</h1><p>你好，我是四火。</p><p>上一讲我们介绍了网站性能优化的基础知识，包括性能指标、关注点，以及寻找性能瓶颈的思路。那么这一讲，我们就来介绍网站性能优化的具体方法，我们将从产品和架构、后端和持久层，以及前端和网络层这样三个部分分别展开。优化的角度和方法可以说花样繁多，我在这里举一些典型的例子，希望既能给你一些内容上的介绍，进而拓宽视野，也能给你一些思考角度上的启发。</p><h2 id="产品和架构调整"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#产品和架构调整"><span class="icon icon-link"></span></a>产品和架构调整</h2><p>对于一个应用来说，产品和架构恰巧是两个互相对立而又相辅相成的角度。作为全栈工程师，我们当然鼓励追求细节，但是在考虑性能优化的时候，我认为还是要<strong>优先考虑从大处着眼，而不是把大量时间花费在小处的细节提升上</strong>，以期望获得较为明显的效果。这里的“大处”，就主要包含了产品和技术架构两个维度。</p><h3 id="1-同步变异步"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-同步变异步"><span class="icon icon-link"></span></a>1. 同步变异步</h3><p>如果页面聚合在服务端进行，那么渲染前等待的时间，在整个任务依赖树上面，取决于最慢的一个路径什么时候完成；而如果页面聚合是在客户端进行的，那么页面每一个子区域的渲染往往都可以以 Ajax 的方式独立进行，且同时进行，而母页面则可以首先展示给用户，减少用户的等待时间。</p><p>这里我还想补充一点，我们可以把同步和异步结合起来使用以获得最好的效果。比方说，用户对于网页加载的延迟是很敏锐的，但是用户对于一个页面上不同的信息，关注程度是不同的。</p><p>举例来说，一篇文章，标题可能是最先关注的，其次才是作者或是正文，至于评论、广告等等这些内容，优先级则更低。因此，我们可以让标题和正文内容的第一屏等高优先级的内容在服务端进行聚合后一并同步返回，这就省去了 Ajax 二次调用的时间开销，而次要内容或是某些生成特别耗时的内容，则可以使用异步方式在客户端单独加载。</p><h3 id="2-远程变本地"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-远程变本地"><span class="icon icon-link"></span></a>2. 远程变本地</h3><p>有些时候，如果能够容许牺牲一定的一致性，而将数据从远程的数据中心冗余到“本地”这样离数据使用者更近的节点，可以减少数据获取的延迟。DNS 的均衡路由就是一个例子，不同地区的用户访问同一个域名的时候，可以被定向到不同的离自己更近的节点上去；CDN 也是一个很典型的例子，静态资源可以从较近的本地节点获取。</p><h3 id="3-页面静态化"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-页面静态化"><span class="icon icon-link"></span></a>3. 页面静态化</h3><p>对于为什么要从大处着眼，我来举一个我在项目中经历过的例子。在我们的一个网站项目，模板中使用了大量的 OGNL 表达式，在做了 profiling 之后，发现 OGNL 表达式占用了相当比例的 CPU，而将其改成 EL 表达式等其它方式，这样做确实可以降低这些 CPU 的使用。这件事情其实没有错，但是这个处理的优先级应该往下放，因为这样的优化，可能只会带来 10% 左右的最终性能提升。</p><p>但是另一方面，我们逐渐引入了页面静态化技术，对于几个关键页面，它直接带来了 300% 到 800% 的性能提升，这就让前面的页面模板的调整显得无足轻重了。性能优化就是这样，并非简单的“一分耕耘一分收获”，有时候我们能找到一些优化的办法，看起来效果很明显，但是调整的代价却不大。</p><p>关于页面静态化，我来举一个 <a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/#">StackOverflow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的例子：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimageb0fcb0980cecf4fdc829e6f931acd8822efc.png" alt=""/></p><p>你看这个 StackOverflow 的页面，我们就可以按照页面静态化的原则来分析：把它划分为几个不同的区域，每个区域都可以具备自己特有的一致性要求，无论是页面还是数据，都可以单独做不同条件下的缓存。</p><p>比方说，正上方和左侧区域是不会变的，这些内容可以写在静态的 HTML 页面模板里，可以说是完全“静态”的；中间的主问题区域，则可能是定期或按一定规则刷新的，相当于在过期时间内也是静态的；而右上角和用户相关的数据，则需要每次页面访问实时生成，以便让不同的用户看到特有的属于他自己的内容，也就是说，这部分内容是完全“动态”的。</p><p>页面静态化的实践中，我们可以将页面解耦成不同的部分：</p><ul><li>从产品的角度来定义每一个部分允许的一致性窗口，比如有的数据是一小时更新一次，数据可以不用非常准确，而有的则是要实时，数据要求非常准确；</li><li>而技术角度，对于每一部分不同的一致性要求，依赖于缓存的特性，也就是空间换时间，我们可以让每个部分进行分别管理，最终聚合起来（页面聚合的方式请参见 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/141817">[第 09 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）。</li></ul><p>在极端的情况下，整个页面是可以直接完全被缓存起来，甚至直接预先生成，而做到全页面静态化的，比如一些几乎不存在个性内容的静态博客站点就是如此。</p><p>当然，还有许多常见的其它架构上的设计，起着提高网站性能的作用，没有展开介绍，是因为它们已经被介绍过，或者是大家普遍比较熟悉了。比如说，对反向代理、集群和负载分担的使用，这些技术我们分别在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/165225">[第 28 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/166084">[第 29 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 介绍过，如今几乎所有的大型网站都使用它们来组网。</p><h2 id="后端和持久层优化"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#后端和持久层优化"><span class="icon icon-link"></span></a>后端和持久层优化</h2><h3 id="1-串行变并行"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-串行变并行"><span class="icon icon-link"></span></a>1. 串行变并行</h3><p>道理上很简单，串行的逻辑，在没有依赖限制的情况下，可以并行执行。后端的逻辑如果需要执行多项操作，那么如果没有依赖，或者依赖项满足的情况下，可以立即执行，而不必一个一个挨个等待依次完成。Spring 的 <a target="_blank" rel="noopener noreferrer" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html">@Async<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 注解，可以比较方便地将普通的 Java 方法调用变成异步进行的，用这种方法可以同时执行数个互不依赖的方法。</p><p>有些朋友可能知道，Amazon 是 SOA 架构（Service-Oriented Architecture，面向服务架构）最早的践行者。贝索斯在 2002 年的时候，就开始要求 Amazon 内部的所有服务，都只能以 Web 接口的形式暴露出来，供其他团队调用，而每个服务，都由专门的团队维护。如今，访问亚马逊的一个商品页，借助 SOA 架构，后台都要调用成百上千个开放的服务，你可以想象，如果这些调用是串行进行的，页面的加载时间将难以想象。</p><h3 id="2-数据库索引创建"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-数据库索引创建"><span class="icon icon-link"></span></a>2. 数据库索引创建</h3><p>凡是提到关系数据库的优化，索引的创建往往是很容易想到的优化方法之一。而对于某些支持半结构化数据存储的非关系数据库，往往也对索引存在有限的支持。</p><p>索引的创建，最常见的一个原因，是为了在查询的时候，显著减少消耗的时间。由于索引是单独以 B 树或者是 B+ 树等变种来存储的，而我们知道这样的数据结构查询的速度可以达到 log(n)，和原表相比，索引在检索时的数据的读取量又很小，因此查询速度的提升往往是立竿见影的。</p><p>但是索引创建并非是没有代价的，在关系数据库中，索引作为原表中索引列数据的一份冗余，维护它自然是有开销的，每当索引数据增、删、改发生的时候，索引也需要相应地发生变化。</p><h3 id="3-数据库表拆分"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-数据库表拆分"><span class="icon icon-link"></span></a>3. 数据库表拆分</h3><p>数据库表拆分也是一个很常见的优化方式，这里的拆分分为横向（水平）拆分和纵向（垂直）拆分两种。</p><p><strong>横向拆分，指的是把业务意义上的同一个表，拆分到不同的数据库节点或不同子表中，也就是说，这些节点中的表结构都是一样的，当然，存储的数据是不一样的。</strong></p><p>我们前面介绍过的 Sharding 和 Partitioning 就是属于这一类型。那么，在查询或修改的时候，我们怎么知道数据在哪台机器上呢？</p><p>这就可以根据主键做 hash 映射或者范围映射来找到相应的节点，再继续进行操作了。Hash 映射本专栏已经介绍过了，而范围映射也很常见，比如用户的交易数据，3 月份的数据一个表，4 月份的数据一个表，这就是使用时间来做范围条件的一个例子。</p><p>**再来说说垂直拆分，说的是把一个表拆成多个表，甚至拆到多个库中，这时的拆分是按照不同列来进行的，拆分出的表结构是完全不一样的，表和表之间通常使用外键关联。**比如有这样一个文件表：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimagec92dc91431880c44619198a143488ef15a2d.jpg" alt=""/></p><p>各列分别为：唯一 ID、标题、创建日期、描述，以及以 BLOB 格式存储的文件具体内容（CONTENT）。</p><p>在这种情况下，如果执行全表扫描的查询，在文件非常大且记录数非常多的情况下，执行的过程会非常慢。这是因为一般的关系数据库是行数据库，数据是一行一行读取的（关于行数据库和列数据库的区别和原理，你可以回看 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/161829">[第 25 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），磁盘一次读取一块，这一块内包含若干行。那么由于 CONTENT 列往往非常大，每次读取只能读到非常少的行，因此需要读取很多次才能完成全表扫描。这种情况下，我们就可以做这样的拆表优化，把这个表拆成如下两个：</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage5b8d5b2e4b69ea8981ead2938ed27de43f8d.jpg" alt=""/></p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage069d06d16222996df1acba163cace9b9889d.jpg" alt=""/></p><p>你看，第一个表一下子就瘦身下来了，这个表没有了那个最大的 BLOB 对象组成的列，在全表扫描进行查询的时候，就可以比较快地进行，而当找到了相应的 ID 并需要取出 CONTENT 的时候，再根据 ID 到第二个表里面去查询出具体需要的文件来。</p><p>你可能注意到了，这种优化的动机和前提有这样两个：</p><ul><li><strong>查询无法单纯地走索引完成，而需要进行全表扫描或部分表扫描；</strong></li><li><strong>某列或某几列占用空间巨大，而它们却并不需要参与关系查询。</strong></li></ul><p>当这两个条件都符合的时候，我们就可以考虑垂直拆分（纵向拆表）了。</p><h3 id="4-悲观锁变乐观锁"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#4-悲观锁变乐观锁"><span class="icon icon-link"></span></a>4. 悲观锁变乐观锁</h3><p>在关系数据库中，如果我们提到了“锁”，就意味着我们想让数据库某条数据的写操作变得“安全”，换言之，当我们需要根据某些条件而对数据进行更改的时候，不会受到并发的其它写操作的影响，而丧失正确性或完整性。在使用“锁”来实现的时候，有悲观锁和乐观锁两种实现。</p><p>所谓悲观锁（Pessimistic Locking），指的是数据库从“最坏”的角度考虑，所以它会先使用排它锁锁定相应的行，进行相应的读判断和写操作，一旦成功了，再提交变更并释放锁资源。**在使用悲观锁锁定相应行的过程中，如果有其它的写操作，是无法同时进行的，而只能等待。**且看这样一组基于 SQL 的例子，它用于将用户的积分更新：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select POINTS from USERS where ID=1001 for update;</span></div><div class="token-line"><span class="token plain">    ... (省略，计算得出积分需要变更为123)</span></div><div class="token-line"><span class="token plain">    update USERS set POINTS=123 where ID=1001;</span></div></pre></div><p>我来简单做个说明：</p><ul><li>第一行，使用 “for update” 这个技巧来锁定 ID 为 1001 的记录，查询出当前的积分；</li><li>第二行，业务逻辑得到积分需要如何变更，假如说得出的结果是积分需要变更为 123；</li><li>第三行，执行积分变更（这里假设事务在 update 之后是配置为自动提交的）；</li></ul><p>这样一来，如果有两条请求同时想执行以上逻辑，那么第一条请求可以执行成功，而第二条会一直等在那里，直到第一条执行完成，它再去执行。这种方式就保证了锁机制的有效性。</p><p>下面再来说说乐观锁（Optimistic Locking）。它和悲观锁正好相反，这种情况假定“大多数”的操作发生锁冲突的概率较小，使用一个当前版本号，来表示当前记录的版本。**乐观锁方式下，不需要使用显示的加锁、提交这样的操作，但缺点是一旦发生冲突，整个过程要重来。**我们可以把前面的步骤变成下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">select POINTS, VERSION from USERS where ID=1001;</span></div><div class="token-line"><span class="token plain">    ... (省略，计算得出积分需要变更为123)</span></div><div class="token-line"><span class="token plain">    update USERS set POINTS=123 and VERSION=VERSION+1 where ID=1001 and VERSION=1;</span></div></pre></div><ul><li>第一行，在读取积分的时候，也一并读取到了当前的版本号，假设版本号是 1；</li><li>第二行，业务逻辑得到积分需要如何变更，假如说得出的结果是积分需要变更为 123；</li><li>第三行，更新积分为 123 并自增版本号，但是条件是版本号为 1。之后需要检测这条 update 语句影响的代码行数：如果影响的行数为 1，说明更新成功，程序结束；如果影响的行数为 0，说明在第一行读取数据以后，记录发生了变更，需要重新执行整个过程。</li></ul><p>还有许许多多其它的后端和持久层的优化通用技术，这里就不展开了。比如缓存的应用，互联网应用有句话叫做“缓存为王”，缓存的本质就是空间换时间，在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/156886">[第 21 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中我们曾经仔细聊过这部分的内容。再比如，应用之外，我们还经常需要从应用宿主和操作系统等角度来考虑，对于这部分，我在扩展阅读中我给出了一些材料供你阅读。</p><h2 id="前端和网络层优化"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#前端和网络层优化"><span class="icon icon-link"></span></a>前端和网络层优化</h2><p>当我们思考前端优化的时候，和后端一样，我们可以考虑连接、下载、解析、加载、渲染等等整个过程，先从大局上对整个时间消耗的分布有一个把握，下图来自<a target="_blank" rel="noopener noreferrer" href="https://tech.meituan.com/2014/03/03/performance-metric.html">这篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>文章。</p><p><img src="/images/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BF%AE%E7%82%BC%E6%8C%87%E5%8D%97/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B8%93%E9%A2%98/resourceimage73917321dc1c3cc44bc7a15b1efaf2e92391.jpeg" alt=""/></p><h3 id="1-减少请求次数"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#1-减少请求次数"><span class="icon icon-link"></span></a>1. 减少请求次数</h3><p>这是进行许多前端优化的共同目标之一，有不少全栈工程师日常在进行的实践，都遵循了这一条原则。</p><ul><li>文本资源：CSS 压缩、JavaScript 压缩。有两个静态资源的后期处理方式我们经常结合起来使用，一个是压缩，一个是混淆。前者将多个文件压缩成一个，目的是减少大小，而更重要的是减少请求数；后者则是将变量使用无意义的名称替代，目的就是让产品代码“难懂”，减少代码实际意义的泄露。</li><li>图像资源：<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Sprite_(computer_graphics)#Sprites_by_CSS">CSS Sprites<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Data_URI_scheme">Inline Image<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。前者又叫做雪碧图、精灵图，是将网站所用的多张图片拼成一张，这样多张图片只需要下载一次，而使用 CSS 中的 background-image 和 background-position 在目标位置选择显示哪一张图片。后者则是干脆将二进制的图片使用 Base64 算法序列化成文本，直接嵌入在原始页面上。</li><li>缓存控制头部。即 Cache-Control 头，这部分我们在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/156886">[第 21 讲]<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 已经介绍过；还有 Etag 头，浏览器会把它发送给服务端用于鉴别目标资源是否发生了更改，如果没有更改，一个 304 响应会返回；以及 Expires 头，是服务端来指定过期时间的。</li></ul><h3 id="2-减少渲染次数"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#2-减少渲染次数"><span class="icon icon-link"></span></a>2. 减少渲染次数</h3><p>CSS 或者 DOM 的变化都会引发渲染，而渲染是由单独的线程来进行的，这个过程会阻塞用户的操作。对于较大的页面、DOM 较多的页面，浏览器渲染会占用大量的 CPU 并带来明显的停顿时间。</p><p>渲染其实包括两种，一种是 reflow，就是页面元素的位置、间隔等等发生更改，这个工作是由 CPU 完成的；另一种叫做 repaint，基本上就是当颜色等发生变更的时候就需要重新绘制，这个工作是由 GPU 完成的。</p><p>因此，如果我们能够减少反复、多次，或是无意义的渲染，就可以在一定程度上为 Web 应用提速，特别是 reflow。那么对于这方面优化的其中一个思路，就是合并操作，即可以合并多个 DOM 操作为一次进行，或是合并单个 DOM 的多次操作为一次进行（React 或者 Vue.js 的 Virtual DOM 技术就借鉴了这种思路）。</p><h3 id="3-减少-javascript-阻塞"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#3-减少-javascript-阻塞"><span class="icon icon-link"></span></a>3. 减少 JavaScript 阻塞</h3><p>JavaScript 阻塞，本质上是由于 JavaScript 解释执行是单线程所造成的，阻塞期间浏览器拒绝响应用户的操作。同步的 Ajax 调用会引发阻塞（一直阻塞到响应返回），耗时的 JavaScript 代码执行也会引起阻塞。</p><p>我们通过将大的工作分裂成多次执行（可以通过每次具备一定间隔时间的回调来实现），每次执行后主动让出执行线程，这样每次就可以只阻塞一小会儿，以显著减少 JavaScript 阻塞对用户造成的影响；而对于一些独立的耗时操作，可以引入 <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 分配单独运行的线程来完成。</p><h3 id="4-文本消息压缩"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#4-文本消息压缩"><span class="icon icon-link"></span></a>4. 文本消息压缩</h3><p>对于页面这样的文本内容，通过配置 Web 容器的 gzip 压缩，可以获得很好的压缩比，从而减小消息体的大小，减少消息传输的时间，代价是压缩和解压缩需要消耗 CPU 时间。</p><p><strong>这种优化的本质是时间换空间，而前面介绍过的缓存本质则是空间换时间</strong>，二者比起来，刚好是相反的。可有趣的是，它们的目的却是一致的，都是为了缩短用户访问的时间，都是为了减少延迟。</p><p>对于前端的优化，技巧比较零散，可能有不少朋友会想起那最著名的 <a target="_blank" rel="noopener noreferrer" href="https://developer.yahoo.com/performance/rules.html">35 条军规<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（中文译文有不少，比如<a target="_blank" rel="noopener noreferrer" href="https://github.com/creeperyang/blog/issues/1">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），这篇文章是如今很多前端技能优化学习首先要阅读的“老文章”了。</p><h2 id="总结思考"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#总结思考"><span class="icon icon-link"></span></a>总结思考</h2><p>今天我从产品和架构、后端和持久化，以及前端和网络层三个角度，结合一些具体的技巧，向你介绍了一些常见的网站性能优化方法。网站的性能优化是一个大课题，希望你在学完上一讲和这一讲之后，你能从前到后比较全面地去分析和思考问题。</p><p>下面我来提两个问题吧：</p><ul><li>你在项目中是否做过性能优化的工作，能否介绍一下你都进行了哪些有效的优化实践呢？</li><li>文中介绍了数据库表拆分的两种方式，水平拆分和垂直拆分，它们都带来了显而易见的好处。可是，我们总是需要辩证地去看待一项技术，你能说出它们会带来哪些坏处吗？</li></ul><h2 id="扩展阅读"><a aria-hidden="true" tabindex="-1" href="/blog/全栈工程师修炼指南/07.第六章专题/02#扩展阅读"><span class="icon icon-link"></span></a>扩展阅读</h2><ul><li>文中提到了 Amazon 对于 SOA 的实践，你可以阅读<a target="_blank" rel="noopener noreferrer" href="http://www.ruanyifeng.com/blog/2016/09/how_amazon_take_soa.html">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>简单了解一下这个故事。</li><li>本文主要讲的还是应用层面的调优，没有介绍虚拟机、容器等性能优化和操作系统的性能优化。如果你对它们感兴趣的话，我在这里推荐两个材料。关于 JVM 调优，可以参看 <a target="_blank" rel="noopener noreferrer" href="https://www.ibm.com/developerworks/cn/java/j-lo-performance-tuning-practice/index.html">Java 应用性能调优实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇，而操作系统层面的性能优化，你可以从 <a target="_blank" rel="noopener noreferrer" href="https://lihz1990.gitbooks.io/transoflptg/content/">Linux 性能调优指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这个材料中找感兴趣的阅读。</li><li><a target="_blank" rel="noopener noreferrer" href="https://imweb.io/topic/5b4d417eee0c3b0779df96d9">从Webkit内部渲染机制出发，谈网站渲染性能优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这篇文章是从浏览器的机制这个角度来讲性能优化的，推荐一读。</li><li>文中介绍了 reflow 和 repaint，对于这方面的优化可以阅读 <a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5a9372895188257a6b06132e">reflow和repaint引发的性能问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这篇文章。</li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/全栈工程师修炼指南/07.第六章专题/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
