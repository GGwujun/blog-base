<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | 土地不能浪费：如何管理内存对象？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/07.土地革命内存/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="malloc给我们的启发" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#malloc给我们的启发"><span>malloc给我们的启发</span></a></li><li title="页还能细分吗" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#页还能细分吗"><span>页还能细分吗</span></a></li><li title="如何表示一个内存对象" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#如何表示一个内存对象"><span>如何表示一个内存对象</span></a></li><li title="内存对象容器" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#内存对象容器"><span>内存对象容器</span></a></li><li title="初始化" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#初始化"><span>初始化</span></a></li><li title="分配内存对象" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象"><span>分配内存对象</span></a></li><li title="分配内存对象的接口" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象的接口"><span>分配内存对象的接口</span></a></li><li title="查找内存对象容器" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#查找内存对象容器"><span>查找内存对象容器</span></a></li><li title="建立内存对象容器" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#建立内存对象容器"><span>建立内存对象容器</span></a></li><li title="扩容内存对象容器" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#扩容内存对象容器"><span>扩容内存对象容器</span></a></li><li title="分配内存对象" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象-1"><span>分配内存对象</span></a></li><li title="释放内存对象" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象"><span>释放内存对象</span></a></li><li title="释放内存对象的接口" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象的接口"><span>释放内存对象的接口</span></a></li><li title="查找内存对象容器" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#查找内存对象容器-1"><span>查找内存对象容器</span></a></li><li title="释放内存对象" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象-1"><span>释放内存对象</span></a></li><li title="销毁内存对象容器" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/04#销毁内存对象容器"><span>销毁内存对象容器</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--土地不能浪费如何管理内存对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#19--土地不能浪费如何管理内存对象"><span class="icon icon-link"></span></a>19 | 土地不能浪费：如何管理内存对象？</h1><p>你好，我是LMOS。</p><p>在前面的课程中，我们建立了物理内存页面管理器，它既可以分配单个页面，也可以分配多个连续的页面，还能指定在特殊内存地址区域中分配页面。</p><p>但你发现没有，物理内存页面管理器一次分配至少是一个页面，而我们对内存分页是一个页面4KB，即4096字节。对于小于一个页面的内存分配请求，它无能为力。如果要实现小于一个页面的内存分配请求，又该怎么做呢？</p><p>这节课我们就一起来解决这个问题。课程配套代码，你可以从<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson19~21/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>获得。</p><h2 id="malloc给我们的启发"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#malloc给我们的启发"><span class="icon icon-link"></span></a>malloc给我们的启发</h2><p>首先，我想和你说说，为什么小于一个页面的内存我们也要格外珍惜？</p><p>如果你在大学学过C程序设计语言的话，相信你对C库中的malloc函数也不会陌生，它负责完成分配一块内存空间的功能。</p><p>下面的代码。我相信你也写过，或者写过类似的，不用多介绍你也可以明白。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string.h&gt; </span></div><div class="token-line"><span class="token plain">    #include &lt;stdlib.h&gt;   </span></div><div class="token-line"><span class="token plain">    int main() {    </span></div><div class="token-line"><span class="token plain">        char *str;      </span></div><div class="token-line"><span class="token plain">        //内存分配 存放15个char字符类型   </span></div><div class="token-line"><span class="token plain">        str = (char *) malloc(15);</span></div><div class="token-line"><span class="token plain">        if (str == NULL) {</span></div><div class="token-line"><span class="token plain">            printf(&quot;mem alloc err\n&quot;);</span></div><div class="token-line"><span class="token plain">            return -1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //把hello world字符串复制到str开始的内存地址空间中</span></div><div class="token-line"><span class="token plain">        strcpy(str, &quot;hello world&quot;);</span></div><div class="token-line"><span class="token plain">        //打印hello world字符串和它的地址    </span></div><div class="token-line"><span class="token plain">        printf(&quot;String = %s,  Address = %u\n&quot;, str, str);</span></div><div class="token-line"><span class="token plain">        //释放分配的内存</span></div><div class="token-line"><span class="token plain">        free(str);      </span></div><div class="token-line"><span class="token plain">        return(0); </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码流程很简单，就是分配一块15字节大小的内存空间，然后把字符串复制到分配的内存空间中，最后用字符串的形式打印了那个块内存，最后释放该内存空间。</p><p>但我们并不是要了解malloc、free函数的工作原理，而是要清楚，像这样分配几个字节内存空间的操作，这在内核中比比皆是。</p><h2 id="页还能细分吗"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#页还能细分吗"><span class="icon icon-link"></span></a>页还能细分吗</h2><p>是的，单从内存角度来看，页最小是以字节为单位的。但是从MMU角度看，内存是以页为单位的，所以我们的Cosmos的物理内存分配器也以页为单位。现在的问题是，内核中有大量远小于一个页面的内存分配请求，如果对此还是分配一个页面，就会浪费内存。</p><p>要想解决这个问题，<strong>就要细分“页”这个单位</strong>。虽然从MMU角度来看，页不能细分，但是从软件逻辑层面页可以细分，但是如何分，则十分讲究。</p><p>结合历史经验和硬件特性（Cache行大小）来看，我们可以把一个页面或者连续的多个页面，分成32字节、64字节、128字节、256字节、512字节、1024字节、2048字节、4096字节（一个页）。这些都是Cache行大小的倍数。我们给这些小块内存取个名字，叫<strong>内存对象</strong>。</p><p>我们可以这样设计：**把一个或者多个内存页面分配出来，作为一个内存对象的容器，在这个容器中容纳相同的内存对象，即同等大小的内存块。**你可以把这个容器，想像成一个内存对象数组。为了让你更好理解，我还给你画了张图解释。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea947a9e3c059aceb3433de2116f9bee02d47.jpg" alt="" title="内存对象视图"/></p><h2 id="如何表示一个内存对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#如何表示一个内存对象"><span class="icon icon-link"></span></a>如何表示一个内存对象</h2><p>前面只是进行了理论上的设计和构想，下面我们就通过代码来实现这些构想，真正把想法变成现实。</p><p>我们从内存对象开始入手。如何表示一个内存对象呢？当然是要设计一个表示内存对象的数据结构，代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_FREOBJH</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t oh_list;     //链表</span></div><div class="token-line"><span class="token plain">        uint_t oh_stus;       //对象状态</span></div><div class="token-line"><span class="token plain">        void* oh_stat;        //对象的开始地址</span></div><div class="token-line"><span class="token plain">    }freobjh_t;</span></div></pre></div><p>我们在后面的代码中就用freobjh_t结构表示一个对象，其中的链表是为了找到这个对象。是不是很简单？没错，表示一个内存对象就是如此简单。</p><h2 id="内存对象容器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#内存对象容器"><span class="icon icon-link"></span></a>内存对象容器</h2><p>光有内存对象还不够，如何放置内存对象是很重要的。根据前面的构想，为了把多个同等大小的内存对象放在一个内存对象容器中，我们需要设计出表示内存对象容器的数据结构。内存容器要占用内存页面，需要内存对象计数信息、内存对象大小信息，还要能扩展容量。</p><p>把上述功能综合起来，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//管理内存对象容器占用的内存页面所对应的msadsc_t结构</span></div><div class="token-line"><span class="token plain">    typedef struct s_MSCLST</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t ml_msanr;  //多少个msadsc_t</span></div><div class="token-line"><span class="token plain">        uint_t ml_ompnr;  //一个msadsc_t对应的连续的物理内存页面数</span></div><div class="token-line"><span class="token plain">        list_h_t ml_list; //挂载msadsc_t的链表</span></div><div class="token-line"><span class="token plain">    }msclst_t;</span></div><div class="token-line"><span class="token plain">    //管理内存对象容器占用的内存</span></div><div class="token-line"><span class="token plain">    typedef struct s_MSOMDC</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //msclst_t结构数组mc_lst[0]=1个连续页面的msadsc_t</span></div><div class="token-line"><span class="token plain">        //               mc_lst[1]=2个连续页面的msadsc_t</span></div><div class="token-line"><span class="token plain">        //               mc_lst[2]=4个连续页面的msadsc_t</span></div><div class="token-line"><span class="token plain">        //               mc_lst[3]=8个连续页面的msadsc_t</span></div><div class="token-line"><span class="token plain">        //               mc_lst[4]=16个连续页面的msadsc_t</span></div><div class="token-line"><span class="token plain">        msclst_t mc_lst[MSCLST_MAX];</span></div><div class="token-line"><span class="token plain">        uint_t mc_msanr;   //总共多个msadsc_t结构</span></div><div class="token-line"><span class="token plain">        list_h_t mc_list;</span></div><div class="token-line"><span class="token plain">        //内存对象容器第一个占用msadsc_t</span></div><div class="token-line"><span class="token plain">        list_h_t mc_kmobinlst;</span></div><div class="token-line"><span class="token plain">        //内存对象容器第一个占用msadsc_t对应的连续的物理内存页面数</span></div><div class="token-line"><span class="token plain">        uint_t mc_kmobinpnr;</span></div><div class="token-line"><span class="token plain">    }msomdc_t;</span></div><div class="token-line"><span class="token plain">    //管理内存对象容器扩展容量</span></div><div class="token-line"><span class="token plain">    typedef struct s_KMBEXT</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t mt_list;        //链表</span></div><div class="token-line"><span class="token plain">        adr_t mt_vstat;          //内存对象容器扩展容量开始地址</span></div><div class="token-line"><span class="token plain">        adr_t mt_vend;           //内存对象容器扩展容量结束地址</span></div><div class="token-line"><span class="token plain">        kmsob_t* mt_kmsb;        //指向内存对象容器结构</span></div><div class="token-line"><span class="token plain">        uint_t mt_mobjnr;        //内存对象容器扩展容量的内存中有多少对象</span></div><div class="token-line"><span class="token plain">    }kmbext_t;</span></div><div class="token-line"><span class="token plain">    //内存对象容器</span></div><div class="token-line"><span class="token plain">    typedef struct s_KMSOB</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t so_list;        //链表</span></div><div class="token-line"><span class="token plain">        spinlock_t so_lock;      //保护结构自身的自旋锁</span></div><div class="token-line"><span class="token plain">        uint_t so_stus;          //状态与标志</span></div><div class="token-line"><span class="token plain">        uint_t so_flgs;</span></div><div class="token-line"><span class="token plain">        adr_t so_vstat;          //内存对象容器的开始地址</span></div><div class="token-line"><span class="token plain">        adr_t so_vend;           //内存对象容器的结束地址</span></div><div class="token-line"><span class="token plain">        size_t so_objsz;         //内存对象大小</span></div><div class="token-line"><span class="token plain">        size_t so_objrelsz;      //内存对象实际大小</span></div><div class="token-line"><span class="token plain">        uint_t so_mobjnr;        //内存对象容器中总共的对象个数</span></div><div class="token-line"><span class="token plain">        uint_t so_fobjnr;        //内存对象容器中空闲的对象个数</span></div><div class="token-line"><span class="token plain">        list_h_t so_frelst;      //内存对象容器中空闲的对象链表头</span></div><div class="token-line"><span class="token plain">        list_h_t so_alclst;      //内存对象容器中分配的对象链表头</span></div><div class="token-line"><span class="token plain">        list_h_t so_mextlst;     //内存对象容器扩展kmbext_t结构链表头</span></div><div class="token-line"><span class="token plain">        uint_t so_mextnr;        //内存对象容器扩展kmbext_t结构个数</span></div><div class="token-line"><span class="token plain">        msomdc_t so_mc;          //内存对象容器占用内存页面管理结构</span></div><div class="token-line"><span class="token plain">        void* so_privp;          //本结构私有数据指针</span></div><div class="token-line"><span class="token plain">        void* so_extdp;          //本结构扩展数据指针</span></div><div class="token-line"><span class="token plain">    }kmsob_t;</span></div></pre></div><p>这段代码中设计了四个数据结构：kmsob_t用于表示内存对象容器，kmbext_t用于表示内存对象容器的扩展内存，msomdc_t和msclst_t用于管理内存对象容器占用的物理内存页面。</p><p>你可能很难理解它们之间的关系，所以我为你准备了一幅图，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage7ybb7yye7013ae2a878286fc6052c9318bbb.jpg" alt="" title="内存对象容器关系"/></p><p>结合图示我们可以发现，在一组连续物理内存页面（用来存放内存对象）的开始地址那里，就存放着我们kmsob_t和kmbext_t的实例变量，它们占用了几十字节的空间。</p><h2 id="初始化"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#初始化"><span class="icon icon-link"></span></a>初始化</h2><p>因为kmsob_t、kmbext_t、freobjh_t结构的实例变量，它们是建立内存对象容器时创建并初始化的，这个过程是伴随着分配内存对象而进行的，所以内存对象管理器的初始化很简单。</p><p>但是有一点还是要初始化的，那就是<strong>管理kmsob_t结构的数据结构</strong>，它用于挂载不同大小的内存容器。现在我们就在cosmos/hal/x86/目录下建立一个kmsob.c文件，来实现这个数据结构并初始化，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define KOBLST_MAX (64)</span></div><div class="token-line"><span class="token plain">    //挂载kmsob_t结构</span></div><div class="token-line"><span class="token plain">    typedef struct s_KOBLST</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t ol_emplst; //挂载kmsob_t结构的链表</span></div><div class="token-line"><span class="token plain">        kmsob_t* ol_cahe;   //最近一次查找的kmsob_t结构</span></div><div class="token-line"><span class="token plain">        uint_t ol_emnr;     //挂载kmsob_t结构的数量</span></div><div class="token-line"><span class="token plain">        size_t ol_sz;       //kmsob_t结构中内存对象的大小</span></div><div class="token-line"><span class="token plain">    }koblst_t;</span></div><div class="token-line"><span class="token plain">    //管理kmsob_t结构的数据结构</span></div><div class="token-line"><span class="token plain">    typedef struct s_KMSOBMGRHED</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t ks_lock;  //保护自身的自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t ks_tclst;   //链表</span></div><div class="token-line"><span class="token plain">        uint_t ks_tcnr;</span></div><div class="token-line"><span class="token plain">        uint_t ks_msobnr;    //总共多少个kmsob_t结构</span></div><div class="token-line"><span class="token plain">        kmsob_t* ks_msobche; //最近分配内存对象的kmsob_t结构</span></div><div class="token-line"><span class="token plain">        koblst_t ks_msoblst[KOBLST_MAX]; //koblst_t结构数组</span></div><div class="token-line"><span class="token plain">    }kmsobmgrhed_t;</span></div><div class="token-line"><span class="token plain">    //初始化koblst_t结构体</span></div><div class="token-line"><span class="token plain">    void koblst_t_init(koblst_t *initp, size_t koblsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;ol_emplst);</span></div><div class="token-line"><span class="token plain">        initp-&gt;ol_cahe = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;ol_emnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;ol_sz = koblsz;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //初始化kmsobmgrhed_t结构体</span></div><div class="token-line"><span class="token plain">    void kmsobmgrhed_t_init(kmsobmgrhed_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        size_t koblsz = 32;</span></div><div class="token-line"><span class="token plain">        knl_spinlock_init(&amp;initp-&gt;ks_lock);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;ks_tclst);</span></div><div class="token-line"><span class="token plain">        initp-&gt;ks_tcnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;ks_msobnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;ks_msobche = NULL;</span></div><div class="token-line"><span class="token plain">        for (uint_t i = 0; i &lt; KOBLST_MAX; i++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            koblst_t_init(&amp;initp-&gt;ks_msoblst[i], koblsz);</span></div><div class="token-line"><span class="token plain">            koblsz += 32;//这里并不是按照开始的图形分类的而是每次增加32字节，所以是32，64,96,128,160,192,224，256，.......</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //初始化kmsob</span></div><div class="token-line"><span class="token plain">    void init_kmsob()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kmsobmgrhed_t_init(&amp;memmgrob.mo_kmsobmgr);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码注释已经很清楚了，就是init_kmsob函数调用kmsobmgrhed_t_init函数，在其中循环初始化koblst_t结构体数组，不多做解释。</p><p>但是有一点我们要搞清楚：<strong>kmsobmgrhed_t结构的实例变量是放在哪里的，它其实放在我们之前的memmgrob_t结构中了</strong>，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//cosmos/include/halinc/halglobal.c</span></div><div class="token-line"><span class="token plain">    HAL_DEFGLOB_VARIABLE(memmgrob_t,memmgrob);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    typedef struct s_MEMMGROB</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t mo_list;</span></div><div class="token-line"><span class="token plain">        spinlock_t mo_lock;</span></div><div class="token-line"><span class="token plain">        uint_t mo_stus;</span></div><div class="token-line"><span class="token plain">        uint_t mo_flgs;</span></div><div class="token-line"><span class="token plain">        //略去很多字段</span></div><div class="token-line"><span class="token plain">        //管理kmsob_t结构的数据结构</span></div><div class="token-line"><span class="token plain">        kmsobmgrhed_t mo_kmsobmgr;</span></div><div class="token-line"><span class="token plain">        void* mo_privp;</span></div><div class="token-line"><span class="token plain">        void* mo_extp;</span></div><div class="token-line"><span class="token plain">    }memmgrob_t;</span></div><div class="token-line"><span class="token plain">    //cosmos/hal/x86/memmgrinit.c</span></div><div class="token-line"><span class="token plain">    void init_memmgr()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //初始化内存页结构</span></div><div class="token-line"><span class="token plain">        init_msadsc();</span></div><div class="token-line"><span class="token plain">        //初始化内存区结构</span></div><div class="token-line"><span class="token plain">        init_memarea();</span></div><div class="token-line"><span class="token plain">        //处理内存占用</span></div><div class="token-line"><span class="token plain">        init_search_krloccupymm(&amp;kmachbsp);</span></div><div class="token-line"><span class="token plain">        //合并内存页到内存区中</span></div><div class="token-line"><span class="token plain">        init_memmgrob();</span></div><div class="token-line"><span class="token plain">        //初始化kmsob</span></div><div class="token-line"><span class="token plain">        init_kmsob();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这并没有那么难，是不是？到这里，我们在内存管理初始化init_memmgr函数中调用了init_kmsob函数，对管理内存对象容器的结构进行了初始化，这样后面我们就能分配内存对象了。</p><h2 id="分配内存对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象"><span class="icon icon-link"></span></a>分配内存对象</h2><p>根据前面的初始化过程，我们只是初始化了kmsobmgrhed_t结构，却没初始化任何kmsob_t结构，而这个结构就是存放内存对象的容器，没有它是不能进行任何分配内存对象的操作的。</p><p>下面我们一起在分配内存对象的过程中探索，应该如何查找、建立kmsob_t结构，然后在kmsob_t结构中建立freobjh_t结构，最后在内存对象容器的容量不足时，一起来扩展容器的内存。</p><h3 id="分配内存对象的接口"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象的接口"><span class="icon icon-link"></span></a>分配内存对象的接口</h3><p>分配内存对象的流程，仍然要从分配接口开始。分配内存对象的接口很简单，只有一个内存对象大小的参数，然后返回内存对象的首地址。下面我们先在kmsob.c文件中写好这个函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//分配内存对象的核心函数</span></div><div class="token-line"><span class="token plain">    void *kmsob_new_core(size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //获取kmsobmgrhed_t结构的地址</span></div><div class="token-line"><span class="token plain">        kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;</span></div><div class="token-line"><span class="token plain">        void *retptr = NULL;</span></div><div class="token-line"><span class="token plain">        koblst_t *koblp = NULL;</span></div><div class="token-line"><span class="token plain">        kmsob_t *kmsp = NULL;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cpuflg;</span></div><div class="token-line"><span class="token plain">        //对kmsobmgrhed_t结构加锁</span></div><div class="token-line"><span class="token plain">        knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        koblp = onmsz_retn_koblst(kmobmgrp, msz);</span></div><div class="token-line"><span class="token plain">        if (NULL == koblp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            retptr = NULL;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        kmsp = onkoblst_retn_newkmsob(koblp, msz);</span></div><div class="token-line"><span class="token plain">        if (NULL == kmsp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            kmsp = _create_kmsob(kmobmgrp, koblp, koblp-&gt;ol_sz);</span></div><div class="token-line"><span class="token plain">            if (NULL == kmsp)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                retptr = NULL;</span></div><div class="token-line"><span class="token plain">                goto ret_step;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        retptr = kmsob_new_onkmsob(kmsp, msz);</span></div><div class="token-line"><span class="token plain">        if (NULL == retptr)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            retptr = NULL;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //更新kmsobmgrhed_t结构的信息</span></div><div class="token-line"><span class="token plain">        kmsob_updata_cache(kmobmgrp, koblp, kmsp, KUC_NEWFLG);</span></div><div class="token-line"><span class="token plain">    ret_step:</span></div><div class="token-line"><span class="token plain">        //解锁kmsobmgrhed_t结构</span></div><div class="token-line"><span class="token plain">        knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        return retptr;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //内存对象分配接口</span></div><div class="token-line"><span class="token plain">    void *kmsob_new(size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //对于小于1 或者 大于2048字节的大小不支持 直接返回NULL表示失败</span></div><div class="token-line"><span class="token plain">        if (1 &gt; msz || 2048 &lt; msz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //调用核心函数</span></div><div class="token-line"><span class="token plain">        return kmsob_new_core(msz);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面代码中，内存对象分配接口很简单，只是对分配内存对象的大小进行检查，然后调用分配内存对象的核心函数，在这个核心函数中，就是围绕我们之前定义的几个数据结构，去进行一系列操作了。</p><p>但是究竟做了哪些操作呢，别急，我们继续往下看。</p><h3 id="查找内存对象容器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#查找内存对象容器"><span class="icon icon-link"></span></a>查找内存对象容器</h3><p>根据前面的设计，我们已经知道内存对象是放在内存对象容器中的，所以要分配内存对象，必须要先根据要分配的内存对象大小，找到内存对象容器。</p><p>同时，我们还知道，内存对象容器数据结构kmsob_t就挂载在kmsobmgrhed_t数据结构中的ks_msoblst数组中，所以我们要遍历ks_msoblst数组，我们来写一个onmsz_retn_koblst函数，它返回ks_msoblst数组元素的指针，表示先根据内存对象的大小找到挂载kmsob_t结构对应的koblst_t结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//看看内存对象容器是不是合乎要求</span></div><div class="token-line"><span class="token plain">    kmsob_t *scan_newkmsob_isok(kmsob_t *kmsp, size_t msz)</span></div><div class="token-line"><span class="token plain">    {    </span></div><div class="token-line"><span class="token plain">        //只要内存对象大小小于等于内存对象容器的对象大小就行</span></div><div class="token-line"><span class="token plain">        if (msz &lt;= kmsp-&gt;so_objsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return kmsp;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    koblst_t *onmsz_retn_koblst(kmsobmgrhed_t *kmmgrhlokp, size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //遍历ks_msoblst数组</span></div><div class="token-line"><span class="token plain">        for (uint_t kli = 0; kli &lt; KOBLST_MAX; kli++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //只要大小合适就返回       </span></div><div class="token-line"><span class="token plain">            if (kmmgrhlokp-&gt;ks_msoblst[kli].ol_sz &gt;= msz)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return &amp;kmmgrhlokp-&gt;ks_msoblst[kli];</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    kmsob_t *onkoblst_retn_newkmsob(koblst_t *koblp, size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kmsob_t *kmsp = NULL, *tkmsp = NULL;</span></div><div class="token-line"><span class="token plain">        list_h_t *tmplst = NULL;</span></div><div class="token-line"><span class="token plain">        //先看看上次分配所用到的koblst_t是不是正好是这次需要的</span></div><div class="token-line"><span class="token plain">        kmsp = scan_newkmsob_isok(koblp-&gt;ol_cahe, msz);</span></div><div class="token-line"><span class="token plain">        if (NULL != kmsp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return kmsp;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //如果koblst_t中挂载的kmsob_t大于0</span></div><div class="token-line"><span class="token plain">        if (0 &lt; koblp-&gt;ol_emnr)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //开始遍历koblst_t中挂载的kmsob_t</span></div><div class="token-line"><span class="token plain">            list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                tkmsp = list_entry(tmplst, kmsob_t, so_list);</span></div><div class="token-line"><span class="token plain">                //检查当前kmsob_t是否合乎要求</span></div><div class="token-line"><span class="token plain">                kmsp = scan_newkmsob_isok(tkmsp, msz);</span></div><div class="token-line"><span class="token plain">                if (NULL != kmsp)</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                    return kmsp;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码非常好理解，就是通过onmsz_retn_koblst函数，它根据内存对象大小查找并返回ks_msoblst数组元素的指针，这个数组元素中就挂载着相应的内存对象容器，然后由onkoblst_retn_newkmsob函数查询其中的内存对象容器并返回。</p><h3 id="建立内存对象容器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#建立内存对象容器"><span class="icon icon-link"></span></a>建立内存对象容器</h3><p>不知道你发现没有，有一种情况必然会发生，那就是第一次分配内存对象时调用onkoblst_retn_newkmsob函数，它肯定会返回一个NULL。因为第一次分配时肯定没有kmsob_t结构，所以我们在这个时候建立一个kmsob_t结构，即<strong>建立内存对象容器</strong>。</p><p>下面我们写一个_create_kmsob函数来创建kmsob_t结构，并执行一些初始化工作，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//初始化内存对象数据结构</span></div><div class="token-line"><span class="token plain">    void freobjh_t_init(freobjh_t *initp, uint_t stus, void *stat)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;oh_list);</span></div><div class="token-line"><span class="token plain">        initp-&gt;oh_stus = stus;</span></div><div class="token-line"><span class="token plain">        initp-&gt;oh_stat = stat;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //初始化内存对象容器数据结构</span></div><div class="token-line"><span class="token plain">    void kmsob_t_init(kmsob_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;so_list);</span></div><div class="token-line"><span class="token plain">        knl_spinlock_init(&amp;initp-&gt;so_lock);</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_stus = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_flgs = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_vstat = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_vend = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_objsz = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_objrelsz = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_mobjnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_fobjnr = 0;</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;so_frelst);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;so_alclst);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;so_mextlst);</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_mextnr = 0;</span></div><div class="token-line"><span class="token plain">        msomdc_t_init(&amp;initp-&gt;so_mc);</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_privp = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;so_extdp = NULL;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //把内存对象容器数据结构，挂载到对应的koblst_t结构中去</span></div><div class="token-line"><span class="token plain">    bool_t kmsob_add_koblst(koblst_t *koblp, kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_add(&amp;kmsp-&gt;so_list, &amp;koblp-&gt;ol_emplst);</span></div><div class="token-line"><span class="token plain">        koblp-&gt;ol_emnr++;</span></div><div class="token-line"><span class="token plain">        return TRUE;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //初始化内存对象容器</span></div><div class="token-line"><span class="token plain">    kmsob_t *_create_init_kmsob(kmsob_t *kmsp, size_t objsz, adr_t cvadrs, adr_t cvadre, msadsc_t *msa, uint_t relpnr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //初始化kmsob结构体</span></div><div class="token-line"><span class="token plain">        kmsob_t_init(kmsp);</span></div><div class="token-line"><span class="token plain">        //设置内存对象容器的开始、结束地址，内存对象大小</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_vstat = cvadrs;</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_vend = cvadre;</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_objsz = objsz;</span></div><div class="token-line"><span class="token plain">        //把物理内存页面对应的msadsc_t结构加入到kmsob_t中的so_mc.mc_kmobinlst链表上</span></div><div class="token-line"><span class="token plain">        list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_kmobinlst);</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_mc.mc_kmobinpnr = (uint_t)relpnr;</span></div><div class="token-line"><span class="token plain">        //设置内存对象的开始地址为kmsob_t结构之后，结束地址为内存对象容器的结束地址</span></div><div class="token-line"><span class="token plain">        freobjh_t *fohstat = (freobjh_t *)(kmsp + 1), *fohend = (freobjh_t *)cvadre;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        uint_t ap = (uint_t)((uint_t)fohstat);</span></div><div class="token-line"><span class="token plain">        freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);</span></div><div class="token-line"><span class="token plain">        for (; tmpfoh &lt; fohend;)</span></div><div class="token-line"><span class="token plain">        {//相当在kmsob_t结构体之后建立一个freobjh_t结构体数组</span></div><div class="token-line"><span class="token plain">            if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)cvadre)</span></div><div class="token-line"><span class="token plain">            {//初始化每个freobjh_t结构体</span></div><div class="token-line"><span class="token plain">                freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);</span></div><div class="token-line"><span class="token plain">                //把每个freobjh_t结构体加入到kmsob_t结构体中的so_frelst中</span></div><div class="token-line"><span class="token plain">               list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span></div><div class="token-line"><span class="token plain">                kmsp-&gt;so_mobjnr++;</span></div><div class="token-line"><span class="token plain">                kmsp-&gt;so_fobjnr++;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            ap += (uint_t)kmsp-&gt;so_objsz;</span></div><div class="token-line"><span class="token plain">            tmpfoh = (freobjh_t *)((uint_t)ap);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return kmsp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //建立一个内存对象容器</span></div><div class="token-line"><span class="token plain">    kmsob_t *_create_kmsob(kmsobmgrhed_t *kmmgrlokp, koblst_t *koblp, size_t objsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kmsob_t *kmsp = NULL;</span></div><div class="token-line"><span class="token plain">        msadsc_t *msa = NULL;</span></div><div class="token-line"><span class="token plain">        uint_t relpnr = 0;</span></div><div class="token-line"><span class="token plain">        uint_t pages = 1;</span></div><div class="token-line"><span class="token plain">        if (128 &lt; objsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            pages = 2;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (512 &lt; objsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            pages = 4;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //为内存对象容器分配物理内存空间，这是我们之前实现的物理内存页面管理器</span></div><div class="token-line"><span class="token plain">        msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);</span></div><div class="token-line"><span class="token plain">        if (NULL == msa)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span></div><div class="token-line"><span class="token plain">        u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;</span></div><div class="token-line"><span class="token plain">        //计算它们的虚拟地址</span></div><div class="token-line"><span class="token plain">        adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);</span></div><div class="token-line"><span class="token plain">        adr_t vadre = phyadr_to_viradr((adr_t)phyade);</span></div><div class="token-line"><span class="token plain">        //初始化kmsob_t并建立内存对象</span></div><div class="token-line"><span class="token plain">        kmsp = _create_init_kmsob((kmsob_t *)vadrs, koblp-&gt;ol_sz, vadrs, vadre, msa, relpnr);</span></div><div class="token-line"><span class="token plain">        //把kmsob_t结构，挂载到对应的koblst_t结构中去</span></div><div class="token-line"><span class="token plain">        if (kmsob_add_koblst(koblp, kmsp) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            system_error(&quot; _create_kmsob kmsob_add_koblst FALSE\n&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //增加计数</span></div><div class="token-line"><span class="token plain">        kmmgrlokp-&gt;ks_msobnr++;</span></div><div class="token-line"><span class="token plain">        return kmsp;</span></div></pre></div><p>_create_kmsob函数就是根据分配内存对象大小，建立一个内存对象容器。</p><p>首先，这个函数会找物理内存页面管理器申请一块连续内存页面。然后，在其中的开始部分建立kmsob_t结构的实例变量，又在kmsob_t结构的后面建立freobjh_t结构数组，并把每个freobjh_t结构挂载到kmsob_t结构体中的so_frelst中。最后再把kmsob_t结构，挂载到kmsobmgrhed_t结构对应的koblst_t结构中去。</p><p>上面的注释已经很清楚了，我相信你看得懂。</p><h3 id="扩容内存对象容器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#扩容内存对象容器"><span class="icon icon-link"></span></a>扩容内存对象容器</h3><p>如果我们不断重复分配同一大小的内存对象，那么那个内存对象容器中的内存对象，迟早要分配完的。一旦内存对象分配完，内存对象容器就没有空闲的内存空间产生内存对象了。这时，我们就要为内存对象容器扩展内存空间了。</p><p>下面我们来写代码实现，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//初始化kmbext_t结构</span></div><div class="token-line"><span class="token plain">    void kmbext_t_init(kmbext_t *initp, adr_t vstat, adr_t vend, kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;mt_list);</span></div><div class="token-line"><span class="token plain">        initp-&gt;mt_vstat = vstat;</span></div><div class="token-line"><span class="token plain">        initp-&gt;mt_vend = vend;</span></div><div class="token-line"><span class="token plain">        initp-&gt;mt_kmsb = kmsp;</span></div><div class="token-line"><span class="token plain">        initp-&gt;mt_mobjnr = 0;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //扩展内存页面</span></div><div class="token-line"><span class="token plain">    bool_t kmsob_extn_pages(kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        msadsc_t *msa = NULL;</span></div><div class="token-line"><span class="token plain">        uint_t relpnr = 0;</span></div><div class="token-line"><span class="token plain">        uint_t pages = 1;</span></div><div class="token-line"><span class="token plain">        if (128 &lt; kmsp-&gt;so_objsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            pages = 2;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (512 &lt; kmsp-&gt;so_objsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            pages = 4;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //找物理内存页面管理器分配2或者4个连续的页面</span></div><div class="token-line"><span class="token plain">        msa = mm_division_pages(&amp;memmgrob, pages, &amp;relpnr, MA_TYPE_KRNL, DMF_RELDIV);</span></div><div class="token-line"><span class="token plain">        if (NULL == msa)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return FALSE;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        u64_t phyadr = msa-&gt;md_phyadrs.paf_padrs &lt;&lt; PSHRSIZE;</span></div><div class="token-line"><span class="token plain">        u64_t phyade = phyadr + (relpnr &lt;&lt; PSHRSIZE) - 1;</span></div><div class="token-line"><span class="token plain">        adr_t vadrs = phyadr_to_viradr((adr_t)phyadr);</span></div><div class="token-line"><span class="token plain">        adr_t vadre = phyadr_to_viradr((adr_t)phyade);</span></div><div class="token-line"><span class="token plain">        //求出物理内存页面数对应在kmsob_t的so_mc.mc_lst数组中下标</span></div><div class="token-line"><span class="token plain">        sint_t mscidx = retn_mscidx(relpnr);</span></div><div class="token-line"><span class="token plain">        //把物理内存页面对应的msadsc_t结构加入到kmsob_t的so_mc.mc_lst数组中</span></div><div class="token-line"><span class="token plain">        list_add(&amp;msa-&gt;md_list, &amp;kmsp-&gt;so_mc.mc_lst[mscidx].ml_list);</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_mc.mc_lst[mscidx].ml_msanr++;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        kmbext_t *bextp = (kmbext_t *)vadrs;</span></div><div class="token-line"><span class="token plain">        //初始化kmbext_t数据结构</span></div><div class="token-line"><span class="token plain">        kmbext_t_init(bextp, vadrs, vadre, kmsp);</span></div><div class="token-line"><span class="token plain">    //设置内存对象的开始地址为kmbext_t结构之后，结束地址为扩展内存页面的结束地址</span></div><div class="token-line"><span class="token plain">        freobjh_t *fohstat = (freobjh_t *)(bextp + 1), *fohend = (freobjh_t *)vadre;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        uint_t ap = (uint_t)((uint_t)fohstat);</span></div><div class="token-line"><span class="token plain">        freobjh_t *tmpfoh = (freobjh_t *)((uint_t)ap);</span></div><div class="token-line"><span class="token plain">        for (; tmpfoh &lt; fohend;)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            if ((ap + (uint_t)kmsp-&gt;so_objsz) &lt;= (uint_t)vadre)</span></div><div class="token-line"><span class="token plain">            {//在扩展的内存空间中建立内存对象</span></div><div class="token-line"><span class="token plain">                freobjh_t_init(tmpfoh, 0, (void *)tmpfoh);</span></div><div class="token-line"><span class="token plain">                list_add(&amp;tmpfoh-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span></div><div class="token-line"><span class="token plain">                kmsp-&gt;so_mobjnr++;</span></div><div class="token-line"><span class="token plain">                kmsp-&gt;so_fobjnr++;</span></div><div class="token-line"><span class="token plain">                bextp-&gt;mt_mobjnr++;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            ap += (uint_t)kmsp-&gt;so_objsz;</span></div><div class="token-line"><span class="token plain">            tmpfoh = (freobjh_t *)((uint_t)ap);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        list_add(&amp;bextp-&gt;mt_list, &amp;kmsp-&gt;so_mextlst);</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_mextnr++;</span></div><div class="token-line"><span class="token plain">        return TRUE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了前面建立内存对象容器的经验，加上这里的注释，我们理解上述代码并不难：不过是分配了另一块连续的内存空间，作为空闲的内存对象，并且把这块内存空间加内存对象容器中统一管理。</p><h3 id="分配内存对象-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#分配内存对象-1"><span class="icon icon-link"></span></a>分配内存对象</h3><p>有了内存对象容器，就可以分配内存对象了。由于我们前面精心设计了内存对象容器、内存对象等数据结构，这使得我们的内存对象分配代码时极其简单，而且性能极高。</p><p>下面我们来实现它吧！代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//判断内存对象容器中有没有内存对象</span></div><div class="token-line"><span class="token plain">    uint_t scan_kmob_objnr(kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if (0 &lt; kmsp-&gt;so_fobjnr)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return kmsp-&gt;so_fobjnr;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //实际分配内存对象</span></div><div class="token-line"><span class="token plain">    void *kmsob_new_opkmsob(kmsob_t *kmsp, size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //获取kmsob_t中的so_frelst链表头的第一个空闲内存对象</span></div><div class="token-line"><span class="token plain">        freobjh_t *fobh = list_entry(kmsp-&gt;so_frelst.next, freobjh_t, oh_list);</span></div><div class="token-line"><span class="token plain">        //从链表中脱链</span></div><div class="token-line"><span class="token plain">        list_del(&amp;fobh-&gt;oh_list);</span></div><div class="token-line"><span class="token plain">        //kmsob_t中的空闲对象计数减一</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_fobjnr--;</span></div><div class="token-line"><span class="token plain">        //返回内存对象首地址</span></div><div class="token-line"><span class="token plain">        return (void *)(fobh);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void *kmsob_new_onkmsob(kmsob_t *kmsp, size_t msz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void *retptr = NULL;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cpuflg;</span></div><div class="token-line"><span class="token plain">        knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        //如果内存对象容器中没有空闲的内存对象了就需要扩展内存对象容器的内存了</span></div><div class="token-line"><span class="token plain">        if (scan_kmsob_objnr(kmsp) &lt; 1)</span></div><div class="token-line"><span class="token plain">        {//扩展内存对象容器的内存</span></div><div class="token-line"><span class="token plain">            if (kmsob_extn_pages(kmsp) == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                retptr = NULL;</span></div><div class="token-line"><span class="token plain">                goto ret_step;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //实际分配内存对象</span></div><div class="token-line"><span class="token plain">        retptr = kmsob_new_opkmsob(kmsp, msz);</span></div><div class="token-line"><span class="token plain">    ret_step:</span></div><div class="token-line"><span class="token plain">        knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        return retptr;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>分配内存对象的核心操作就是，<strong>kmsob_new_opkmsob函数从空闲内存对象链表头中取出第一个内存对象，返回它的首地址</strong>。这个算法非常高效，无论内存对象容器中的内存对象有多少，kmsob_new_opkmsob函数的操作始终是固定的，而如此高效的算法得益于我们先进的数据结构设计。</p><p>好了，到这里内存对象的分配就已经完成了，下面我们去实现内存对象的释放。</p><h2 id="释放内存对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象"><span class="icon icon-link"></span></a>释放内存对象</h2><p>释放内存对象，就是要把内存对象还给它所归属的内存对象容器。其逻辑就是根据释放内存对象的地址和大小，找到对应的内存对象容器，然后把该内存对象加入到对应内存对象容器的空闲链表上，最后看一看要不要释放内存对象容器占用的物理内存页面。</p><h3 id="释放内存对象的接口"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象的接口"><span class="icon icon-link"></span></a>释放内存对象的接口</h3><p>这里我们依然要从释放内存对象的接口开始实现，下面我们在kmsob.c文中写下这个函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bool_t kmsob_delete_core(void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kmsobmgrhed_t *kmobmgrp = &amp;memmgrob.mo_kmsobmgr;</span></div><div class="token-line"><span class="token plain">        bool_t rets = FALSE;</span></div><div class="token-line"><span class="token plain">        koblst_t *koblp = NULL;</span></div><div class="token-line"><span class="token plain">        kmsob_t *kmsp = NULL;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cpuflg;</span></div><div class="token-line"><span class="token plain">        knl_spinlock_cli(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        //根据释放内存对象的大小在kmsobmgrhed_t中查找并返回koblst_t，在其中挂载着对应的kmsob_t，这个在前面已经写好了</span></div><div class="token-line"><span class="token plain">        koblp = onmsz_retn_koblst(kmobmgrp, fsz);</span></div><div class="token-line"><span class="token plain">        if (NULL == koblp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        kmsp = onkoblst_retn_delkmsob(koblp, fadrs, fsz);</span></div><div class="token-line"><span class="token plain">        if (NULL == kmsp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = kmsob_delete_onkmsob(kmsp, fadrs, fsz);</span></div><div class="token-line"><span class="token plain">        if (FALSE == rets)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (_destroy_kmsob(kmobmgrp, koblp, kmsp) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = TRUE;</span></div><div class="token-line"><span class="token plain">    ret_step:</span></div><div class="token-line"><span class="token plain">        knl_spinunlock_sti(&amp;kmobmgrp-&gt;ks_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //释放内存对象接口</span></div><div class="token-line"><span class="token plain">    bool_t kmsob_delete(void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //对参数进行检查，但是多了对内存对象地址的检查 </span></div><div class="token-line"><span class="token plain">        if (NULL == fadrs || 1 &gt; fsz || 2048 &lt; fsz)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return FALSE;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //调用释放内存对象的核心函数</span></div><div class="token-line"><span class="token plain">        return kmsob_delete_core(fadrs, fsz);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，等到kmsob_delete函数检查参数通过之后，就调用释放内存对象的核心函数kmsob_delete_core，在这个函数中，一开始根据释放内存对象大小，找到挂载其kmsob_t结构的koblst_t结构，接着又做了一系列的操作，这些操作正是我们接下来要实现的。</p><h3 id="查找内存对象容器-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#查找内存对象容器-1"><span class="icon icon-link"></span></a>查找内存对象容器</h3><p>释放内存对象，首先要找到这个将要释放的内存对象所属的内存对象容器。释放时的查找和分配时的查找不一样，因为要检查<strong>释放的内存对象是不是属于该内存对象容器。</strong></p><p>下面我们一起来实现这个函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//检查释放的内存对象是不是在kmsob_t结构中</span></div><div class="token-line"><span class="token plain">    kmsob_t *scan_delkmsob_isok(kmsob_t *kmsp, void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {//检查释放内存对象的地址是否落在kmsob_t结构的地址区间</span></div><div class="token-line"><span class="token plain">        if ((adr_t)fadrs &gt;= (kmsp-&gt;so_vstat + sizeof(kmsob_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= kmsp-&gt;so_vend)</span></div><div class="token-line"><span class="token plain">        {    //检查释放内存对象的大小是否小于等于kmsob_t内存对象容器的对象大小 </span></div><div class="token-line"><span class="token plain">            if (fsz &lt;= kmsp-&gt;so_objsz)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return kmsp;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (1 &gt; kmsp-&gt;so_mextnr)</span></div><div class="token-line"><span class="token plain">        {//如果kmsob_t结构没有扩展空间，直接返回</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        kmbext_t *bexp = NULL;</span></div><div class="token-line"><span class="token plain">        list_h_t *tmplst = NULL;</span></div><div class="token-line"><span class="token plain">        //遍历kmsob_t结构中的每个扩展空间</span></div><div class="token-line"><span class="token plain">        list_for_each(tmplst, &amp;kmsp-&gt;so_mextlst)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            bexp = list_entry(tmplst, kmbext_t, mt_list);</span></div><div class="token-line"><span class="token plain">            //检查释放内存对象的地址是否落在扩展空间的地址区间</span></div><div class="token-line"><span class="token plain">            if ((adr_t)fadrs &gt;= (bexp-&gt;mt_vstat + sizeof(kmbext_t)) &amp;&amp; ((adr_t)fadrs + (adr_t)fsz) &lt;= bexp-&gt;mt_vend)</span></div><div class="token-line"><span class="token plain">            {//同样的要检查大小</span></div><div class="token-line"><span class="token plain">                if (fsz &lt;= kmsp-&gt;so_objsz)</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                    return kmsp;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //查找释放内存对象所属的kmsob_t结构</span></div><div class="token-line"><span class="token plain">    kmsob_t *onkoblst_retn_delkmsob(koblst_t *koblp, void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        v *kmsp = NULL, *tkmsp = NULL;</span></div><div class="token-line"><span class="token plain">        list_h_t *tmplst = NULL;</span></div><div class="token-line"><span class="token plain">        //看看上次刚刚操作的kmsob_t结构</span></div><div class="token-line"><span class="token plain">        kmsp = scan_delkmsob_isok(koblp-&gt;ol_cahe, fadrs, fsz);</span></div><div class="token-line"><span class="token plain">        if (NULL != kmsp)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return kmsp;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (0 &lt; koblp-&gt;ol_emnr)</span></div><div class="token-line"><span class="token plain">        {    //遍历挂载koblp-&gt;ol_emplst链表上的每个kmsob_t结构</span></div><div class="token-line"><span class="token plain">            list_for_each(tmplst, &amp;koblp-&gt;ol_emplst)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                tkmsp = list_entry(tmplst, kmsob_t, so_list);</span></div><div class="token-line"><span class="token plain">                //检查释放的内存对象是不是属于这个kmsob_t结构</span></div><div class="token-line"><span class="token plain">                kmsp = scan_delkmsob_isok(tkmsp, fadrs, fsz);</span></div><div class="token-line"><span class="token plain">                if (NULL != kmsp)</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                    return kmsp;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码注释已经很明白了，搜索对应koblst_t结构中的每个kmsob_t结构体，随后进行检查，检查了kmsob_t结构的自身内存区域和扩展内存区域。即比较释放内存对象的地址是不是落在它们的内存区间中，其大小是否合乎要求。</p><h3 id="释放内存对象-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#释放内存对象-1"><span class="icon icon-link"></span></a>释放内存对象</h3><p>如果不出意外，会找到释放内存对象的kmsob_t结构，这样就可以释放内存对象了，就是把这块内存空间还给内存对象容器，这个过程的具体代码实现如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bool_t kmsob_del_opkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if ((kmsp-&gt;so_fobjnr + 1) &gt; kmsp-&gt;so_mobjnr)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return FALSE;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //让freobjh_t结构重新指向要释放的内存空间</span></div><div class="token-line"><span class="token plain">        freobjh_t *obhp = (freobjh_t *)fadrs;</span></div><div class="token-line"><span class="token plain">        //重新初始化块内存空间</span></div><div class="token-line"><span class="token plain">        freobjh_t_init(obhp, 0, obhp);</span></div><div class="token-line"><span class="token plain">        //加入kmsob_t结构的空闲链表</span></div><div class="token-line"><span class="token plain">        list_add(&amp;obhp-&gt;oh_list, &amp;kmsp-&gt;so_frelst);</span></div><div class="token-line"><span class="token plain">        //kmsob_t结构的空闲对象计数加一</span></div><div class="token-line"><span class="token plain">        kmsp-&gt;so_fobjnr++;</span></div><div class="token-line"><span class="token plain">        return TRUE;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //释放内存对象</span></div><div class="token-line"><span class="token plain">    bool_t kmsob_delete_onkmsob(kmsob_t *kmsp, void *fadrs, size_t fsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        bool_t rets = FALSE;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cpuflg;</span></div><div class="token-line"><span class="token plain">        //对kmsob_t结构加锁</span></div><div class="token-line"><span class="token plain">        knl_spinlock_cli(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        //实际完成内存对象释放</span></div><div class="token-line"><span class="token plain">        if (kmsob_del_opkmsob(kmsp, fadrs, fsz) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto ret_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = TRUE;</span></div><div class="token-line"><span class="token plain">    ret_step:</span></div><div class="token-line"><span class="token plain">        //对kmsob_t结构解锁</span></div><div class="token-line"><span class="token plain">        knl_spinunlock_sti(&amp;kmsp-&gt;so_lock, &amp;cpuflg);</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合上述代码和注释，我们现在明白了kmsob_delete_onkmsob函数调用kmsob_del_opkmsob函数。其核心机制就是<strong>把要释放内存对象的空间，重新初始化，变成一个freobjh_t结构的实例变量，最后把这个freobjh_t结构加入到kmsob_t结构中空闲链表中</strong>，这就实现了内存对象的释放。</p><h3 id="销毁内存对象容器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#销毁内存对象容器"><span class="icon icon-link"></span></a>销毁内存对象容器</h3><p>如果我们释放了所有的内存对象，就会出现空的内存对象容器。如果下一次请求同样大小的内存对象，那么这个空的内存对象容器还能继续复用，提高性能。</p><p>但是你有没有想到，频繁请求的是不同大小的内存对象，那么空的内存对象容器会越来越多，这会占用大量内存，所以我们必须要把空的内存对象容器销毁。</p><p>下面我们写代码实现销毁内存对象容器。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">uint_t scan_freekmsob_isok(kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //当内存对象容器的总对象个数等于空闲对象个数时，说明这内存对象容器空闲</span></div><div class="token-line"><span class="token plain">        if (kmsp-&gt;so_mobjnr == kmsp-&gt;so_fobjnr)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return 2;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return 1;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    bool_t _destroy_kmsob_core(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t *tmplst = NULL;</span></div><div class="token-line"><span class="token plain">        msadsc_t *msa = NULL;</span></div><div class="token-line"><span class="token plain">        msclst_t *mscp = kmsp-&gt;so_mc.mc_lst;</span></div><div class="token-line"><span class="token plain">        list_del(&amp;kmsp-&gt;so_list);</span></div><div class="token-line"><span class="token plain">        koblp-&gt;ol_emnr--;</span></div><div class="token-line"><span class="token plain">        kmobmgrp-&gt;ks_msobnr--;</span></div><div class="token-line"><span class="token plain">        //释放内存对象容器扩展空间的物理内存页面</span></div><div class="token-line"><span class="token plain">        //遍历kmsob_t结构中的so_mc.mc_lst数组</span></div><div class="token-line"><span class="token plain">        for (uint_t j = 0; j &lt; MSCLST_MAX; j++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            if (0 &lt; mscp[j].ml_msanr)</span></div><div class="token-line"><span class="token plain">            {//遍历每个so_mc.mc_lst数组中的msadsc_t结构</span></div><div class="token-line"><span class="token plain">                list_for_each_head_dell(tmplst, &amp;mscp[j].ml_list)</span></div><div class="token-line"><span class="token plain">                {</span></div><div class="token-line"><span class="token plain">                    msa = list_entry(tmplst, msadsc_t, md_list);</span></div><div class="token-line"><span class="token plain">                    list_del(&amp;msa-&gt;md_list);</span></div><div class="token-line"><span class="token plain">                    //msadsc_t脱链</span></div><div class="token-line"><span class="token plain">                    //释放msadsc_t对应的物理内存页面</span></div><div class="token-line"><span class="token plain">                    if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)mscp[j].ml_ompnr) == FALSE)</span></div><div class="token-line"><span class="token plain">                    {</span></div><div class="token-line"><span class="token plain">                        system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //释放内存对象容器本身占用的物理内存页面</span></div><div class="token-line"><span class="token plain">        //遍历每个so_mc.mc_kmobinlst中的msadsc_t结构。它只会遍历一次</span></div><div class="token-line"><span class="token plain">        list_for_each_head_dell(tmplst, &amp;kmsp-&gt;so_mc.mc_kmobinlst)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            msa = list_entry(tmplst, msadsc_t, md_list);</span></div><div class="token-line"><span class="token plain">            list_del(&amp;msa-&gt;md_list);</span></div><div class="token-line"><span class="token plain">            //msadsc_t脱链</span></div><div class="token-line"><span class="token plain">            //释放msadsc_t对应的物理内存页面</span></div><div class="token-line"><span class="token plain">            if (mm_merge_pages(&amp;memmgrob, msa, (uint_t)kmsp-&gt;so_mc.mc_kmobinpnr) == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                system_error(&quot;_destroy_kmsob_core mm_merge_pages FALSE2\n&quot;);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return TRUE;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //</span></div><div class="token-line"><span class="token plain">    ```销毁内存对象容器</span></div><div class="token-line"><span class="token plain">    bool_t _destroy_kmsob(kmsobmgrhed_t *kmobmgrp, koblst_t *koblp, kmsob_t *kmsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //看看能不能销毁</span></div><div class="token-line"><span class="token plain">        uint_t screts = scan_freekmsob_isok(kmsp);</span></div><div class="token-line"><span class="token plain">        if (2 == screts)</span></div><div class="token-line"><span class="token plain">        {//调用销毁内存对象容器的核心函数</span></div><div class="token-line"><span class="token plain">            return _destroy_kmsob_core(kmobmgrp, koblp, kmsp);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return FALSE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，首先会检查一下内存对象容器是不是空闲的，如果空闲，就调用<strong>销毁内存对象容器的核心函数_destroy_kmsob_core</strong>。在_destroy_kmsob_core函数中，首先要释放内存对象容器的扩展空间所占用的物理内存页面，最后才可以释放内存对象容器自身占用物理内存页面。</p><p>请注意。<strong>这个顺序不能前后颠倒</strong>，这是因为扩展空间的物理内存页面对应的msadsc_t结构，它就挂载在kmsob_t结构的so_mc.mc_lst数组中。</p><p>好了，到这里我们内存对象释放的流程就完成了，这意味着我们整个内存对象管理也告一段落了。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天我们从malloc函数入手，思考内核要怎样分配大量小块内存。我们把物理内存页面进一步细分成内存对象，为了表示和管理内存对象，又设计了内存对象、内存对象容器等一系列数据结构，随后写代码把它们初始化，最后我们依赖这些数据结构实现了内存对象管理算法。</p><p>下面我们来回顾一下这节课的重点。</p><p>1.我们发现，在应用程序中可以使用malloc函数动态分配一些小块内存，其实这样的场景在内核中也是比比皆是。比如，内核经常要动态创建数据结构的实例变量，就需要分配小块的内存空间。</p><p>2.为了实现内存对象的表示、分配和释放功能，我们定义了内存对象和内存对象容器的数据结构freobjh_t、kmsob_t，并为了管理kmsob_t结构又定义了kmsobmgrhed_t结构。</p><p>3.我们写好了初始化kmsobmgrhed_t结构的函数，并在init_kmsob中调用了它，进而又被init_memmgr函数调用，由于kmsobmgrhed_t结构是为了管理kmsob_t结构的所以在一开始就要被初始化。</p><p>4.我们基于这些数据结构实现了内存对象的分配和释放。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>为什么我们在分配内存对象大小时要按照Cache行大小的倍数分配呢？</p><p>欢迎你在留言区分享你的思考或疑问。如果这节课对你有帮助，也欢迎你分享给自己的同事、朋友，跟他一起交流讨论。</p><p>好，我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/07.土地革命内存/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:34:15</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
