<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>23 | 瞧一瞧Linux：SLAB如何分配内存？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/07.土地革命内存/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="SLAB" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/08#slab"><span>SLAB</span></a></li><li title="走进SLAB对象" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#走进slab对象"><span>走进SLAB对象</span></a></li><li title="第一个kmem_cache" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#第一个kmem_cache"><span>第一个kmem_cache</span></a></li><li title="管理kmem_cache" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#管理kmem_cache"><span>管理kmem_cache</span></a></li><li title="SLAB分配对象的过程" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/08#slab分配对象的过程"><span>SLAB分配对象的过程</span></a></li><li title="SLAB分配接口" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#slab分配接口"><span>SLAB分配接口</span></a></li><li title="如何查找kmem_cache结构" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#如何查找kmem_cache结构"><span>如何查找kmem_cache结构</span></a></li><li title="分配对象" data-depth="3"><a href="/blog-base/操作系统实战/07.土地革命内存/08#分配对象"><span>分配对象</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/08#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/07.土地革命内存/08#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="23--瞧一瞧linuxslab如何分配内存"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#23--瞧一瞧linuxslab如何分配内存"><span class="icon icon-link"></span></a>23 | 瞧一瞧Linux：SLAB如何分配内存？</h1><p>你好，我是LMOS。</p><p>上节课我们学习了伙伴系统，了解了它是怎样管理物理内存页面的。那么你自然会想到这个问题：Linux系统中，比页更小的内存对象要怎样分配呢？</p><p>带着这个问题，我们来一起看看**SLAB分配器的原理和实现。**在学习过程中，你也可以对照一下我们Cosmos的内存管理组件，看看两者的内存管理有哪些异同。</p><h2 id="slab"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#slab"><span class="icon icon-link"></span></a>SLAB</h2><p>与Cosmos物理内存页面管理器一样，Linux中的伙伴系统是以页面为最小单位分配的，现实更多要以内核对象为单位分配内存，其实更具体一点说，就是根据内核对象的实例变量大小来申请和释放内存空间，这些数据结构实例变量的大小通常从几十字节到几百字节不等，远远小于一个页面的大小。</p><p>如果一个几十字节大小的数据结构实例变量，就要为此分配一个页面，这无疑是对宝贵物理内存的一种巨大浪费，因此一个更好的技术方案应运而生，就是<strong>Slab分配器</strong>（由Sun公司的雇员Jeff Bonwick在Solaris 2.4中设计并实现）。</p><p>由于作者公开了实现方法，后来被Linux所借鉴，用于实现内核中更小粒度的内存分配。看看吧，你以为Linux很强大，真的强大吗？不过是站在巨人的肩膀上飞翔的。</p><h3 id="走进slab对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#走进slab对象"><span class="icon icon-link"></span></a>走进SLAB对象</h3><p>何为SLAB对象？在SLAB分配器中，它把一个内存页面或者一组连续的内存页面，划分成大小相同的块，其中这一个小的内存块就是SLAB对象，但是这一组连续的内存页面中不只是SLAB对象，还有SLAB管理头和着色区。</p><p>我画个图你就明白了，如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage1b221b210fe094e7eba4b19ef118f76e6322.4a542238.jpg" alt="" title="SLAB对象示意图"/></p><p>上图中有一个内存页面和两个内存页面的SLAB，你可能对着色区有点陌生，我来给你讲解一下。</p><p>这个着色区也是一块动态的内存块，建立SLAB时才会设置它的大小，目的是为了错开不同SLAB中的对象地址，降低硬件Cache行中的地址争用，以免导致Cache抖动效应，整个系统性能下降。</p><p>SLAB头其实是一个数据结构，但是它不一定放在保存对象内存页面的开始。通常会有一个保存SLAB管理头的SLAB，在Linux中，SLAB管理头用kmem_cache结构来表示，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct array_cache {</span></div><div class="token-line"><span class="token plain">        unsigned int avail;</span></div><div class="token-line"><span class="token plain">        unsigned int limit;</span></div><div class="token-line"><span class="token plain">        void *entry[]; </span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    struct kmem_cache {</span></div><div class="token-line"><span class="token plain">        //是每个CPU一个array_cache类型的变量，cpu_cache是用于管理空闲对象的 </span></div><div class="token-line"><span class="token plain">        struct array_cache __percpu *cpu_cache;</span></div><div class="token-line"><span class="token plain">        unsigned int size; //cache大小</span></div><div class="token-line"><span class="token plain">        slab_flags_t flags;//slab标志</span></div><div class="token-line"><span class="token plain">        unsigned int num;//对象个数</span></div><div class="token-line"><span class="token plain">        unsigned int gfporder;//分配内存页面的order</span></div><div class="token-line"><span class="token plain">        gfp_t allocflags;</span></div><div class="token-line"><span class="token plain">        size_t colour;//着色区大小</span></div><div class="token-line"><span class="token plain">        unsigned int colour_off;//着色区的开始偏移</span></div><div class="token-line"><span class="token plain">        const char *name;//本SLAB的名字</span></div><div class="token-line"><span class="token plain">        struct list_head list;//所有的SLAB都要链接起来</span></div><div class="token-line"><span class="token plain">        int refcount;//引用计数</span></div><div class="token-line"><span class="token plain">        int object_size;//对象大小</span></div><div class="token-line"><span class="token plain">        int align;//对齐大小</span></div><div class="token-line"><span class="token plain">        struct kmem_cache_node *node[MAX_NUMNODES];//指向管理kmemcache的上层结构</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>上述代码中，有多少个CPU，就会有多少个array_cache类型的变量。这种为每个CPU构造一个变量副本的同步机制，就是<strong>每CPU变量</strong>（per-cpu-variable）。array_cache结构中&quot;entry[]&quot;表示了一个遵循LIFO顺序的数组，&quot;avail&quot;和&quot;limit&quot;分别指定了当前可用对象的数目和允许容纳对象的最大数目。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage83b68392800e70d37795c902b0d5dfebe5b6.dfbc5a13.jpg" alt="" title="kmem_cache结构图解"/></p><h3 id="第一个kmem_cache"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#第一个kmem_cache"><span class="icon icon-link"></span></a>第一个kmem_cache</h3><p>第一个kmem_cache是哪里来的呢？其实它是静态定义在代码中的，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static struct kmem_cache kmem_cache_boot = {</span></div><div class="token-line"><span class="token plain">        .batchcount = 1,</span></div><div class="token-line"><span class="token plain">        .limit = BOOT_CPUCACHE_ENTRIES,</span></div><div class="token-line"><span class="token plain">        .shared = 1,</span></div><div class="token-line"><span class="token plain">        .size = sizeof(struct kmem_cache),</span></div><div class="token-line"><span class="token plain">        .name = &quot;kmem_cache&quot;,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void __init kmem_cache_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        int i;</span></div><div class="token-line"><span class="token plain">        //指向静态定义的kmem_cache_boot</span></div><div class="token-line"><span class="token plain">        kmem_cache = &amp;kmem_cache_boot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (i = 0; i &lt; NUM_INIT_LISTS; i++)</span></div><div class="token-line"><span class="token plain">            kmem_cache_node_init(&amp;init_kmem_cache_node[i]);</span></div><div class="token-line"><span class="token plain">        //建立保存kmem_cache结构的kmem_cache</span></div><div class="token-line"><span class="token plain">        create_boot_cache(kmem_cache, &quot;kmem_cache&quot;,</span></div><div class="token-line"><span class="token plain">            offsetof(struct kmem_cache, node) +</span></div><div class="token-line"><span class="token plain">                      nr_node_ids * sizeof(struct kmem_cache_node *),</span></div><div class="token-line"><span class="token plain">                      SLAB_HWCACHE_ALIGN, 0, 0);</span></div><div class="token-line"><span class="token plain">        //加入全局slab_caches链表中</span></div><div class="token-line"><span class="token plain">        list_add(&amp;kmem_cache-&gt;list, &amp;slab_caches);</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            int nid;</span></div><div class="token-line"><span class="token plain">            for_each_online_node(nid) {</span></div><div class="token-line"><span class="token plain">                init_list(kmem_cache, &amp;init_kmem_cache_node[CACHE_CACHE + nid], nid);</span></div><div class="token-line"><span class="token plain">                init_list(kmalloc_caches[KMALLOC_NORMAL][INDEX_NODE],                      &amp;init_kmem_cache_node[SIZE_NODE + nid], nid);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //建立kmalloc函数使用的的kmem_cache</span></div><div class="token-line"><span class="token plain">        create_kmalloc_caches(ARCH_KMALLOC_FLAGS);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="管理kmem_cache"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#管理kmem_cache"><span class="icon icon-link"></span></a>管理kmem_cache</h3><p>我们建好了第一个kmem_cache，以后kmem_cache越来越多，而且我们并没有看到kmem_cache结构中有任何指向内存页面的字段，但在kmem_cache结构中有个保存kmem_cache_node结构的指针数组。</p><p>kmem_cache_node结构是每个内存节点对应一个，它就是用来管理kmem_cache结构的，它开始是静态定义的，初始化时建立了第一个kmem_cache结构之后，init_list函数负责一个个分配内存空间，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define NUM_INIT_LISTS (2 * MAX_NUMNODES)</span></div><div class="token-line"><span class="token plain">    //定义的kmem_cache_node结构数组</span></div><div class="token-line"><span class="token plain">    static struct kmem_cache_node __initdata init_kmem_cache_node[NUM_INIT_LISTS];</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct kmem_cache_node {</span></div><div class="token-line"><span class="token plain">        spinlock_t list_lock;//自旋锁</span></div><div class="token-line"><span class="token plain">        struct list_head slabs_partial;//有一部分空闲对象的kmem_cache结构</span></div><div class="token-line"><span class="token plain">        struct list_head slabs_full;//没有空闲对象的kmem_cache结构</span></div><div class="token-line"><span class="token plain">        struct list_head slabs_free;//对象全部空闲kmem_cache结构</span></div><div class="token-line"><span class="token plain">        unsigned long total_slabs; //一共多少kmem_cache结构</span></div><div class="token-line"><span class="token plain">        unsigned long free_slabs;  //空闲的kmem_cache结构</span></div><div class="token-line"><span class="token plain">        unsigned long free_objects;//空闲的对象</span></div><div class="token-line"><span class="token plain">        unsigned int free_limit;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    static void __init init_list(struct kmem_cache *cachep, struct kmem_cache_node *list,</span></div><div class="token-line"><span class="token plain">                    int nodeid)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct kmem_cache_node *ptr;</span></div><div class="token-line"><span class="token plain">        //分配新的 kmem_cache_node 结构的空间</span></div><div class="token-line"><span class="token plain">        ptr = kmalloc_node(sizeof(struct kmem_cache_node), GFP_NOWAIT, nodeid);</span></div><div class="token-line"><span class="token plain">        BUG_ON(!ptr);</span></div><div class="token-line"><span class="token plain">        //复制初始时的静态kmem_cache_node结构</span></div><div class="token-line"><span class="token plain">        memcpy(ptr, list, sizeof(struct kmem_cache_node));</span></div><div class="token-line"><span class="token plain">        spin_lock_init(&amp;ptr-&gt;list_lock);</span></div><div class="token-line"><span class="token plain">        MAKE_ALL_LISTS(cachep, ptr, nodeid);</span></div><div class="token-line"><span class="token plain">        //设置kmem_cache_node的地址</span></div><div class="token-line"><span class="token plain">        cachep-&gt;node[nodeid] = ptr;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们第一次分配对象时，肯定没有对应的内存页面存放对象，那么SLAB模块就会调用<strong>cache_grow_begin函数</strong>获取内存页面，然后用获取的页面来存放对象，我们一起来看看代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static void slab_map_pages(struct kmem_cache *cache, struct page *page,void *freelist)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //页面结构指向kmem_cache结构</span></div><div class="token-line"><span class="token plain">        page-&gt;slab_cache = cache;</span></div><div class="token-line"><span class="token plain">        //指向空闲对象的链表</span></div><div class="token-line"><span class="token plain">        page-&gt;freelist = freelist;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static struct page *cache_grow_begin(struct kmem_cache *cachep,</span></div><div class="token-line"><span class="token plain">                    gfp_t flags, int nodeid)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void *freelist;</span></div><div class="token-line"><span class="token plain">        size_t offset;</span></div><div class="token-line"><span class="token plain">        gfp_t local_flags;</span></div><div class="token-line"><span class="token plain">        int page_node;</span></div><div class="token-line"><span class="token plain">        struct kmem_cache_node *n;</span></div><div class="token-line"><span class="token plain">        struct page *page;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        WARN_ON_ONCE(cachep-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span></div><div class="token-line"><span class="token plain">        local_flags = flags &amp; (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);</span></div><div class="token-line"><span class="token plain">        //获取页面</span></div><div class="token-line"><span class="token plain">        page = kmem_getpages(cachep, local_flags, nodeid);</span></div><div class="token-line"><span class="token plain">        //获取页面所在的内存节点号</span></div><div class="token-line"><span class="token plain">        page_node = page_to_nid(page);</span></div><div class="token-line"><span class="token plain">        //根据内存节点获取对应kmem_cache_node结构</span></div><div class="token-line"><span class="token plain">        n = get_node(cachep, page_node);</span></div><div class="token-line"><span class="token plain">        //分配管理空闲对象的数据结构</span></div><div class="token-line"><span class="token plain">        freelist = alloc_slabmgmt(cachep, page, offset,</span></div><div class="token-line"><span class="token plain">                local_flags &amp; ~GFP_CONSTRAINT_MASK, page_node);</span></div><div class="token-line"><span class="token plain">        //让页面中相关的字段指向kmem_cache和空闲对象</span></div><div class="token-line"><span class="token plain">        slab_map_pages(cachep, page, freelist);</span></div><div class="token-line"><span class="token plain">        //初始化空闲对象管理数据</span></div><div class="token-line"><span class="token plain">        cache_init_objs(cachep, page);</span></div><div class="token-line"><span class="token plain">        return page;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static void cache_grow_end(struct kmem_cache *cachep, struct page *page)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct kmem_cache_node *n;</span></div><div class="token-line"><span class="token plain">        void *list = NULL;</span></div><div class="token-line"><span class="token plain">        if (!page)</span></div><div class="token-line"><span class="token plain">            return;</span></div><div class="token-line"><span class="token plain">        //初始化结page构的slab_list链表</span></div><div class="token-line"><span class="token plain">        INIT_LIST_HEAD(&amp;page-&gt;slab_list);</span></div><div class="token-line"><span class="token plain">        //根据内存节点获取对应kmem_cache_node结构.</span></div><div class="token-line"><span class="token plain">        n = get_node(cachep, page_to_nid(page));</span></div><div class="token-line"><span class="token plain">        spin_lock(&amp;n-&gt;list_lock);</span></div><div class="token-line"><span class="token plain">        //slab计数增加</span></div><div class="token-line"><span class="token plain">        n-&gt;total_slabs++;</span></div><div class="token-line"><span class="token plain">        if (!page-&gt;active) {</span></div><div class="token-line"><span class="token plain">            //把这个page结构加入到kmem_cache_node结构的空闲链表中</span></div><div class="token-line"><span class="token plain">            list_add_tail(&amp;page-&gt;slab_list, &amp;n-&gt;slabs_free);</span></div><div class="token-line"><span class="token plain">            n-&gt;free_slabs++;</span></div><div class="token-line"><span class="token plain">        } </span></div><div class="token-line"><span class="token plain">        spin_unlock(&amp;n-&gt;list_lock);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中的注释已经很清楚了，cache_grow_begin函数会为kmem_cache结构分配用来存放对象的页面，随后会调用与之对应的cache_grow_end函数，把这页面挂载到kmem_cache_node结构的链表中，并让页面指向kmem_cache结构。</p><p>这样kmem_cache_node，kmem_cache，page这三者之间就联系起来了。你再看一下后面的图，就更加清楚了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagee730e7b479af38d5ed1ab00f35b4fe88fe30.fe662ce4.jpg" alt="" title="SLAB全局结构示意图"/></p><p>上图中page可能是一组连续的pages，但是只会把第一个page挂载到kmem_cache_node中，同时，在slab_map_pages函数中又让page指向了kmem_cache。</p><p>但你要特别留意kmem_cache_node中的三个链表，它们分别挂载的pages，有一部分是空闲对象的page、还有对象全部都已经分配的page，以及全部都为空闲对象的page。这是为了提高分配时查找kmem_cache的性能。</p><h2 id="slab分配对象的过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#slab分配对象的过程"><span class="icon icon-link"></span></a>SLAB分配对象的过程</h2><p>有了前面对SLAB数据结构的了解，SLAB分配对象的过程你自己也能推导出来，无非是根据请求分配对象的大小，查找对应的kmem_cache结构，接着从这个结构中获取arry_cache结构，然后分配对象。</p><p>如果没有空闲对象了，就需要在kmem_cache对应的kmem_cache_node结构中查找有空闲对象的kmem_cache。如果还是没找到，最后就要分配内存页面新增kmem_cache结构了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage78fe78868f267073d4b0a8fb73b15bb41bfe.ee815c92.jpg" alt="" title="SLAB分配对象的过程图解"/></p><p>下面我们从接口开始了解这些过程。</p><h3 id="slab分配接口"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#slab分配接口"><span class="icon icon-link"></span></a>SLAB分配接口</h3><p>其实在Linux内核中，用的最多的是kmalloc函数，经常用于分配小的缓冲区，或者数据结构分配实例空间，这个函数就是SLAB分配接口，它是用来分配对象的，这个对象就是一小块内存空间。</p><p>下面一起来看看代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,unsigned long caller)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct kmem_cache *cachep;</span></div><div class="token-line"><span class="token plain">        void *ret;</span></div><div class="token-line"><span class="token plain">        if (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        //查找size对应的kmem_cache</span></div><div class="token-line"><span class="token plain">        cachep = kmalloc_slab(size, flags);</span></div><div class="token-line"><span class="token plain">        if (unlikely(ZERO_OR_NULL_PTR(cachep)))</span></div><div class="token-line"><span class="token plain">            return cachep;</span></div><div class="token-line"><span class="token plain">        //分配对象</span></div><div class="token-line"><span class="token plain">        ret = slab_alloc(cachep, flags, caller);</span></div><div class="token-line"><span class="token plain">        return ret;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void *__kmalloc(size_t size, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return __do_kmalloc(size, flags, _RET_IP_);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static __always_inline void *kmalloc(size_t size, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return __kmalloc(size, flags);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面代码的流程很简单，就是在__do_kmalloc函数中，查找出分配大小对应的kmem_cache结构，然后调用slab_alloc函数进行分配。可以说，slab_alloc函数才是SLAB的接口函数，但是它的参数中<strong>必须要有kmem_cache结构</strong>。</p><p>具体是如何查找的呢？我们这就来看看。</p><h3 id="如何查找kmem_cache结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#如何查找kmem_cache结构"><span class="icon icon-link"></span></a>如何查找kmem_cache结构</h3><p>由于SLAB的接口函数slab_alloc，它的参数中必须要有kmem_cache结构指针，指定从哪个kmem_cache结构分配对象，所以在调用slab_alloc函数之前必须给出kmem_cache结构。</p><p>我们怎么查找到它呢？这就需要调用kmalloc_slab函数了，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">enum kmalloc_cache_type {</span></div><div class="token-line"><span class="token plain">        KMALLOC_NORMAL = 0,</span></div><div class="token-line"><span class="token plain">        KMALLOC_RECLAIM,</span></div><div class="token-line"><span class="token plain">    #ifdef CONFIG_ZONE_DMA</span></div><div class="token-line"><span class="token plain">        KMALLOC_DMA,</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">        NR_KMALLOC_TYPES</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    struct kmem_cache *kmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1] __ro_after_init ={ static u8 size_index[24] __ro_after_init = {</span></div><div class="token-line"><span class="token plain">        3,  /* 8 */</span></div><div class="token-line"><span class="token plain">        4,  /* 16 */</span></div><div class="token-line"><span class="token plain">        5,  /* 24 */</span></div><div class="token-line"><span class="token plain">        5,  /* 32 */</span></div><div class="token-line"><span class="token plain">        6,  /* 40 */</span></div><div class="token-line"><span class="token plain">        6,  /* 48 */</span></div><div class="token-line"><span class="token plain">        6,  /* 56 */</span></div><div class="token-line"><span class="token plain">        6,  /* 64 */</span></div><div class="token-line"><span class="token plain">        1,  /* 72 */</span></div><div class="token-line"><span class="token plain">        1,  /* 80 */</span></div><div class="token-line"><span class="token plain">        1,  /* 88 */</span></div><div class="token-line"><span class="token plain">        1,  /* 96 */</span></div><div class="token-line"><span class="token plain">        7,  /* 104 */</span></div><div class="token-line"><span class="token plain">        7,  /* 112 */</span></div><div class="token-line"><span class="token plain">        7,  /* 120 */</span></div><div class="token-line"><span class="token plain">        7,  /* 128 */</span></div><div class="token-line"><span class="token plain">        2,  /* 136 */</span></div><div class="token-line"><span class="token plain">        2,  /* 144 */</span></div><div class="token-line"><span class="token plain">        2,  /* 152 */</span></div><div class="token-line"><span class="token plain">        2,  /* 160 */</span></div><div class="token-line"><span class="token plain">        2,  /* 168 */</span></div><div class="token-line"><span class="token plain">        2,  /* 176 */</span></div><div class="token-line"><span class="token plain">        2,  /* 184 */</span></div><div class="token-line"><span class="token plain">        2   /* 192 */</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //根据分配标志返回枚举类型，其实是0、1、2其中之一</span></div><div class="token-line"><span class="token plain">    static __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    #ifdef CONFIG_ZONE_DMA</span></div><div class="token-line"><span class="token plain">        if (likely((flags &amp; (__GFP_DMA | __GFP_RECLAIMABLE)) == 0))</span></div><div class="token-line"><span class="token plain">            return KMALLOC_NORMAL;</span></div><div class="token-line"><span class="token plain">        return flags &amp; __GFP_DMA ? KMALLOC_DMA : KMALLOC_RECLAIM;</span></div><div class="token-line"><span class="token plain">    #else</span></div><div class="token-line"><span class="token plain">        return flags &amp; __GFP_RECLAIMABLE ? KMALLOC_RECLAIM : KMALLOC_NORMAL;</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    struct kmem_cache *kmalloc_slab(size_t size, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        unsigned int index;</span></div><div class="token-line"><span class="token plain">        //计算出index</span></div><div class="token-line"><span class="token plain">        if (size &lt;= 192) {</span></div><div class="token-line"><span class="token plain">            if (!size)</span></div><div class="token-line"><span class="token plain">                return ZERO_SIZE_PTR;</span></div><div class="token-line"><span class="token plain">            index = size_index[size_index_elem(size)];</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            if (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span></div><div class="token-line"><span class="token plain">                return NULL;</span></div><div class="token-line"><span class="token plain">            index = fls(size - 1);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return kmalloc_caches[kmalloc_type(flags)][index];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上述代码，不难发现kmalloc_caches就是个全局的二维数组，kmalloc_slab函数只是根据分配大小和分配标志计算出了数组下标，最后取出其中kmem_cache结构指针。</p><p>那么kmalloc_caches中的kmem_cache，它又是谁建立的呢？我们还是接着看代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct kmem_cache *__init create_kmalloc_cache(const char *name,</span></div><div class="token-line"><span class="token plain">            unsigned int size, slab_flags_t flags,</span></div><div class="token-line"><span class="token plain">            unsigned int useroffset, unsigned int usersize)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //从第一个kmem_cache中分配一个对象放kmem_cache</span></div><div class="token-line"><span class="token plain">        struct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        if (!s)</span></div><div class="token-line"><span class="token plain">            panic(&quot;Out of memory when creating slab %s\n&quot;, name);</span></div><div class="token-line"><span class="token plain">        //设置s的对齐参数，处理s的freelist就是arr_cache</span></div><div class="token-line"><span class="token plain">        create_boot_cache(s, name, size, flags, useroffset, usersize);</span></div><div class="token-line"><span class="token plain">        list_add(&amp;s-&gt;list, &amp;slab_caches);</span></div><div class="token-line"><span class="token plain">        s-&gt;refcount = 1;</span></div><div class="token-line"><span class="token plain">        return s;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //新建一个kmem_cache</span></div><div class="token-line"><span class="token plain">    static void __init new_kmalloc_cache(int idx, enum kmalloc_cache_type type, slab_flags_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if (type == KMALLOC_RECLAIM)</span></div><div class="token-line"><span class="token plain">            flags |= SLAB_RECLAIM_ACCOUNT;</span></div><div class="token-line"><span class="token plain">            //根据kmalloc_info中信息建立一个kmem_cache</span></div><div class="token-line"><span class="token plain">        kmalloc_caches[type][idx] = create_kmalloc_cache(</span></div><div class="token-line"><span class="token plain">                        kmalloc_info[idx].name[type],</span></div><div class="token-line"><span class="token plain">                        kmalloc_info[idx].size, flags, 0,</span></div><div class="token-line"><span class="token plain">                        kmalloc_info[idx].size);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //建立所有的kmalloc_caches中的kmem_cache</span></div><div class="token-line"><span class="token plain">    void __init create_kmalloc_caches(slab_flags_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        int i;</span></div><div class="token-line"><span class="token plain">        enum kmalloc_cache_type type;</span></div><div class="token-line"><span class="token plain">        for (type = KMALLOC_NORMAL; type &lt;= KMALLOC_RECLAIM; type++) {</span></div><div class="token-line"><span class="token plain">            for (i = KMALLOC_SHIFT_LOW; i &lt;= KMALLOC_SHIFT_HIGH; i++) {</span></div><div class="token-line"><span class="token plain">                if (!kmalloc_caches[type][i])</span></div><div class="token-line"><span class="token plain">                    //建立一个新的kmem_cache</span></div><div class="token-line"><span class="token plain">                    new_kmalloc_cache(i, type, flags);</span></div><div class="token-line"><span class="token plain">                if (KMALLOC_MIN_SIZE &lt;= 32 &amp;&amp; i == 6 &amp;&amp;</span></div><div class="token-line"><span class="token plain">                        !kmalloc_caches[type][1])</span></div><div class="token-line"><span class="token plain">                    new_kmalloc_cache(1, type, flags);</span></div><div class="token-line"><span class="token plain">                if (KMALLOC_MIN_SIZE &lt;= 64 &amp;&amp; i == 7 &amp;&amp;</span></div><div class="token-line"><span class="token plain">                        !kmalloc_caches[type][2])</span></div><div class="token-line"><span class="token plain">                    new_kmalloc_cache(2, type, flags);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，__do_kmalloc函数中根据分配对象大小查找的所有kmem_cache结构，我们就建立好了，保存在kmalloc_caches数组中。下面我们再去看看对象是如何分配的。</p><h3 id="分配对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#分配对象"><span class="icon icon-link"></span></a>分配对象</h3><p>下面我们从slab_alloc函数开始探索对象的分配过程，slab_alloc函数的第一个参数就kmem_cache结构的指针，表示从该kmem_cache结构中分配对象。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static __always_inline void *slab_alloc(struct kmem_cache *cachep, gfp_t flags, unsigned long caller)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        unsigned long save_flags;</span></div><div class="token-line"><span class="token plain">        void *objp;</span></div><div class="token-line"><span class="token plain">        //关中断</span></div><div class="token-line"><span class="token plain">        local_irq_save(save_flags);</span></div><div class="token-line"><span class="token plain">        //分配对象</span></div><div class="token-line"><span class="token plain">        objp = __do_cache_alloc(cachep, flags);</span></div><div class="token-line"><span class="token plain">        //恢复中断</span></div><div class="token-line"><span class="token plain">        local_irq_restore(save_flags);</span></div><div class="token-line"><span class="token plain">        return objp;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接口函数总是简单的，真正干活的是__do_cache_alloc函数，下面我们就来看看这个函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static inline void *____cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void *objp;</span></div><div class="token-line"><span class="token plain">        struct array_cache *ac;</span></div><div class="token-line"><span class="token plain">        //获取当前cpu在cachep结构中的array_cache结构的指针</span></div><div class="token-line"><span class="token plain">        ac = cpu_cache_get(cachep);</span></div><div class="token-line"><span class="token plain">        //如果ac中的avail不为0,说明当前kmem_cache结构中freelist是有空闲对象</span></div><div class="token-line"><span class="token plain">        if (likely(ac-&gt;avail)) {</span></div><div class="token-line"><span class="token plain">            ac-&gt;touched = 1;</span></div><div class="token-line"><span class="token plain">            //空间对象的地址保存在ac-&gt;entry</span></div><div class="token-line"><span class="token plain">            objp = ac-&gt;entry[--ac-&gt;avail];</span></div><div class="token-line"><span class="token plain">            goto out;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        objp = cache_alloc_refill(cachep, flags);</span></div><div class="token-line"><span class="token plain">    out:</span></div><div class="token-line"><span class="token plain">        return objp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static __always_inline void *__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return ____cache_alloc(cachep, flags);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中真正做事的函数是**____cache_alloc函数**，它首先获取了当前kmem_cache结构中指向array_cache结构的指针，找到它里面空闲对象的地址（如果你不懂array_cache结构，请回到SLAB对象那一小节复习），然后在array_cache结构中取出一个空闲对象地址返回，这样就分配成功了。</p><p>这个速度是很快的，如果array_cache结构中没有空闲对象了，就会调用cache_alloc_refill函数。那这个函数又干了什么呢？我们接着往下看。代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static struct page *get_first_slab(struct kmem_cache_node *n, bool pfmemalloc)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct page *page;</span></div><div class="token-line"><span class="token plain">        assert_spin_locked(&amp;n-&gt;list_lock);</span></div><div class="token-line"><span class="token plain">        //首先从kmem_cache_node结构中的slabs_partial链表上查看有没有page</span></div><div class="token-line"><span class="token plain">        page = list_first_entry_or_null(&amp;n-&gt;slabs_partial, struct page,slab_list);</span></div><div class="token-line"><span class="token plain">        if (!page) {</span></div><div class="token-line"><span class="token plain">        //如果没有</span></div><div class="token-line"><span class="token plain">            n-&gt;free_touched = 1;</span></div><div class="token-line"><span class="token plain">        //从kmem_cache_node结构中的slabs_free链表上查看有没有page</span></div><div class="token-line"><span class="token plain">            page = list_first_entry_or_null(&amp;n-&gt;slabs_free, struct page,slab_list);</span></div><div class="token-line"><span class="token plain">            if (page)</span></div><div class="token-line"><span class="token plain">                n-&gt;free_slabs--; //空闲slab计数减一</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //返回page</span></div><div class="token-line"><span class="token plain">        return page;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        int batchcount;</span></div><div class="token-line"><span class="token plain">        struct kmem_cache_node *n;</span></div><div class="token-line"><span class="token plain">        struct array_cache *ac, *shared;</span></div><div class="token-line"><span class="token plain">        int node;</span></div><div class="token-line"><span class="token plain">        void *list = NULL;</span></div><div class="token-line"><span class="token plain">        struct page *page;</span></div><div class="token-line"><span class="token plain">        //获取内存节点</span></div><div class="token-line"><span class="token plain">        node = numa_mem_id();</span></div><div class="token-line"><span class="token plain">        ac = cpu_cache_get(cachep);</span></div><div class="token-line"><span class="token plain">        batchcount = ac-&gt;batchcount;</span></div><div class="token-line"><span class="token plain">        //获取cachep所属的kmem_cache_node</span></div><div class="token-line"><span class="token plain">        n = get_node(cachep, node);</span></div><div class="token-line"><span class="token plain">        shared = READ_ONCE(n-&gt;shared);</span></div><div class="token-line"><span class="token plain">        if (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</span></div><div class="token-line"><span class="token plain">            goto direct_grow;</span></div><div class="token-line"><span class="token plain">        while (batchcount &gt; 0) {</span></div><div class="token-line"><span class="token plain">            //获取kmem_cache_node结构中其它kmem_cache,返回的是page，而page会指向kmem_cache</span></div><div class="token-line"><span class="token plain">            page = get_first_slab(n, false);</span></div><div class="token-line"><span class="token plain">            if (!page)</span></div><div class="token-line"><span class="token plain">                goto must_grow;</span></div><div class="token-line"><span class="token plain">            batchcount = alloc_block(cachep, ac, page, batchcount);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    must_grow:</span></div><div class="token-line"><span class="token plain">        n-&gt;free_objects -= ac-&gt;avail;</span></div><div class="token-line"><span class="token plain">    direct_grow:</span></div><div class="token-line"><span class="token plain">        if (unlikely(!ac-&gt;avail)) {</span></div><div class="token-line"><span class="token plain">            //分配新的kmem_cache并初始化</span></div><div class="token-line"><span class="token plain">            page = cache_grow_begin(cachep, gfp_exact_node(flags), node);</span></div><div class="token-line"><span class="token plain">            ac = cpu_cache_get(cachep);</span></div><div class="token-line"><span class="token plain">            if (!ac-&gt;avail &amp;&amp; page)</span></div><div class="token-line"><span class="token plain">                alloc_block(cachep, ac, page, batchcount);</span></div><div class="token-line"><span class="token plain">            //让page挂载到kmem_cache_node结构的slabs_list链表上</span></div><div class="token-line"><span class="token plain">            cache_grow_end(cachep, page);</span></div><div class="token-line"><span class="token plain">            if (!ac-&gt;avail)</span></div><div class="token-line"><span class="token plain">                return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ac-&gt;touched = 1;</span></div><div class="token-line"><span class="token plain">        //重新分配</span></div><div class="token-line"><span class="token plain">        return ac-&gt;entry[--ac-&gt;avail];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>调用cache_alloc_refill函数的过程，主要的工作都有哪些呢？我给你梳理一下。</p><p>首先，获取了cachep所属的kmem_cache_node。</p><p>然后调用get_first_slab，获取kmem_cache_node结构还有没有包含空闲对象的kmem_cache。但是请注意，这里返回的是page，因为page会指向kmem_cache结构，page所代表的物理内存页面，也保存着kmem_cache结构中的对象。</p><p>最后，如果kmem_cache_node结构没有包含空闲对象的kmem_cache了，就必须调用cache_grow_begin函数，找伙伴系统分配新的内存页面，而且还要找第一个kmem_cache分配新的对象，来存放kmem_cache结构的实例变量，并进行必要的初始化。</p><p>这些步骤完成之后，再调用cache_grow_end函数，把刚刚分配的page挂载到kmem_cache_node结构的slabs_list链表上。因为cache_grow_begin和cache_grow_end函数在前面已经分析过了，这里不再赘述。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天的内容讲完了，我来帮你梳理一下本课程的重点。</p><p>1.为了分配小于1个page的小块内存，Linux实现了SLAB，用kmem_cache结构管理page对应内存页面上小块内存对象，然后让该page指向kmem_cache，由kmem_cache_node结构管理多个page。</p><p>2.我们从Linux内核中使用的kmalloc函数入手，了解了SLAB下整个内存对象的分配过程。</p><p>到此为止，我们对SLAB的研究就告一段落了，是不是感觉和Cosmos内存管理有些相像而又不同呢？甚至我们Cosmos内存管理要更为简洁和高效。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/07.土地革命内存/08#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>Linux的SLAB，使用kmalloc函数能分配多大的内存对象呢？</p><p>欢迎你在留言区跟我交流互动，也欢迎你把这节课分享给你的同事、朋友，跟他一起研究SLAB相关的内容。</p><p>我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/07.土地革命内存/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
