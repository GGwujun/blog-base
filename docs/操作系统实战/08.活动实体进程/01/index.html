<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>24 | 活动的描述：到底什么是进程？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/08.活动实体进程/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="感受一下" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#感受一下"><span>感受一下</span></a></li><li title="什么是进程" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#什么是进程"><span>什么是进程</span></a></li><li title="进程的结构" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#进程的结构"><span>进程的结构</span></a></li><li title="实现进程" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#实现进程"><span>实现进程</span></a></li><li title="如何表示一个进程" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#如何表示一个进程"><span>如何表示一个进程</span></a></li><li title="进程的地址空间" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#进程的地址空间"><span>进程的地址空间</span></a></li><li title="进程的机器上下文" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#进程的机器上下文"><span>进程的机器上下文</span></a></li><li title="建立进程" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#建立进程"><span>建立进程</span></a></li><li title="建立进程接口" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#建立进程接口"><span>建立进程接口</span></a></li><li title="建立内核进程" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#建立内核进程"><span>建立内核进程</span></a></li><li title="创建thread_t结构" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#创建thread_t结构"><span>创建thread_t结构</span></a></li><li title="初始化内核栈" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#初始化内核栈"><span>初始化内核栈</span></a></li><li title="建立普通进程" data-depth="3"><a href="/blog-base/操作系统实战/08.活动实体进程/01#建立普通进程"><span>建立普通进程</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/08.活动实体进程/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="24--活动的描述到底什么是进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#24--活动的描述到底什么是进程"><span class="icon icon-link"></span></a>24 | 活动的描述：到底什么是进程？</h1><p>你好，我是LMOS。</p><p>在前面的课程里，我们已经实现了数据同步、hal层的初始化，中断框架、物理内存、内存对象、虚拟内存管理，这些都是操作系统中最核心的东西。</p><p>今天，我再给你讲讲操作系统里一个层次非常高的组件——进程 ，而它又非常依赖于内存管理、中断、硬件体系结构。好在前面课程中，这些基础知识我们已经搞得清清楚楚，安排得明明白白了，所以我们今天理解进程就变得顺理成章。</p><h2 id="感受一下"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#感受一下"><span class="icon icon-link"></span></a>感受一下</h2><p>在你看来，什么是进程呢？日常我们跟计算机打交道的时候，最常接触的就是一些应用程序，比如Word、浏览器，你可以直观感受到它们的存在。而我们却很难直观感受到什么是进程，自然也就不容易描述它的模样与形态了。</p><p>其实，在我们启用Word这些应用时，操作系统在背后就会建立至少一个进程。虽然我们难以观察它的形态，但我们绝对可以通过一些状态数据来发现进程的存在。</p><p>在Linux的终端下输入ps命令， 我们就可以看到系统中有多少个进程了。如下图所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebb99bb69be65d794c9105d57f3f0b7583499.jpg" alt=""/></p><p>这是进程吗？是的，不过这只是一些具体进程的数据，如创建进程和用户、进程ID、使用CPU的百分比，进程运行状态，进程的建立时间、进程的运行时间、进程名等，这些数据综合起来就代表了一个进程。</p><p>也许看到这，你会呵呵一笑，觉得原来抽象的进程背后，不过是一堆数据而已，关于进程这就是我们能直观感受到的东西，这就完了吗？当然没有，我们接着往下看。</p><h2 id="什么是进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#什么是进程"><span class="icon icon-link"></span></a>什么是进程</h2><p>如果你要组织一个活动怎么办？你首先会想到，这个活动的流程是什么，需要配备哪些人员和物资，中途要不要休息，活动当前进行到哪里了……如果你是个精明的人，你大概会用<strong>表格</strong>把这些信息记录下来。</p><p>同理，你运行一个应用程序时，操作系统也要记录这个应用程序使用多少内存，打开了什么文件，当有些资源不可用的时候要不要睡眠，当前进程运行到哪里了。操作系统把这些信息综合统计，存放在内存中，抽象为进程。</p><p>现在你就可以回答什么是进程了：进程是一个应用程序运行时刻的实例（从进程的结构看）；进程是应用程序运行时所需资源的容器（从进程的功能看）；甚至进程是一堆数据结构（从操作系统对进程实现的角度来说）。</p><p>这也太简单了吧？对，进程的抽象概念就是这么简单。我知道这一定不能让你真正明白什么是进程，抽象的概念就是如此，你不在实践中设计并实现它，是很难真正明白的。下面我们先来细化设计。</p><h2 id="进程的结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#进程的结构"><span class="icon icon-link"></span></a>进程的结构</h2><p>首先，进程是一个应用程序运行时刻的实例，它的目的就是操作系统用于管理和运行多个应用程序的；其次，从前面我们实现的内存管理组件角度看，操作系统是给应用程序提供服务的。</p><p>所以，从这两个角度看，进程必须要有一个地址空间，这个地址空间至少包括两部分内容：一部分是内核，一部分是用户的应用程序。</p><p>最后，结合x86硬件平台对虚拟地址空间的制约，我给你画了一幅图，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage72b3725580e605b20be40ac3e0b24d82d0b3.jpg" alt="" title="进程结构示意图"/></p><p>上图中有8个进程，每个进程拥有x86 CPU的整个虚拟地址空间，这个虚拟地址空间被分成了两个部分，上半部分是所有进程都共享的内核部分 ，里面放着一份内核代码和数据，下半部分是应用程序，分别独立，互不干扰。</p><p>还记得我们讲过的x86 CPU的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/375278">特权级<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>吗？</p><p>当CPU在R0特权级运行时，就运行在上半部分内核的地址空间中，当CPU在R3特权级时，就运行在下半部分的应用程序地址空间中。各进程的虚拟地址空间是相同的，它们之间物理地址不同，是由MMU页表进行隔离的，所以每个进程的应用程序的代码绝对不能随意访问内核的代码和数据。</p><p>以上是整体结构，下面我们来细化一下进程需要实现哪些功能？</p><p>我们先从<strong>应用程序和内核的关系</strong>看。应用程序需要内核提供资源，而内核需要控制应用程序的运行。那么内核必须能够命令应用程序，让它<strong>随时中断（进入内核地址空间）或恢复执行</strong>，这就需要保存应用程序的机器上下文和它运行时刻的栈。</p><p>接着，我们深入<strong>内核提供服务的机制</strong>。众所周知，内核是这样提供服务的：通过停止应用程序代码运行，进入内核地址空间运行内核代码，然后返回结果。就像活动组织者会用表格备案一样，内核还需要记录一个应用程序都访问了哪些资源，比如打开了某个文件，或是访问了某个设备。而这样的“记录表”，我们就用“<strong>资源描述符</strong>”来表示。</p><p>而我们前面已经说了，进程是一个应用程序运行时刻的实例。那这样一来，一个细化的进程结构，就可以像下图这样设计。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage65686577df8ebc8323fa9f34835371a4b268.jpg" alt="" title="进程结构细化示意图"/></p><p>上图中表示了一个进程详细且必要的结构，其中带*号是每个进程都有独立一份，有了这样的设计结构，多个进程就能并发运行了。前面这些内容还是纸上谈兵，你重点搞明白进程的概念和结构就行了。</p><h2 id="实现进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#实现进程"><span class="icon icon-link"></span></a>实现进程</h2><p>前面我们简单介绍了进程的概念和结构，之所以简单，是为了不在理论层面就把问题复杂化，这对我们实现Cosmos的进程组件没有任何好处。</p><p>但只懂理论还是空中阁楼，我们可以一步步在设计实现中，由浅到深地理解什么是进程。我们这就把前面的概念和设计，一步步落实到代码，设计出对应的数据结构。</p><h3 id="如何表示一个进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#如何表示一个进程"><span class="icon icon-link"></span></a>如何表示一个进程</h3><p>根据前面课程的经验，如果要在软件代码中表示一个什么东西时，就要设计出对应的数据结构。</p><p>那么对于一个进程，它有状态，id，运行时间，优先级，应用程序栈，内核栈，机器上下文，资源描述符，地址空间，我们将这些信息组织在一起，就形成了一个进程的数据结构。</p><p>下面我带你把它变成代码，在cosmos/include/knlinc/目录下建立一个krlthread_t.h文件，在其中写上代码，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_THREAD</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t  td_lock;           //进程的自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t    td_list;           //进程链表 </span></div><div class="token-line"><span class="token plain">        uint_t      td_flgs;           //进程的标志</span></div><div class="token-line"><span class="token plain">        uint_t      td_stus;           //进程的状态</span></div><div class="token-line"><span class="token plain">        uint_t      td_cpuid;          //进程所在的CPU的id</span></div><div class="token-line"><span class="token plain">        uint_t      td_id;             //进程的id</span></div><div class="token-line"><span class="token plain">        uint_t      td_tick;           //进程运行了多少tick</span></div><div class="token-line"><span class="token plain">        uint_t      td_privilege;      //进程的权限</span></div><div class="token-line"><span class="token plain">        uint_t      td_priority;       //进程的优先级</span></div><div class="token-line"><span class="token plain">        uint_t      td_runmode;        //进程的运行模式</span></div><div class="token-line"><span class="token plain">        adr_t       td_krlstktop;      //应用程序内核栈顶地址</span></div><div class="token-line"><span class="token plain">        adr_t       td_krlstkstart;    //应用程序内核栈开始地址</span></div><div class="token-line"><span class="token plain">        adr_t       td_usrstktop;      //应用程序栈顶地址</span></div><div class="token-line"><span class="token plain">        adr_t       td_usrstkstart;    //应用程序栈开始地址</span></div><div class="token-line"><span class="token plain">        mmadrsdsc_t* td_mmdsc;         //地址空间结构</span></div><div class="token-line"><span class="token plain">        context_t   td_context;        //机器上下文件结构</span></div><div class="token-line"><span class="token plain">        objnode_t*  td_handtbl[TD_HAND_MAX];//打开的对象数组</span></div><div class="token-line"><span class="token plain">    }thread_t;</span></div></pre></div><p>在Cosmos中，我们就使用thread_t结构的一个实例变量代表一个进程。进程的内核栈和进程的应用程序栈是两块内存空间，进程的权限表示一个进程是用户进程还是系统进程。进程的权限不同，它们能完成功能也不同。</p><p>万事都有轻重缓急，进程也一样，进程有64个优先级，td_priority数值越小优先级越高。td_handtbl只是一个objnode_t结构的指针类型数组。</p><p>比方说，一个进程打开一个文件内核就会创建一个对应的objnode_t结构的实例变量，这个objnode_t结构的地址就保存在td_handtbl数组中。你可以这么理解：这个objnode_t结构就是进程打开资源的描述符。</p><h3 id="进程的地址空间"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#进程的地址空间"><span class="icon icon-link"></span></a>进程的地址空间</h3><p>在thread_t结构中有个mmadrsdsc_t结构的指针，在这个结构中有虚拟地址区间结构和MMU相关的信息。mmadrsdsc_t结构你应该很熟悉，在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/387258">虚拟内存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>那节课中，我们学习过，今天我们再次复习一下，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_MMADRSDSC</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t msd_lock;               //保护自身的自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t msd_list;                 //链表</span></div><div class="token-line"><span class="token plain">        uint_t msd_flag;                   //状态和标志</span></div><div class="token-line"><span class="token plain">        uint_t msd_stus;</span></div><div class="token-line"><span class="token plain">        uint_t msd_scount;                 //计数，该结构可能被共享</span></div><div class="token-line"><span class="token plain">        sem_t  msd_sem;                    //信号量</span></div><div class="token-line"><span class="token plain">        mmudsc_t msd_mmu;                  //MMU页表相关的信息</span></div><div class="token-line"><span class="token plain">        virmemadrs_t msd_virmemadrs;       //虚拟地址空间结构</span></div><div class="token-line"><span class="token plain">        adr_t msd_stext;                   //应用的指令区的开始、结束地址</span></div><div class="token-line"><span class="token plain">        adr_t msd_etext;</span></div><div class="token-line"><span class="token plain">        adr_t msd_sdata;                   //应用的数据区的开始、结束地址</span></div><div class="token-line"><span class="token plain">        adr_t msd_edata;</span></div><div class="token-line"><span class="token plain">        adr_t msd_sbss;                    //应用初始化为0的区域开始、结束地址</span></div><div class="token-line"><span class="token plain">        adr_t msd_ebss;</span></div><div class="token-line"><span class="token plain">        adr_t msd_sbrk;                    //应用的堆区的开始、结束地址</span></div><div class="token-line"><span class="token plain">        adr_t msd_ebrk;</span></div><div class="token-line"><span class="token plain">    }mmadrsdsc_t;</span></div></pre></div><p>上述代码中，注释已经很清楚了，mmadrsdsc_t结构描述了一个进程的完整的地址空间。需要搞清楚的是：在常规情况下，新建一个进程就要建立一个mmadrsdsc_t结构，让thread_t结构的td_mmdsc的指针变量指向它。</p><h3 id="进程的机器上下文"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#进程的机器上下文"><span class="icon icon-link"></span></a>进程的机器上下文</h3><p>进程的机器上下文分为几个部分，一部分是CPU寄存器，一部分是内核函数调用路径。CPU的通用寄存器，是中断发生进入内核时，压入内核栈中的，从中断入口处开始调用的函数，都是属于内核的函数。</p><p>函数的调用路径就在内核栈中，整个过程是这样的：进程调度器函数会调用进程切换函数，完成切换进程这个操作，而**在进程切换函数中会保存栈寄存器的值。**好，下面我们来设计这样一个结构来保存这些信息。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_CONTEXT</span></div><div class="token-line"><span class="token plain">    {  </span></div><div class="token-line"><span class="token plain">        uint_t       ctx_nextrip; //保存下一次运行的地址</span></div><div class="token-line"><span class="token plain">        uint_t       ctx_nextrsp; //保存下一次运行时内核栈的地址 </span></div><div class="token-line"><span class="token plain">        x64tss_t*    ctx_nexttss; //指向tss结构</span></div><div class="token-line"><span class="token plain">    }context_t;</span></div></pre></div><p>context_t结构中的字段不多，我们相对陌生的就是x64tss_t结构的指针，这个结构是CPU要求的一个结构，这个结构它本身的地址放在一个GDT表项中，由CPU的tr寄存器指向，tr寄存器中的值是GDT中x64tss_t结构项对应的索引。x64tss_t结构的代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// cosmos/hal/x86/halglobal.c</span></div><div class="token-line"><span class="token plain">    // 每个CPU核心一个tss </span></div><div class="token-line"><span class="token plain">    HAL_DEFGLOB_VARIABLE(x64tss_t,x64tss)[CPUCORE_MAX]; </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    typedef struct s_X64TSS</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        u32_t reserv0; //保留</span></div><div class="token-line"><span class="token plain">        u64_t rsp0;  //R0特权级的栈地址</span></div><div class="token-line"><span class="token plain">        u64_t rsp1;  //R1特权级的栈地址，我们未使用</span></div><div class="token-line"><span class="token plain">        u64_t rsp2;  //R2特权级的栈地址，我们未使用</span></div><div class="token-line"><span class="token plain">        u64_t reserv28;//保留</span></div><div class="token-line"><span class="token plain">        u64_t ist[7];  //我们未使用</span></div><div class="token-line"><span class="token plain">        u64_t reserv92;//保留</span></div><div class="token-line"><span class="token plain">        u16_t reserv100;//保留</span></div><div class="token-line"><span class="token plain">        u16_t iobase;   //我们未使用</span></div><div class="token-line"><span class="token plain">    }__attribute__((packed)) x64tss_t;</span></div></pre></div><p>CPU在发生中断时，会根据中断门描述里的目标段选择子，进行必要的特权级切换，特权级的切换就必须要切换栈，CPU硬件会自己把当前rsp寄存器保存到内部的临时寄存器tmprsp；然后从x64tss_t结构体中找出对应的栈地址，装入rsp寄存器中；接着，再把当前的ss、tmprsp、rflags、cs、rip，依次压入当前rsp指向的栈中。</p><h2 id="建立进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#建立进程"><span class="icon icon-link"></span></a>建立进程</h2><p>之前我们已经设计好了进程相关的数据结构，现在我们要讨论如何建立一个新的进程了。建立进程非常简单，就是在内存中建立起对应的数据结构的实例变量。</p><p>但是对进程来说，并不是建立thread_t结构的实例变量就完事了，还要建立进程的应用程序栈和进程的内核栈，进程地址空间等。下面我们一起来实现建立进程的功能。</p><h3 id="建立进程接口"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#建立进程接口"><span class="icon icon-link"></span></a>建立进程接口</h3><p>我们先从建立进程的接口开始写起，先在cosmos/kernel/目录下新建一个文件krlthread.c，在其中写上一个函数。接口函数总是简单的，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlnew_thread(void *filerun, uint_t flg, uint_t prilg, uint_t prity, size_t usrstksz, size_t krlstksz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        size_t tustksz = usrstksz, tkstksz = krlstksz;</span></div><div class="token-line"><span class="token plain">        //对参数进行检查，不合乎要求就返回NULL表示创建失败</span></div><div class="token-line"><span class="token plain">        if (filerun == NULL || usrstksz &gt; DAFT_TDUSRSTKSZ || krlstksz &gt; DAFT_TDKRLSTKSZ)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if ((prilg != PRILG_USR &amp;&amp; prilg != PRILG_SYS) || (prity &gt;= PRITY_MAX))</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //进程应用程序栈大小检查，大于默认大小则使用默认大小</span></div><div class="token-line"><span class="token plain">        if (usrstksz &lt; DAFT_TDUSRSTKSZ)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            tustksz = DAFT_TDUSRSTKSZ;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //进程内核栈大小检查，大于默认大小则使用默认大小</span></div><div class="token-line"><span class="token plain">        if (krlstksz &lt; DAFT_TDKRLSTKSZ)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            tkstksz = DAFT_TDKRLSTKSZ;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //是否建立内核进程</span></div><div class="token-line"><span class="token plain">        if (KERNTHREAD_FLG == flg)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return krlnew_kern_thread_core(filerun, flg, prilg, prity, tustksz, tkstksz);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //是否建立普通进程</span></div><div class="token-line"><span class="token plain">        else if (USERTHREAD_FLG == flg)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return krlnew_user_thread_core(filerun, flg, prilg, prity, tustksz, tkstksz);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中的krlnew_thread函数的流程非常简单，对参数进行合理检查，其参数从左到右分别是应用程序启动运行的地址、创建标志、进程权限和进程优先级、进程的应用程序栈和内核栈大小。</p><p>进程对栈的大小有要求，如果小于默认大小8KB就使用默认的栈大小，最后根据创建标志确认是建立内核态进程还是建立普通进程。</p><h3 id="建立内核进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#建立内核进程"><span class="icon icon-link"></span></a>建立内核进程</h3><p>什么是内核进程？你一定在想，其实内核进程就是<strong>用进程的方式去运行一段内核代码，那么这段代码就可以随时暂停或者继续运行，又或者和其它代码段并发运行，只是这种进程永远不会回到进程应用程序地址空间中去，只会在内核地址空间中运行。</strong></p><p>下面我来写代码实现建立一个内核态进程，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlnew_kern_thread_core(void *filerun, uint_t flg, uint_t prilg, uint_t prity, size_t usrstksz, size_t krlstksz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        thread_t *ret_td = NULL;</span></div><div class="token-line"><span class="token plain">        bool_t acs = FALSE;</span></div><div class="token-line"><span class="token plain">        adr_t krlstkadr = NULL;</span></div><div class="token-line"><span class="token plain">        //分配内核栈空间</span></div><div class="token-line"><span class="token plain">        krlstkadr = krlnew(krlstksz);</span></div><div class="token-line"><span class="token plain">        if (krlstkadr == NULL)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //建立thread_t结构体的实例变量</span></div><div class="token-line"><span class="token plain">        ret_td = krlnew_thread_dsc();</span></div><div class="token-line"><span class="token plain">        if (ret_td == NULL)</span></div><div class="token-line"><span class="token plain">        {//创建失败必须要释放之前的栈空间</span></div><div class="token-line"><span class="token plain">            acs = krldelete(krlstkadr, krlstksz);</span></div><div class="token-line"><span class="token plain">            if (acs == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return NULL;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //设置进程权限 </span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_privilege = prilg;</span></div><div class="token-line"><span class="token plain">        //设置进程优先级</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_priority = prity;</span></div><div class="token-line"><span class="token plain">        //设置进程的内核栈顶和内核栈开始地址</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_krlstktop = krlstkadr + (adr_t)(krlstksz - 1);</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_krlstkstart = krlstkadr;</span></div><div class="token-line"><span class="token plain">        //初始化进程的内核栈</span></div><div class="token-line"><span class="token plain">        krlthread_kernstack_init(ret_td, filerun, KMOD_EFLAGS);</span></div><div class="token-line"><span class="token plain">        //加入进程调度系统</span></div><div class="token-line"><span class="token plain">        krlschdclass_add_thread(ret_td);</span></div><div class="token-line"><span class="token plain">        //返回进程指针</span></div><div class="token-line"><span class="token plain">        return ret_td;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码的逻辑非常简单，首先分配一个内核栈的内存空间，接着创建thread_t结构的实例变量，然后对thtead_t结构体的字段进行设置，最后，初始化进程内核栈把这个新进程加入到进程的调度系统之中，下面来一步步写入实现这些逻辑的代码。</p><h3 id="创建thread_t结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#创建thread_t结构"><span class="icon icon-link"></span></a>创建thread_t结构</h3><p>创建thread_t结构，其实就是分配一块内存用于存放thread_t结构的实例变量。类似这样的操作我们课程里做过多次，相信现在你已经能驾轻就熟了。下面我们来写代码实现这个操作，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//初始化context_t结构</span></div><div class="token-line"><span class="token plain">    void context_t_init(context_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        initp-&gt;ctx_nextrip = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;ctx_nextrsp = 0;</span></div><div class="token-line"><span class="token plain">        //指向当前CPU的tss</span></div><div class="token-line"><span class="token plain">        initp-&gt;ctx_nexttss = &amp;x64tss[hal_retn_cpuid()];</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //返回进程id其实就thread_t结构的地址</span></div><div class="token-line"><span class="token plain">    uint_t krlretn_thread_id(thread_t *tdp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return (uint_t)tdp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //初始化thread_t结构</span></div><div class="token-line"><span class="token plain">    void thread_t_init(thread_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krlspinlock_init(&amp;initp-&gt;td_lock);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;td_list);</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_flgs = TDFLAG_FREE;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_stus = TDSTUS_NEW;//进程状态为新建</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_cpuid = hal_retn_cpuid();</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_id = krlretn_thread_id(initp);</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_tick = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_privilege = PRILG_USR;//普通进程权限</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_priority = PRITY_MIN;//最高优先级</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_runmode = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_krlstktop = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_krlstkstart = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_usrstktop = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_usrstkstart = NULL;</span></div><div class="token-line"><span class="token plain">        initp-&gt;td_mmdsc = &amp;initmmadrsdsc;//指向默认的地址空间结构</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        context_t_init(&amp;initp-&gt;td_context);</span></div><div class="token-line"><span class="token plain">        //初始化td_handtbl数组</span></div><div class="token-line"><span class="token plain">        for (uint_t hand = 0; hand &lt; TD_HAND_MAX; hand++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            initp-&gt;td_handtbl[hand] = NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //创建thread_t结构</span></div><div class="token-line"><span class="token plain">    thread_t *krlnew_thread_dsc()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //分配thread_t结构大小的内存空间</span></div><div class="token-line"><span class="token plain">        thread_t *rettdp = (thread_t *)(krlnew((size_t)(sizeof(thread_t))));</span></div><div class="token-line"><span class="token plain">        if (rettdp == NULL)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //初始化刚刚分配的thread_t结构</span></div><div class="token-line"><span class="token plain">        thread_t_init(rettdp);</span></div><div class="token-line"><span class="token plain">        return rettdp;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>相信凭你现在的能力，上述代码一定是超级简单的。不过我们依然要注意这样几点。</p><p>首先，我们以thread_t结构的地址作为进程的ID，这个ID具有唯一性；其次，我们目前没有为一个进程分配mmadrsdsc_t结构体，而是指向了默认的地址空间结构initmmadrsdsc；最后，hal_retn_cpuid函数在目前的情况下永远返回0，这是因为我们使用了一个CPU。</p><h3 id="初始化内核栈"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#初始化内核栈"><span class="icon icon-link"></span></a>初始化内核栈</h3><p>为什么要初始化进程的内核栈呢？</p><p>你也许会想，进程的内核栈无非是一块内存，其实只要初始化为0就好。当然不是这么简单，我们初始化进程的内核栈，其实是为了在进程的内核栈中放置一份CPU的寄存器数据。</p><p>这份CPU寄存器数据是一个进程机器上下文的一部分，当一个进程开始运行时，我们将会使用“pop”指令从进程的内核栈中弹出到CPU中，这样CPU就开始运行进程了，CPU的一些寄存器是有位置关系的，所以我们要定义一个结构体来操作它们，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_INTSTKREGS</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t r_gs;</span></div><div class="token-line"><span class="token plain">        uint_t r_fs;</span></div><div class="token-line"><span class="token plain">        uint_t r_es;</span></div><div class="token-line"><span class="token plain">        uint_t r_ds;  //段寄存器</span></div><div class="token-line"><span class="token plain">        uint_t r_r15;</span></div><div class="token-line"><span class="token plain">        uint_t r_r14;</span></div><div class="token-line"><span class="token plain">        uint_t r_r13;</span></div><div class="token-line"><span class="token plain">        uint_t r_r12;</span></div><div class="token-line"><span class="token plain">        uint_t r_r11;</span></div><div class="token-line"><span class="token plain">        uint_t r_r10;</span></div><div class="token-line"><span class="token plain">        uint_t r_r9;</span></div><div class="token-line"><span class="token plain">        uint_t r_r8;</span></div><div class="token-line"><span class="token plain">        uint_t r_rdi;</span></div><div class="token-line"><span class="token plain">        uint_t r_rsi;</span></div><div class="token-line"><span class="token plain">        uint_t r_rbp;</span></div><div class="token-line"><span class="token plain">        uint_t r_rdx; //通用寄存器</span></div><div class="token-line"><span class="token plain">        uint_t r_rcx;</span></div><div class="token-line"><span class="token plain">        uint_t r_rbx;</span></div><div class="token-line"><span class="token plain">        uint_t r_rax;</span></div><div class="token-line"><span class="token plain">        uint_t r_rip_old;//程序的指针寄存器</span></div><div class="token-line"><span class="token plain">        uint_t r_cs_old;//代码段寄存器</span></div><div class="token-line"><span class="token plain">        uint_t r_rflgs; //rflags标志寄存</span></div><div class="token-line"><span class="token plain">        uint_t r_rsp_old;//栈指针寄存器</span></div><div class="token-line"><span class="token plain">        uint_t r_ss_old; //栈段寄存器</span></div><div class="token-line"><span class="token plain">    }intstkregs_t;</span></div></pre></div><p>intstkregs_t结构中，每个字段都是8字节64位的，因为x86 CPU在长模式下rsp栈指针寄存器始终8字节对齐。栈是向下伸长的（从高地址向低地址）所以这个结构是反向定义（相对于栈）如果你不理解这个寄存器位置，可以回到中断处理<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/381810">那节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>复习一下。</p><p>intstkregs_t结构已经定义好了，下面我们来写代码初始化内核栈，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void krlthread_kernstack_init(thread_t *thdp, void *runadr, uint_t cpuflags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //处理栈顶16字节对齐</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_krlstktop &amp;= (~0xf);</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_usrstktop &amp;= (~0xf);</span></div><div class="token-line"><span class="token plain">        //内核栈顶减去intstkregs_t结构的大小</span></div><div class="token-line"><span class="token plain">        intstkregs_t *arp = (intstkregs_t *)(thdp-&gt;td_krlstktop - sizeof(intstkregs_t));</span></div><div class="token-line"><span class="token plain">        //把intstkregs_t结构的空间初始化为0</span></div><div class="token-line"><span class="token plain">        hal_memset((void*)arp, 0, sizeof(intstkregs_t));</span></div><div class="token-line"><span class="token plain">        //rip寄存器的值设为程序运行首地址 </span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rip_old = (uint_t)runadr;</span></div><div class="token-line"><span class="token plain">        //cs寄存器的值设为内核代码段选择子 </span></div><div class="token-line"><span class="token plain">        arp-&gt;r_cs_old = K_CS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rflgs = cpuflags;</span></div><div class="token-line"><span class="token plain">        //返回进程的内核栈</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rsp_old = thdp-&gt;td_krlstktop;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_ss_old = 0;</span></div><div class="token-line"><span class="token plain">        //其它段寄存器的值设为内核数据段选择子</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_ds = K_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_es = K_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_fs = K_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_gs = K_DS_IDX;</span></div><div class="token-line"><span class="token plain">        //设置进程下一次运行的地址为runadr</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_context.ctx_nextrip = (uint_t)runadr;</span></div><div class="token-line"><span class="token plain">        //设置进程下一次运行的栈地址为arp</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_context.ctx_nextrsp = (uint_t)arp;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码没什么难点，就是第7行我要给你解释一下，arp为什么要用内核栈顶地址减去intstkregs_t结构的大小呢？</p><p>C语言处理结构体时，从结构体第一个字段到最后一个字段，这些字段的地址是从下向上（地址从到高）伸长的，而栈正好相反，所以要减去intstkregs_t结构的大小，为intstkregs_t结构腾出空间，如下图所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage06ba06504e64c34ff37794b259ecbd4364ba.jpg" alt="" title="内核态进程结构"/></p><p>因为我们建立的是内核态进程，所以上面初始化的内核栈是不能返回到进程的应用程序空间的。而如果要返回到进程的应用程序空间中，内核栈中的内容是不同的，但是内核栈结构却一样。</p><p>下面我们动手写代码，初始化返回进程应用程序空间的内核栈。请注意，初始化的还是内核栈，只是内容不同，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void krlthread_userstack_init(thread_t *thdp, void *runadr, uint_t cpuflags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //处理栈顶16字节对齐</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_krlstktop &amp;= (~0xf);</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_usrstktop &amp;= (~0xf);</span></div><div class="token-line"><span class="token plain">        //内核栈顶减去intstkregs_t结构的大小</span></div><div class="token-line"><span class="token plain">        intstkregs_t *arp = (intstkregs_t *)(thdp-&gt;td_krlstktop - sizeof(intstkregs_t));</span></div><div class="token-line"><span class="token plain">        //把intstkregs_t结构的空间初始化为0</span></div><div class="token-line"><span class="token plain">        hal_memset((void*)arp, 0, sizeof(intstkregs_t));</span></div><div class="token-line"><span class="token plain">        //rip寄存器的值设为程序运行首地址 </span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rip_old = (uint_t)runadr;</span></div><div class="token-line"><span class="token plain">        //cs寄存器的值设为应用程序代码段选择子 </span></div><div class="token-line"><span class="token plain">        arp-&gt;r_cs_old = U_CS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rflgs = cpuflags;</span></div><div class="token-line"><span class="token plain">        //返回进程应用程序空间的栈</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_rsp_old = thdp-&gt;td_usrstktop;</span></div><div class="token-line"><span class="token plain">        //其它段寄存器的值设为应用程序数据段选择子</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_ss_old = U_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_ds = U_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_es = U_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_fs = U_DS_IDX;</span></div><div class="token-line"><span class="token plain">        arp-&gt;r_gs = U_DS_IDX;</span></div><div class="token-line"><span class="token plain">        //设置进程下一次运行的地址为runadr</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_context.ctx_nextrip = (uint_t)runadr;</span></div><div class="token-line"><span class="token plain">        //设置进程下一次运行的栈地址为arp</span></div><div class="token-line"><span class="token plain">        thdp-&gt;td_context.ctx_nextrsp = (uint_t)arp;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中初始化进程的内核栈，所使用的段选择子指向的是应用程序的代码段和数据段，这个代码段和数据段它们特权级为R3，CPU正是根据这个代码段、数据段选择子来切换CPU工作特权级的。这样，CPU的执行流就可以返回到进程的应用程序空间了。</p><h3 id="建立普通进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#建立普通进程"><span class="icon icon-link"></span></a>建立普通进程</h3><p>在建立进程的接口函数krlnew_thread的流程中，会根据参数flg的值，选择调用不同的函数，来建立不同类型的进程。</p><p>前面我们已经写好了建立内核进程的函数，接下来我们还要写好建立普通进程的函数，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlnew_user_thread_core(void *filerun, uint_t flg, uint_t prilg, uint_t prity, size_t usrstksz, size_t krlstksz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        thread_t *ret_td = NULL;</span></div><div class="token-line"><span class="token plain">        bool_t acs = FALSE;</span></div><div class="token-line"><span class="token plain">        adr_t usrstkadr = NULL, krlstkadr = NULL;</span></div><div class="token-line"><span class="token plain">        //分配应用程序栈空间</span></div><div class="token-line"><span class="token plain">        usrstkadr = krlnew(usrstksz);</span></div><div class="token-line"><span class="token plain">        if (usrstkadr == NULL)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //分配内核栈空间</span></div><div class="token-line"><span class="token plain">        krlstkadr = krlnew(krlstksz);</span></div><div class="token-line"><span class="token plain">        if (krlstkadr == NULL)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            if (krldelete(usrstkadr, usrstksz) == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return NULL;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //建立thread_t结构体的实例变量</span></div><div class="token-line"><span class="token plain">        ret_td = krlnew_thread_dsc();</span></div><div class="token-line"><span class="token plain">        //创建失败必须要释放之前的栈空间</span></div><div class="token-line"><span class="token plain">        if (ret_td == NULL)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            acs = krldelete(usrstkadr, usrstksz);</span></div><div class="token-line"><span class="token plain">            acs = krldelete(krlstkadr, krlstksz);</span></div><div class="token-line"><span class="token plain">            if (acs == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return NULL;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //设置进程权限 </span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_privilege = prilg;</span></div><div class="token-line"><span class="token plain">        //设置进程优先级</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_priority = prity;</span></div><div class="token-line"><span class="token plain">        //设置进程的内核栈顶和内核栈开始地址</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_krlstktop = krlstkadr + (adr_t)(krlstksz - 1);</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_krlstkstart = krlstkadr;</span></div><div class="token-line"><span class="token plain">        //设置进程的应用程序栈顶和内核应用程序栈开始地址</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_usrstktop = usrstkadr + (adr_t)(usrstksz - 1);</span></div><div class="token-line"><span class="token plain">        ret_td-&gt;td_usrstkstart = usrstkadr;</span></div><div class="token-line"><span class="token plain">        //初始化返回进程应用程序空间的内核栈</span></div><div class="token-line"><span class="token plain">        krlthread_userstack_init(ret_td, filerun, UMOD_EFLAGS);</span></div><div class="token-line"><span class="token plain">        //加入调度器系统</span></div><div class="token-line"><span class="token plain">        krlschdclass_add_thread(ret_td);</span></div><div class="token-line"><span class="token plain">        return ret_td;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>和建立内核进程相比，建立普通进程有两点不同。第一，<strong>多分配了一个应用程序栈</strong>。因为内核进程不会返回到进程的应用程序空间，所以不需要应用程序栈，而普通进程则需要；第二，在最后调用的是<strong>krlthread_userstack_init函数</strong>，该函数初始化返回进程应用程序空间的内核栈，这在前面已经介绍过了。</p><p>到此为止，我们建立进程的功能已经实现了。但是最后将进程加入到调度系统的函数，我们还没有写，这个函数是进程调度器模块的函数，我们下节课再讨论。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>这节课我们用最简洁的方式了解了进程以及如何建立一个进程，我来为你梳理一下今天的课程重点。</p><p>首先，我们在Linux系统上，用ps命令列出Linux系统上所有的进程，直观的感受了一下什么进程，从理论上了解了一下进程的结构。</p><p>然后我们把进程相关的信息，做了归纳整理，设计出一系列相应的数据结构，这其中包含了表示进程的数据结构，与进程相关内存地址空间结构，还有进程的机器上下文数据结构。这些数据结构综合起来就表示了进程。</p><p>最后进入建立进程的环节。有了进程相关的数据结构就可以写代码建立一个进程了，我们的建立进程的接口函数，既能建立普通进程又能建立内核进程，而建立进程的过程无非是创建进程结构体、分配进程的内核栈与应用程序栈，并对进程的内核栈进行初始化，最后将进程加入调度系统，以便后面将进程投入运行。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage33fe330a5c9553e4ce72bf4501bbae3ab9fe.jpg" alt="" title="进程建立流程图"/></p><p>很多理论书籍总是在开头就花大量篇幅讲进程，但你却很难搞懂，这是为什么呢？第一，他们在用抽象方法讲解抽象概念，对初学者很不友好；第二，讲解顺序不对，想搞懂进程，需要前置知识，它是一个高层次的组件。</p><p>相信经过前面章节的学习，你现在理解进程会轻松自如。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/08.活动实体进程/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请问，各个进程是如何共享同一份内核代码和数据的？</p><p>欢迎你在留言区和我交流，相信通过积极参与，你将更好地理解这节课的内容。也欢迎你把这节课分享给你的朋友，说不定可以帮他真正弄懂什么是进程。</p><p>好，我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/08.活动实体进程/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:45:25</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
