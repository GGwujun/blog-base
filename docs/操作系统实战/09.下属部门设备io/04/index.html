<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>31 | 瞧一瞧Linux：如何获取所有设备信息？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/09.下属部门设备io/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="感受一下Linux下的设备信息" data-depth="2"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#感受一下linux下的设备信息"><span>感受一下Linux下的设备信息</span></a></li><li title="数据结构" data-depth="2"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#数据结构"><span>数据结构</span></a></li><li title="kobject与kset" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#kobject与kset"><span>kobject与kset</span></a></li><li title="总线" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#总线"><span>总线</span></a></li><li title="设备" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#设备"><span>设备</span></a></li><li title="驱动" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动"><span>驱动</span></a></li><li title="文件操作函数" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#文件操作函数"><span>文件操作函数</span></a></li><li title="驱动程序实例" data-depth="2"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动程序实例"><span>驱动程序实例</span></a></li><li title="驱动程序框架" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动程序框架"><span>驱动程序框架</span></a></li><li title="建立设备" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#建立设备"><span>建立设备</span></a></li><li title="打开、关闭、读写函数" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#打开关闭读写函数"><span>打开、关闭、读写函数</span></a></li><li title="测试驱动" data-depth="3"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#测试驱动"><span>测试驱动</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/09.下属部门设备io/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="31--瞧一瞧linux如何获取所有设备信息"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#31--瞧一瞧linux如何获取所有设备信息"><span class="icon icon-link"></span></a>31 | 瞧一瞧Linux：如何获取所有设备信息？</h1><p>你好，我是LMOS。</p><p>前面我们已经完成了Cosmos的驱动设备的建立，还写好了一个真实的设备驱动。</p><p>今天，我们就来看看Linux是如何管理设备的。我们将从Linux如何组织设备开始，然后研究设备驱动相关的数据结构，最后我们还是要一起写一个Linux设备驱动实例，这样才能真正理解它。</p><h2 id="感受一下linux下的设备信息"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#感受一下linux下的设备信息"><span class="icon icon-link"></span></a>感受一下Linux下的设备信息</h2><p>Linux的设计哲学就是一切皆文件，各种设备在Linux系统下自然也是一个个文件。不过这个文件并不对应磁盘上的数据文件，而是对应着存在内存当中的设备文件。实际上，我们对设备文件进行操作，就等同于操作具体的设备。</p><p>既然我们了解万事万物，都是从最直观的感受开始的，想要理解Linux对设备的管理，自然也是同样的道理。那么Linux设备文件在哪个目录下呢？其实现在我们在/sys/bus目录下，就可以查看所有的设备了。</p><p>Linux用BUS（总线）组织设备和驱动，我们在/sys/bus目录下输入tree命令，就可以看到所有总线下的所有设备了，如下图所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage5628567588d1ca461ed56c4cd3447d9dff28.jpg" alt="" title="Linux设备文件"/></p><p>上图中，显示了部分Linux设备文件，有些设备文件是链接到其它目录下文件，这不是重点，重点是你要在心中有这个目录层次结构，即<strong>总线目录下有设备目录，设备目录下是设备文件</strong>。</p><h2 id="数据结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#数据结构"><span class="icon icon-link"></span></a>数据结构</h2><p>我们接着刚才的图往下说，我们能感觉到Linux的驱动模型至少有三个核心数据结构，分别是总线、设备和驱动，但是要像上图那样有层次化地组织它们，只有总线、设备、驱动这三个数据结构是不够的，还得有两个数据结构来组织它们，那就是kobject和kset，下面我们就去研究它们。</p><h3 id="kobject与kset"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#kobject与kset"><span class="icon icon-link"></span></a>kobject与kset</h3><p>kobject和kset是构成/sys目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，kobject、kset数据结构都能表示一个目录或者文件节点。下面我们先来研究一下kobject数据结构，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct kobject {</span></div><div class="token-line"><span class="token plain">        const char      *name;           //名称，反映在sysfs中</span></div><div class="token-line"><span class="token plain">        struct list_head    entry;       //挂入kset结构的链表</span></div><div class="token-line"><span class="token plain">        struct kobject      *parent;     //指向父结构 </span></div><div class="token-line"><span class="token plain">        struct kset     *kset;           //指向所属的kset</span></div><div class="token-line"><span class="token plain">        struct kobj_type    *ktype;</span></div><div class="token-line"><span class="token plain">        struct kernfs_node  *sd;         //指向sysfs文件系统目录项 </span></div><div class="token-line"><span class="token plain">        struct kref     kref;            //引用计数器结构</span></div><div class="token-line"><span class="token plain">        unsigned int state_initialized:1;//初始化状态</span></div><div class="token-line"><span class="token plain">        unsigned int state_in_sysfs:1;   //是否在sysfs中</span></div><div class="token-line"><span class="token plain">        unsigned int state_add_uevent_sent:1;</span></div><div class="token-line"><span class="token plain">        unsigned int state_remove_uevent_sent:1;</span></div><div class="token-line"><span class="token plain">        unsigned int uevent_suppress:1;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>每一个 kobject，都对应着 /sys目录下（其实是sysfs文件系统挂载在/sys目录下） 的一个目录或者文件，目录或者文件的名字就是kobject结构中的name。</p><p>我们从kobject结构中可以看出，它挂载在kset下，并且指向了kset，那kset是什么呢？我们来分析分析，它是kobject结构的容器吗？</p><p>其实是也不是，因为kset结构中本身又包含一个kobject结构，所以它既是kobject的容器，同时本身还是一个kobject。kset结构代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct kset {</span></div><div class="token-line"><span class="token plain">        struct list_head list; //挂载kobject结构的链表</span></div><div class="token-line"><span class="token plain">        spinlock_t list_lock; //自旋锁</span></div><div class="token-line"><span class="token plain">        struct kobject kobj;//自身包含一个kobject结构</span></div><div class="token-line"><span class="token plain">        const struct kset_uevent_ops *uevent_ops;//暂时不关注</span></div><div class="token-line"><span class="token plain">    } __randomize_layout;</span></div></pre></div><p>看到这里你应该知道了，kset不仅仅自己是个kobject，还能挂载多个kobject，这说明kset是kobject的集合容器。在Linux内核中，至少有两个顶层kset，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct kset *devices_kset;//管理所有设备</span></div><div class="token-line"><span class="token plain">    static struct kset *bus_kset;//管理所有总线</span></div><div class="token-line"><span class="token plain">    static struct kset *system_kset;</span></div><div class="token-line"><span class="token plain">    int __init devices_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        devices_kset = kset_create_and_add(&quot;devices&quot;, &amp;device_uevent_ops, NULL);//建立设备kset</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    int __init buses_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        bus_kset = kset_create_and_add(&quot;bus&quot;, &amp;bus_uevent_ops, NULL);//建立总线kset</span></div><div class="token-line"><span class="token plain">        if (!bus_kset)</span></div><div class="token-line"><span class="token plain">            return -ENOMEM;</span></div><div class="token-line"><span class="token plain">        system_kset = kset_create_and_add(&quot;system&quot;, NULL, &amp;devices_kset-&gt;kobj);//在设备kset之下建立system的kset</span></div><div class="token-line"><span class="token plain">        if (!system_kset)</span></div><div class="token-line"><span class="token plain">            return -ENOMEM;</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我知道，你可能很难想象许多个kset和kobject在逻辑上形成的层次结构，所以我为你画了一幅图，你可以结合这张示意图理解这个结构。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebcdabcd9216d04b1f2ec6yy67ddf18052fda.jpg" alt="" title="kset与kobject"/></p><p>上图中展示了一个类似文件目录的结构，这正是kset与kobject设计的目标之一。kset与kobject结构只是基础数据结构，但是仅仅只有它的话，也就只能实现这个层次结构，其它的什么也不能干，根据我们以往的经验可以猜出，kset与kobject结构肯定是嵌入到更高级的数据结构之中使用，下面我们继续探索。</p><h3 id="总线"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#总线"><span class="icon icon-link"></span></a>总线</h3><p>kset、kobject结构只是开胃菜，这个基础了解了，我们还要回到研究Linux设备与驱动的正题上。我们之前说过了，Linux用总线组织设备和驱动，由此可见总线是Linux设备的基础，它可以表示CPU与设备的连接，那么总线的数据结构是什么样呢？我们一起来看看。</p><p>Linux把总线抽象成bus_type结构，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct bus_type {</span></div><div class="token-line"><span class="token plain">        const char      *name;//总线名称</span></div><div class="token-line"><span class="token plain">        const char      *dev_name;//用于列举设备，如（&quot;foo%u&quot;, dev-&gt;id）</span></div><div class="token-line"><span class="token plain">        struct device       *dev_root;//父设备</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **bus_groups;//总线的默认属性</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **dev_groups;//总线上设备的默认属性</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **drv_groups;//总线上驱动的默认属性</span></div><div class="token-line"><span class="token plain">        //每当有新的设备或驱动程序被添加到这个总线上时调用</span></div><div class="token-line"><span class="token plain">        int (*match)(struct device *dev, struct device_driver *drv);</span></div><div class="token-line"><span class="token plain">        //当一个设备被添加、移除或其他一些事情时被调用产生uevent来添加环境变量。</span></div><div class="token-line"><span class="token plain">        int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span></div><div class="token-line"><span class="token plain">        //当一个新的设备或驱动程序添加到这个总线时被调用，并回调特定驱动程序探查函数，以初始化匹配的设备</span></div><div class="token-line"><span class="token plain">        int (*probe)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //将设备状态同步到软件状态时调用</span></div><div class="token-line"><span class="token plain">        void (*sync_state)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //当一个设备从这个总线上删除时被调用</span></div><div class="token-line"><span class="token plain">        int (*remove)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //当系统关闭时被调用</span></div><div class="token-line"><span class="token plain">        void (*shutdown)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //调用以使设备重新上线（在下线后）</span></div><div class="token-line"><span class="token plain">        int (*online)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //调用以使设备离线，以便热移除。可能会失败。</span></div><div class="token-line"><span class="token plain">        int (*offline)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //当这个总线上的设备想进入睡眠模式时调用</span></div><div class="token-line"><span class="token plain">        int (*suspend)(struct device *dev, pm_message_t state);</span></div><div class="token-line"><span class="token plain">        //调用以使该总线上的一个设备脱离睡眠模式</span></div><div class="token-line"><span class="token plain">        int (*resume)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //调用以找出该总线上的一个设备支持多少个虚拟设备功能</span></div><div class="token-line"><span class="token plain">        int (*num_vf)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //调用以在该总线上的设备配置DMA</span></div><div class="token-line"><span class="token plain">        int (*dma_configure)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //该总线的电源管理操作，回调特定的设备驱动的pm-ops</span></div><div class="token-line"><span class="token plain">        const struct dev_pm_ops *pm;</span></div><div class="token-line"><span class="token plain">        //此总线的IOMMU具体操作，用于将IOMMU驱动程序实现到总线上</span></div><div class="token-line"><span class="token plain">        const struct iommu_ops *iommu_ops;</span></div><div class="token-line"><span class="token plain">        //驱动核心的私有数据，只有驱动核心能够接触这个</span></div><div class="token-line"><span class="token plain">        struct subsys_private *p;</span></div><div class="token-line"><span class="token plain">        struct lock_class_key lock_key;</span></div><div class="token-line"><span class="token plain">        //当探测或移除该总线上的一个设备时，设备驱动核心应该锁定该设备</span></div><div class="token-line"><span class="token plain">        bool need_parent_lock;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>可以看出，上面代码的bus_type结构中，包括总线名字、总线属性，还有操作该总线下所有设备通用操作函数的指针，其各个函数的功能我在代码注释中已经写清楚了。</p><p>从这一点可以发现，**总线不仅仅是组织设备和驱动的容器，还是同类设备的共有功能的抽象层。**下面我们来看看subsys_private，它是总线的驱动核心的私有数据，其中有我们想知道的秘密，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//通过kobject找到对应的subsys_private</span></div><div class="token-line"><span class="token plain">    #define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)</span></div><div class="token-line"><span class="token plain">    struct subsys_private {</span></div><div class="token-line"><span class="token plain">        struct kset subsys;//定义这个子系统结构的kset</span></div><div class="token-line"><span class="token plain">        struct kset *devices_kset;//该总线的&quot;设备&quot;目录，包含所有的设备</span></div><div class="token-line"><span class="token plain">        struct list_head interfaces;//总线相关接口的列表</span></div><div class="token-line"><span class="token plain">        struct mutex mutex;//保护设备，和接口列表</span></div><div class="token-line"><span class="token plain">        struct kset *drivers_kset;//该总线的&quot;驱动&quot;目录，包含所有的驱动</span></div><div class="token-line"><span class="token plain">        struct klist klist_devices;//挂载总线上所有设备的可迭代链表</span></div><div class="token-line"><span class="token plain">        struct klist klist_drivers;//挂载总线上所有驱动的可迭代链表</span></div><div class="token-line"><span class="token plain">        struct blocking_notifier_head bus_notifier;</span></div><div class="token-line"><span class="token plain">        unsigned int drivers_autoprobe:1;</span></div><div class="token-line"><span class="token plain">        struct bus_type *bus;   //指向所属总线</span></div><div class="token-line"><span class="token plain">        struct kset glue_dirs;</span></div><div class="token-line"><span class="token plain">        struct class *class;//指向这个结构所关联类结构的指针</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>看到这里，你应该明白kset的作用了，我们通过bus_kset可以找到所有的kset，通过kset又能找到subsys_private，再通过subsys_private就可以找到总线了，也可以找到该总线上所有的设备与驱动。</p><h3 id="设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#设备"><span class="icon icon-link"></span></a>设备</h3><p>虽然Linux抽象出了总线结构，但是Linux还需要表示一个设备，下面我们来探索Linux是如何表示一个设备的。</p><p>其实，在Linux系统中设备也是一个数据结构，里面包含了一个设备的所有信息。代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct device {</span></div><div class="token-line"><span class="token plain">        struct kobject kobj;</span></div><div class="token-line"><span class="token plain">        struct device       *parent;//指向父设备</span></div><div class="token-line"><span class="token plain">        struct device_private   *p;//设备的私有数据</span></div><div class="token-line"><span class="token plain">        const char      *init_name; //设备初始化名字</span></div><div class="token-line"><span class="token plain">        const struct device_type *type;//设备类型</span></div><div class="token-line"><span class="token plain">        struct bus_type *bus;  //指向设备所属总线</span></div><div class="token-line"><span class="token plain">        struct device_driver *driver;//指向设备的驱动</span></div><div class="token-line"><span class="token plain">        void        *platform_data;//设备平台数据</span></div><div class="token-line"><span class="token plain">        void        *driver_data;//设备驱动的私有数据</span></div><div class="token-line"><span class="token plain">        struct dev_links_info   links;//设备供应商链接</span></div><div class="token-line"><span class="token plain">        struct dev_pm_info  power;//用于设备的电源管理</span></div><div class="token-line"><span class="token plain">        struct dev_pm_domain    *pm_domain;//提供在系统暂停时执行调用</span></div><div class="token-line"><span class="token plain">    #ifdef CONFIG_GENERIC_MSI_IRQ</span></div><div class="token-line"><span class="token plain">        struct list_head    msi_list;//主机的MSI描述符链表</span></div><div class="token-line"><span class="token plain">    #endif</span></div><div class="token-line"><span class="token plain">        struct dev_archdata archdata;</span></div><div class="token-line"><span class="token plain">        struct device_node  *of_node; //用访问设备树节点</span></div><div class="token-line"><span class="token plain">        struct fwnode_handle    *fwnode; //设备固件节点</span></div><div class="token-line"><span class="token plain">        dev_t           devt;   //用于创建sysfs &quot;dev&quot;</span></div><div class="token-line"><span class="token plain">        u32         id; //设备实例id</span></div><div class="token-line"><span class="token plain">        spinlock_t      devres_lock;//设备资源链表锁</span></div><div class="token-line"><span class="token plain">        struct list_head    devres_head;//设备资源链表</span></div><div class="token-line"><span class="token plain">        struct class        *class;//设备的类</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **groups;  //可选的属性组</span></div><div class="token-line"><span class="token plain">        void    (*release)(struct device *dev);//在所有引用结束后释放设备</span></div><div class="token-line"><span class="token plain">        struct iommu_group  *iommu_group;//该设备属于的IOMMU组</span></div><div class="token-line"><span class="token plain">        struct dev_iommu    *iommu;//每个设备的通用IOMMU运行时数据</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>device结构很大，这里删除了我们不需要关心的内容。另外，我们看到device结构中同样包含了kobject结构，这使得设备可以加入kset和kobject组建的层次结构中。device结构中有总线和驱动指针，这能帮助设备找到自己的驱动程序和总线。</p><h3 id="驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动"><span class="icon icon-link"></span></a>驱动</h3><p>有了设备结构，还需要有设备对应的驱动，Linux是如何表示一个驱动的呢？同样也是一个数据结构，其中包含了驱动程序的相关信息。其实在device结构中我们就看到了，就是device_driver结构，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct device_driver {</span></div><div class="token-line"><span class="token plain">        const char      *name;//驱动名称</span></div><div class="token-line"><span class="token plain">        struct bus_type     *bus;//指向总线</span></div><div class="token-line"><span class="token plain">        struct module       *owner;//模块持有者</span></div><div class="token-line"><span class="token plain">        const char      *mod_name;//用于内置模块</span></div><div class="token-line"><span class="token plain">        bool suppress_bind_attrs;//禁用通过sysfs的绑定/解绑</span></div><div class="token-line"><span class="token plain">        enum probe_type probe_type;//要使用的探查类型（同步或异步）</span></div><div class="token-line"><span class="token plain">        const struct of_device_id   *of_match_table;//开放固件表</span></div><div class="token-line"><span class="token plain">        const struct acpi_device_id *acpi_match_table;//ACPI匹配表</span></div><div class="token-line"><span class="token plain">        //被调用来查询一个特定设备的存在</span></div><div class="token-line"><span class="token plain">        int (*probe) (struct device *dev);</span></div><div class="token-line"><span class="token plain">        //将设备状态同步到软件状态时调用</span></div><div class="token-line"><span class="token plain">        void (*sync_state)(struct device *dev);</span></div><div class="token-line"><span class="token plain">        //当设备被从系统中移除时被调用，以便解除设备与该驱动的绑定</span></div><div class="token-line"><span class="token plain">        int (*remove) (struct device *dev);</span></div><div class="token-line"><span class="token plain">        //关机时调用，使设备停止</span></div><div class="token-line"><span class="token plain">        void (*shutdown) (struct device *dev);</span></div><div class="token-line"><span class="token plain">        //调用以使设备进入睡眠模式，通常是进入一个低功率状态</span></div><div class="token-line"><span class="token plain">        int (*suspend) (struct device *dev, pm_message_t state);</span></div><div class="token-line"><span class="token plain">        //调用以使设备从睡眠模式中恢复</span></div><div class="token-line"><span class="token plain">        int (*resume) (struct device *dev);</span></div><div class="token-line"><span class="token plain">        //默认属性</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **groups;</span></div><div class="token-line"><span class="token plain">        //绑定设备的属性</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **dev_groups;</span></div><div class="token-line"><span class="token plain">        //设备电源操作</span></div><div class="token-line"><span class="token plain">        const struct dev_pm_ops *pm;</span></div><div class="token-line"><span class="token plain">        //当sysfs目录被写入时被调用</span></div><div class="token-line"><span class="token plain">        void (*coredump) (struct device *dev);</span></div><div class="token-line"><span class="token plain">        //驱动程序私有数据</span></div><div class="token-line"><span class="token plain">        struct driver_private *p;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    struct driver_private {</span></div><div class="token-line"><span class="token plain">        struct kobject kobj;</span></div><div class="token-line"><span class="token plain">        struct klist klist_devices;//驱动管理的所有设备的链表</span></div><div class="token-line"><span class="token plain">        struct klist_node knode_bus;//加入bus链表的节点</span></div><div class="token-line"><span class="token plain">        struct module_kobject *mkobj;//指向用kobject管理模块节点</span></div><div class="token-line"><span class="token plain">        struct device_driver *driver;//指向驱动本身</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在device_driver结构中，包含了驱动程序的名字、驱动程序所在模块、设备探查和电源相关的回调函数的指针。在driver_private结构中同样包含了kobject结构，用于组织所有的驱动，还指向了驱动本身，你发现没有，bus_type中的subsys_private结构的机制如出一辙。</p><h3 id="文件操作函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#文件操作函数"><span class="icon icon-link"></span></a>文件操作函数</h3><p>前面我们学习的都是Linux驱动程序的核心数据结构，我们很少用到，只是为了让你了解最基础的原理。</p><p>其实，在Linux系统中提供了更为高级的封装，Linux将设备分成几类分别是：字符设备、块设备、网络设备以及杂项设备。具体情况你可以参考我后面梳理的图表。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea479a4104a41c67d94f6c9a7de94a05c6a79.jpg" alt="" title="设备类型一览表"/></p><p>这些类型的设备的数据结构，都会直接或者间接包含基础的device结构，我们以杂项设备为例子研究一下，Linux用miscdevice结构表示一个杂项设备，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct miscdevice  {</span></div><div class="token-line"><span class="token plain">        int minor;//设备号</span></div><div class="token-line"><span class="token plain">        const char *name;//设备名称</span></div><div class="token-line"><span class="token plain">        const struct file_operations *fops;//文件操作函数结构</span></div><div class="token-line"><span class="token plain">        struct list_head list;//链表</span></div><div class="token-line"><span class="token plain">        struct device *parent;//指向父设备的device结构</span></div><div class="token-line"><span class="token plain">        struct device *this_device;//指向本设备的device结构</span></div><div class="token-line"><span class="token plain">        const struct attribute_group **groups;</span></div><div class="token-line"><span class="token plain">        const char *nodename;//节点名字</span></div><div class="token-line"><span class="token plain">        umode_t mode;//访问权限</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>miscdevice结构就是一个杂项设备，它一般在驱动程序代码文件中静态定义。我们清楚地看见有个this_device指针，它指向下层的、属于这个杂项设备的device结构。</p><p>但是这里重点是<strong>file_operations结构</strong>，设备一经注册，就会在sys相关的目录下建立设备对应的文件结点，对这个文件结点打开、读写等操作，最终会调用到驱动程序对应的函数，而对应的函数指针就保存在file_operations结构中，我们现在来看看这个结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct file_operations {</span></div><div class="token-line"><span class="token plain">        struct module *owner;//所在的模块</span></div><div class="token-line"><span class="token plain">        loff_t (*llseek) (struct file *, loff_t, int);//调整读写偏移</span></div><div class="token-line"><span class="token plain">        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//读</span></div><div class="token-line"><span class="token plain">        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//写</span></div><div class="token-line"><span class="token plain">        int (*mmap) (struct file *, struct vm_area_struct *);//映射</span></div><div class="token-line"><span class="token plain">        int (*open) (struct inode *, struct file *);//打开</span></div><div class="token-line"><span class="token plain">        int (*flush) (struct file *, fl_owner_t id);//刷新</span></div><div class="token-line"><span class="token plain">        int (*release) (struct inode *, struct file *);//关闭</span></div><div class="token-line"><span class="token plain">    } __randomize_layout;</span></div></pre></div><p>file_operations结构中的函数指针有31个，我删除了我们不熟悉的函数指针，我们了解原理，不需要搞清楚所有函数指针的功能。</p><p>那么，Linux如何调用到这个file_operations结构中的函数呢？我以打开操作为例给你讲讲，Linux的打开系统调用接口会调用filp_open函数，filp_open函数的调用路径如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//filp_open</span></div><div class="token-line"><span class="token plain">    //file_open_name</span></div><div class="token-line"><span class="token plain">    //do_filp_open</span></div><div class="token-line"><span class="token plain">    //path_openat</span></div><div class="token-line"><span class="token plain">    static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct path path;</span></div><div class="token-line"><span class="token plain">        int error = path_lookupat(nd, flags, &amp;path);//解析文件路径得到文件inode节点</span></div><div class="token-line"><span class="token plain">        if (!error) {</span></div><div class="token-line"><span class="token plain">            audit_inode(nd-&gt;name, path.dentry, 0);</span></div><div class="token-line"><span class="token plain">            error = vfs_open(&amp;path, file);//vfs层打开文件接口</span></div><div class="token-line"><span class="token plain">            path_put(&amp;path);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return error;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    int vfs_open(const struct path *path, struct file *file)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        file-&gt;f_path = *path;</span></div><div class="token-line"><span class="token plain">        return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static int do_dentry_open(struct file *f, struct inode *inode,int (*open)(struct inode *, struct file *))</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //略过我们不想看的代码</span></div><div class="token-line"><span class="token plain">        f-&gt;f_op = fops_get(inode-&gt;i_fop);//获取文件节点的file_operations</span></div><div class="token-line"><span class="token plain">        if (!open)//如果open为空则调用file_operations结构中的open函数</span></div><div class="token-line"><span class="token plain">            open = f-&gt;f_op-&gt;open;</span></div><div class="token-line"><span class="token plain">        if (open) {</span></div><div class="token-line"><span class="token plain">            error = open(inode, f);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //略过我们不想看的代码</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这里，我们就知道了，file_operations结构的地址存在一个文件的inode结构中。在Linux系统中，都是用inode结构表示一个文件，不管它是数据文件还是设备文件。</p><p>到这里，我们已经清楚了文件操作函数以及它的调用流程。</p><h2 id="驱动程序实例"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动程序实例"><span class="icon icon-link"></span></a>驱动程序实例</h2><p>我们想要真正理解Linux设备驱动，最好的方案就是写一个真实的驱动程序实例。下面我们一起应用前面的基础，结合Linux提供的驱动程序开发接口，一起实现一个真实驱动程序。</p><p>这个驱动程序的主要工作，就是获取所有总线和其下所有设备的名字。为此我们需要先了解驱动程序的整体框架，接着建立我们总线和设备，然后实现驱动程序的打开、关闭，读写操作函数，最后我们写个应用程序，来测试我们的驱动程序。</p><h3 id="驱动程序框架"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#驱动程序框架"><span class="icon icon-link"></span></a>驱动程序框架</h3><p>Linux内核的驱动程序是在一个可加载的内核模块中实现，可加载的内核模块只需要两个函数和模块信息就行，但是我们要在模块中实现总线和设备驱动，所以需要更多的函数和数据结构，它们的代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define DEV_NAME  &quot;devicesinfo&quot;</span></div><div class="token-line"><span class="token plain">    #define BUS_DEV_NAME  &quot;devicesinfobus&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int misc_find_match(struct device *dev, void *data)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;device name is:%s\n&quot;, dev-&gt;kobj.name);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //对应于设备文件的读操作函数</span></div><div class="token-line"><span class="token plain">    static ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //对应于设备文件的写操作函数</span></div><div class="token-line"><span class="token plain">    static ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);    </span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //对应于设备文件的打开操作函数</span></div><div class="token-line"><span class="token plain">    static int  misc_open(struct inode *pinode, struct file *pfile)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    } </span></div><div class="token-line"><span class="token plain">    //对应于设备文件的关闭操作函数</span></div><div class="token-line"><span class="token plain">    static int misc_release(struct inode *pinode, struct file *pfile)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static int devicesinfo_bus_match(struct device *dev, struct device_driver *driver)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">            return !strncmp(dev-&gt;kobj.name, driver-&gt;name, strlen(driver-&gt;name));</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //对应于设备文件的操作函数结构</span></div><div class="token-line"><span class="token plain">    static const  struct file_operations misc_fops = {</span></div><div class="token-line"><span class="token plain">        .read     = misc_read,</span></div><div class="token-line"><span class="token plain">        .write    = misc_write,</span></div><div class="token-line"><span class="token plain">        .release  = misc_release,</span></div><div class="token-line"><span class="token plain">        .open     = misc_open,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //misc设备的结构</span></div><div class="token-line"><span class="token plain">    static struct miscdevice  misc_dev =  {</span></div><div class="token-line"><span class="token plain">        .fops  =  &amp;misc_fops,         //设备文件操作方法</span></div><div class="token-line"><span class="token plain">        .minor =  255,                //次设备号</span></div><div class="token-line"><span class="token plain">        .name  =  DEV_NAME,           //设备名/dev/下的设备节点名</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //总线结构</span></div><div class="token-line"><span class="token plain">    struct bus_type devicesinfo_bus = {</span></div><div class="token-line"><span class="token plain">            .name = BUS_DEV_NAME, //总线名字</span></div><div class="token-line"><span class="token plain">            .match = devicesinfo_bus_match, //总线match函数指针</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    //内核模块入口函数</span></div><div class="token-line"><span class="token plain">    static int __init miscdrv_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;INIT misc\n&quot;)；</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //内核模块退出函数</span></div><div class="token-line"><span class="token plain">    static void  __exit miscdrv_exit(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;EXIT,misc\n&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    module_init(miscdrv_init);//申明内核模块入口函数</span></div><div class="token-line"><span class="token plain">    module_exit(miscdrv_exit);//申明内核模块退出函数</span></div><div class="token-line"><span class="token plain">    MODULE_LICENSE(&quot;GPL&quot;);//模块许可</span></div><div class="token-line"><span class="token plain">    MODULE_AUTHOR(&quot;LMOS&quot;);//模块开发者</span></div></pre></div><p>一个最简单的驱动程序框架的内核模块就写好了，该有的函数和数据结构都有了，那些数据结构都是静态定义的，它们的内部字段我们在前面也已经了解了。这个模块一旦加载就会执行miscdrv_init函数，卸载时就会执行miscdrv_exit函数。</p><h3 id="建立设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#建立设备"><span class="icon icon-link"></span></a>建立设备</h3><p>Linux系统也提供了很多专用接口函数，用来建立总线和设备。下面我们先来建立一个总线，然后在总线下建立一个设备。</p><p>首先来说说建立一个总线，Linux系统提供了一个bus_register函数向内核注册一个总线，相当于建立了一个总线，我们需要在miscdrv_init函数中调用它，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int __init miscdrv_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;INIT misc\n&quot;);</span></div><div class="token-line"><span class="token plain">        busok = bus_register(&amp;devicesinfo_bus);//注册总线</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>bus_register函数会在系统中注册一个总线，所需参数就是总线结构的地址(&amp;devicesinfo_bus)，返回非0表示注册失败。现在我们来看看，在bus_register函数中都做了些什么事情，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bus_register(struct bus_type *bus)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        int retval;</span></div><div class="token-line"><span class="token plain">        struct subsys_private *priv;</span></div><div class="token-line"><span class="token plain">        //分配一个subsys_private结构</span></div><div class="token-line"><span class="token plain">        priv = kzalloc(sizeof(struct subsys_private), GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">        //bus_type和subsys_private结构互相指向</span></div><div class="token-line"><span class="token plain">        priv-&gt;bus = bus;</span></div><div class="token-line"><span class="token plain">        bus-&gt;p = priv;</span></div><div class="token-line"><span class="token plain">        //把总线的名称加入subsys_private的kobject中</span></div><div class="token-line"><span class="token plain">        retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, &quot;%s&quot;, bus-&gt;name);</span></div><div class="token-line"><span class="token plain">        priv-&gt;subsys.kobj.kset = bus_kset;//指向bus_kset</span></div><div class="token-line"><span class="token plain">        //把subsys_private中的kset注册到系统中</span></div><div class="token-line"><span class="token plain">        retval = kset_register(&amp;priv-&gt;subsys);</span></div><div class="token-line"><span class="token plain">        //建立总线的文件结构在sysfs中</span></div><div class="token-line"><span class="token plain">        retval = bus_create_file(bus, &amp;bus_attr_uevent);</span></div><div class="token-line"><span class="token plain">        //建立subsys_private中的devices和drivers的kset</span></div><div class="token-line"><span class="token plain">        priv-&gt;devices_kset = kset_create_and_add(&quot;devices&quot;, NULL,</span></div><div class="token-line"><span class="token plain">                             &amp;priv-&gt;subsys.kobj);</span></div><div class="token-line"><span class="token plain">        priv-&gt;drivers_kset = kset_create_and_add(&quot;drivers&quot;, NULL,</span></div><div class="token-line"><span class="token plain">                             &amp;priv-&gt;subsys.kobj);</span></div><div class="token-line"><span class="token plain">        //建立subsys_private中的devices和drivers链表，用于属于总线的设备和驱动</span></div><div class="token-line"><span class="token plain">        klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</span></div><div class="token-line"><span class="token plain">        klist_init(&amp;priv-&gt;klist_drivers, NULL, NULL);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我删除了很多你不用关注的代码，看到这里，你应该知道总线是怎么通过subsys_private把设备和驱动关联起来的（通过bus_type和subsys_private结构互相指向），下面我们看看怎么建立设备。我们这里建立一个misc杂项设备。misc杂项设备需要定一个数据结构，然后调用misc杂项设备注册接口函数，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define DEV_NAME  &quot;devicesinfo&quot;</span></div><div class="token-line"><span class="token plain">    static const  struct file_operations misc_fops = {</span></div><div class="token-line"><span class="token plain">        .read     = misc_read,</span></div><div class="token-line"><span class="token plain">        .write    = misc_write,</span></div><div class="token-line"><span class="token plain">        .release  = misc_release,</span></div><div class="token-line"><span class="token plain">        .open     = misc_open,</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    static struct miscdevice  misc_dev =  {</span></div><div class="token-line"><span class="token plain">        .fops  =  &amp;misc_fops,         //设备文件操作方法</span></div><div class="token-line"><span class="token plain">        .minor =  255,                //次设备号</span></div><div class="token-line"><span class="token plain">        .name  =  DEV_NAME,           //设备名/dev/下的设备节点名</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    static int __init miscdrv_init(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        misc_register(&amp;misc_dev);//注册misc杂项设备</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;INIT misc busok\n&quot;);</span></div><div class="token-line"><span class="token plain">        busok = bus_register(&amp;devicesinfo_bus);//注册总线</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码中，静态定义了miscdevice结构的变量misc_dev，miscdevice结构我们在前面已经了解过了，最后调用misc_register函数注册了misc杂项设备。</p><p>misc_register函数到底做了什么，我们一起来看看，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int misc_register(struct miscdevice *misc)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        dev_t dev;</span></div><div class="token-line"><span class="token plain">        int err = 0;</span></div><div class="token-line"><span class="token plain">        bool is_dynamic = (misc-&gt;minor == MISC_DYNAMIC_MINOR);</span></div><div class="token-line"><span class="token plain">        INIT_LIST_HEAD(&amp;misc-&gt;list);</span></div><div class="token-line"><span class="token plain">        mutex_lock(&amp;misc_mtx);</span></div><div class="token-line"><span class="token plain">        if (is_dynamic) {//minor次设备号如果等于255就自动分配次设备</span></div><div class="token-line"><span class="token plain">            int i = find_first_zero_bit(misc_minors, DYNAMIC_MINORS);</span></div><div class="token-line"><span class="token plain">            if (i &gt;= DYNAMIC_MINORS) {</span></div><div class="token-line"><span class="token plain">                err = -EBUSY;</span></div><div class="token-line"><span class="token plain">                goto out;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            misc-&gt;minor = DYNAMIC_MINORS - i - 1;</span></div><div class="token-line"><span class="token plain">            set_bit(i, misc_minors);</span></div><div class="token-line"><span class="token plain">        } else {//否则检查次设备号是否已经被占有</span></div><div class="token-line"><span class="token plain">            struct miscdevice *c;</span></div><div class="token-line"><span class="token plain">            list_for_each_entry(c, &amp;misc_list, list) {</span></div><div class="token-line"><span class="token plain">                if (c-&gt;minor == misc-&gt;minor) {</span></div><div class="token-line"><span class="token plain">                    err = -EBUSY;</span></div><div class="token-line"><span class="token plain">                    goto out;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        dev = MKDEV(MISC_MAJOR, misc-&gt;minor);//合并主、次设备号</span></div><div class="token-line"><span class="token plain">        //建立设备</span></div><div class="token-line"><span class="token plain">        misc-&gt;this_device =</span></div><div class="token-line"><span class="token plain">            device_create_with_groups(misc_class, misc-&gt;parent, dev,</span></div><div class="token-line"><span class="token plain">                          misc, misc-&gt;groups, &quot;%s&quot;, misc-&gt;name);</span></div><div class="token-line"><span class="token plain">        //把这个misc加入到全局misc_list链表</span></div><div class="token-line"><span class="token plain">        list_add(&amp;misc-&gt;list, &amp;misc_list);</span></div><div class="token-line"><span class="token plain">     out:</span></div><div class="token-line"><span class="token plain">        mutex_unlock(&amp;misc_mtx);</span></div><div class="token-line"><span class="token plain">        return err;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看出，misc_register函数只是负责分配设备号，以及把miscdev加入链表，真正的核心工作由device_create_with_groups函数来完成，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct device *device_create_with_groups(struct class *class,</span></div><div class="token-line"><span class="token plain">                         struct device *parent, dev_t devt,void *drvdata,const struct attribute_group **groups,const char *fmt, ...)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        va_list vargs;</span></div><div class="token-line"><span class="token plain">        struct device *dev;</span></div><div class="token-line"><span class="token plain">        va_start(vargs, fmt);</span></div><div class="token-line"><span class="token plain">        dev = device_create_groups_vargs(class, parent, devt, drvdata, groups,fmt, vargs);</span></div><div class="token-line"><span class="token plain">        va_end(vargs);</span></div><div class="token-line"><span class="token plain">        return dev;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    struct device *device_create_groups_vargs(struct class *class, struct device *parent, dev_t devt, void *drvdata,const struct attribute_group **groups,const char *fmt, va_list args)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct device *dev = NULL;</span></div><div class="token-line"><span class="token plain">        int retval = -ENODEV;</span></div><div class="token-line"><span class="token plain">        dev = kzalloc(sizeof(*dev), GFP_KERNEL);//分配设备结构的内存空间</span></div><div class="token-line"><span class="token plain">        device_initialize(dev);//初始化设备结构</span></div><div class="token-line"><span class="token plain">        dev-&gt;devt = devt;//设置设备号</span></div><div class="token-line"><span class="token plain">        dev-&gt;class = class;//设置设备类</span></div><div class="token-line"><span class="token plain">        dev-&gt;parent = parent;//设置设备的父设备</span></div><div class="token-line"><span class="token plain">        dev-&gt;groups = groups;////设置设备属性</span></div><div class="token-line"><span class="token plain">        dev-&gt;release = device_create_release;</span></div><div class="token-line"><span class="token plain">        dev_set_drvdata(dev, drvdata);//设置miscdev的地址到设备结构中</span></div><div class="token-line"><span class="token plain">        retval = kobject_set_name_vargs(&amp;dev-&gt;kobj, fmt, args);//把名称设置到设备的kobjext中去</span></div><div class="token-line"><span class="token plain">        retval = device_add(dev);//把设备加入到系统中</span></div><div class="token-line"><span class="token plain">        if (retval)</span></div><div class="token-line"><span class="token plain">            goto error;</span></div><div class="token-line"><span class="token plain">        return dev;//返回设备</span></div><div class="token-line"><span class="token plain">    error:</span></div><div class="token-line"><span class="token plain">        put_device(dev);</span></div><div class="token-line"><span class="token plain">        return ERR_PTR(retval);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，misc设备的注册就搞清楚了，下面我们来测试一下看看结果，看看Linux系统是不是多了一个总线和设备。</p><p>你可以在本课程的代码目录中，执行make指令，就会产生一个miscdvrv.ko内核模块文件，我们把这个模块文件加载到Linux系统中就行了。</p><p>为了看到效果，我们还必须要做另一件事情。 在终端中用sudo cat /proc/kmsg 指令读取/proc/kmsg文件，该文件是内核prink函数输出信息的文件。指令如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#第一步在终端中执行如下指令</span></div><div class="token-line"><span class="token plain">    sudo cat /proc/kmsg</span></div><div class="token-line"><span class="token plain">    #第二步在另一个终端中执行如下指令</span></div><div class="token-line"><span class="token plain">    make</span></div><div class="token-line"><span class="token plain">    sudo insmod miscdrv.ko</span></div><div class="token-line"><span class="token plain">    #不用这个模块了可以用以下指令卸载</span></div><div class="token-line"><span class="token plain">    sudo rmmod miscdrv.ko</span></div></pre></div><p>insmod指令是加载一个内核模块，一旦加载成功就会执行miscdrv_init函数。如果不出意外，你在终端中会看到如下图所示的情况。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage933b93a929ea1218c7f934713fbf03ba643b.jpg" alt="" title="驱动测试"/></p><p>这说明我们设备已经建立了，你应该可以在/dev目录看到一个devicesinfo文件，同时你在/sys/bus/目录下也可以看到一个devicesinfobus文件。这就是我们建立的设备和总线的文件节点的名称。</p><h3 id="打开关闭读写函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#打开关闭读写函数"><span class="icon icon-link"></span></a>打开、关闭、读写函数</h3><p>建立了设备和总线，有了设备文件节点，应用程序就可以打开、关闭以及读写这个设备文件了。</p><p>虽然现在确实可以操作设备文件了，只不过还不能完成任何实际功能，因为我们只是写好了框架函数，所以我们下面就去写好并填充这些框架函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//打开</span></div><div class="token-line"><span class="token plain">    static int  misc_open(struct inode *pinode, struct file *pfile)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //关闭 </span></div><div class="token-line"><span class="token plain">    static int misc_release(struct inode *pinode, struct file *pfile)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //写</span></div><div class="token-line"><span class="token plain">    static ssize_t misc_write(struct file *pfile, const char __user *buff, size_t size, loff_t *off)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称    </span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上三个函数，仍然没干什么实际工作，就是打印该函数所在文件的行号和名称，然后返回0就完事了。回到前面，我们的目的是要获取Linux中所有总线上的所有设备，所以在读函数中来实现是合理的。</p><p>具体实现的代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define to_subsys_private(obj) container_of(obj, struct subsys_private, subsys.kobj)//从kobject上获取subsys_private的地址</span></div><div class="token-line"><span class="token plain">    struct kset *ret_buskset(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct subsys_private *p;</span></div><div class="token-line"><span class="token plain">        if(busok)</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        if(!devicesinfo_bus.p)</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        p = devicesinfo_bus.p;</span></div><div class="token-line"><span class="token plain">        if(!p-&gt;subsys.kobj.kset)</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        //返回devicesinfo_bus总线上的kset，正是bus_kset</span></div><div class="token-line"><span class="token plain">        return p-&gt;subsys.kobj.kset;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static int misc_find_match(struct device *dev, void *data)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct bus_type* b = (struct bus_type*)data;</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;%s----&gt;device name is:%s\n&quot;, b-&gt;name, dev-&gt;kobj.name);//打印总线名称和设备名称</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    static ssize_t misc_read (struct file *pfile, char __user *buff, size_t size, loff_t *off)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct kobject* kobj;</span></div><div class="token-line"><span class="token plain">        struct kset* kset;</span></div><div class="token-line"><span class="token plain">        struct subsys_private* p;</span></div><div class="token-line"><span class="token plain">        kset = ret_buskset();//获取bus_kset的地址</span></div><div class="token-line"><span class="token plain">        if(!kset)</span></div><div class="token-line"><span class="token plain">            return 0;</span></div><div class="token-line"><span class="token plain">        printk(KERN_EMERG &quot;line:%d,%s is call\n&quot;,__LINE__,__FUNCTION__);//打印这个函数所在文件的行号和名称</span></div><div class="token-line"><span class="token plain">        //扫描所有总线的kobject</span></div><div class="token-line"><span class="token plain">        list_for_each_entry(kobj, &amp;kset-&gt;list, entry)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            p = to_subsys_private(kobj);</span></div><div class="token-line"><span class="token plain">            printk(KERN_EMERG &quot;Bus name is:%s\n&quot;,p-&gt;bus-&gt;name);</span></div><div class="token-line"><span class="token plain">            //遍历具体总线上的所有设备</span></div><div class="token-line"><span class="token plain">            bus_for_each_dev(p-&gt;bus, NULL, p-&gt;bus, misc_find_match);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>正常情况下，我们是不能获取bus_kset地址的，它是所有总线的根，包含了所有总线的kobject，Linux为了保护bus_kset，并没有在bus_type结构中直接包含kobject，而是让总线指向一个subsys_private结构，在其中包含了kobject结构。</p><p>所以，我们要注册一个总线，这样就能拔出萝卜带出泥，得到bus_kset，根据它又能找到所有subsys_private结构中的kobject，接着找到subsys_private结构，反向查询到bus_type结构的地址。</p><p>然后调用Linux提供的bus_for_each_dev函数，就可以遍历一个总线上的所有设备，它每遍历到一个设备，就调用一个函数，这个函数是用参数的方式传给它的，在我们代码中就是misc_find_match函数。</p><p>在调用misc_find_match函数时，会把一个设备结构的地址和另一个指针作为参数传递进来。最后就能打印每个设备的名称了。</p><h3 id="测试驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#测试驱动"><span class="icon icon-link"></span></a>测试驱动</h3><p>驱动程序已经写好，加载之后会自动建立设备文件，但是驱动程序不会主动工作，我们还需要写一个应用程序，对设备文件进行读写，才能测试驱动。我们这里这个驱动对打开、关闭、写操作没有什么实际的响应，但是只要一读就会打印所有设备的信息了。</p><p>下面我们来写好这个应用，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;stdlib.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;string.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;unistd.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/types.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/stat.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;fcntl.h&gt;</span></div><div class="token-line"><span class="token plain">    #define DEV_NAME &quot;/dev/devicesinfo&quot;</span></div><div class="token-line"><span class="token plain">    int main(void)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        char buf[] = {0, 0, 0, 0};</span></div><div class="token-line"><span class="token plain">        int fd;</span></div><div class="token-line"><span class="token plain">        //打开设备文件</span></div><div class="token-line"><span class="token plain">        fd = open(DEV_NAME, O_RDWR);</span></div><div class="token-line"><span class="token plain">        if (fd &lt; 0) {</span></div><div class="token-line"><span class="token plain">            printf(&quot;打开 :%s 失败!\n&quot;, DEV_NAME);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //写数据到内核空间</span></div><div class="token-line"><span class="token plain">        write(fd, buf, 4);</span></div><div class="token-line"><span class="token plain">        //从内核空间中读取数据</span></div><div class="token-line"><span class="token plain">        read(fd, buf, 4);</span></div><div class="token-line"><span class="token plain">        //关闭设备,也可以不调用，程序关闭时系统自动调用</span></div><div class="token-line"><span class="token plain">        close(fd);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可以这样操作：切换到本课程的代码目录make一下，然后加载miscdrv.ko模块，最后在终端中执行sudo ./app，就能在另一个已经执行了sudo cat /proc/kmsg的终端中，看到后面图片这样形式的数据。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage291c29e4b5f1a05d114423b3e69b796ccc1c.jpg" alt="" title="获取设备名称"/></p><p>上图是我系统中总线名和设备名，你的计算机上可能略有差异，因为我们的计算机硬件可能不同，所以有差异是正常的，不必奇怪。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>尽管Linux驱动模型异常复杂，我们还是以最小的成本，领会了Linux驱动模型设计的要点，还动手写了个小小的驱动程序。现在我来为你梳理一下这节课的重点。</p><p>首先，我们通过查看sys目录下的文件层次结构，直观感受了一下Linux系统的总线、设备、驱动是什么情况。</p><p>然后，我们了解一些重要的数据结构，它们分别是总线、驱动、设备、文件操作函数结构，还有非常关键的<strong>kset和kobject</strong>，这两个结构一起组织了总线、设备、驱动，最终形成了类目录文件这样的层次结构。</p><p>最后，我们建立一个驱动程序实例，从驱动程序框架开始，我们了解如何建立一个总线和设备，编写了对应的文件操作函数，在读操作函数中实现扫描了所有总线上的所有设备，并打印总线名称和设备名称，还写了个应用程序进行了测试，检查有没有达到预期的功能。</p><p>如果你对Linux是怎么在总线上注册设备和驱动，又对驱动和设备怎么进行匹配感兴趣的话，也可以自己阅读Linux内核代码，其中有很多驱动实例，你可以研究和实验，动手和动脑相结合，我相信你一定可以搞清楚的。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/09.下属部门设备io/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>为什么无论是我们加载miscdrv.ko内核模块，还是运行app测试，都要在前面加上sudo呢？</p><p>欢迎你在留言区记录你的学习收获，也欢迎你把这节课分享给你身边的小伙伴，一起拿下Linux设备驱动的内容。</p><p>我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/09.下属部门设备IO/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:34:37</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
