<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>13 | 第一个C函数：如何实现板级初始化？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/06.夺权启动初始化/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="第一个C函数" data-depth="2"><a href="/blog-base/操作系统实战/06.夺权启动初始化/04#第一个c函数"><span>第一个C函数</span></a></li><li title="hal层初始化" data-depth="3"><a href="/blog-base/操作系统实战/06.夺权启动初始化/04#hal层初始化"><span>hal层初始化</span></a></li><li title="进入内核层" data-depth="3"><a href="/blog-base/操作系统实战/06.夺权启动初始化/04#进入内核层"><span>进入内核层</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/06.夺权启动初始化/04#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/06.夺权启动初始化/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13--第一个c函数如何实现板级初始化"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#13--第一个c函数如何实现板级初始化"><span class="icon icon-link"></span></a>13 | 第一个C函数：如何实现板级初始化？</h1><p>你好，我是LMOS。</p><p>前面三节课，我们为调用Cosmos的**第一个C函数hal_start做了大量工作。**这节课我们要让操作系统Cosmos里的第一个C函数真正跑起来啦，也就是说，我们会真正进入到我们的内核中。</p><p>今天我们会继续在这个hal_start函数里，首先执行板级初始化，其实就是hal层（硬件抽象层，下同）初始化，其中执行了平台初始化，hal层的内存初始化，中断初始化，最后进入到内核层的初始化。</p><p>这节课的配套代码，你可以从<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson13/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载。</p><h2 id="第一个c函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#第一个c函数"><span class="icon icon-link"></span></a>第一个C函数</h2><p>任何软件工程，第一个函数总是简单的，因为它是总调用者，像是一个管理者，坐在那里发号施令，自己却是啥活也不干。</p><p>由于这是第一个C函数，也是初始化函数，我们还是要为它单独建立一个文件，以显示对它的尊重，依然在Cosmos/hal/x86/下建立一个hal_start.c文件。写上这样一个函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void hal_start()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //第一步：初始化hal层</span></div><div class="token-line"><span class="token plain">        //第二步：初始化内核层</span></div><div class="token-line"><span class="token plain">        for(;;);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>根据前面的设计，Cosmos是有hal层和内核层之分，所以在上述代码中，要分两步走。第一步是初始化hal层；第二步，初始化内核层。只是这两步的函数我们还没有写。</p><p>然而最后的死循环却有点奇怪，其实它的目的很简单，就是避免这个函数返回，因为这个返回了就无处可去，避免走回头路。</p><h3 id="hal层初始化"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#hal层初始化"><span class="icon icon-link"></span></a>hal层初始化</h3><p>为了分离硬件的特性，我们设计了hal层，把硬件相关的操作集中在这个层，并向上提供接口，目的是让内核上层不用关注硬件相关的细节，也能方便以后移植和扩展。(关于hal层的设计，可以回顾<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/372609">第3节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</p><p>也许今天我们是在x86平台上写Cosmos，明天就要在ARM平台上开发Cosmos，那时我们就可以写个ARM平台的hal层，来替换Cosmos中的x86平台的hal层。</p><p>下面我们在Cosmos/hal/x86/下建立一个halinit.c文件，写出hal层的初始化函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_hal()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //初始化平台</span></div><div class="token-line"><span class="token plain">        //初始化内存</span></div><div class="token-line"><span class="token plain">        //初始化中断</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个函数也是一个调用者，没怎么干活。不过根据代码的注释能看出，它调用的函数多一点，但主要是完成初始化平台、初始化内存、初始化中断的功能函数。</p><h4 id="初始化平台"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#初始化平台"><span class="icon icon-link"></span></a>初始化平台</h4><p>我们先来写好平台初始化函数，因为它需要最先被调用。</p><p>这个函数主要负责完成两个任务，一是<strong>把二级引导器建立的机器信息结构复制到hal层中的一个全局变量中</strong>，方便内核中的其它代码使用里面的信息，之后二级引导器建立的数据所占用的内存都会被释放。二是要<strong>初始化图形显示驱动</strong>，内核在运行过程要在屏幕上输出信息。</p><p>下面我们在Cosmos/hal/x86/下建立一个halplatform.c文件，写上如下代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void machbstart_t_init(machbstart_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //清零</span></div><div class="token-line"><span class="token plain">        memset(initp, 0, sizeof(machbstart_t));</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void init_machbstart()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        machbstart_t *kmbsp = &amp;kmachbsp;</span></div><div class="token-line"><span class="token plain">        machbstart_t *smbsp = MBSPADR;//物理地址1MB处</span></div><div class="token-line"><span class="token plain">        machbstart_t_init(kmbsp);</span></div><div class="token-line"><span class="token plain">        //复制，要把地址转换成虚拟地址</span></div><div class="token-line"><span class="token plain">        memcopy((void *)phyadr_to_viradr((adr_t)smbsp), (void *)kmbsp, sizeof(machbstart_t));</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //平台初始化函数</span></div><div class="token-line"><span class="token plain">    void init_halplaltform()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //复制机器信息结构</span></div><div class="token-line"><span class="token plain">        init_machbstart();</span></div><div class="token-line"><span class="token plain">        //初始化图形显示驱动</span></div><div class="token-line"><span class="token plain">        init_bdvideo();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这个代码中别的地方很好理解，就是kmachbsp你可能会有点奇怪，它是个结构体变量，结构体类型是machbstart_t，这个结构和二级引导器所使用的一模一样。</p><p>同时，它还是一个hal层的全局变量，我们想专门有个文件定义所有hal层的全局变量，于是我们在Cosmos/hal/x86/下建立一个halglobal.c文件，写上如下代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//全局变量定义变量放在data段</span></div><div class="token-line"><span class="token plain">    #define HAL_DEFGLOB_VARIABLE(vartype,varname) \</span></div><div class="token-line"><span class="token plain">    EXTERN  __attribute__((section(&quot;.data&quot;))) vartype varname</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    HAL_DEFGLOB_VARIABLE(machbstart_t,kmachbsp);</span></div></pre></div><p>前面的EXTERN，在halglobal.c文件中定义为空，而在其它文件中定义为extern，告诉编译器这是外部文件的变量，避免发生错误。</p><p>下面，我们在Cosmos/hal/x86/下的bdvideo.c文件中，写好init_bdvideo函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_bdvideo()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        dftgraph_t *kghp = &amp;kdftgh;</span></div><div class="token-line"><span class="token plain">        //初始化图形数据结构，里面放有图形模式，分辨率，图形驱动函数指针</span></div><div class="token-line"><span class="token plain">        init_dftgraph();</span></div><div class="token-line"><span class="token plain">        //初始bga图形显卡的函数指针</span></div><div class="token-line"><span class="token plain">        init_bga();</span></div><div class="token-line"><span class="token plain">        //初始vbe图形显卡的函数指针</span></div><div class="token-line"><span class="token plain">        init_vbe();</span></div><div class="token-line"><span class="token plain">        //清空屏幕 为黑色</span></div><div class="token-line"><span class="token plain">        fill_graph(kghp, BGRA(0, 0, 0));</span></div><div class="token-line"><span class="token plain">        //显示背景图片 </span></div><div class="token-line"><span class="token plain">        set_charsdxwflush(0, 0);</span></div><div class="token-line"><span class="token plain">        hal_background();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>init_defgraph()函数初始了dftgraph_t结构体类型的变量kdftgh，我们在halglobal.c文件中定义这个变量，结构类型我们这样来定义。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_DFTGRAPH</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        u64_t gh_mode;         //图形模式</span></div><div class="token-line"><span class="token plain">        u64_t gh_x;            //水平像素点</span></div><div class="token-line"><span class="token plain">        u64_t gh_y;            //垂直像素点</span></div><div class="token-line"><span class="token plain">        u64_t gh_framphyadr;   //显存物理地址 </span></div><div class="token-line"><span class="token plain">        u64_t gh_fvrmphyadr;   //显存虚拟地址</span></div><div class="token-line"><span class="token plain">        u64_t gh_fvrmsz;       //显存大小</span></div><div class="token-line"><span class="token plain">        u64_t gh_onepixbits;   //一个像素字占用的数据位数</span></div><div class="token-line"><span class="token plain">        u64_t gh_onepixbyte;</span></div><div class="token-line"><span class="token plain">        u64_t gh_vbemodenr;    //vbe模式号</span></div><div class="token-line"><span class="token plain">        u64_t gh_bank;         //显存的bank数</span></div><div class="token-line"><span class="token plain">        u64_t gh_curdipbnk;    //当前bank</span></div><div class="token-line"><span class="token plain">        u64_t gh_nextbnk;      //下一个bank</span></div><div class="token-line"><span class="token plain">        u64_t gh_banksz;       //bank大小</span></div><div class="token-line"><span class="token plain">        u64_t gh_fontadr;      //字库地址</span></div><div class="token-line"><span class="token plain">        u64_t gh_fontsz;       //字库大小</span></div><div class="token-line"><span class="token plain">        u64_t gh_fnthight;     //字体高度</span></div><div class="token-line"><span class="token plain">        u64_t gh_nxtcharsx;    //下一字符显示的x坐标</span></div><div class="token-line"><span class="token plain">        u64_t gh_nxtcharsy;    //下一字符显示的y坐标</span></div><div class="token-line"><span class="token plain">        u64_t gh_linesz;       //字符行高</span></div><div class="token-line"><span class="token plain">        pixl_t gh_deffontpx;   //默认字体大小</span></div><div class="token-line"><span class="token plain">        u64_t gh_chardxw;</span></div><div class="token-line"><span class="token plain">        u64_t gh_flush;</span></div><div class="token-line"><span class="token plain">        u64_t gh_framnr;</span></div><div class="token-line"><span class="token plain">        u64_t gh_fshdata;      //刷新相关的</span></div><div class="token-line"><span class="token plain">        dftghops_t gh_opfun;   //图形驱动操作函数指针结构体</span></div><div class="token-line"><span class="token plain">    }dftgraph_t;</span></div><div class="token-line"><span class="token plain">    typedef struct s_DFTGHOPS</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //读写显存数据</span></div><div class="token-line"><span class="token plain">        size_t (*dgo_read)(void* ghpdev,void* outp,size_t rdsz);</span></div><div class="token-line"><span class="token plain">        size_t (*dgo_write)(void* ghpdev,void* inp,size_t wesz);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_ioctrl)(void* ghpdev,void* outp,uint_t iocode);</span></div><div class="token-line"><span class="token plain">        //刷新</span></div><div class="token-line"><span class="token plain">        void   (*dgo_flush)(void* ghpdev);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_set_bank)(void* ghpdev, sint_t bnr);</span></div><div class="token-line"><span class="token plain">        //读写像素</span></div><div class="token-line"><span class="token plain">        pixl_t (*dgo_readpix)(void* ghpdev,uint_t x,uint_t y);</span></div><div class="token-line"><span class="token plain">        void   (*dgo_writepix)(void* ghpdev,pixl_t pix,uint_t x,uint_t y);</span></div><div class="token-line"><span class="token plain">        //直接读写像素 </span></div><div class="token-line"><span class="token plain">        pixl_t (*dgo_dxreadpix)(void* ghpdev,uint_t x,uint_t y);</span></div><div class="token-line"><span class="token plain">        void   (*dgo_dxwritepix)(void* ghpdev,pixl_t pix,uint_t x,uint_t y);</span></div><div class="token-line"><span class="token plain">        //设置x，y坐标和偏移</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_set_xy)(void* ghpdev,uint_t x,uint_t y);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_set_vwh)(void* ghpdev,uint_t vwt,uint_t vhi);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_set_xyoffset)(void* ghpdev,uint_t xoff,uint_t yoff);</span></div><div class="token-line"><span class="token plain">        //获取x，y坐标和偏移</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_get_xy)(void* ghpdev,uint_t* rx,uint_t* ry);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_get_vwh)(void* ghpdev,uint_t* rvwt,uint_t* rvhi);</span></div><div class="token-line"><span class="token plain">        sint_t (*dgo_get_xyoffset)(void* ghpdev,uint_t* rxoff,uint_t* ryoff);</span></div><div class="token-line"><span class="token plain">    }dftghops_t;</span></div><div class="token-line"><span class="token plain">    //刷新显存</span></div><div class="token-line"><span class="token plain">    void flush_videoram(dftgraph_t *kghp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kghp-&gt;gh_opfun.dgo_flush(kghp);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>不难发现，我们正是把这些实际的图形驱动函数的地址填入了这个结构体中，然后通过这个结构体，我们就可以调用到相应的函数了。</p><p>因为写这些函数都是体力活，我已经帮你搞定了，你直接使用就可以。上面的flush_videoram函数已经证明了这一想法。</p><p>来，我们测试一下，看看结果，我们图形驱动程序初始化会显示背景图片——background.bmp，这是在打包映像文件时包含进去的，你自己可以随时替换，只要是满足<strong>1024*768，24位的位图文件</strong>就行了。</p><p>下面我们要把这些函数调用起来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//在halinit.c文件中</span></div><div class="token-line"><span class="token plain">    void init_hal()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_halplaltform();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //在hal_start.c文件中</span></div><div class="token-line"><span class="token plain">    void hal_start()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_hal();//初始化hal层，其中会调用初始化平台函数，在那里会调用初始化图形驱动</span></div><div class="token-line"><span class="token plain">        for(;;);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接下来，让我们一起make vboxtest，应该很有成就感。一幅风景图呈现在我们面前，上面有Cosmos的版本、编译时间、CPU工作模式，内存大小等数据。这相当一个我们Cosmos的水印信息。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagec083c08ebf3fb25fddab6d4dbd24326aae83.b0c632e2.jpg" alt="" title="图形驱动测试"/></p><h4 id="初始化内存"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#初始化内存"><span class="icon icon-link"></span></a>初始化内存</h4><p>首先，我们在Cosmos/hal/x86/下建立一个halmm.c文件，用于初始化内存，为了后面的内存管理器作好准备。</p><p>hal层的内存初始化比较容易，只要向内存管理器提供内存空间布局信息就可以。</p><p>你可能在想，不对啊，明明我们在二级引导器中已经获取了内存布局信息，是的，<strong>但Cosmos的内存管理器需要保存更多的信息，最好是顺序的内存布局信息，这样可以增加额外的功能属性，同时降低代码的复杂度。</strong></p><p>不难发现，BIOS提供的结构无法满足前面这些要求。不过我们也有办法解决，只要以BIOS提供的结构为基础，设计一套新的数据结构就搞定了。这个结构可以这样设计。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define PMR_T_OSAPUSERRAM 1</span></div><div class="token-line"><span class="token plain">    #define PMR_T_RESERVRAM 2</span></div><div class="token-line"><span class="token plain">    #define PMR_T_HWUSERRAM 8</span></div><div class="token-line"><span class="token plain">    #define PMR_T_ARACONRAM 0xf</span></div><div class="token-line"><span class="token plain">    #define PMR_T_BUGRAM 0xff</span></div><div class="token-line"><span class="token plain">    #define PMR_F_X86_32 (1&lt;&lt;0)</span></div><div class="token-line"><span class="token plain">    #define PMR_F_X86_64 (1&lt;&lt;1)</span></div><div class="token-line"><span class="token plain">    #define PMR_F_ARM_32 (1&lt;&lt;2)</span></div><div class="token-line"><span class="token plain">    #define PMR_F_ARM_64 (1&lt;&lt;3)</span></div><div class="token-line"><span class="token plain">    #define PMR_F_HAL_MASK 0xff</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    typedef struct s_PHYMMARGE</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t pmr_lock;//保护这个结构是自旋锁</span></div><div class="token-line"><span class="token plain">        u32_t pmr_type;     //内存地址空间类型</span></div><div class="token-line"><span class="token plain">        u32_t pmr_stype;</span></div><div class="token-line"><span class="token plain">        u32_t pmr_dtype;    //内存地址空间的子类型，见上面的宏</span></div><div class="token-line"><span class="token plain">        u32_t pmr_flgs;     //结构的标志与状态</span></div><div class="token-line"><span class="token plain">        u32_t pmr_stus;</span></div><div class="token-line"><span class="token plain">        u64_t pmr_saddr;    //内存空间的开始地址</span></div><div class="token-line"><span class="token plain">        u64_t pmr_lsize;    //内存空间的大小</span></div><div class="token-line"><span class="token plain">        u64_t pmr_end;      //内存空间的结束地址</span></div><div class="token-line"><span class="token plain">        u64_t pmr_rrvmsaddr;//内存保留空间的开始地址</span></div><div class="token-line"><span class="token plain">        u64_t pmr_rrvmend;  //内存保留空间的结束地址</span></div><div class="token-line"><span class="token plain">        void* pmr_prip;     //结构的私有数据指针，以后扩展所用</span></div><div class="token-line"><span class="token plain">        void* pmr_extp;     //结构的扩展数据指针，以后扩展所用</span></div><div class="token-line"><span class="token plain">    }phymmarge_t;</span></div></pre></div><p>有些情况下内核要另起炉灶，不想把所有的内存空间都交给内存管理器去管理，所以要保留一部分内存空间，这就是上面结构中那两个pmr_rrvmsaddr、pmr_rrvmend字段的作用。</p><p>有了数据结构，我们还要写代码来操作它：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">u64_t initpmrge_core(e820map_t *e8sp, u64_t e8nr, phymmarge_t *pmargesp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        u64_t retnr = 0;</span></div><div class="token-line"><span class="token plain">        for (u64_t i = 0; i &lt; e8nr; i++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //根据一个e820map_t结构建立一个phymmarge_t结构</span></div><div class="token-line"><span class="token plain">            if (init_one_pmrge(&amp;e8sp[i], &amp;pmargesp[i]) == FALSE)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                return retnr;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            retnr++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return retnr;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void init_phymmarge()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        machbstart_t *mbsp = &amp;kmachbsp;</span></div><div class="token-line"><span class="token plain">        phymmarge_t *pmarge_adr = NULL;</span></div><div class="token-line"><span class="token plain">        u64_t pmrgesz = 0;</span></div><div class="token-line"><span class="token plain">        //根据machbstart_t机器信息结构计算获得phymmarge_t结构的开始地址和大小</span></div><div class="token-line"><span class="token plain">        ret_phymmarge_adrandsz(mbsp, &amp;pmarge_adr, &amp;pmrgesz);</span></div><div class="token-line"><span class="token plain">        u64_t tmppmrphyadr = mbsp-&gt;mb_nextwtpadr;</span></div><div class="token-line"><span class="token plain">        e820map_t *e8p = (e820map_t *)((adr_t)(mbsp-&gt;mb_e820padr));</span></div><div class="token-line"><span class="token plain">        //建立phymmarge_t结构</span></div><div class="token-line"><span class="token plain">        u64_t ipmgnr = initpmrge_core(e8p, mbsp-&gt;mb_e820nr, pmarge_adr);</span></div><div class="token-line"><span class="token plain">        //把phymmarge_t结构的地址大小个数保存machbstart_t机器信息结构中</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_e820expadr = tmppmrphyadr;</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_e820exnr = ipmgnr;</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_e820exsz = ipmgnr * sizeof(phymmarge_t);</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_nextwtpadr = PAGE_ALIGN(mbsp-&gt;mb_e820expadr + mbsp-&gt;mb_e820exsz);</span></div><div class="token-line"><span class="token plain">        //phymmarge_t结构中地址空间从低到高进行排序，我已经帮你写好了</span></div><div class="token-line"><span class="token plain">        phymmarge_sort(pmarge_adr, ipmgnr);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合上面的代码，你会发现这是根据e820map_t结构数组，建立了一个phymmarge_t结构数组，init_one_pmrge函数正是把e820map_t结构中的信息复制到phymmarge_t结构中来。理解了这个原理，即使不看我的，你自己也会写。</p><p>下面我们把这些函数，用一个总管函数调动起来，这个总管函数叫什么名字好呢？当然是init_halmm，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_halmm()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_phymmarge();</span></div><div class="token-line"><span class="token plain">        //init_memmgr();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里init_halmm函数中还调用了init_memmgr函数，这个正是这我们内存管理器初始化函数，我会在内存管理的那节课展开讲。而init_halmm函数将要被init_hal函数调用。</p><h4 id="初始化中断"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#初始化中断"><span class="icon icon-link"></span></a>初始化中断</h4><p>什么是中断呢？为了帮你快速理解，我们先来看两种情景：</p><ol><li>你在开车时，突然汽车引擎坏了，你需要修复它才能继续驾驶汽车……</li><li>你在外旅游，你女朋友突然来电话了，你可以选择接电话或者不接电话，当然不接电话的后果很严重（笑）……</li></ol><p>在以上两种情景中，虽然不十分恰当，但都是在做一件事时，因为一些原因而要切换到另一件事上。其实计算机中的CPU也是一样，在做一件事时，因为一些原因要转而做另一件事，于是中断产生了……</p><p>根据原因的类型不同，中断被分为两类。</p><p>异常，这是同步的，原因是错误和故障，就像汽车引擎坏了。不修复错误就不能继续运行，所以这时，CPU会跳到这种错误的处理代码那里开始运行，运行完了会返回。</p><p>为啥说它是同步的呢？这是因为如果不修改程序中的错误，下次运行程序到这里同样会发生异常。</p><p>中断，这是异步的，我们通常说的中断就是这种类型，它是因为外部事件而产生的，就好像旅游时女朋友来电话了。通常设备需要CPU关注时，会给CPU发送一个中断信号，所以这时CPU会跳到处理这种事件的代码那里开始运行，运行完了会返回。</p><p>由于不确定何种设备何时发出这种中断信号，所以它是异步的。</p><p>在x86 CPU上，最多支持256个中断，还记得前面所说的中断表和中断门描述符吗，这意味着我们要准备256个中断门描述符和256个中断处理程序的入口。</p><p>下面我们来定义它，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_GATE</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">            u16_t   offset_low;     /* 偏移 */</span></div><div class="token-line"><span class="token plain">            u16_t   selector;       /* 段选择子 */</span></div><div class="token-line"><span class="token plain">            u8_t    dcount;         /* 该字段只在调用门描述符中有效。如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。*/</span></div><div class="token-line"><span class="token plain">            u8_t    attr;           /* P(1) DPL(2) DT(1) TYPE(4) */</span></div><div class="token-line"><span class="token plain">            u16_t   offset_high;    /* 偏移的高位段 */</span></div><div class="token-line"><span class="token plain">            u32_t   offset_high_h;</span></div><div class="token-line"><span class="token plain">            u32_t   offset_resv;</span></div><div class="token-line"><span class="token plain">    }__attribute__((packed)) gate_t;</span></div><div class="token-line"><span class="token plain">    //定义中断表</span></div><div class="token-line"><span class="token plain">    HAL_DEFGLOB_VARIABLE(gate_t,x64_idt)[IDTMAX];</span></div></pre></div><p>说到这里你会发现，中断表其实是个gate_t结构的数组，由CPU的IDTR寄存器指向，IDTMAX为256。</p><p>但是光有数组还不行，还要设置其中的数据，下面我们就来设计这个函数，建立一个文件halsgdidt.c，在其中写一个函数，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//vector 向量也是中断号</span></div><div class="token-line"><span class="token plain">    //desc_type 中断门类型，中断门，陷阱门</span></div><div class="token-line"><span class="token plain">    //handler 中断处理程序的入口地址</span></div><div class="token-line"><span class="token plain">    //privilege 中断门的权限级别</span></div><div class="token-line"><span class="token plain">    void set_idt_desc(u8_t vector, u8_t desc_type, inthandler_t handler, u8_t privilege)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        gate_t *p_gate = &amp;x64_idt[vector];</span></div><div class="token-line"><span class="token plain">        u64_t base = (u64_t)handler;</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;offset_low = base &amp; 0xFFFF;</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;selector = SELECTOR_KERNEL_CS;</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;dcount = 0;</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;attr = (u8_t)(desc_type | (privilege &lt;&lt; 5));</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;offset_high = (u16_t)((base &gt;&gt; 16) &amp; 0xFFFF);</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;offset_high_h = (u32_t)((base &gt;&gt; 32) &amp; 0xffffffff);</span></div><div class="token-line"><span class="token plain">        p_gate-&gt;offset_resv = 0;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码，正是按照要求，把这些数据填入中断门描述符中的。有了中断门之后，还差中断处理程序，中断处理程序只负责这三件事：</p><p>1.保护CPU 寄存器，即中断发生时的程序运行的上下文。<br/>2.调用中断处理程序，这个程序可以是修复异常的，可以是设备驱动程序中对设备响应的程序。<br/>3.恢复CPU寄存器，即恢复中断时程序运行的上下文，使程序继续运行。</p><p>以上这些操作又要用汇编代码才可以编写，我觉得这是内核中最重要的部分，所以我们建立一个文件，并用kernel.asm命名。</p><p>我们先来写好完成以上三个功能的汇编宏代码，避免写256遍同样的代码，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//保存中断后的寄存器</span></div><div class="token-line"><span class="token plain">    %macro	SAVEALL	0</span></div><div class="token-line"><span class="token plain">    	push rax</span></div><div class="token-line"><span class="token plain">    	push rbx</span></div><div class="token-line"><span class="token plain">    	push rcx</span></div><div class="token-line"><span class="token plain">    	push rdx</span></div><div class="token-line"><span class="token plain">    	push rbp</span></div><div class="token-line"><span class="token plain">    	push rsi</span></div><div class="token-line"><span class="token plain">    	push rdi</span></div><div class="token-line"><span class="token plain">    	push r8</span></div><div class="token-line"><span class="token plain">    	push r9</span></div><div class="token-line"><span class="token plain">    	push r10</span></div><div class="token-line"><span class="token plain">    	push r11</span></div><div class="token-line"><span class="token plain">    	push r12</span></div><div class="token-line"><span class="token plain">    	push r13</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	push r15</span></div><div class="token-line"><span class="token plain">    	xor r14,r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,ds</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,es</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,fs</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,gs</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //恢复中断后寄存器</span></div><div class="token-line"><span class="token plain">    %macro	RESTOREALL	0</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov gs,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14 </span></div><div class="token-line"><span class="token plain">    	mov fs,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov es,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov ds,r14w</span></div><div class="token-line"><span class="token plain">    	pop r15</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	pop r13</span></div><div class="token-line"><span class="token plain">    	pop r12</span></div><div class="token-line"><span class="token plain">    	pop r11</span></div><div class="token-line"><span class="token plain">    	pop r10</span></div><div class="token-line"><span class="token plain">    	pop r9</span></div><div class="token-line"><span class="token plain">    	pop r8</span></div><div class="token-line"><span class="token plain">    	pop rdi</span></div><div class="token-line"><span class="token plain">    	pop rsi</span></div><div class="token-line"><span class="token plain">    	pop rbp</span></div><div class="token-line"><span class="token plain">    	pop rdx</span></div><div class="token-line"><span class="token plain">    	pop rcx</span></div><div class="token-line"><span class="token plain">    	pop rbx</span></div><div class="token-line"><span class="token plain">    	pop rax</span></div><div class="token-line"><span class="token plain">    	iretq</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //保存异常下的寄存器</span></div><div class="token-line"><span class="token plain">    %macro	SAVEALLFAULT 0</span></div><div class="token-line"><span class="token plain">    	push rax</span></div><div class="token-line"><span class="token plain">    	push rbx</span></div><div class="token-line"><span class="token plain">    	push rcx</span></div><div class="token-line"><span class="token plain">    	push rdx</span></div><div class="token-line"><span class="token plain">    	push rbp</span></div><div class="token-line"><span class="token plain">    	push rsi</span></div><div class="token-line"><span class="token plain">    	push rdi</span></div><div class="token-line"><span class="token plain">    	push r8</span></div><div class="token-line"><span class="token plain">    	push r9</span></div><div class="token-line"><span class="token plain">    	push r10</span></div><div class="token-line"><span class="token plain">    	push r11</span></div><div class="token-line"><span class="token plain">    	push r12</span></div><div class="token-line"><span class="token plain">    	push r13</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	push r15</span></div><div class="token-line"><span class="token plain">    	xor r14,r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,ds</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,es</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,fs</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    	mov r14w,gs</span></div><div class="token-line"><span class="token plain">    	push r14</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //恢复异常下寄存器</span></div><div class="token-line"><span class="token plain">    %macro	RESTOREALLFAULT	0</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov gs,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14 </span></div><div class="token-line"><span class="token plain">    	mov fs,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov es,r14w</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	mov ds,r14w</span></div><div class="token-line"><span class="token plain">    	pop r15</span></div><div class="token-line"><span class="token plain">    	pop r14</span></div><div class="token-line"><span class="token plain">    	pop r13</span></div><div class="token-line"><span class="token plain">    	pop r12</span></div><div class="token-line"><span class="token plain">    	pop r11</span></div><div class="token-line"><span class="token plain">    	pop r10</span></div><div class="token-line"><span class="token plain">    	pop r9</span></div><div class="token-line"><span class="token plain">    	pop r8</span></div><div class="token-line"><span class="token plain">    	pop rdi</span></div><div class="token-line"><span class="token plain">    	pop rsi</span></div><div class="token-line"><span class="token plain">    	pop rbp</span></div><div class="token-line"><span class="token plain">    	pop rdx</span></div><div class="token-line"><span class="token plain">    	pop rcx</span></div><div class="token-line"><span class="token plain">    	pop rbx</span></div><div class="token-line"><span class="token plain">    	pop rax</span></div><div class="token-line"><span class="token plain">    	add rsp,8</span></div><div class="token-line"><span class="token plain">    	iretq</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //没有错误码CPU异常</span></div><div class="token-line"><span class="token plain">    %macro	SRFTFAULT 1</span></div><div class="token-line"><span class="token plain">    	push	  _NOERRO_CODE</span></div><div class="token-line"><span class="token plain">    	SAVEALLFAULT</span></div><div class="token-line"><span class="token plain">    	mov r14w,0x10</span></div><div class="token-line"><span class="token plain">    	mov ds,r14w</span></div><div class="token-line"><span class="token plain">    	mov es,r14w</span></div><div class="token-line"><span class="token plain">    	mov fs,r14w</span></div><div class="token-line"><span class="token plain">    	mov gs,r14w</span></div><div class="token-line"><span class="token plain">    	mov 	rdi,%1 ;rdi, rsi</span></div><div class="token-line"><span class="token plain">    	mov 	rsi,rsp</span></div><div class="token-line"><span class="token plain">    	call 	hal_fault_allocator</span></div><div class="token-line"><span class="token plain">    	RESTOREALLFAULT</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //CPU异常</span></div><div class="token-line"><span class="token plain">    %macro	SRFTFAULT_ECODE 1</span></div><div class="token-line"><span class="token plain">    	SAVEALLFAULT</span></div><div class="token-line"><span class="token plain">    	mov r14w,0x10</span></div><div class="token-line"><span class="token plain">    	mov ds,r14w</span></div><div class="token-line"><span class="token plain">    	mov es,r14w</span></div><div class="token-line"><span class="token plain">    	mov fs,r14w</span></div><div class="token-line"><span class="token plain">    	mov gs,r14w</span></div><div class="token-line"><span class="token plain">    	mov 	rdi,%1</span></div><div class="token-line"><span class="token plain">    	mov 	rsi,rsp</span></div><div class="token-line"><span class="token plain">    	call 	hal_fault_allocator</span></div><div class="token-line"><span class="token plain">    	RESTOREALLFAULT</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div><div class="token-line"><span class="token plain">    //硬件中断</span></div><div class="token-line"><span class="token plain">    %macro	HARWINT	1</span></div><div class="token-line"><span class="token plain">    	SAVEALL</span></div><div class="token-line"><span class="token plain">    	mov r14w,0x10</span></div><div class="token-line"><span class="token plain">    	mov ds,r14w</span></div><div class="token-line"><span class="token plain">    	mov es,r14w</span></div><div class="token-line"><span class="token plain">    	mov fs,r14w</span></div><div class="token-line"><span class="token plain">    	mov gs,r14w</span></div><div class="token-line"><span class="token plain">    	mov	rdi, %1</span></div><div class="token-line"><span class="token plain">    	mov 	rsi,rsp</span></div><div class="token-line"><span class="token plain">    	call    hal_intpt_allocator</span></div><div class="token-line"><span class="token plain">    	RESTOREALL</span></div><div class="token-line"><span class="token plain">    %endmacro</span></div></pre></div><p>别看前面的代码这么长，其实<strong>最重要的只有两个指令：push、pop</strong>，这两个正是用来压入寄存器和弹出寄存器的，正好可以用来保存和恢复CPU所有的通用寄存器。</p><p>有的CPU异常，CPU自动把异常码压入到栈中，而有的CPU异常没有异常码，<strong>为了统一，我们对没有异常码的手动压入一个常数，维持栈的平衡。</strong></p><p>有了中断异常处理的宏，我们还要它们变成中断异常的处理程序入口点函数。汇编函数其实就是一个标号加一段汇编代码，C编译器把C语言函数编译成汇编代码后，也是标号加汇编代码，函数名就是标号。</p><p>下面我们在kernel.asm中写好它们：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//除法错误异常 比如除0</span></div><div class="token-line"><span class="token plain">    exc_divide_error:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 0</span></div><div class="token-line"><span class="token plain">    //单步执行异常</span></div><div class="token-line"><span class="token plain">    exc_single_step_exception:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 1</span></div><div class="token-line"><span class="token plain">    exc_nmi:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 2</span></div><div class="token-line"><span class="token plain">    //调试断点异常</span></div><div class="token-line"><span class="token plain">    exc_breakpoint_exception:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 3</span></div><div class="token-line"><span class="token plain">    //溢出异常</span></div><div class="token-line"><span class="token plain">    exc_overflow:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 4</span></div><div class="token-line"><span class="token plain">    //段不存在异常</span></div><div class="token-line"><span class="token plain">    exc_segment_not_present:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT_ECODE 11</span></div><div class="token-line"><span class="token plain">    //栈异常</span></div><div class="token-line"><span class="token plain">    exc_stack_exception:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT_ECODE 12</span></div><div class="token-line"><span class="token plain">    //通用异常</span></div><div class="token-line"><span class="token plain">    exc_general_protection:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT_ECODE 13</span></div><div class="token-line"><span class="token plain">    //缺页异常</span></div><div class="token-line"><span class="token plain">    exc_page_fault:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT_ECODE 14</span></div><div class="token-line"><span class="token plain">    hxi_exc_general_intpfault:</span></div><div class="token-line"><span class="token plain">    	SRFTFAULT 256</span></div><div class="token-line"><span class="token plain">    //硬件1～7号中断</span></div><div class="token-line"><span class="token plain">    hxi_hwint00:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+0)</span></div><div class="token-line"><span class="token plain">    hxi_hwint01:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+1)</span></div><div class="token-line"><span class="token plain">    hxi_hwint02:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+2)</span></div><div class="token-line"><span class="token plain">    hxi_hwint03:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+3)</span></div><div class="token-line"><span class="token plain">    hxi_hwint04:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+4)</span></div><div class="token-line"><span class="token plain">    hxi_hwint05:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+5)</span></div><div class="token-line"><span class="token plain">    hxi_hwint06:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+6)</span></div><div class="token-line"><span class="token plain">    hxi_hwint07:</span></div><div class="token-line"><span class="token plain">    	HARWINT	(INT_VECTOR_IRQ0+7)</span></div></pre></div><p>为了突出重点，这里没有全部展示代码 ，你只用搞清原理就行了。那有了中断处理程序的入口地址，下面我们就可以在halsgdidt.c文件写出函数设置中断门描述符了，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_idt_descriptor()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    //一开始把所有中断的处理程序设置为保留的通用处理程序</span></div><div class="token-line"><span class="token plain">        for (u16_t intindx = 0; intindx &lt;= 255; intindx++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            set_idt_desc((u8_t)intindx, DA_386IGate, hxi_exc_general_intpfault, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_DIVIDE, DA_386IGate, exc_divide_error, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_DEBUG, DA_386IGate, exc_single_step_exception, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_NMI, DA_386IGate, exc_nmi, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_BREAKPOINT, DA_386IGate, exc_breakpoint_exception, PRIVILEGE_USER);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_OVERFLOW, DA_386IGate, exc_overflow, PRIVILEGE_USER);</span></div><div class="token-line"><span class="token plain">    //篇幅所限，未全部展示</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_PAGE_FAULT, DA_386IGate, exc_page_fault, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_IRQ0 + 0, DA_386IGate, hxi_hwint00, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_IRQ0 + 1, DA_386IGate, hxi_hwint01, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_IRQ0 + 2, DA_386IGate, hxi_hwint02, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        set_idt_desc(INT_VECTOR_IRQ0 + 3, DA_386IGate, hxi_hwint03, PRIVILEGE_KRNL);</span></div><div class="token-line"><span class="token plain">        //篇幅所限，未全部展示</span></div><div class="token-line"><span class="token plain">         return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码已经很明显了，一开始把所有中断的处理程序设置为保留的通用处理程序，避免未知中断异常发生了CPU无处可去，然后对已知的中断和异常进一步设置，这会覆盖之前的通用处理程序，这样就可以确保万无一失。</p><p>下面我们把这些代码整理一下，安装到具体的调用路径上，让上层调用者调用到就好了。</p><p>我们依然在halintupt.c文件中写上init_halintupt()函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_halintupt()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_idt_descriptor();</span></div><div class="token-line"><span class="token plain">        init_intfltdsc();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到此为止，CPU体系层面的中断就初始化完成了。你会发现，我们在init_halintupt()函数中还调用了<strong>init_intfltdsc()函数</strong>，这个函数是干什么的呢？请往下看。</p><p>我们先来设计一下Cosmos的中断处理框架，后面我们把中断和异常统称为中断，因为它们的处理方式相同。</p><p>前面我们只是解决了中断的CPU相关部分，而CPU只是响应中断，但是并不能解决产生中断的问题。</p><p>比如缺页中断来了，我们要解决内存地址映射关系，程序才可以继续运行。再比如硬盘中断来了，我们要读取硬盘的数据，要处理这问题，就要写好相应的处理函数。</p><p>因为有些处理是内核所提供的，而有些处理函数是设备驱动提供的，想让它们和中断关联起来，就要好好设计<strong>中断处理框架</strong>了。</p><p>下面我们来画幅图，描述中断框架的设计：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagefd7afd2cd9e5b63cd7e52cd68b65e81aee7a.9dcbe2e7.jpg" alt="" title="中断框架设计图"/></p><p>可以看到，中断、异常分发器的左侧的东西我们已经处理完成，下面需要写好中断、异常分发器和中断异常描述符。</p><p>我们先来搞定中断异常描述，结合框架图，中断异常描述也是个表，它在C语言中就是个结构数组，让我们一起来写好这个数组：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_INTFLTDSC{    </span></div><div class="token-line"><span class="token plain">        spinlock_t  i_lock;    </span></div><div class="token-line"><span class="token plain">        u32_t       i_flg;    </span></div><div class="token-line"><span class="token plain">        u32_t       i_stus;    </span></div><div class="token-line"><span class="token plain">        uint_t      i_prity;        //中断优先级    </span></div><div class="token-line"><span class="token plain">        uint_t      i_irqnr;        //中断号    </span></div><div class="token-line"><span class="token plain">        uint_t      i_deep;         //中断嵌套深度    </span></div><div class="token-line"><span class="token plain">        u64_t       i_indx;         //中断计数    </span></div><div class="token-line"><span class="token plain">        list_h_t    i_serlist;      //也可以使用中断回调函数的方式</span></div><div class="token-line"><span class="token plain">        uint_t      i_sernr;        //中断回调函数个数   </span></div><div class="token-line"><span class="token plain">        list_h_t    i_serthrdlst;   //中断线程链表头    </span></div><div class="token-line"><span class="token plain">        uint_t      i_serthrdnr;    //中断线程个数    </span></div><div class="token-line"><span class="token plain">        void*       i_onethread;    //只有一个中断线程时直接用指针    </span></div><div class="token-line"><span class="token plain">        void*       i_rbtreeroot;   //如果中断线程太多则按优先级组成红黑树</span></div><div class="token-line"><span class="token plain">        list_h_t    i_serfisrlst;      </span></div><div class="token-line"><span class="token plain">        uint_t      i_serfisrnr;       </span></div><div class="token-line"><span class="token plain">        void*       i_msgmpool;     //可能的中断消息池    </span></div><div class="token-line"><span class="token plain">        void*       i_privp;    </span></div><div class="token-line"><span class="token plain">        void*       i_extp;</span></div><div class="token-line"><span class="token plain">    }intfltdsc_t;</span></div></pre></div><p>上面结构中，记录了中断了优先级。因为有些中断可以稍后执行，而有的中断需要紧急执行，所以要设计一个优先级。其中还有中断号，中断计数等统计信息。</p><p>中断可以由线程的方式执行，也可以是一个回调函数，该函数的地址放另一个结构体中，这个结构体我已经帮你写好了，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef drvstus_t (*intflthandle_t)(uint_t ift_nr,void* device,void* sframe); //中断处理函数的指针类型</span></div><div class="token-line"><span class="token plain">    typedef struct s_INTSERDSC{    </span></div><div class="token-line"><span class="token plain">        list_h_t    s_list;        //在中断异常描述符中的链表</span></div><div class="token-line"><span class="token plain">        list_h_t    s_indevlst;    //在设备描述描述符中的链表</span></div><div class="token-line"><span class="token plain">        u32_t       s_flg;        </span></div><div class="token-line"><span class="token plain">        intfltdsc_t* s_intfltp;    //指向中断异常描述符 </span></div><div class="token-line"><span class="token plain">        void*       s_device;      //指向设备描述符</span></div><div class="token-line"><span class="token plain">        uint_t      s_indx;    </span></div><div class="token-line"><span class="token plain">        intflthandle_t s_handle;   //中断处理的回调函数指针</span></div><div class="token-line"><span class="token plain">    }intserdsc_t;</span></div></pre></div><p>如果内核或者设备驱动程序要安装一个中断处理函数，就要先申请一个intserdsc_t结构体，然后把中断函数的地址写入其中，最后把这个结构挂载到对应的intfltdsc_t结构中的i_serfisrlst链表中。</p><p>你可能要问了，为什么不能直接把中断处理函数放在intfltdsc_t结构中呢，还要多此一举搞个intserdsc_t结构体呢？</p><p>这是因为我们的计算机中可能有很多设备，每个设备都可能产生中断，但是中断控制器的中断信号线是有限的。你可以这样理解：中断控制器最多只能产生几十号中断号，而设备不止几十个，所以会有多个设备共享一根中断信号线。</p><p>这就导致一个中断发生后，无法确定是哪个设备产生的中断，所以我们干脆让设备驱动程序来决定，因为它是最了解设备的。</p><p>这里我们让这个intfltdsc_t结构上的所有中断处理函数都依次执行，查看是不是自己的设备产生了中断，如果是就处理，不是则略过。</p><p>好，明白了这两个结构之后，我们就要开始初始化了。首先是在halglobal.c文件定义intfltdsc_t结构。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//定义intfltdsc_t结构数组大小为256</span></div><div class="token-line"><span class="token plain">    HAL_DEFGLOB_VARIABLE(intfltdsc_t,machintflt)[IDTMAX];</span></div></pre></div><p>下面我们再来实现中断、异常分发器函数，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//中断处理函数</span></div><div class="token-line"><span class="token plain">    void hal_do_hwint(uint_t intnumb, void *krnlsframp)</span></div><div class="token-line"><span class="token plain">    {    </span></div><div class="token-line"><span class="token plain">        intfltdsc_t *ifdscp = NULL;    </span></div><div class="token-line"><span class="token plain">        cpuflg_t cpuflg;</span></div><div class="token-line"><span class="token plain">        //根据中断号获取中断异常描述符地址    </span></div><div class="token-line"><span class="token plain">        ifdscp = hal_retn_intfltdsc(intnumb);</span></div><div class="token-line"><span class="token plain">        //对断异常描述符加锁并中断    </span></div><div class="token-line"><span class="token plain">        hal_spinlock_saveflg_cli(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);    </span></div><div class="token-line"><span class="token plain">        ifdscp-&gt;i_indx++;    </span></div><div class="token-line"><span class="token plain">        ifdscp-&gt;i_deep++;</span></div><div class="token-line"><span class="token plain">        //运行中断处理的回调函数</span></div><div class="token-line"><span class="token plain">        hal_run_intflthandle(intnumb, krnlsframp);    </span></div><div class="token-line"><span class="token plain">        ifdscp-&gt;i_deep--;</span></div><div class="token-line"><span class="token plain">        //解锁并恢复中断状态    </span></div><div class="token-line"><span class="token plain">        hal_spinunlock_restflg_sti(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);    </span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //异常分发器</span></div><div class="token-line"><span class="token plain">    void hal_fault_allocator(uint_t faultnumb, void *krnlsframp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //我们的异常处理回调函数也是放在中断异常描述符中的</span></div><div class="token-line"><span class="token plain">        hal_do_hwint(faultnumb, krnlsframp);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //中断分发器</span></div><div class="token-line"><span class="token plain">    void hal_hwint_allocator(uint_t intnumb, void *krnlsframp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        hal_do_hwint(intnumb, krnlsframp);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>前面的代码确实是按照我们的中断框架设计实现的，下面我们去实现hal_run_intflthandle函数，它负责调用中断处理的回调函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void hal_run_intflthandle(uint_t ifdnr, void *sframe)</span></div><div class="token-line"><span class="token plain">    {    </span></div><div class="token-line"><span class="token plain">        intserdsc_t *isdscp;    </span></div><div class="token-line"><span class="token plain">        list_h_t *lst;</span></div><div class="token-line"><span class="token plain">        //根据中断号获取中断异常描述符地址    </span></div><div class="token-line"><span class="token plain">        intfltdsc_t *ifdscp = hal_retn_intfltdsc(ifdnr);</span></div><div class="token-line"><span class="token plain">        //遍历i_serlist链表    </span></div><div class="token-line"><span class="token plain">        list_for_each(lst, &amp;ifdscp-&gt;i_serlist)    </span></div><div class="token-line"><span class="token plain">        {   </span></div><div class="token-line"><span class="token plain">            //获取i_serlist链表上对象即intserdsc_t结构</span></div><div class="token-line"><span class="token plain">            isdscp = list_entry(lst, intserdsc_t, s_list);  </span></div><div class="token-line"><span class="token plain">            //调用中断处理回调函数      </span></div><div class="token-line"><span class="token plain">            isdscp-&gt;s_handle(ifdnr, isdscp-&gt;s_device, sframe);    </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码已经很清楚了，循环遍历intfltdsc_t结构中，i_serlist链表上所有挂载的intserdsc_t结构，然后调用intserdsc_t结构中的中断处理的回调函数。</p><p>我们Cosmos链表借用了Linux所用的链表，代码我已经帮你写好了，放在了list.h和list_t.h文件中，请自行查看。</p><h4 id="初始化中断控制器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#初始化中断控制器"><span class="icon icon-link"></span></a>初始化中断控制器</h4><p>我们把CPU端的中断搞定了以后，还有设备端的中断，这个可以交给设备驱动程序，但是CPU和设备之间的中断控制器，还需要我们出面解决。</p><p>多个设备的中断信号线都会连接到中断控制器上，中断控制器可以决定启用或者屏蔽哪些设备的中断，还可以决定设备中断之间的优先线，所以它才叫中断控制器。</p><p>x86平台上的中断控制器有多种，最开始是8259A，然后是IOAPIC，最新的是MSI-X。为了简单的说明原理，我们选择了8259A中断控制器。</p><p>8259A在任何x86平台上都可以使用，x86平台使用了两片8259A芯片，以级联的方式存在。它拥有15个中断源（即可以有15个中断信号接入）。让我们看看8259A在系统上的框架图：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage4d094d81f7feb668abf30c5cced619549709.867b5bf8.jpg" alt="" title="8259A在系统上的框架图"/></p><p>上面直接和CPU连接的是主8259A，下面的是从8259A，每一个8259A芯片都有两个I/O端口，我们可以通过它们对8259A进行编程。主8259A的端口地址是0x20，0x21；从8259A的端口地址是0xA0，0xA1。</p><p>下面我们来做代码初始化，我们程序员可以向8259A写两种命令字： ICW和OCW；ICW这种命令字用来实现8259a芯片的初始化。而OCW这种命令用来向8259A发布命令，以对其进行控制。OCW可以在8259A被初始化之后的任何时候被使用。</p><p>我已经把代码定好了，放在了8259.c文件中，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_i8259()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //初始化主从8259a</span></div><div class="token-line"><span class="token plain">        out_u8_p(ZIOPT, ICW1);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(SIOPT, ICW1);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(ZIOPT1, ZICW2);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(SIOPT1, SICW2);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(ZIOPT1, ZICW3);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(SIOPT1, SICW3);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(ZIOPT1, ICW4);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(SIOPT1, ICW4);</span></div><div class="token-line"><span class="token plain">        //屏蔽全部中断源</span></div><div class="token-line"><span class="token plain">        out_u8_p(ZIOPT1, 0xff);    </span></div><div class="token-line"><span class="token plain">        out_u8_p(SIOPT1, 0xff);        </span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果你要了解8259A的细节，就是上述代码中为什么要写入这些数据，你可以自己在Intel官方网站上搜索8259A的数据手册，自行查看。</p><p>这里你只要在init_halintupt()函数的最后，调用这个函数就行。你有没有想过，既然我们是研究操作系统不是要写硬件驱动，为什么要在初始化中断控制器后，屏蔽所有的中断源呢？因为我们Cosmos在初始化阶段还不能处理中断。</p><p>到此，我们的Cosmos的hal层初始化就结束了。关于内存管理器的初始化，我会在内存管理模块讲解，你先有个印象就行。</p><h3 id="进入内核层"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#进入内核层"><span class="icon icon-link"></span></a>进入内核层</h3><p>hal层的初始化已经完成，按照前面的设计，我们的Cosmos还有内核层，我们下面就要进入到内核层，建立一个文件，写上一个函数，作为本课程的结尾。</p><p>但是这个函数是个<strong>空函数</strong>，目前什么也不做，它是为Cosmos内核层初始化而存在的，但是由于课程只进行到这里，所以我只是写个空函数，为后面的课程做好准备。</p><p>由于内核层是从hal层进入的，必须在hal_start()函数中被调用，所以在此完成这个函数——init_krl()。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_krl()</span></div><div class="token-line"><span class="token plain">    { </span></div><div class="token-line"><span class="token plain">        //禁止函数返回    </span></div><div class="token-line"><span class="token plain">        die(0);    </span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>下面我们在hal_start()函数中调用它就行了，如下所示</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void hal_start()</span></div><div class="token-line"><span class="token plain">    {   </span></div><div class="token-line"><span class="token plain">        //初始化Cosmos的hal层 </span></div><div class="token-line"><span class="token plain">        init_hal();</span></div><div class="token-line"><span class="token plain">        //初始化Cosmos的内核层    </span></div><div class="token-line"><span class="token plain">        init_krl();    </span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面的代码中，不难发现Cosmos的hal层初始化完成后，就自动进入了Cosmos内核层的初始化。至此本课程已经结束。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>写一个C函数是容易的，但是写操作系统的第一个C函数并不容易，好在我们一路坚持，没有放弃，才取得了这个阶段性的胜利。但温故而知新，对学过的东西要学而时习之，下面我们来回顾一下本课程的重点。</p><p>1.Cosmos的第一个C函数产生了，它十分简单但极其有意义，它的出现标志着C语言的运行环境已经完善。从此我们可以用C语言高效地开发操作系统了，由爬行时代进入了跑步前行的状态，可喜可贺。</p><p>2.第一个C函数，干的第一件重要工作就是**调用hal层的初始化函数。**这个初始化函数首先初始化了平台，初始化了机器信息结构供内核的其它代码使用，还初始化了我们图形显示驱动、显示了背景图片；其次是初始化了内存管理相关的数据结构；接着初始了中断，中断处理框架是两层，所以最为复杂；最后初始化了中断控制器。</p><p>3.当hal层初始化完成了，我们就进入了内核层，由于到了课程的尾声，我们先暂停在这里。</p><p>在这节课里我帮你写了很多代码，那些代码非常简单和枯燥，但是必须要有它们才可以。综合我们前面讲过的知识，我相信你有能力看懂它们。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/06.夺权启动初始化/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请你梳理一下，Cosmos hal层的函数调用关系。</p><p>欢迎你在留言区跟我交流互动，也欢迎把这节课转发给你的朋友和同事。</p><p>好，我是LMOS，咱们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/06.夺权启动初始化/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
