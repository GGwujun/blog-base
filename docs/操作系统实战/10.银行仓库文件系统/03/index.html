<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>34 | 仓库管理：如何实现文件的六大基本操作？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战/10.银行仓库文件系统/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="辅助操作" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#辅助操作"><span>辅助操作</span></a></li><li title="操作根目录文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#操作根目录文件"><span>操作根目录文件</span></a></li><li title="获取文件名" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#获取文件名"><span>获取文件名</span></a></li><li title="判断文件是否存在" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#判断文件是否存在"><span>判断文件是否存在</span></a></li><li title="文件相关的操作" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#文件相关的操作"><span>文件相关的操作</span></a></li><li title="新建文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#新建文件"><span>新建文件</span></a></li><li title="删除文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#删除文件"><span>删除文件</span></a></li><li title="打开文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#打开文件"><span>打开文件</span></a></li><li title="读写文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#读写文件"><span>读写文件</span></a></li><li title="关闭文件" data-depth="3"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#关闭文件"><span>关闭文件</span></a></li><li title="串联整合" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#串联整合"><span>串联整合</span></a></li><li title="测试" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#测试"><span>测试</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="34--仓库管理如何实现文件的六大基本操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#34--仓库管理如何实现文件的六大基本操作"><span class="icon icon-link"></span></a>34 | 仓库管理：如何实现文件的六大基本操作？</h1><p>你好，我是LMOS。</p><p>我们在上一节课中，已经建立了仓库，并对仓库进行了划分，就是文件系统的格式化。有了仓库就需要往里面存取东西，对于我们的仓库来说，就是存取应用程序的文件。</p><p>所以今天我们要给仓库增加一些相关的操作，这些操作主要用于新建、打开、关闭、读写文件，它们也是文件系统的标准功能，自然即使我们这个最小的文件系统，也必须要支持。</p><p>好了，话不多说，我们开始吧。这节课的配套代码，你可以从<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson34/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载。</p><h2 id="辅助操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#辅助操作"><span class="icon icon-link"></span></a>辅助操作</h2><p>通过上一节课的学习，我们了解了文件系统格式化操作，不难发现文件系统格式化并不复杂，但是它们需要大量的辅助函数。同样的，完成文件相关的操作，我们也需要大量的辅助函数。为了让你更加清楚每个实现细节，这里我们先来实现文件操作相关的辅助函数。</p><h3 id="操作根目录文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#操作根目录文件"><span class="icon icon-link"></span></a>操作根目录文件</h3><p>根据我们文件系统的设计，不管是新建、删除、打开一个文件，首先都要找到与该文件对应的rfsdir_t结构。</p><p>在我们的文件系统中，一个文件的rfsdir_t结构就储存在根目录文件中，所以想要读取文件对应的rfsdir_t结构，首先就要获取和释放根目录文件。</p><p>下面我们来实现获取和释放根目录文件的函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//获取根目录文件</span></div><div class="token-line"><span class="token plain">    void* get_rootdirfile_blk(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void* retptr = NULL;  </span></div><div class="token-line"><span class="token plain">        rfsdir_t* rtdir = get_rootdir(devp);//获取根目录文件的rfsdir_t结构</span></div><div class="token-line"><span class="token plain">        //分配4KB大小的缓冲区并清零</span></div><div class="token-line"><span class="token plain">        void* buf = new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        hal_memset(buf, FSYS_ALCBLKSZ, 0);</span></div><div class="token-line"><span class="token plain">        //读取根目录文件的逻辑储存块到缓冲区中</span></div><div class="token-line"><span class="token plain">        read_rfsdevblk(devp, buf, rtdir-&gt;rdr_blknr)</span></div><div class="token-line"><span class="token plain">        retptr = buf;//设置缓冲区的首地址为返回值</span></div><div class="token-line"><span class="token plain">        goto errl1;</span></div><div class="token-line"><span class="token plain">    errl:</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">    errl1:</span></div><div class="token-line"><span class="token plain">        del_rootdir(devp, rtdir);//释放根目录文件的rfsdir_t结构</span></div><div class="token-line"><span class="token plain">        return retptr;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //释放根目录文件</span></div><div class="token-line"><span class="token plain">    void del_rootdirfile_blk(device_t* devp,void* blkp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //因为逻辑储存块的头512字节的空间中，保存的就是fimgrhd_t结构</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)blkp;</span></div><div class="token-line"><span class="token plain">        //把根目录文件回写到储存设备中去，块号为fimgrhd_t结构自身所在的块号</span></div><div class="token-line"><span class="token plain">        write_rfsdevblk(devp, blkp, fmp-&gt;fmd_sfblk)</span></div><div class="token-line"><span class="token plain">        //释放缓冲区</span></div><div class="token-line"><span class="token plain">        del_buf(blkp, FSYS_ALCBLKSZ); </span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，get_rootdir函数的作用就是读取文件系统超级块中rfsdir_t结构到一个缓冲区中，del_rootdir函数则是用来释放这个缓冲区，其代码非常简单，我已经帮你写好了。</p><p>获取根目录文件的方法也很容易，根据超级块中的rfsdir_t结构中的信息，读取根目录文件的逻辑储存块就行了。而释放根目录文件，就是把根目录文件的储存块回写到储存设备中去，最后释放对应的缓冲区就可以了。</p><h3 id="获取文件名"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#获取文件名"><span class="icon icon-link"></span></a>获取文件名</h3><p>下面我们来实现获取文件名，在我们的印象中，一个完整的文件名应该是这样的“/cosmos/drivers/drvrfs.c”，这样的文件名包含了完整目录路径。</p><p>除了第一个“/”是根目录外，其它的“/”只是一个目录路径分隔符。然而，在很多情况下，我们通常需要把目录路径分隔符去除，提取其中的目录名称或者文件名称。为了简化问题，我们对文件系统来点限制，我们的文件名只能是“/xxxx”这种类型的。</p><p>下面我们就来实现去除路径分隔符提取文件名称的函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//检查文件路径名</span></div><div class="token-line"><span class="token plain">    sint_t rfs_chkfilepath(char_t* fname)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        char_t* chp = fname;</span></div><div class="token-line"><span class="token plain">        //检查文件路径名的第一个字符是否为“/”，不是则返回2</span></div><div class="token-line"><span class="token plain">        if(chp[0] != &#x27;/&#x27;) { return 2; }</span></div><div class="token-line"><span class="token plain">        for(uint_t i = 1; ; i++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //检查除第1个字符外其它字符中还有没有为“/”的，有就返回3</span></div><div class="token-line"><span class="token plain">            if(chp[i] == &#x27;/&#x27;) { return 3; }</span></div><div class="token-line"><span class="token plain">            //如果这里i大于等于文件名称的最大长度，就返回4</span></div><div class="token-line"><span class="token plain">            if(i &gt;= DR_NM_MAX) { return 4; }</span></div><div class="token-line"><span class="token plain">            //到文件路径字符串的末尾就跳出循环</span></div><div class="token-line"><span class="token plain">            if(chp[i] == 0 &amp;&amp; i &gt; 1) { break; }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //返回0表示正确</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //提取纯文件名</span></div><div class="token-line"><span class="token plain">    sint_t rfs_ret_fname(char_t* buf,char_t* fpath)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //检查文件路径名是不是“/xxxx”的形式</span></div><div class="token-line"><span class="token plain">        sint_t stus = rfs_chkfilepath(fpath);</span></div><div class="token-line"><span class="token plain">        //如果不为0就直接返回这个状态值表示错误</span></div><div class="token-line"><span class="token plain">        if(stus != 0) { return stus; }</span></div><div class="token-line"><span class="token plain">        //从路径名字符串的第2个字符开始复制字符到buf中</span></div><div class="token-line"><span class="token plain">        rfs_strcpy(&amp;fpath[1], buf);</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，完成获取文件名的是rfs_ret_fname函数，这个函数可以把fpath指向的路径名中的文件名提取出来，放到buf指向的缓冲区中，但在这之前，需要先调用rfs_chkfilepath函数检查路径名是不是“/xxxx”的形式，这是这个功能正常实现的必要条件。</p><h3 id="判断文件是否存在"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#判断文件是否存在"><span class="icon icon-link"></span></a>判断文件是否存在</h3><p>获取了文件名称，我们还需要实现这样一个功能：判断一个文件是否存在。因为新建和删除文件，要先判断储存设备里是不是存在着这个文件。具体来说，新建文件时，无法新建相同文件名的文件；删除文件时，不能删除不存在的文件。</p><p>我们一起通过后面这个函数还完成这个功能，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sint_t rfs_chkfileisindev(device_t* devp,char_t* fname)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        sint_t rets = 6;</span></div><div class="token-line"><span class="token plain">        sint_t ch = rfs_strlen(fname);//获取文件名的长度，注意不是文件路径名</span></div><div class="token-line"><span class="token plain">        //检查文件名的长度是不是合乎要求</span></div><div class="token-line"><span class="token plain">        if(ch &lt; 1 || ch &gt;= (sint_t)DR_NM_MAX) { return 4; }</span></div><div class="token-line"><span class="token plain">        void* rdblkp = get_rootdirfile_blk(devp);</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)rdblkp;</span></div><div class="token-line"><span class="token plain">        //检查该fimgrhd_t结构的类型是不是FMD_DIR_TYPE，即这个文件是不是目录文件</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_type != FMD_DIR_TYPE) { rets = 3; goto err; }</span></div><div class="token-line"><span class="token plain">        //检查根目录文件是不是为空，即没有写入任何数据，所以返回0，表示根目录下没有对应的文件</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp;</span></div><div class="token-line"><span class="token plain">     fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) {</span></div><div class="token-line"><span class="token plain">            rets = 0; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);//指向根目录文件的第一个字节</span></div><div class="token-line"><span class="token plain">        //指向根目录文件的结束地址</span></div><div class="token-line"><span class="token plain">        void* maxchkp = (void*)((uint_t)rdblkp + FSYS_ALCBLKSZ - 1);</span></div><div class="token-line"><span class="token plain">        //当前的rfsdir_t结构的指针比根目录文件的结束地址小，就继续循环    </span></div><div class="token-line"><span class="token plain">        for(;(void*)dirp &lt; maxchkp;) {</span></div><div class="token-line"><span class="token plain">            //如果这个rfsdir_t结构的类型是RDR_FIL_TYPE，说明它对应的是文件而不是目录，所以下面就继续比较其文件名</span></div><div class="token-line"><span class="token plain">            if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {</span></div><div class="token-line"><span class="token plain">                if(rfs_strcmp(dirp-&gt;rdr_name,fname) == 1) {//比较其文件名</span></div><div class="token-line"><span class="token plain">                    rets = 1; goto err;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            dirp++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = 0; //到了这里说明没有找到相同的文件</span></div><div class="token-line"><span class="token plain">    err:</span></div><div class="token-line"><span class="token plain">        del_rootdirfile_blk(devp,rdblkp);//释放根目录文件</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，rfs_chkfileisindev函数逻辑很简单。首先是检查文件名的长度，接着获取了根目录文件，然后遍历根其中的所有rfsdir_t结构并比较文件名是否相同，相同就返回1，不同就返回其它值，最后释放了根目录文件。</p><p>因为get_rootdirfile_blk函数已经把根目录文件读取到内存里了，所以可以用dirp指针和maxchkp指针操作其中的数据。</p><p>好了，操作根目录文件、获取文件名、判断一个文件是否存在的三大函数就实现了，有了它们，再去实现文件相关的其它操作就方便多了，我们接着探索。</p><h2 id="文件相关的操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#文件相关的操作"><span class="icon icon-link"></span></a>文件相关的操作</h2><p>直到现在，我们还没对任何文件进行操作，而我们实现文件系统，就是为了应用程序更好地存放自己的“劳动成果”——文件，因此一个文件系统必须要支持一些文件操作。</p><p>下面我们将依次实现新建、删除、打开、读写以及关闭文件，这几大文件操作，这也是文件系统需要提供的最基本的功能。</p><h3 id="新建文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#新建文件"><span class="icon icon-link"></span></a>新建文件</h3><p>在没有文件之前，对任何文件本身的操作都是无效的，所以我们首先就要实现新建文件这个功能。</p><p>在写代码之前，我们还是先来看一看如何新建一个文件，一共可以分成后面这4步。</p><p>1.从文件路径名中提取出纯文件名，检查储存设备上是否已经存在这个文件。<br/>2.分配一个空闲的逻辑储存块，并在根目录文件的末尾写入这个新建文件对应的rfsdir_t结构。<br/>3.在一个新的4KB大小的缓冲区中，初始化新建文件对应的fimgrhd_t结构。<br/>4.把第3步对应的缓冲区里的数据，写入到先前分配的空闲逻辑储存块中。</p><p>下面我们先来写好新建文件的接口函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//新建文件的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_new_file(device_t* devp, char_t* fname, uint_t flg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //在栈中分配一个字符缓冲区并清零</span></div><div class="token-line"><span class="token plain">        char_t fne[DR_NM_MAX];</span></div><div class="token-line"><span class="token plain">        hal_memset((void*)fne, DR_NM_MAX, 0);</span></div><div class="token-line"><span class="token plain">        //从文件路径名中提取出纯文件名</span></div><div class="token-line"><span class="token plain">        if(rfs_ret_fname(fne, fname) != 0) { return DFCERRSTUS; }</span></div><div class="token-line"><span class="token plain">        //检查储存介质上是否已经存在这个新建的文件，如果是则返回错误</span></div><div class="token-line"><span class="token plain">        if(rfs_chkfileisindev(devp, fne) != 0) {return DFCERRSTUS; }</span></div><div class="token-line"><span class="token plain">        //调用实际建立文件的函数</span></div><div class="token-line"><span class="token plain">        return rfs_new_dirfileblk(devp, fne, RDR_FIL_TYPE, 0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们在新建文件的接口函数中，就实现了前面第一步，完成了提取文件名和检查文件是否在储存设备中存在的工作。接着我们来实现真正新建文件的函数，就是上述代码中rfs_new_dirfileblk函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_new_dirfileblk(device_t* devp,char_t* fname,uint_t flgtype,uint_t val)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        drvstus_t rets = DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        void* buf = new_buf(FSYS_ALCBLKSZ);//分配一个4KB大小的缓冲区    </span></div><div class="token-line"><span class="token plain">        hal_memset(buf, FSYS_ALCBLKSZ, 0);//清零该缓冲区</span></div><div class="token-line"><span class="token plain">        uint_t fblk = rfs_new_blk(devp);//分配一个新的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">        void* rdirblk = get_rootdirfile_blk(devp);//获取根目录文件</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)rdirblk;</span></div><div class="token-line"><span class="token plain">        //指向文件当前的写入地址，因为根目录文件已经被读取到内存中了</span></div><div class="token-line"><span class="token plain">        rfsdir_t* wrdirp = (rfsdir_t*)((uint_t)rdirblk + fmp-&gt;fmd_curfinwbkoff);</span></div><div class="token-line"><span class="token plain">        //对文件当前的写入地址进行检查</span></div><div class="token-line"><span class="token plain">        if(((uint_t)wrdirp) &gt;= ((uint_t)rdirblk + FSYS_ALCBLKSZ)) {</span></div><div class="token-line"><span class="token plain">            rets=DFCERRSTUS; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        wrdirp-&gt;rdr_stus = 0;</span></div><div class="token-line"><span class="token plain">        wrdirp-&gt;rdr_type = flgtype;//设为文件类型</span></div><div class="token-line"><span class="token plain">        wrdirp-&gt;rdr_blknr = fblk;//设为刚刚分配的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">        rfs_strcpy(fname, wrdirp-&gt;rdr_name);//把文件名复制到rfsdir_t结构</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_filesz += (uint_t)(sizeof(rfsdir_t));//增加根目录文件的大小</span></div><div class="token-line"><span class="token plain">        //增加根目录文件当前的写入地址，保证下次不被覆盖</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_curfinwbkoff += (uint_t)(sizeof(rfsdir_t));</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* ffmp = (fimgrhd_t*)buf;//指向新分配的缓冲区</span></div><div class="token-line"><span class="token plain">        fimgrhd_t_init(ffmp);//调用fimgrhd_t结构默认的初始化函数</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_type = FMD_FIL_TYPE;//因为建立的是文件，所以设为文件类型</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_sfblk = fblk;//把自身所在的块，设为分配的逻辑储存块</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_curfwritebk = fblk;//把当前写入的块，设为分配的逻辑储存块</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_curfinwbkoff = 0x200;//把当前写入块的写入偏移量设为512</span></div><div class="token-line"><span class="token plain">        //把文件储存块数组的第1个元素的开始块，设为刚刚分配的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_fleblk[0].fb_blkstart = fblk;</span></div><div class="token-line"><span class="token plain">        //因为只分配了一个逻辑储存块，所以设为1</span></div><div class="token-line"><span class="token plain">        ffmp-&gt;fmd_fleblk[0].fb_blknr = 1;</span></div><div class="token-line"><span class="token plain">        //把缓冲区中的数据写入到刚刚分配的空闲逻辑储存块中</span></div><div class="token-line"><span class="token plain">        if(write_rfsdevblk(devp, buf, fblk) == DFCERRSTUS) { 			</span></div><div class="token-line"><span class="token plain">            rets = DFCERRSTUS; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    err:</span></div><div class="token-line"><span class="token plain">        del_rootdirfile_blk(devp, rdirblk);//释放根目录文件</span></div><div class="token-line"><span class="token plain">    err1:</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);//释放缓冲区</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看完上述代码，我想提醒你，在rfs_new_dirfileblk函数中有两点很关键。</p><p>第一，前面反复提到的目录文件中存放的就是<strong>一系列的rfsdir_t结构</strong>。</p><p>第二，fmp和ffmp这两个指针很重要。fmp指针指向的是根目录文件的fimgrhd_t结构，因为要写入一个新的rfsdir_t结构，所以要获取并改写根目录文件的fimgrhd_t结构中的数据。而ffmp指针指向的是新建文件的fimgrhd_t结构，并且初始化了其中的一些数据。最后，该函数把这个缓冲区中的数据写入到分配的空闲逻辑储存块中，同时释放了根目录文件和缓冲区。</p><h3 id="删除文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#删除文件"><span class="icon icon-link"></span></a>删除文件</h3><p>新建文件的操作完成了，下面我们来实现删除文件的操作。</p><p>如果只能新建文件而不能删除文件，那么储存设备的空间最终会耗尽，所以文件系统就必须支持删除文件的操作。</p><p>同样的，还是先来了解删除文件的方法。删除文件可以通过后面这4步来实现。</p><p>1.从文件路径名中提取出纯文件名。<br/>2.获取根目录文件，从根目录文件中查找待删除文件的rfsdir_t结构，然后释放该文件占用的逻辑储存块。<br/>3.初始化与待删除文件相对应的rfsdir_t结构，并设置rfsdir_t结构的类型为RDR_DEL_TYPE。<br/>4.释放根目录文件。</p><p>这次我们用三个函数来实现这些步骤，删除文件的接口函数的代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//文件删除的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_del_file(device_t* devp, char_t* fname, uint_t flg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if(flg != 0) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return rfs_del_dirfileblk(devp, fname, RDR_FIL_TYPE, 0);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>删除文件的接口函数非常之简单，就是判断一下标志，接着调用了rfs_del_dirfileblk函数，下面我们就来写好这个rfs_del_dirfileblk函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_del_dirfileblk(device_t* devp, char_t* fname, uint_t flgtype, uint_t val)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        if(flgtype != RDR_FIL_TYPE || val != 0) { return DFCERRSTUS; }</span></div><div class="token-line"><span class="token plain">        char_t fne[DR_NM_MAX];</span></div><div class="token-line"><span class="token plain">        hal_memset((void*)fne, DR_NM_MAX, 0);</span></div><div class="token-line"><span class="token plain">        //提取纯文件名</span></div><div class="token-line"><span class="token plain">        if(rfs_ret_fname(fne,fname) != 0) { return DFCERRSTUS; }</span></div><div class="token-line"><span class="token plain">        //调用删除文件的核心函数</span></div><div class="token-line"><span class="token plain">        if(del_dirfileblk_core(devp, fne) != 0) { return DFCERRSTUS; }</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>rfs_del_dirfileblk函数只是提取了文件名，然后调用了一个删除文件的核心函数，这个核心函数就是del_dirfileblk_core函数，它的实现代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//删除文件的核心函数</span></div><div class="token-line"><span class="token plain">    sint_t del_dirfileblk_core(device_t* devp, char_t* fname)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        sint_t rets = 6;</span></div><div class="token-line"><span class="token plain">        void* rblkp=get_rootdirfile_blk(devp);//获取根目录文件</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)rblkp;</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_type!=FMD_DIR_TYPE) { //检查根目录文件的类型</span></div><div class="token-line"><span class="token plain">            rets=4; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp; fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) { //检查根目录文件中有没有数据</span></div><div class="token-line"><span class="token plain">            rets = 3; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff);</span></div><div class="token-line"><span class="token plain">        void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ-1);</span></div><div class="token-line"><span class="token plain">        for(;(void*)dirp &lt; maxchkp;) {</span></div><div class="token-line"><span class="token plain">            if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {//检查其类型是否为文件类型</span></div><div class="token-line"><span class="token plain">                //如果文件名相同，就执行以下删除动作</span></div><div class="token-line"><span class="token plain">                if(rfs_strcmp(dirp-&gt;rdr_name, fname) == 1) {</span></div><div class="token-line"><span class="token plain">                    //释放rfsdir_t结构的rdr_blknr中指向的逻辑储存块</span></div><div class="token-line"><span class="token plain">                    rfs_del_blk(devp, dirp-&gt;rdr_blknr);</span></div><div class="token-line"><span class="token plain">                    //初始化rfsdir_t结构，实际上是清除其中的数据</span></div><div class="token-line"><span class="token plain">                    rfsdir_t_init(dirp);</span></div><div class="token-line"><span class="token plain">                    //设置rfsdir_t结构的类型为删除类型，表示它已经删除</span></div><div class="token-line"><span class="token plain">                    dirp-&gt;rdr_type = RDR_DEL_TYPE;</span></div><div class="token-line"><span class="token plain">                    rets = 0; goto err;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            dirp++;//下一个rfsdir_t</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets=1;</span></div><div class="token-line"><span class="token plain">    err:</span></div><div class="token-line"><span class="token plain">        del_rootdirfile_blk(devp,rblkp);//释放根目录文件</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中的del_dirfileblk_core函数，它主要是遍历根目录文件中所有的rfsdir_t结构，并比较其文件名，看看删除的文件名称是否相同，相同就释放该rfsdir_t结构的rdr_blknr字段对应的逻辑储存块，清除该rfsdir_t结构中的数据，同时设置该rfsdir_t结构的类型为删除类型。</p><p>你可以这样理解：删除一个文件，就是把这个文件对应的rfsdir_t结构中的数据清空，这样就无法查找到这个文件了。同时，也要释放该文件占用的逻辑储存块。因为没有清空文件数据，所以可以通过反删除软件找回文件。</p><h3 id="打开文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#打开文件"><span class="icon icon-link"></span></a>打开文件</h3><p>接下来，我们就要实现打开文件操作了。一个已经存在的文件，要对它进行读写操作，首先就应该打开这个文件。</p><p>在实现这个打开文件操作之前，我们不妨先回忆一下前面课程里提到的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/395772">objnode_t结构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>Cosmos内核上层组件调用设备驱动程序时，都需要建立一个相应的objnode_t结构，把这个I/O包发送给相应的驱动程序，但是objnode_t结构不仅仅是用于驱动程序，它还用于表示进程使用了哪些资源，例如打开了哪些设备或者文件，而每打开一个设备或者文件就建立一个objnode_t结构，放在特定进程的资源表中。</p><p>为了适应文件系统设备驱动程序，在cosmos/include/krlinc/krlobjnode_t.h文件中，需要在objnode_t结构中增加一些东西，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define OBJN_TY_DEV 1//设备类型</span></div><div class="token-line"><span class="token plain">    #define OBJN_TY_FIL 2//文件类型</span></div><div class="token-line"><span class="token plain">    #define OBJN_TY_NUL 0//默认类型</span></div><div class="token-line"><span class="token plain">    typedef struct s_OBJNODE</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t  on_lock;</span></div><div class="token-line"><span class="token plain">        list_h_t    on_list;</span></div><div class="token-line"><span class="token plain">        sem_t       on_complesem;</span></div><div class="token-line"><span class="token plain">        uint_t      on_flgs;</span></div><div class="token-line"><span class="token plain">        uint_t      on_stus;</span></div><div class="token-line"><span class="token plain">        //……</span></div><div class="token-line"><span class="token plain">        void*       on_fname;//文件路径名指针</span></div><div class="token-line"><span class="token plain">        void*       on_finode;//文件对应的fimgrhd_t结构指针</span></div><div class="token-line"><span class="token plain">        void*       on_extp;//扩展所用</span></div><div class="token-line"><span class="token plain">    }objnode_t;</span></div></pre></div><p>上述代码中objnode_t结构里增加了两个字段，一个是指向文件路径名的指针，表示打开哪个文件。因为要知道一个文件的所有信息，所以增加了指向对应文件的fimgrhd_t结构指针，也就是我们增加的第二个字段。</p><p>现在我们来看看打开一个文件的流程。一共也是4步。</p><p>1.从objnode_t结构的文件路径提取文件名。<br/>2.获取根目录文件，在该文件中搜索对应的rfsdir_t结构，看看文件是否存在。<br/>3.分配一个4KB缓存区，把该文件对应的rfsdir_t结构中指向的逻辑储存块读取到缓存区中，然后释放根目录文件。<br/>4.把缓冲区中的fimgrhd_t结构的地址，保存到objnode_t结构的on_finode域中。</p><p>下面来写两个函数实现这些流程，同样我们需要先写好接口函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//打开文件的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_open_file(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp = (objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //检查objnode_t中的文件路径名</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_fname == NULL) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //调用打开文件的核心函数</span></div><div class="token-line"><span class="token plain">        void* fmdp = rfs_openfileblk(devp, (char_t*)obp-&gt;on_fname);</span></div><div class="token-line"><span class="token plain">        if(fmdp == NULL) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //把返回的fimgrhd_t结构的地址保存到objnode_t中的on_finode字段中</span></div><div class="token-line"><span class="token plain">        obp-&gt;on_finode = fmdp;</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>接口函数rfs_open_file中只是对参数进行了检查。然后调用了核心函数，这个函数就是rfs_openfileblk，它的代码实现如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//打开文件的核心函数</span></div><div class="token-line"><span class="token plain">    void* rfs_openfileblk(device_t *devp, char_t* fname)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        char_t fne[DR_NM_MAX]; void* rets = NULL,*buf = NULL;</span></div><div class="token-line"><span class="token plain">        hal_memset((void*)fne,DR_NM_MAX,0);</span></div><div class="token-line"><span class="token plain">        if(rfs_ret_fname(fne, fname) != 0) {//从文件路径名中提取纯文件名</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        void* rblkp = get_rootdirfile_blk(devp); //获取根目录文件</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)rblkp;</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_type != FMD_DIR_TYPE) {//判断根目录文件的类型是否合理 </span></div><div class="token-line"><span class="token plain">            rets = NULL; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //判断根目录文件里有没有数据</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_curfwritebk == fmp-&gt;fmd_fleblk[0].fb_blkstart &amp;&amp; </span></div><div class="token-line"><span class="token plain">    fmp-&gt;fmd_curfinwbkoff == fmp-&gt;fmd_fileifstbkoff) { </span></div><div class="token-line"><span class="token plain">            rets = NULL; goto err;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rfsdir_t* dirp = (rfsdir_t*)((uint_t)(fmp) + fmp-&gt;fmd_fileifstbkoff); </span></div><div class="token-line"><span class="token plain">        void* maxchkp = (void*)((uint_t)rblkp + FSYS_ALCBLKSZ - 1);</span></div><div class="token-line"><span class="token plain">        for(;(void*)dirp &lt; maxchkp;) {//开始遍历文件对应的rfsdir_t结构</span></div><div class="token-line"><span class="token plain">            if(dirp-&gt;rdr_type == RDR_FIL_TYPE) {</span></div><div class="token-line"><span class="token plain">                //如果文件名相同就跳转到opfblk标号处运行</span></div><div class="token-line"><span class="token plain">                if(rfs_strcmp(dirp-&gt;rdr_name, fne) == 1) {</span></div><div class="token-line"><span class="token plain">                    goto opfblk;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            dirp++;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //如果到这里说明没有找到该文件对应的rfsdir_t结构，所以设置返回值为NULL</span></div><div class="token-line"><span class="token plain">        rets = NULL; goto err;</span></div><div class="token-line"><span class="token plain">    opfblk:</span></div><div class="token-line"><span class="token plain">        buf = new_buf(FSYS_ALCBLKSZ);//分配4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        //读取该文件占用的逻辑储存块</span></div><div class="token-line"><span class="token plain">        if(read_rfsdevblk(devp, buf, dirp-&gt;rdr_blknr) == DFCERRSTUS) {</span></div><div class="token-line"><span class="token plain">            rets = NULL; goto err1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* ffmp = (fimgrhd_t*)buf;</span></div><div class="token-line"><span class="token plain">        if(ffmp-&gt;fmd_type == FMD_NUL_TYPE || ffmp-&gt;fmd_fileifstbkoff != 0x200) {//判断将要打开的文件是否合法</span></div><div class="token-line"><span class="token plain">            rets = NULL; goto err1;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = buf; goto err;//设置缓冲区首地址为返回值</span></div><div class="token-line"><span class="token plain">    err1:</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ); //上面的步骤若出现问题就要释放缓冲区</span></div><div class="token-line"><span class="token plain">    err:</span></div><div class="token-line"><span class="token plain">        del_rootdirfile_blk(devp, rblkp); //释放根目录文件</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>结合上面的代码我们能够看到，通过rfs_openfileblk函数中的for循环，可以遍历要打开的文件在根目录文件中对应的rfsdir_t结构，然后把对应文件占用的逻辑储存块读取到缓冲区中，最后返回这个缓冲区的首地址。</p><p>因为这个缓冲区开始的空间中，就存放着其文件对应的fimgrhd_t结构，所以返回fimgrhd_t结构的地址，整个打开文件的流程就结束了。</p><h3 id="读写文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#读写文件"><span class="icon icon-link"></span></a>读写文件</h3><p>刚才我们已经实现了打开文件， 而打开一个文件，就是为了对这个文件进行读写。</p><p>其实对文件的读写包含两个操作，一个是从储存设备中读取文件的数据，另一个是把文件的数据写入到储存设备中。</p><p>咱们先来看看如何读取已经打开的文件中的数据，大致的流程如下。</p><p>1.检查objnode_t结构中用于存放文件数据的缓冲区及其大小。<br/>2.检查imgrhd_t结构中文件相关的信息。<br/>3.把文件的数据读取到objnode_t结构中指向的缓冲区中。</p><p>通过后面的代码，我们把读文件的接口函数跟核心函数一起实现。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//读取文件数据的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_read_file(device_t* devp,void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp = (objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) { </span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS; </span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return rfs_readfileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //实际读取文件数据的函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_readfileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //检查文件的相关信息是否合理</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //检查读取文件数据的长度是否大于（4096-512）</span></div><div class="token-line"><span class="token plain">        if(len &gt; (FSYS_ALCBLKSZ - fmp-&gt;fmd_fileifstbkoff)) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //指向文件数据的开始地址</span></div><div class="token-line"><span class="token plain">        void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_fileifstbkoff);</span></div><div class="token-line"><span class="token plain">        //把文件开始处的数据复制len个字节到buf指向的缓冲区中</span></div><div class="token-line"><span class="token plain">        hal_memcpy(wrp, buf, len); </span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中读取文件数据的函数很简单，关键是要明白前面那个打开文件的函数，因为在那里它已经把文件数据复制到一个缓冲区中了，rfs_readfileblk函数中的参数buf、len都是接口函数rfs_read_file从objnode_t结构中提取出来的，其它的部分我已经通过注释已经说明了。</p><p>好了，我们下面就来实现怎么向文件中写入数据，和读取文件的流程一样，只不过要将要写入的数据复制到打开文件时为其分配的缓冲区中，最后还要把打开文件时为其分配的缓冲区中的数据，写入到相应的逻辑储存块中。</p><p>我们还是把写文件的接口函数和核心函数一起实现，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//写入文件数据的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_write_file(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp = (objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_finode == NULL || obp-&gt;on_buf == NULL || obp-&gt;on_bufsz != FSYS_ALCBLKSZ) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return rfs_writefileblk(devp, (fimgrhd_t*)obp-&gt;on_finode, obp-&gt;on_buf, obp-&gt;on_len);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //实际写入文件数据的函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_writefileblk(device_t* devp, fimgrhd_t* fmp, void* buf, uint_t len)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //检查文件的相关信息是否合理</span></div><div class="token-line"><span class="token plain">        if(fmp-&gt;fmd_sfblk != fmp-&gt;fmd_curfwritebk || fmp-&gt;fmd_curfwritebk != fmp-&gt;fmd_fleblk[0].fb_blkstart) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //检查当前将要写入数据的偏移量加上写入数据的长度，是否大于等于4KB</span></div><div class="token-line"><span class="token plain">        if((fmp-&gt;fmd_curfinwbkoff + len) &gt;= FSYS_ALCBLKSZ) {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //指向将要写入数据的内存空间</span></div><div class="token-line"><span class="token plain">        void* wrp = (void*)((uint_t)fmp + fmp-&gt;fmd_curfinwbkoff);</span></div><div class="token-line"><span class="token plain">        //把buf缓冲区中的数据复制len个字节到wrp指向的内存空间中去</span></div><div class="token-line"><span class="token plain">        hal_memcpy(buf, wrp, len);</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_filesz += len;//增加文件大小</span></div><div class="token-line"><span class="token plain">        //使fmd_curfinwbkoff指向下一次将要写入数据的位置</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_curfinwbkoff += len;</span></div><div class="token-line"><span class="token plain">        //把文件数据写入到相应的逻辑储存块中，完成数据同步</span></div><div class="token-line"><span class="token plain">        write_rfsdevblk(devp, (void*)fmp, fmp-&gt;fmd_curfwritebk);</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，你要注意的是，<strong>rfs_writefileblk函数永远都是从fimgrhd_t 结构的fmd_curfinwbkoff字段中的偏移量开始写入文件数据的</strong>，比如向空文件中写入2个字节，那么其fmd_curfinwbkoff字段的值就是2，因为第0、1个字节空间已经被占用了，这就是<strong>追加写入数据</strong>的方式。</p><p>rfs_writefileblk函数最后调用write_rfsdevblk函数把文件数据写入到相应的逻辑储存块中，完成数据同步。我们发现只要打开文件了，读写文件还是很简单的，最后还要实现关闭文件的操作。</p><h3 id="关闭文件"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#关闭文件"><span class="icon icon-link"></span></a>关闭文件</h3><p>有打开文件的操作，就需要有关闭文件的操作，因为打开一个文件，会为此分配一个缓冲区，这些都是系统资源，所以需要一个关闭文件的操作来释放这些资源，以防止系统资源泄漏。</p><p>关闭文件的流程很简单，首先检查文件是否已经打开。然后把文件写入到对应的逻辑储存块中，完成数据的同步。最后释放文件数据占用的缓冲区。下面我们开始写代码实现，我们依然把接口和核心函数放在一起实现，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//关闭文件的接口函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_close_file(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp = (objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //检查文件是否已经打开了</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_finode == NULL) { </span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return rfs_closefileblk(devp, obp-&gt;on_finode);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //关闭文件的核心函数</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_closefileblk(device_t *devp, void* fblkp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //指向文件的fimgrhd_t结构</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)fblkp;</span></div><div class="token-line"><span class="token plain">        //完成文件数据的同步</span></div><div class="token-line"><span class="token plain">        write_rfsdevblk(devp, fblkp, fmp-&gt;fmd_sfblk);</span></div><div class="token-line"><span class="token plain">        //释放缓冲区</span></div><div class="token-line"><span class="token plain">        del_buf(fblkp, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码是非常简单的，但在目前的情况下，rfs_closefileblk函数中是没有必要调用write_rfsdevblk函数的，因为前面在写入文件数据的同时，就已经把文件的数据写入到逻辑储存块中去了。最后释放了先前打开文件时分配的缓冲区，而objnode_t结构不应该在此释放，它是由Cosmos内核上层组件进行释放的。</p><h2 id="串联整合"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#串联整合"><span class="icon icon-link"></span></a>串联整合</h2><p>到目前为止，我们实现了文件相关的操作，并且提供了接口函数，但是我们的文件系统是以设备的形式存在的，所以文件操作的接口，必须要串联整合到文件系统设备驱动程序之中，文件系统才能真正工作。</p><p>下面我们就去整合联串文件系统设备驱动程序。首先来串联整合文件系统的打开文件操作和新建文件操作，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_open(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp=(objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //根据objnode_t结构中的访问标志进行判断</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_OPEFILE) {</span></div><div class="token-line"><span class="token plain">            return rfs_open_file(devp, iopack);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_acsflgs == FSDEV_OPENFLG_NEWFILE) {</span></div><div class="token-line"><span class="token plain">            return rfs_new_file(devp, obp-&gt;on_fname, 0);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中rfs_open函数对应于设备驱动程序的打开功能派发函数，但没有相应的新建功能派发函数，于是我们就根据objnode_t结构中访问标志域设置不同的编码，来进行判断。</p><p>接着我们来串联整合关闭文件的操作。这次要简单一些，因为设备驱动程序有对应的关闭功能派发函数，直接调用关闭文件操作的接口函数就可以了，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_close(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return rfs_close_file(devp, iopack);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后是文件读写操作的串联整合，设备驱动程序也有对应的读写功能派发函数，同样也是直接调用文件读写操作的接口函数即可，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_read(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //调用读文件操作的接口函数</span></div><div class="token-line"><span class="token plain">        return rfs_read_file(devp, iopack);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_write(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //调用写文件操作的接口函数</span></div><div class="token-line"><span class="token plain">        return rfs_write_file(devp, iopack);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>最后，来串联整合稍微有点复杂的删除文件操作，这是因为设备驱动程序没有对应的功能派发函数，所以我们需要用到设备驱动程序的控制功能派发函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_ioctrl(device_t* devp, void* iopack)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        objnode_t* obp = (objnode_t*)iopack;</span></div><div class="token-line"><span class="token plain">        //根据objnode_t结构中的控制码进行判断</span></div><div class="token-line"><span class="token plain">        if(obp-&gt;on_ioctrd == FSDEV_IOCTRCD_DELFILE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //调用删除文件操作的接口函数</span></div><div class="token-line"><span class="token plain">            return rfs_del_file(devp, obp-&gt;on_fname, 0);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，我们给文件系统设备分配了一个FSDEV_IOCTRCD_DELFILE（一个整数）控制码，Cosmos内核上层组件的代码就可以根据需要，设置objnode_t结构中的控制码就能达到相应的目的了。</p><p>现在，文件相关的操作已经串联整合好了。</p><h2 id="测试"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#测试"><span class="icon icon-link"></span></a>测试</h2><p>前面实现了文件系统的6种最常用的文件操作，并且已经整合到文件系统设备驱动程序框架代码中去了，可是这些代码究竟对不对，测试运行了才知道。</p><p>下面来写好测试代码。要注意的是，Cosmos下的任何设备驱动程序<strong>都必须要有objnode_t结构才能运行</strong>。所以，在这里我们需要手动建立一个objnode_t结构并设置好其中的字段，模拟一下Cosmos上层组件调用设备驱动程序的过程。</p><p>这一过程我们可以写个test_fsys函数来实现，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void test_fsys(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kprint(&quot;开始文件操作测试\n&quot;);</span></div><div class="token-line"><span class="token plain">        void *rwbuf = new_buf(FSYS_ALCBLKSZ);//分配缓冲区</span></div><div class="token-line"><span class="token plain">        //把缓冲区中的所有字节都置为0xff</span></div><div class="token-line"><span class="token plain">        hal_memset(rwbuf, 0xff, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        objnode_t *ondp = krlnew_objnode();//新建一个objnode_t结构</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_acsflgs = FSDEV_OPENFLG_NEWFILE;//设置新建文件标志</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_fname = &quot;/testfile&quot;;//设置新建文件名</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_buf = rwbuf;//设置缓冲区</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_bufsz = FSYS_ALCBLKSZ;//设置缓冲区大小</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_len = 512;//设置读写多少字节</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_ioctrd = FSDEV_IOCTRCD_DELFILE;//设置控制码</span></div><div class="token-line"><span class="token plain">        if (rfs_open(devp, ondp) == DFCERRSTUS) {//新建文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;新建文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//设置打开文件标志</span></div><div class="token-line"><span class="token plain">        if (rfs_open(devp, ondp) == DFCERRSTUS) {//打开文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;打开文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (rfs_write(devp, ondp) == DFCERRSTUS) {//把数据写入文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;写入文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        hal_memset(rwbuf, 0, FSYS_ALCBLKSZ);//清零缓冲区</span></div><div class="token-line"><span class="token plain">        if (rfs_read(devp, ondp) == DFCERRSTUS) {//读取文件数据</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;读取文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (rfs_close(devp, ondp) == DFCERRSTUS) {//关闭文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;关闭文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        u8_t *cb = (u8_t *)rwbuf;//指向缓冲区</span></div><div class="token-line"><span class="token plain">        for (uint_t i = 0; i &lt; 512; i++) {//检查缓冲区空间中的头512个字节的数据，是否为0xff</span></div><div class="token-line"><span class="token plain">            if (cb[i] != 0xff) {//如果不等于0xff就死机</span></div><div class="token-line"><span class="token plain">                hal_sysdie(&quot;检查文件内容错误&quot;);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            kprint(&quot;testfile文件第[%x]个字节数据:%x\n&quot;, i, (uint_t)cb[i]);//打印文件内容</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (rfs_ioctrl(devp, ondp) == DFCERRSTUS){//删除文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;删除文件错误&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        ondp-&gt;on_acsflgs = FSDEV_OPENFLG_OPEFILE;//再次设置打开文件标志</span></div><div class="token-line"><span class="token plain">        if (rfs_open(devp, ondp) == DFCERRSTUS) {//再次打开文件</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;再次打开文件失败&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        hal_sysdie(&quot;结束文件操作测试&quot;);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码虽然有点长，因为我们一下子测试了关于文件的6大操作。每个文件操作失败后都会死机，不会继续向下运行。</p><p>测试逻辑很简单：开始会建立并打开一个文件，接着写入数据，然后读取文件中数据进行比较，看看是不是和之前写入的数据相等，最后删除这个文件并再次打开，看是否会出错。因为文件已经删除了，打开一个已经删除的文件自然要出错，出错就说明测试成功。</p><p>现在我们把test_fsys函数放在rfs_entry函数的最后调用，然后打开终端切换到cosmos目录下执行make vboxtest 命令，最后不出意外的话，你会看到如下图所示的情况。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageedd4eddb4f92fd55c34113ba55c81e2b95d4.bf2ff1db.jpg" alt="" title="文件操作测试示意图"/></p><p>从图里我们能看到，文件中的数据和最后重新打开已经删除文件时出现的错误，这说明了我们的代码是正确无误的。</p><p>至此 ，测试了文件相关的6大操作的代码，代码质量都是相当高的，都达到了我们的预期，一个简单、有诸多限制但却五脏俱全的文件系统就实现了。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>这节课告一段落，恭喜你坚持到这里。</p><p>文件系统虽然复杂，但我们发现只要做得足够“小”，就能大大降低了实现的难度。虽然降低了实现的难度，但我们的rfs文件系统依然包含了一个正常文件系统所具有的功能特性，现在我来为你梳理一下本节课的重点：</p><p>1.首先是文件系统的辅助操作，因为文件系统的复杂性，所以必须要实现一些如获取与释放根目录文件、获取文件名、判断文件是否存在等基础辅助操作函数。</p><p>2.然后实现了文件系统必须要提供的6大文件操作：<strong>新建文件、删除文件、打开文件、读写文件、关闭文件</strong>。</p><p>3.最后把这些文件操作全部串联整合到文件系统设备驱动程序之中，并且进行了测试，确认代码正确无误。</p><p>今天这节课，我们又实现了Cosmos内核的一个基础组件，即文件系统，不过它是以<strong>设备的形式</strong>存在的，这样做是为了方便以后的扩展和移植。</p><p>现在文件系统是实现了，不过还不够完善。你可能在想，我们文件系统在内存中，一断电数据就全完了。是的，不过你可以尝试写好硬盘驱动，然后把内存中的逻辑储存块写入到硬盘中就行了，期待你的实现。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战/10.银行仓库文件系统/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请你想一想，我们这个简单的、小的，却五脏俱全的文件系统有哪些限制？</p><p>欢迎你在留言区记录你的收获或疑问，也鼓励你边学边练，多多动手实践。同时我推荐你把这节课分享给身边的朋友，跟他一起学习进步。</p><p>好，我是LMOS，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战/10.银行仓库文件系统/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:22:05</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
