<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>12 | 面试实战：经典排序算法面试题详解 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/常用算法25讲/02.排序篇/12" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/常用算法25讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/常用算法25讲/01.开篇词/01"><span>开篇词 | 解决这三个误区，才能真正学好算法！</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲/02.排序篇">02.排序篇</a><ul><li><a href="/blog-base/常用算法25讲/02.排序篇/01"><span>01 | 理解快排：打通算法学习的任督二脉</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/02"><span>02 | 快排优化：举一反三，轻松面对快排面试题</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/03"><span>03 | 二叉堆：动态维护集合最值的利器</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/04"><span>04 | 堆排序：体会线性建堆法的威力</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/05"><span>05 | 堆排序面试题：如何维护Top-K元素和中位数？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/06"><span>06 | 线程池基础：如何用线程池设计出更“优美”的代码？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/07"><span>07 | 封装线程池（上）：初探泛型编程</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/08"><span>08 | 封装线程池（下）：从0到1，体验程序设计全过程</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/09"><span>09 | 归并排序：如何解决逆序数问题？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/10"><span>10 | 多路归并排序：如何解决搜索引擎中的大数据排序问题？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/11"><span>11 | 算法思维：融汇贯通，教你3个有趣的排序算法</span></a></li><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲/02.排序篇/12"><span>12 | 面试实战：经典排序算法面试题详解</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇">03.查找搜索篇</a><ul><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/01"><span>13 | 树结构基础：二叉树结构及其基础操作</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/02"><span>14 | 二叉排序树：如何动态查找第k大元素？</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/03"><span>15 |  AVL树：如何让二叉排序树永远保持最优？</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/04"><span>16 | 红黑树（上）：红黑树基础与插入调整操作</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/05"><span>17 | 红黑树（下）：红黑树的双黑节点与删除调整</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/06"><span>18 | 哈希表：文件的身份认证系统是如何实现的？</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/07"><span>19 | 深度优先搜索：理解搜索状态树，快速输出序列的排列组合</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/08"><span>20 | 广度优先搜索：如何快速解决迷宫问题？</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/04.国庆策划">04.国庆策划</a><ul><li><a href="/blog-base/常用算法25讲/04.国庆策划/01"><span>期中测试 | 一套习题，测出你的掌握程度</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/02"><span>期中测试题答案 | 这些问题，你都答对了吗？</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/03"><span>常见算法面试题，等你来挑战！</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/04"><span>这些常见算法面试题，你会解了吗？</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-base/常用算法25讲/05.进阶篇/01"><span>21 | 深度优先搜索进阶：数独游戏如何快速求解?</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/02"><span>22 | 排序与查找：抓住关键，2-Sum问题的多种解法</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/03"><span>23 | 位运算：位=数据结构，算=算法</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/04"><span>24 | 牛顿迭代：如何用O(1)的时间复杂度求sqrt？</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/05"><span>25 | 毕业设计：用O(1)的时间复杂度计算整数末尾0的数量</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/06.结束语">06.结束语</a><ul><li><a href="/blog-base/常用算法25讲/06.结束语/01"><span>结束语 | 不忘初心，方得始终</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/summary">常用算法25讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="磨刀不误砍柴工：C++中sort的用法" data-depth="2"><a href="/blog-base/常用算法25讲/02.排序篇/12#磨刀不误砍柴工c中sort的用法"><span>磨刀不误砍柴工：C++中sort的用法</span></a></li><li title="动态数组 vector 的排序" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#动态数组-vector-的排序"><span>动态数组 vector 的排序</span></a></li><li title="排序规则的指定：sort 隐藏的第三个参数" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#排序规则的指定sort-隐藏的第三个参数"><span>排序规则的指定：sort 隐藏的第三个参数</span></a></li><li title="经典面试题详解" data-depth="2"><a href="/blog-base/常用算法25讲/02.排序篇/12#经典面试题详解"><span>经典面试题详解</span></a></li><li title="1. 2-sum问题" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#1-2-sum问题"><span>1. 2-sum问题</span></a></li><li title="2. 存在重复元素" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#2-存在重复元素"><span>2. 存在重复元素</span></a></li><li title="3. 两个数组的交集" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#3-两个数组的交集"><span>3. 两个数组的交集</span></a></li><li title="4. 合并两个有序的数组" data-depth="3"><a href="/blog-base/常用算法25讲/02.排序篇/12#4-合并两个有序的数组"><span>4. 合并两个有序的数组</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/常用算法25讲/02.排序篇/12#课程小结"><span>课程小结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog-base/常用算法25讲/02.排序篇/12#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--面试实战经典排序算法面试题详解"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#12--面试实战经典排序算法面试题详解"><span class="icon icon-link"></span></a>12 | 面试实战：经典排序算法面试题详解</h1><p>你好，我是胡光，欢迎回来。</p><p>这个模块，我们主要讲了快速排序、堆排序、归并排序，以及几个有趣排序算法的原理。我相信，你也已经理解排序算法在整个计算机算法大厦中基础且重要的地位了。在我们实际编写程序的过程中，排序算法的应用无处不在。比如说，排序计数可以利用有限的空间消耗，来统计序列中每个词出现的次数。再比如说，处理大数据时的 map-reduce也频繁用到了排序算法。这都说明充分利用数据的有序性质，能让我们要做的事儿变得更简单。</p><p>不仅如此，排序算法的原理和应用也经常作为考点，出现在基础算法面试中。所以今天，我们就来看几道经典排序面试题，让你从真正的算法面试题中积累经验。</p><h2 id="磨刀不误砍柴工c中sort的用法"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#磨刀不误砍柴工c中sort的用法"><span class="icon icon-link"></span></a>磨刀不误砍柴工：C++中sort的用法</h2><p>我们现在使用的主流编程语言中，大部分都已经把时间复杂度稳定在$O(n \times log_2n)$的排序算法实现好了，所以我们在实际编程中不必自己去实现各类排序算法。C++ STL中的sort就是这样一个成熟的模块。因此，在讲具体的面试题之前，我想先给你讲讲它的用法。</p><p>sort 函数是 C++ STL 的 algorithm 库中对线性序列的排序方法，sort 函数的作用是对一个序列进行本地升序排序。也就是说，我们只需要调用一下 sort 函数就可以完成升序排序。代码例子如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// example 1</span></div><div class="token-line"><span class="token plain">    #include &lt;algorithm&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">      	int a[100] = {11, 77, 45, 62, 35, 37, 11, 11, 52, 13};</span></div><div class="token-line"><span class="token plain">    		std::sort(a, a + 10);</span></div><div class="token-line"><span class="token plain">    		// a = {11, 11, 11, 13, 35, 37, 45, 52, 62, 77}</span></div><div class="token-line"><span class="token plain">      	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>但是你看到这段代码以后，可能就会有疑问了，调用sort 函数的时候，我们为什么要用sort(a, a + 10) 呢？它到底是什么意思呢？</p><p>要弄明白这个问题，我们首先要理解a的概念。数组a变量实际上就是这个数组在内存空间中的首地址，因此，例子中的整数型数组 a+10 指的就是，从a 地址出发向后跨了十个整数型变量的地址。那sort 函数的参数就非常好理解了，其中，第一个参数是序列中我们想要排序的首位置，第二个参数就是末位置。这里你要注意，末位置是不参与排序的。</p><p>明白了这一点之后，如果我想让你对数组中第2个数到第7个数进行排序，是不是就很简单了呢？没错，我们只需要把sort 函数后面的参数设置成a+1和a+8就行了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// example 2</span></div><div class="token-line"><span class="token plain">    #include &lt;algorithm&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">      	int a[100] = {11, 77, 45, 62, 35, 37, 11, 11, 52, 13};</span></div><div class="token-line"><span class="token plain">    		std::sort(a + 1, a + 8);</span></div><div class="token-line"><span class="token plain">    		// a == {11, 11, 11, 35, 37, 45, 62, 77, 52, 13}</span></div><div class="token-line"><span class="token plain">      	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="动态数组-vector-的排序"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#动态数组-vector-的排序"><span class="icon icon-link"></span></a>动态数组 vector 的排序</h3><p>除了数组以外，sort同样可以对序列容器进行排序，比如说 C++ STL 的 vector。不过，我们使用 sort 对 vector 排序的时候，需要借助到容器的迭代器。迭代器是 C++ 中模拟指针的方式，它的使用方式和指针类似，就是在C++ 中通过重载运算符封装的指针对象，它本质上还是一个对象，只是表现得像个指针，所以同样也支持指针的间接引用运算符和取值运算符。因此，vector 迭代器的使用方式和数组类似，我们可以直接把前面两个例子中的a换成vector。</p><p>我们再将 example-1 中的代码更改为 vector 的写法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// example 3</span></div><div class="token-line"><span class="token plain">    #include &lt;algorithm&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;vector&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">        int a[100] = {11, 77, 45, 62, 35, 37, 11, 11, 52, 13};</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; b(a, a + 10);</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 10; i += 1) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        // b.begin()指向的是b的首位置，b.end()指向的是b的末位置</span></div><div class="token-line"><span class="token plain">        std::sort(b.begin(), b.end()); </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 10; i += 1) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      	// 11 11 11 13 35 37 45 52 62 77</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们再将 example-2 中的代码更改为 vector 的写法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// example 4</span></div><div class="token-line"><span class="token plain">    #include &lt;algorithm&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;vector&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">        int a[100] = {11, 77, 45, 62, 35, 37, 11, 11, 52, 13};</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; b(a, a + 10);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //定义int容器的迭代器，并初始化到b的首位置</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt;::iterator iter = b.begin(); </span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 10; i += 1) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">        std::sort(iter + 1, iter + 8);</span></div><div class="token-line"><span class="token plain">      	</span></div><div class="token-line"><span class="token plain">        // 使用迭代器遍历容器的方法</span></div><div class="token-line"><span class="token plain">        for (iter = b.begin(); iter != b.end(); iter++) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      	</span></div><div class="token-line"><span class="token plain">        // 11 11 11 35 37 45 62 77 52 13</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我刚才说的呀，就是 sort 的基本用法了。但细心的你肯定也发现了，我前面讲的所有排序方法都是对序列升序排序，那如果我们想对序列降序排序，甚至是想要实现更加复杂的排序又该怎么办呢？</p><h3 id="排序规则的指定sort-隐藏的第三个参数"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#排序规则的指定sort-隐藏的第三个参数"><span class="icon icon-link"></span></a>排序规则的指定：sort 隐藏的第三个参数</h3><p>接下来，为了解决这个问题，我会给你讲sort 隐藏的第三个参数，比较规则函数。我们还是先看一个例子，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// example 5</span></div><div class="token-line"><span class="token plain">    #include &lt;algorithm&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;iostream&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;vector&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    bool comp(int a, int b) {</span></div><div class="token-line"><span class="token plain">        return a &gt; b;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">        int a[100] = {11, 77, 45, 62, 35, 37, 11, 11, 52, 13};</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt; b(a, a + 10);</span></div><div class="token-line"><span class="token plain">        std::vector&lt;int&gt;::iterator iter = b.begin();</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i &lt; 10; i += 1) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">        std::sort(b.begin(), b.end(), comp);</span></div><div class="token-line"><span class="token plain">        for (iter = b.begin(); iter != b.end(); iter++) {</span></div><div class="token-line"><span class="token plain">            std::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">      	// 77 62 52 45 37 35 13 11 11 11</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; std::endl;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，通过给 sort 函数传入一个比较大小的函数comp，我们就把前后两项的大小关系颠倒了，从而实现了降序排序。</p><p>所以，comp函数其实就是定义一种排序的规则，来比较它所接受的两个参数 a 和 b。最开始的时候， a 在原序列中排在 b 的前面，如果 a 与 b 的顺序不需要交换，函数就返回 true，如果需要交换就返回 false。</p><p>利用 <strong>comp</strong> 函数的这个性质， 我们就可以实现对复杂结构的排序，比如结构体、pair等等，我就不再多说了，你可以自己试试。</p><h2 id="经典面试题详解"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#经典面试题详解"><span class="icon icon-link"></span></a>经典面试题详解</h2><p>我相信，你现在已经知道怎样在C++中使用排序，来方便地实现一个有序的序列了。那接下来，我们就说说怎么利用排序以及有序序列的性质，来解决相关的面试题了。</p><p>不过啊，我想先和你聊聊我对面试的看法。我一直强调，在算法面试中题目的答案不是最重要的，理解面试官真正想要考察什么才重要。我认为面试题其实仅仅只是一种手段，面试官想要通过它来考察你内在的思维方式，看你是不是能把学过的算法灵活地提取成一种思维，应用在编程还有其他问题里。也就是说，<strong>面试考察的是思维能力，而不是记忆力</strong>。</p><p>所以在接下来讲解面试题的过程中，我会重点来讲怎么利用有序序列的特性来解决每一个相关的问题。</p><h3 id="1-2-sum问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#1-2-sum问题"><span class="icon icon-link"></span></a>1. 2-sum问题</h3><p>首先，我们来看2-sum问题。这道题是LeetCode题库中的第一题，如果你刷过题就肯定见过它。我们先来看一下这道题目：</p><blockquote><p>给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br/><br/>示例：<br/>给定 nums = [2, 7, 11, 15], target = 9<br/>因为 nums[0] + nums[1] = 2 + 7 = 9<br/>所以返回 [0, 1]</p></blockquote><p>在解决这道题之前，我们还得先来讲一个新的概念——杨氏矩阵。杨氏矩阵的性质是，它的每一行都是从左到右递增的，而每一列都是从上到下递增的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage435243a0d0fb820175ae299f8d7852fdd252.aeb69f9a.jpeg" alt="" title="杨氏矩阵示意图\n"/></p><p>那知道杨氏矩阵有什么用呢？我们来看一道经典的习题：给定一个杨氏矩阵和一个整数 x，问整数 x 是否在杨氏矩阵中。</p><p>它的解法是，我们从右上角开始查找，对于矩阵中的当前元素 a。如果 x&lt;a，那 x 不可能在 a 所在的那一列。如果 x&gt;a，那 x 不可能在 a 所在的那一行。当然相对称地，从左下角开始查找原则也是一样的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagef6d3f6a9c1547a91cd86aff9a377eaa256d3.0f045f1b.jpeg" alt=""/></p><p>你可以看到，在最差情况下，我们也只需要从一个角落走到另一个角落。假设矩阵的长度为 N，宽度为 M，那我们只需要进行 N+M 次比较，就可以找到目标值。可是杨氏矩阵问题跟 2-sum 问题又有什么关联呢？我们先接着往下看。</p><p>2-sum问题有一个非常经典的解法，就是给数组 a 排序，然后在数组的头部设置一个指针 p_head ，在数组的尾部设置一个指针p_tail 。如果两个指针所指位置的元素和大于目标值target ，那 p_tail向前挪动一步。如果二者相加的和小于目标值target，那p_head向后挪一步，直到找到等于目标值为止。这个做法我们叫它双指针法。</p><p>那我们为什么要这么做呢？其实对于2-sum问题来说，我们最直观的做法，就是先把这个数组中的所有元素两两加和，然后从这些结果中寻找目标值。因此，我们所需要的是一种高效的查找方式，而有序序列的查找方式就比直接枚举高效多了。</p><p>我们可以想象一个表格，将排好序的序列分别放在表格的首行和首列，表格中其他位置是对应首行、首列相加的和。这里，我们以2-sum问题中的数字为例。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage551255e3e66167c741a9a461f7c6c0f04312.53426b13.jpeg" alt=""/></p><p>你发现了吗？我们刚好构造了一个杨氏矩阵出来，这个矩阵中除红线所画过的对角线之外都是我们的搜索空间。而右上角或左下角的位置，也刚好就是 p_head和 p_tail 位置相加的和，所以两个指针的每一次移动，我们都可以看作是杨氏矩阵中的一个比较和移动的操作。那么实际上这道题的双指针做法，就可以看作是在生成的杨氏矩阵中查找目标值的位置并返回。</p><p>因为杨氏矩阵是数组元素两两之间计算得到的二维表格。所以，虽然双指针解法是在一维数组上操作的，但实际上它是一种二维思维。这类面试题实际上是在考察我们，优化这类求和查找的思路，让它变得更方便。因此，一个优秀的面试过程，往往考查的不是题目的答案，而是本质的思维方式。这也是为什么，有的时候我们虽然回答出了某些题目的正确答案，但面试官依然不满意。</p><h3 id="2-存在重复元素"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#2-存在重复元素"><span class="icon icon-link"></span></a>2. 存在重复元素</h3><p>2sum问题就讲完了，我们接着来看第二道题。</p><blockquote><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i - j 的 绝对值 至多为 k。<br/><br/>示例 1:<br/>输入: nums = [1,2,3,1], k = 3<br/>输出: true<br/><br/>示例 2:<br/>输入: nums = [1,0,1,1], k = 1<br/>输出: true<br/><br/>示例 3:<br/>输入: nums = [1,2,3,1,2,3], k = 2<br/>输出: false</p></blockquote><p>这道题中，首先让我们寻找的是数组中是否存在重复元素。很显然，我们通过排序或哈希计数的方式，都可以直接判断出数组中是否存在重复元素。由于，题目中同时要求重复元素索引之差的绝对值至多为k，因此，我们只需要判断数组中，两个距离最近的重复元素，是不是小于或者等于 k 就可以了。</p><p>知道了这些，我们再分别说说通过排序或哈希计数怎么解决这个问题</p><p>首先是<strong>排序法</strong>。我们知道，有序数组中重复元素的位置都是相邻的，所以我们只需要修改排序条件，让重复元素的索引是升序排列的即可。也就是说，我们只需要判断相邻的重复元素的索引之差是否小于等于 k 。</p><p>其次是哈希计数法。我们需要记录<strong>每一个元素最后出现的位置</strong>。哈希表中记录的索引值，就是在这个元素之前，离它最近的重复元素的索引值。这样一来，我们把它们之间的差和k比较就行了。</p><p>我们来做个总结，这类查找重复元素的题目，通常考查的是我们算法思维的广度，一道题目也会有很多种解法，解决方法的不同也反映了每个人思维方式的不同。因此，能够清楚每种解法的优劣性才是我们学习的重点。</p><h3 id="3-两个数组的交集"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#3-两个数组的交集"><span class="icon icon-link"></span></a>3. 两个数组的交集</h3><p>现在，找出存在重复元素的问题就解决了。我们再来看第三道题，求两个数组的交集 。题目是这样的：</p><blockquote><p>给定两个数组，请你编写一个函数来计算它们的交集。<br/><br/>示例 1：<br/>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br/>输出：[2,2]<br/><br/>示例 2：<br/>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br/>输出：[4,9]</p></blockquote><p>这个问题，我们同样可以利用有序序列的特性来尝试解决。具体怎么做呢？</p><p>假设，我们要在一个升序的序列中查找一个元素。对于某一个位置 x 来说，如果我们要查找的目标元素比它大，那目标元素必然不会存在于 x 的左边，这是二分法能够成立的条件。</p><p>求交集的问题，我们可以以在一个升序数组a 中查找另外一个数组 b 中包含的所有元素为例，如果我们按照升序顺序依次查找 b 中的每一个元素，每进行到下一次枚举的时候，新枚举到的元素也不可能存在于之前已经枚举过的地方。因此每一步都在缩小我们需要查找的边界。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagef638f6a86bbeb464c0a0546c149e3451d338.b42fdbee.jpeg" alt=""/></p><p>这样一来，这个问题其实也可以用双指针法来解决，具体解法是，我们先对数组 nums1 和 nums2 排序，然后分别在 nums1 和 nums2 的首部设置两个指针 p_nums1 和 p_nums2 。</p><ul><li>如果 nums1[p_nums1]&gt;nums2[p_nums2] ，就说明 nums1[p_nums1] 一定不在 p_nums2 及之前，那 p_nums2 就后移一步</li><li>如果 nums1[p_nums1]&lt;nums2[p_nums2] ，就说明 nums1[p_nums1] 一定不在 nums2 中，所以 p_nums1 后移一步</li><li>如 nums1[p_nums1]=nums2[p_nums2] ，就说明我们找到交集了，两个指针都后移一步就行了</li></ul><p>在整个查找过程中，由于两个数组都只遍历了一次，因此我们查找所用的时间复杂度是线性变化的。如果 nums1 的长度是N， nums2 的长度是M，那这个方法的时间消耗为$O(M\times log_2M+N \times log_2N+N+M)$。</p><h3 id="4-合并两个有序的数组"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#4-合并两个有序的数组"><span class="icon icon-link"></span></a>4. 合并两个有序的数组</h3><p>好了，第三道题也解决了，我们来看最后一道题，怎么合并两个有序数组。</p><blockquote><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。这里我要说明一点：初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br/><br/>示例：<br/>输入：<br/>nums1 = [1,2,3,0,0,0], m = 3<br/>nums2 = [2,5,6], n = 3<br/>输出：[1, 2, 2, 3, 5, 6]</p></blockquote><p>显而易见，这道题就是拆分了归并排序中的一个过程。我相信，在掌握了归并排序算法之后，你肯定能很快知道这道题的解法。</p><p>不过我们还看到，题面中还有一个条件，就是要在 nums1 中做原地合并，并且 nums1 中也预留了用来合并的足够空间。有了这个条件，这道题就和常规的归并排序有些不一样了。在原地合并的过程中，我们需要注意，不要覆盖掉 nums1 中已有的元素，破坏原数组。</p><p>具体怎么做呢？我们注意到， nums1 中预留的空间都集中在它的尾部，所以我们可以考虑优先把尾部的空位填满。这样一来，剩余头部位置就相当于是给剩余元素留出来的空位。因此，在这种情况下，我们就不需要担心原来 nums 中的元素会被覆盖掉。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>这节课，我们在实战中综合运用了学过的排序算法。通过这四道经典的排序面试题，我希望你能够充分意识到，利用有序序列可以简化我们所遇到的问题，比如，在求2-sum问题以及求两个数组的交集问题中，我们就是利用有序序列中最大值、最小值的边界，简化了问题的求解步骤，省去了很多不必要的工作。而在存在重复元素问题中，我们又利用了排序计数的方法，快速找出了问题的答案。</p><p>想要从本质上理解排序算法，我们还可以从另一个角度来看。我们都知道一个基础概念熵，它能表示一个体系的混乱程度。那排序算法从本质上来说，可以有效降低问题系统的熵，问题系统的熵越小也就越容易被解决。</p><p>总的来说，排序算法是性价比最高的一类算法，它不仅容易掌握，而且能解决的实际编程问题，远比我们目前看到的多。所以，学好排序真的“太划算”啦。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/02.排序篇/12#课后练习"><span class="icon icon-link"></span></a>课后练习</h2><ol><li>对于两个数组的交集和杨氏矩阵这两个问题，你有更快的解法吗？</li><li>在求两个数组的交集问题中，如果我们加上一些额外条件：</li></ol><ul><li>给定的数组已经排好序了，你又会怎么优化呢？</li><li>在nums1 比 nums2 小很多的时候，你觉得还有哪种方法是更优的解？</li><li>如果数组太大，内存也有限，你不能一次加载所有元素到内存里，这个时候又该怎么办呢？</li></ul><p>好了，我今天讲的这几道题，你都理解了吗？如果你的朋友也遇到了类似问题，那就快把这节课转发给他吧！今天就讲到这里了，我是胡光，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/常用算法25讲/02.排序篇/12.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:21:14</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
