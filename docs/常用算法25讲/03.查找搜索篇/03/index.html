<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>15 | AVL树：如何让二叉排序树永远保持最优？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/常用算法25讲/03.查找搜索篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/常用算法25讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/常用算法25讲/01.开篇词/01"><span>开篇词 | 解决这三个误区，才能真正学好算法！</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/02.排序篇">02.排序篇</a><ul><li><a href="/blog-base/常用算法25讲/02.排序篇/01"><span>01 | 理解快排：打通算法学习的任督二脉</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/02"><span>02 | 快排优化：举一反三，轻松面对快排面试题</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/03"><span>03 | 二叉堆：动态维护集合最值的利器</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/04"><span>04 | 堆排序：体会线性建堆法的威力</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/05"><span>05 | 堆排序面试题：如何维护Top-K元素和中位数？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/06"><span>06 | 线程池基础：如何用线程池设计出更“优美”的代码？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/07"><span>07 | 封装线程池（上）：初探泛型编程</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/08"><span>08 | 封装线程池（下）：从0到1，体验程序设计全过程</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/09"><span>09 | 归并排序：如何解决逆序数问题？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/10"><span>10 | 多路归并排序：如何解决搜索引擎中的大数据排序问题？</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/11"><span>11 | 算法思维：融汇贯通，教你3个有趣的排序算法</span></a></li><li><a href="/blog-base/常用算法25讲/02.排序篇/12"><span>12 | 面试实战：经典排序算法面试题详解</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲/03.查找搜索篇">03.查找搜索篇</a><ul><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/01"><span>13 | 树结构基础：二叉树结构及其基础操作</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/02"><span>14 | 二叉排序树：如何动态查找第k大元素？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/常用算法25讲/03.查找搜索篇/03"><span>15 |  AVL树：如何让二叉排序树永远保持最优？</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/04"><span>16 | 红黑树（上）：红黑树基础与插入调整操作</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/05"><span>17 | 红黑树（下）：红黑树的双黑节点与删除调整</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/06"><span>18 | 哈希表：文件的身份认证系统是如何实现的？</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/07"><span>19 | 深度优先搜索：理解搜索状态树，快速输出序列的排列组合</span></a></li><li><a href="/blog-base/常用算法25讲/03.查找搜索篇/08"><span>20 | 广度优先搜索：如何快速解决迷宫问题？</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/04.国庆策划">04.国庆策划</a><ul><li><a href="/blog-base/常用算法25讲/04.国庆策划/01"><span>期中测试 | 一套习题，测出你的掌握程度</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/02"><span>期中测试题答案 | 这些问题，你都答对了吗？</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/03"><span>常见算法面试题，等你来挑战！</span></a></li><li><a href="/blog-base/常用算法25讲/04.国庆策划/04"><span>这些常见算法面试题，你会解了吗？</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/05.进阶篇">05.进阶篇</a><ul><li><a href="/blog-base/常用算法25讲/05.进阶篇/01"><span>21 | 深度优先搜索进阶：数独游戏如何快速求解?</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/02"><span>22 | 排序与查找：抓住关键，2-Sum问题的多种解法</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/03"><span>23 | 位运算：位=数据结构，算=算法</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/04"><span>24 | 牛顿迭代：如何用O(1)的时间复杂度求sqrt？</span></a></li><li><a href="/blog-base/常用算法25讲/05.进阶篇/05"><span>25 | 毕业设计：用O(1)的时间复杂度计算整数末尾0的数量</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/06.结束语">06.结束语</a><ul><li><a href="/blog-base/常用算法25讲/06.结束语/01"><span>结束语 | 不忘初心，方得始终</span></a></li></ul></li><li><a href="/blog-base/常用算法25讲/summary">常用算法25讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="二叉树的旋转：二叉树自适应能力的关键" data-depth="2"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#二叉树的旋转二叉树自适应能力的关键"><span>二叉树的旋转：二叉树自适应能力的关键</span></a></li><li title="AVL树的基本操作" data-depth="2"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl树的基本操作"><span>AVL树的基本操作</span></a></li><li title="AVL树的插入" data-depth="3"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl树的插入"><span>AVL树的插入</span></a></li><li title="AVL 树的级联合并" data-depth="3"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl-树的级联合并"><span>AVL 树的级联合并</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#课程小结"><span>课程小结</span></a></li><li title="课后练习" data-depth="2"><a href="/blog-base/常用算法25讲/03.查找搜索篇/03#课后练习"><span>课后练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="15---avl树如何让二叉排序树永远保持最优"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#15---avl树如何让二叉排序树永远保持最优"><span class="icon icon-link"></span></a>15 |  AVL树：如何让二叉排序树永远保持最优？</h1><p>你好，我是胡光。</p><p>上节课，我们学习了二叉排序树，并且利用它解决了动态查找第k大元素的问题。但是这还不够，因为二叉排序树中存在退化现象，极端情况下，二叉排序树的操作效率并不会比线性表高。虽然我们也学习了最优二叉排序树的求解算法，但是它的代价依旧不低。</p><p>为了解决这个问题啊，曾经也有人提出来过，在维护一个动态更新的有序序列的时候，我们先不管二叉排序树是否是最优的，只要是在维护过程中树高超出了一定的限制（如$5\times log_2N$)，我们就重新求解二叉排序树。</p><p>这是一种比较折中的办法，但仍然要我们间歇性花费不低的代价去保持树的效率。那么有没有什么办法，能够让二叉排序树拥有自适应的能力，在每一次插入、删除之后可以随时调整自己，让自己保持最优状态呢？</p><p>当然是有办法的，早在1962年，就有两位数学家提出来了一种方法，这种方法可以做到在二叉排序树上进行增、删、查，以及查找动态第k大元素等操作，时间复杂度都是$O(log_2N)$，这个方法就叫做<strong>平衡树</strong>，也叫做<strong>AVL树</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2eea2e007fbf1f63d991fc2e2e8956f0e0ea.4aa257d9.jpg" alt="" title="图1：AVL树"/></p><p>在平衡树中，“平衡”的意思，就是将二叉树左右两棵子树的高度看作是这两棵树的重量，把这两个重量放在一个天平上，尽可能保持这个天平是平衡的。也就是说，一棵平衡树的<strong>左右两棵子树的树高之差不会超过1</strong>。由此我们知道，平衡树就是一个最优的二叉排序树，平衡树的树高也就一直保持在$log_2N$左右（实际上是在$log_2(N+1)$和$1.4405\times log_2(N+2)-0.3277$之间）。正因为维持了树高，所以一棵有N个节点的平衡树，每一个操作的时间复杂度都可保持在$O(log_2N)$。</p><p>在正式讲平衡树之前，我们还要引入二叉树上的一个关键的操作，旋转（Rotate）操作，这个操作也是平衡树能够改变形态、保持平衡的关键。</p><h2 id="二叉树的旋转二叉树自适应能力的关键"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#二叉树的旋转二叉树自适应能力的关键"><span class="icon icon-link"></span></a>二叉树的旋转：二叉树自适应能力的关键</h2><p>旋转操作的字面意思，就是将二叉树转了一下。旋转后的二叉排序树也依然会保持二叉排序树的性质。也就是说，我们在进行了一次旋转操作之后，最终的产物仍然是一棵二叉排序树，这棵二叉树排序上的每一个节点，总是<strong>大于它的左孩子，小于右孩子，而且中序遍历后的结果也保持不变</strong>。</p><p>树的旋转究竟是怎么操作的呢？打个比方，我们可以把树上的每一个节点看作是弹珠，每一条边看作是绳子。平常这棵树，我们都是用手拎着它的根节点那颗弹珠，让其他的弹珠自然垂下。然后我们有一天突发奇想，想要换一颗弹珠来拎着，比如我们想要拎根的左子节点那颗弹珠，然后让其他的弹珠继续自然垂下。这样，左子节点成为了新的树根，而根节点成为了新树根的右子节点。</p><p>但是，只是这么简单的操作是不够的。如果我们把图1中左子节点，也就是4当作根节点，最终的结果就是节点4除了原有的两个子节点之外，根节点也成为了它的子节点，那它就有3个孩子节点，这显然就不符合二叉树的定义了。所以我们还要进一步明确旋转的细节。</p><p>我们把这个问题放到一个比较简单，但却足以代表所有情况的例子中。如下图中左边这棵树，我们将它按照上面描述的方式进行了一次操作之后，2变成了根节点，1、3、4都变成了它的孩子节点。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3a9e3a5ab73ea19e09fefdfd8fbc9094639e.d35a590d.jpg" alt="" title="图2：二叉排序树的右旋操作"/></p><p>为了保持二叉树的性质，我们就需要选出一个孩子节点移动到另一个空位上。这个时候，1、3、5有两个空位，4有一个空位。我们可以把其中一个孩子节点移到5上吗？你千万不要被这个简单的例子迷惑了，5 号节点完全可以代表一棵左右孩子双全的子树。</p><p>因此，我们需要找到唯一一个一定会出现一个空位的节点。没有错，就是原来的根节点，所以我们应该把2 号节点多出来的一个孩子节点放到原根节点，也就是4的下面。</p><p>相信你也看到了，根节点空出来的位置刚好是左孩子的位置，而新的根节点 2 号节点，由于它原本就是 4 号节点的左孩子，因此它的所有子树节点的值都小于 4 号节点。也就是说，2 号节点的任意一个孩子都可以放到 4 号节点的左孩子位置。</p><p>但是别忘了，我们还有一个目标，那就是保持原二叉树的中序遍历序列不变。如果我们把2号节点的左孩子变成了4号节点的左孩子，那在中序遍历之后，我们就无法先遍历到这些节点了，所以，我们只能把2号节点的右孩子，变成4号节点的左孩子。这也就保持了4号节点的中序前驱在新的树中，依旧是中序前驱。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageca2bcaf3b1ccca93605fb6184ece3f82a22b.515c1de8.jpg" alt="" title="图3：右旋操作"/></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Node *right_rotate(Node *root) {</span></div><div class="token-line"><span class="token plain">        Node *temp = root-&gt;lchild;</span></div><div class="token-line"><span class="token plain">        root-&gt;lchild = temp-&gt;rchild;</span></div><div class="token-line"><span class="token plain">        temp-&gt;rchild = root;</span></div><div class="token-line"><span class="token plain">        update_height(root);</span></div><div class="token-line"><span class="token plain">        update_height(temp);</span></div><div class="token-line"><span class="token plain">        return temp;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这种把二叉树的左孩子作为根进行的旋转操作，也被称作是<strong>右旋操作</strong>（Right Rotate），那与之对称的就是左旋操作（Left Rotate）。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage65876575a19f43139d7862f02c95d0449887.046a287e.jpg" alt="" title="图4：左旋操作"/></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Node *left_rotate(Node *root) {</span></div><div class="token-line"><span class="token plain">        Node *temp = root-&gt;rchild;</span></div><div class="token-line"><span class="token plain">        root-&gt;rchild = temp-&gt;lchild;</span></div><div class="token-line"><span class="token plain">        temp-&gt;lchild = root;</span></div><div class="token-line"><span class="token plain">        update_height(root);</span></div><div class="token-line"><span class="token plain">        update_height(temp);</span></div><div class="token-line"><span class="token plain">        return temp;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>看到这里，相信你也发现了，<strong>二叉树的旋转操作可以有效地改变左右两棵子树的树高差</strong>，所以，旋转操作是平衡树保持平衡的关键操作。接下来，我们就来聊一聊，平衡树是怎样利用旋转操作保持平衡的。</p><h2 id="avl树的基本操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl树的基本操作"><span class="icon icon-link"></span></a>AVL树的基本操作</h2><p>为了保持树的平衡，我们首先需要知道现在这棵树是不是平衡的。这里，我们可以直接计算平衡树的树高差，我们用<strong>右子树的树高减去左子树的树高</strong>，把得到的差叫做<strong>平衡因子</strong>。在平衡树中，平衡因子只可能有3个值：+1，-1和0，一旦某一个节点的平衡因子出现了这3个值之外的数值，就说明这棵子树需要调整。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage746c747e6f17a383e0cebbc21f191404426c.ba2471bc.jpg" alt="" title="图5：计算每个节点的平衡因子"/></p><p>我们知道，旋转操作可以有效地改变左右两棵子树的高差，所以，我们也主要依赖旋转操作来调整平衡因子。那具体怎么做呢？我们可以结合平衡树的更新操作一起来学习。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//AVL树节点定义，需要增加数据域h记录当前节点树高</span></div><div class="token-line"><span class="token plain">    #define H(root) (root)-&gt;h</span></div><div class="token-line"><span class="token plain">    #define K(root) (root)-&gt;key</span></div><div class="token-line"><span class="token plain">    #define L(root) (root)-&gt;lchild</span></div><div class="token-line"><span class="token plain">    #define R(root) (root)-&gt;rchild</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    typedef struct Node {</span></div><div class="token-line"><span class="token plain">        int key, h;</span></div><div class="token-line"><span class="token plain">        struct Node *lchild, *rchild;</span></div><div class="token-line"><span class="token plain">    } Node;</span></div></pre></div><h3 id="avl树的插入"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl树的插入"><span class="icon icon-link"></span></a>AVL树的插入</h3><p>首先，是插入操作。我们先想两个问题，在向平衡树中插入节点的时候，树上会发生什么样的变化？我们怎么利用旋转操作让二叉排序树回归到平衡中呢？</p><p>因为影响平衡的主要因素是树高，所以我们主要考虑插入节点后对树高的影响就好啦。</p><p>最简单的情况，就是我们插入一个节点之后，并没有影响到子树的树高，这个时候，我们不需要进行调整。</p><p>第二种情况，我们插入一个节点之后，虽然影响到了子树的树高，但没有影响到子树平衡。这种情况其实还能细分成三种情况。第一种，我们把节点插入到根节点平衡因子为0的子树中的任意一处，第二种，我们把节点插入到根节点的平衡因子为+1的子树的左子树中，第三种，我们把节点插入到根节点的平衡因子为+1的子树的右子树中。这三种情况听起来可能有点绕，你可以结合任意一张示意图来理解。</p><p>所以，我们需要考虑的情况，只有<strong>插入了节点之后，确实影响到了树的平衡</strong>。其实，这种情况还能进行细分。下面，我就详细来说说。</p><p>首先，我们向一棵平衡因子为+1的子树的右子树中插入一个节点，这样右子树的会树高增加，这个节点的平衡因子就变成了+2。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagef479f4fa30a30fd800081a7dd47df0148079.7bcb17c2.jpg" alt="" title="图6：插入节点，平衡因子变成+2"/></p><p>我们看到，节点A的平衡因子超出了限制，所以我们需要降低A节点的平衡因子。那么这棵树只要经历一次<strong>左旋操作</strong>就能恢复平衡了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageeec1ee24b57d155d4ab5526c346cf239e1c1.3becd193.jpg" alt="" title="图7：经历一次左旋操作，恢复平衡"/></p><p>这种情况其实还有一种对称的情况：我们向平衡因子为-1的子树的左子树中插入节点，因为影响了左子树的树高，所以平衡因子就变成-2，怎么恢复平衡，相信我不说，你也知道了。</p><p>其实前面这些情况，都是<strong>向一个方向插入的节点</strong>。比如说，刚才我们插入的位置是子树A的最右子节点下面，这样A的右子树C的平衡因子就变成了+1。但是，还有一种情况是，我们插入了节点之后，C的平衡因子就变成了-1。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage9abc9aa53f5db53b38d7c96b7eyy08ba1bbc.9130489b.jpg" alt="" title="图8：插入节点，平衡因子变成-1"/></p><p>如果我们把这种情况直接做左旋处理的话，很显然，右子树C的左子树D就会直接成为A的右子树，那么左子树的树高则变成了3，右子树由于只有一个E节点，树高变成了1，根节点C的平衡因子变成了-2，树仍旧是不平衡的。这个时候，我们该怎么办呢？</p><p>我们最终还是要经过左旋让这棵树变平衡，所以我们只能想办法让树在左旋之后，左子树的树高不会增加那么多。因此，我们需要做的是，减少掉右子树C的左子树的树高。那由于C的平衡因子是-1，我们对C子树进行右旋，也不会影响该子树的平衡性，还可以让左子树的树高变成-1。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimaged0c6d0e9e53be2642c0d2c71f1bf6376e4c6.b1aed8b5.jpg" alt="" title="图9：经历一次旋转操作，依然没有恢复平衡"/></p><p>发现了吗，这种情况刚好又和第一种情况是一样的了，我们再进行一次左旋，就可以将这棵树重新调整到平衡状态了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage53465310390ed1e2cf39774bf7035b85e446.4c22fe00.jpg" alt="" title="图10：经历多次旋转操作，恢复平衡"/></p><p>当然，这种情况也是有对称情况的，对称情况是什么，怎么解决，你可以自己操作试试。</p><p>说了这么多，这里我再带你做个总结。我们通过旋转操作来调整二叉树的平衡性的原则是，如果插入节点破坏了树的平衡，我们就需要找到这一次的插入操作，到底影响了哪一棵子树的树高，无非是左、右两种。</p><p>当我们向右子树中插入节点，导致树不平衡时，我们最终一定是通过左旋操作让树重归平衡。但如果我们插入节点的位置是右子树的左子树，那在左旋的时候，这棵左子树会被新的左子树继承，它不平衡的树高也会被继承，所以我们仍然是要通过一次额外的旋转，将不平衡的左子树解决掉。对称情况同理。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//AVL树调整平衡</span></div><div class="token-line"><span class="token plain">    Node *maintain(Node *root) {</span></div><div class="token-line"><span class="token plain">        if (abs(H(L(root)) - H(R(root))) &lt;= 1) return root;</span></div><div class="token-line"><span class="token plain">        if (H(L(root)) &gt; H(R(root))) {</span></div><div class="token-line"><span class="token plain">            if (H(R(L(root))) &gt; H(L(L(root)))) {</span></div><div class="token-line"><span class="token plain">                root-&gt;lchild = left_rotate(root-&gt;lchild);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            root = right_rotate(root);</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            if (H(L(R(root))) &gt; H(R(R(root)))) {</span></div><div class="token-line"><span class="token plain">                root-&gt;rchild = right_rotate(root-&gt;rchild);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            root = left_rotate(root);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return root;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实际上，插入节点导致平衡树不平衡的情况，归根到底就是这两种，或它们的对称情况。所以在插入节点的过程中，我们只需要利用这两种处理方式，就可以一直让树保持平衡状态，这也就保证了这棵树的树高最小，每次插入索引的时间复杂度都是$O(log_2N)$。</p><p>除了插入节点会导致树不平衡，平衡树的插入操作的其他部分就和一般二叉排序树是一样的了，相信你也能理解，我就不多说了。</p><p>当然，平衡树的删除操作也是类似的，在删除了一个节点之后，我们也要解决树不平衡的问题。那除此之外，它的删除操作也和二叉排序树的删除操作一样。</p><h3 id="avl-树的级联合并"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#avl-树的级联合并"><span class="icon icon-link"></span></a>AVL 树的级联合并</h3><p>在解决了平衡树的基本操作之后，我们来讨论一个更加有挑战性的问题。怎么把两棵平衡树合并成一棵平衡树，并且我们假设，一棵树中的所有值都比另一棵树大。</p><p>首先，最直观合并方法，就是把其中一棵平衡树的N个节点逐一插入到另一棵带有M个节点的平衡树中，那么合并的时间复杂度就是$O(Nlog_2M)$。这种合并的代价看上去也可以接受。</p><p>但是，我们还有一种更加巧妙的方法，就是利用有序序列的边界信息。</p><p>假设，我们要合并的两棵树分别是$T_1$和$T_2$，并且，这两棵树的值之间的关系是$max(T_1)&lt;min(T_2)$，这两棵树之间高度的关系是$height(T_1)\ge height(T_2)$。</p><p>第一步，我们要找到$T_2$中最小的节点J，把它删除，得到树$T_2’$，那$T_2$中剩余的节点就全都在J的右子树之中了。</p><p>第二步，我们在$T_1$中，不断向右下走，找到一棵子树P，让$height§-height(T_2’)=0或1$。</p><p>由于$T_1$中的值都比$T_2$中的值小，我们就可以推出，J的值一定比P的值大，因此我们就把P当作J的左子树，$T_2$剩余的节点当作J的右子树，再把P的父亲当作J的父亲。</p><p>因为P是向右下寻找得到的，所以$T_1$中剩余的值依旧符合二叉排序树的性质。而由于我们控制了节点P所在的高度，因此，这个问题我们可以看作是把J节点插入到了$T_1$中。对称情况的解决方法也是类似的。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>平衡树的内容讲完了，我们一起来做个总结。</p><p>这节课，我们先学习了二叉排序树上，一种非常基础也非常重要的操作，二叉树的旋转操作。旋转操作，分成左旋操作和右旋操作，它们都能有效改变树高，所以利用旋转操作，我们可以时刻保持平衡树是平衡状态的。这也让我们在平衡树上的查找，变得非常地容易。</p><p>接着，我们又一起讨论了平衡树的合并和分解操作。其实核心原则就是在插入和删除节点之后，如果树不平衡了，我就进行左旋或者右旋操作，让它恢复平衡。这让我们可以更加灵活地操纵有序序列。</p><p>不过，即使平衡树在索引上保持了如此优秀的效率，但为了能让树在频繁更新的时候依然保持平衡，我们仍旧要付出相当大的代价。</p><p>因此，在实际的应用中，我们很可能不需要让树时刻保持严格的平衡，而只需要让树保持一个相对平衡的状态就行了，当树的不平衡程度打破了我们的忍耐限度时，再让树通过少量的调整恢复到相对平衡的状态中。这种二叉排序树也被称作近似平衡二叉排序树，它可以应用于需要频繁更新的结构上。</p><p>那在接下来的课程中，我会带你学习一种应用非常广泛的近似平衡二叉树，也就是红黑树。</p><h2 id="课后练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/常用算法25讲/03.查找搜索篇/03#课后练习"><span class="icon icon-link"></span></a>课后练习</h2><p>今天，我们在讨论平衡树中插入或者删除元素的时候，还有一些对称情况没有细说。你能结合你的理解，把这些对称情况的算法实现出来吗？</p><p>欢迎在留言区分享你的答案，也希望你能把这节课的内容转发出去。那今天就到这里了，我是胡光，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/常用算法25讲/03.查找搜索篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:21:22</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
