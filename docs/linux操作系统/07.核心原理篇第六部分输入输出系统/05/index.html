<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>35 | 块设备（下）：如何建立代理商销售模式？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/linux操作系统/07.核心原理篇第六部分输入输出系统/05" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a aria-current="page" class="active" href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a aria-current="page" class="active" href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux操作系统/01.入门准备篇">01.入门准备篇</a><ul><li><a href="/blog-base/linux操作系统/01.入门准备篇/01"><span>开篇词 | 为什么要学习Linux操作系统？</span></a></li><li><a href="/blog-base/linux操作系统/01.入门准备篇/02"><span>01 | 入学测验：你究竟对Linux操作系统了解多少？</span></a></li><li><a href="/blog-base/linux操作系统/01.入门准备篇/03"><span>02 | 学习路径：爬过这六个陡坡，你就能对Linux了如指掌</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/02.核心原理篇第一部分linux操作系统综述">02.核心原理篇第一部分Linux操作系统综述</a><ul><li><a href="/blog-base/linux操作系统/02.核心原理篇第一部分linux操作系统综述/01"><span>03 | 你可以把Linux内核当成一家软件外包公司的老板</span></a></li><li><a href="/blog-base/linux操作系统/02.核心原理篇第一部分linux操作系统综述/02"><span>04 | 快速上手几个Linux命令：每家公司都有自己的黑话</span></a></li><li><a href="/blog-base/linux操作系统/02.核心原理篇第一部分linux操作系统综述/03"><span>05 | 学会几个系统调用：咱们公司能接哪些类型的项目？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/03.核心原理篇第二部分系统初始化">03.核心原理篇第二部分系统初始化</a><ul><li><a href="/blog-base/linux操作系统/03.核心原理篇第二部分系统初始化/01"><span>06 | x86架构：有了开放的架构，才能打造开放的营商环境</span></a></li><li><a href="/blog-base/linux操作系统/03.核心原理篇第二部分系统初始化/02"><span>07 | 从BIOS到bootloader：创业伊始，有活儿老板自己上</span></a></li><li><a href="/blog-base/linux操作系统/03.核心原理篇第二部分系统初始化/03"><span>08 | 内核初始化：生意做大了就得成立公司</span></a></li><li><a href="/blog-base/linux操作系统/03.核心原理篇第二部分系统初始化/04"><span>09 | 系统调用：公司成立好了就要开始接项目</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理">04.核心原理篇第三部分进程管理</a><ul><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/01"><span>10 | 进程：公司接这么多项目，如何管？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/02"><span>11 | 线程：如何让复杂的项目并行执行？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/03"><span>12 | 进程数据结构（上）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/04"><span>13 | 进程数据结构（中）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/05"><span>14 | 进程数据结构（下）：项目多了就需要项目管理系统</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/06"><span>15 | 调度（上）：如何制定项目管理流程？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/07"><span>16 | 调度（中）：主动调度是如何发生的？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/08"><span>17 | 调度（下）：抢占式调度是如何发生的？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/09"><span>18 | 进程的创建：如何发起一个新项目？</span></a></li><li><a href="/blog-base/linux操作系统/04.核心原理篇第三部分进程管理/10"><span>19 | 线程的创建：如何执行一个新子项目？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理">05.核心原理篇第四部分内存管理</a><ul><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/01"><span>20 | 内存管理（上）：为客户保密，规划进程内存空间布局</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/02"><span>21 | 内存管理（下）：为客户保密，项目组独享会议室封闭开发</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/03"><span>22 | 进程空间管理：项目组还可以自行布置会议室</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/04"><span>23 | 物理内存管理（上）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/05"><span>24 | 物理内存管理（下）：会议室管理员如何分配会议室？</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/06"><span>25 | 用户态内存映射：如何找到正确的会议室？</span></a></li><li><a href="/blog-base/linux操作系统/05.核心原理篇第四部分内存管理/07"><span>26 | 内核态内存映射：如何找到正确的会议室？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/06.核心原理篇第五部分文件系统">06.核心原理篇第五部分文件系统</a><ul><li><a href="/blog-base/linux操作系统/06.核心原理篇第五部分文件系统/01"><span>27 | 文件系统：项目成果要归档，我们就需要档案库</span></a></li><li><a href="/blog-base/linux操作系统/06.核心原理篇第五部分文件系统/02"><span>28 | 硬盘文件系统：如何最合理地组织档案库的文档？</span></a></li><li><a href="/blog-base/linux操作系统/06.核心原理篇第五部分文件系统/03"><span>29 | 虚拟文件系统：文件多了就需要档案管理系统</span></a></li><li><a href="/blog-base/linux操作系统/06.核心原理篇第五部分文件系统/04"><span>30 | 文件缓存：常用文档应该放在触手可得的地方</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统">07.核心原理篇第六部分输入输出系统</a><ul><li><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/01"><span>31 | 输入与输出：如何建立售前售后生态体系？</span></a></li><li><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/02"><span>32 | 字符设备（上）：如何建立直销模式？</span></a></li><li><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/03"><span>33 | 字符设备（下）：如何建立直销模式？</span></a></li><li><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/04"><span>34 | 块设备（上）：如何建立代理商销售模式？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05"><span>35 | 块设备（下）：如何建立代理商销售模式？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信">08.核心原理篇第七部分进程间通信</a><ul><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/01"><span>36 | 进程间通信：遇到大项目需要项目组之间的合作才行</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/02"><span>37 | 信号（上）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/03"><span>38 | 信号（下）：项目组A完成了，如何及时通知项目组B？</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/04"><span>39 | 管道：项目组A完成了，如何交接给项目组B？</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/05"><span>40 | IPC（上）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/06"><span>41 | IPC（中）：不同项目组之间抢资源，如何协调？</span></a></li><li><a href="/blog-base/linux操作系统/08.核心原理篇第七部分进程间通信/07"><span>42 | IPC（下）：不同项目组之间抢资源，如何协调？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统">09.核心原理篇第八部分网络系统</a><ul><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/01"><span>43 预习 | Socket通信之网络协议基本原理</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/02"><span>43 | Socket通信：遇上特大项目，要学会和其他公司合作</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/03"><span>44 | Socket内核数据结构：如何成立特大项目合作部？</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/04"><span>45 | 发送网络包（上）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/05"><span>46 | 发送网络包（下）：如何表达我们想让合作伙伴做什么？</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/06"><span>47 | 接收网络包（上）：如何搞明白合作伙伴让我们做什么？</span></a></li><li><a href="/blog-base/linux操作系统/09.核心原理篇第八部分网络系统/07"><span>48 | 接收网络包（下）：如何搞明白合作伙伴让我们做什么？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化">10.核心原理篇第九部分虚拟化</a><ul><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/01"><span>49 | 虚拟机：如何成立子公司，让公司变集团？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/02"><span>50 | 计算虚拟化之CPU（上）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/03"><span>51 | 计算虚拟化之CPU（下）：如何复用集团的人力资源？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/04"><span>52 | 计算虚拟化之内存：如何建立独立的办公室？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/05"><span>53 | 存储虚拟化（上）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/06"><span>54 | 存储虚拟化（下）：如何建立自己保管的单独档案库？</span></a></li><li><a href="/blog-base/linux操作系统/10.核心原理篇第九部分虚拟化/07"><span>55 | 网络虚拟化：如何成立独立的合作部？</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/11.核心原理篇第十部分容器化">11.核心原理篇第十部分容器化</a><ul><li><a href="/blog-base/linux操作系统/11.核心原理篇第十部分容器化/01"><span>56 | 容器：大公司为保持创新，鼓励内部创业</span></a></li><li><a href="/blog-base/linux操作系统/11.核心原理篇第十部分容器化/02"><span>57 | Namespace技术：内部创业公司应该独立运营</span></a></li><li><a href="/blog-base/linux操作系统/11.核心原理篇第十部分容器化/03"><span>58 | cgroup技术：内部创业公司应该独立核算成本</span></a></li><li><a href="/blog-base/linux操作系统/11.核心原理篇第十部分容器化/04"><span>59 | 数据中心操作系统：上市敲钟</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇">12.实战串讲篇</a><ul><li><a href="/blog-base/linux操作系统/12.实战串讲篇/01"><span>60 | 搭建操作系统实验环境（上）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/02"><span>61 | 搭建操作系统实验环境（下）：授人以鱼不如授人以渔</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/03"><span>62 | 知识串讲：用一个创业故事串起操作系统原理（一）</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/04"><span>63 | 知识串讲：用一个创业故事串起操作系统原理（二）</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/05"><span>64 | 知识串讲：用一个创业故事串起操作系统原理（三）</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/06"><span>65 | 知识串讲：用一个创业故事串起操作系统原理（四）</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/07"><span>66 | 知识串讲：用一个创业故事串起操作系统原理（五）</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/08"><span>期末测试 | 这些操作系统问题，你真的掌握了吗？</span></a></li><li><a href="/blog-base/linux操作系统/12.实战串讲篇/09"><span>结束语 | 永远别轻视任何技术，也永远别轻视自己</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/13.专栏加餐">13.专栏加餐</a><ul><li><a href="/blog-base/linux操作系统/13.专栏加餐/01"><span>学习攻略（一）：学好操作系统，需要掌握哪些前置知识？</span></a></li><li><a href="/blog-base/linux操作系统/13.专栏加餐/02"><span>“趣谈Linux操作系统”食用指南</span></a></li></ul></li><li><a href="/blog-base/linux操作系统/summary">linux操作系统</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="直接I/O如何访问块设备？" data-depth="2"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#直接io如何访问块设备"><span>直接I/O如何访问块设备？</span></a></li><li title="缓存I/O如何访问块设备？" data-depth="2"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#缓存io如何访问块设备"><span>缓存I/O如何访问块设备？</span></a></li><li title="如何向块设备层提交请求？" data-depth="2"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#如何向块设备层提交请求"><span>如何向块设备层提交请求？</span></a></li><li title="块设备队列结构" data-depth="3"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#块设备队列结构"><span>块设备队列结构</span></a></li><li title="块设备的初始化" data-depth="3"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#块设备的初始化"><span>块设备的初始化</span></a></li><li title="请求提交与调度" data-depth="3"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#请求提交与调度"><span>请求提交与调度</span></a></li><li title="请求的处理" data-depth="3"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#请求的处理"><span>请求的处理</span></a></li><li title="总结时刻" data-depth="2"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#总结时刻"><span>总结时刻</span></a></li><li title="课堂练习" data-depth="2"><a href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#课堂练习"><span>课堂练习</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="35--块设备下如何建立代理商销售模式"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#35--块设备下如何建立代理商销售模式"><span class="icon icon-link"></span></a>35 | 块设备（下）：如何建立代理商销售模式？</h1><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/97876">文件系统<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>那一节，我们讲了文件的写入，到了设备驱动这一层，就没有再往下分析。上一节我们又讲了mount一个块设备，将block_device信息放到了ext4文件系统的super_block里面，有了这些基础，是时候把整个写入的故事串起来了。</p><p>还记得咱们在文件系统那一节分析写入流程的时候，对于ext4文件系统，最后调用的是ext4_file_write_iter，它将I/O的调用分成两种情况：</p><p>第一是<strong>直接I/O</strong>。最终我们调用的是generic_file_direct_write，这里调用的是mapping-&gt;a_ops-&gt;direct_IO，实际调用的是ext4_direct_IO，往设备层写入数据。</p><p>第二种是<strong>缓存I/O</strong>。最终我们会将数据从应用拷贝到内存缓存中，但是这个时候，并不执行真正的I/O操作。它们只将整个页或其中部分标记为脏。写操作由一个timer触发，那个时候，才调用wb_workfn往硬盘写入页面。</p><p>接下来的调用链为：wb_workfn-&gt;wb_do_writeback-&gt;wb_writeback-&gt;writeback_sb_inodes-&gt;__writeback_single_inode-&gt;do_writepages。在do_writepages中，我们要调用mapping-&gt;a_ops-&gt;writepages，但实际调用的是ext4_writepages，往设备层写入数据。</p><p>这一节，我们就沿着这两种情况分析下去。</p><h2 id="直接io如何访问块设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#直接io如何访问块设备"><span class="icon icon-link"></span></a>直接I/O如何访问块设备？</h2><p>我们先来看第一种情况，直接I/O调用到ext4_direct_IO。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct file *file = iocb-&gt;ki_filp;</span></div><div class="token-line"><span class="token plain">    	struct inode *inode = file-&gt;f_mapping-&gt;host;</span></div><div class="token-line"><span class="token plain">    	size_t count = iov_iter_count(iter);</span></div><div class="token-line"><span class="token plain">    	loff_t offset = iocb-&gt;ki_pos;</span></div><div class="token-line"><span class="token plain">    	ssize_t ret;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ret = ext4_direct_IO_write(iocb, iter);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static ssize_t ext4_direct_IO_write(struct kiocb *iocb, struct iov_iter *iter)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct file *file = iocb-&gt;ki_filp;</span></div><div class="token-line"><span class="token plain">    	struct inode *inode = file-&gt;f_mapping-&gt;host;</span></div><div class="token-line"><span class="token plain">    	struct ext4_inode_info *ei = EXT4_I(inode);</span></div><div class="token-line"><span class="token plain">    	ssize_t ret;</span></div><div class="token-line"><span class="token plain">    	loff_t offset = iocb-&gt;ki_pos;</span></div><div class="token-line"><span class="token plain">    	size_t count = iov_iter_count(iter);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	ret = __blockdev_direct_IO(iocb, inode, inode-&gt;i_sb-&gt;s_bdev, iter,</span></div><div class="token-line"><span class="token plain">    				   get_block_func, ext4_end_io_dio, NULL,</span></div><div class="token-line"><span class="token plain">    				   dio_flags);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    ……</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在ext4_direct_IO_write调用__blockdev_direct_IO，有个参数你需要特别注意一下，那就是inode-&gt;i_sb-&gt;s_bdev。通过当前文件的inode，我们可以得到super_block。这个super_block中的s_bdev，就是咱们上一节填进去的那个block_device。</p><p>__blockdev_direct_IO会调用do_blockdev_direct_IO，在这里面我们要准备一个struct dio结构和struct dio_submit结构，用来描述将要发生的写入请求。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static inline ssize_t</span></div><div class="token-line"><span class="token plain">    do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span></div><div class="token-line"><span class="token plain">    		      struct block_device *bdev, struct iov_iter *iter,</span></div><div class="token-line"><span class="token plain">    		      get_block_t get_block, dio_iodone_t end_io,</span></div><div class="token-line"><span class="token plain">    		      dio_submit_t submit_io, int flags)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	unsigned i_blkbits = ACCESS_ONCE(inode-&gt;i_blkbits);</span></div><div class="token-line"><span class="token plain">    	unsigned blkbits = i_blkbits;</span></div><div class="token-line"><span class="token plain">    	unsigned blocksize_mask = (1 &lt;&lt; blkbits) - 1;</span></div><div class="token-line"><span class="token plain">    	ssize_t retval = -EINVAL;</span></div><div class="token-line"><span class="token plain">    	size_t count = iov_iter_count(iter);</span></div><div class="token-line"><span class="token plain">    	loff_t offset = iocb-&gt;ki_pos;</span></div><div class="token-line"><span class="token plain">    	loff_t end = offset + count;</span></div><div class="token-line"><span class="token plain">    	struct dio *dio;</span></div><div class="token-line"><span class="token plain">    	struct dio_submit sdio = { 0, };</span></div><div class="token-line"><span class="token plain">    	struct buffer_head map_bh = { 0, };</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	dio = kmem_cache_alloc(dio_cache, GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    	dio-&gt;flags = flags;</span></div><div class="token-line"><span class="token plain">    	dio-&gt;i_size = i_size_read(inode);</span></div><div class="token-line"><span class="token plain">    	dio-&gt;inode = inode;</span></div><div class="token-line"><span class="token plain">    	if (iov_iter_rw(iter) == WRITE) {</span></div><div class="token-line"><span class="token plain">    		dio-&gt;op = REQ_OP_WRITE;</span></div><div class="token-line"><span class="token plain">    		dio-&gt;op_flags = REQ_SYNC | REQ_IDLE;</span></div><div class="token-line"><span class="token plain">    		if (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span></div><div class="token-line"><span class="token plain">    			dio-&gt;op_flags |= REQ_NOWAIT;</span></div><div class="token-line"><span class="token plain">    	} else {</span></div><div class="token-line"><span class="token plain">    		dio-&gt;op = REQ_OP_READ;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	sdio.blkbits = blkbits;</span></div><div class="token-line"><span class="token plain">    	sdio.blkfactor = i_blkbits - blkbits;</span></div><div class="token-line"><span class="token plain">    	sdio.block_in_file = offset &gt;&gt; blkbits;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	sdio.get_block = get_block;</span></div><div class="token-line"><span class="token plain">    	dio-&gt;end_io = end_io;</span></div><div class="token-line"><span class="token plain">    	sdio.submit_io = submit_io;</span></div><div class="token-line"><span class="token plain">    	sdio.final_block_in_bio = -1;</span></div><div class="token-line"><span class="token plain">    	sdio.next_block_for_io = -1;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	dio-&gt;iocb = iocb;</span></div><div class="token-line"><span class="token plain">    	dio-&gt;refcount = 1;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	sdio.iter = iter;</span></div><div class="token-line"><span class="token plain">    	sdio.final_block_in_request =</span></div><div class="token-line"><span class="token plain">    		(offset + iov_iter_count(iter)) &gt;&gt; blkbits;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sdio.pages_in_io += iov_iter_npages(iter, INT_MAX);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	retval = do_direct_IO(dio, &amp;sdio, &amp;map_bh);</span></div><div class="token-line"><span class="token plain">    .....</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>do_direct_IO里面有两层循环，第一层循环是依次处理这次要写入的所有块。对于每一块，取出对应的内存中的页page，在这一块中，有写入的起始地址from和终止地址to，所以，第二层循环就是依次处理from到to的数据，调用submit_page_section，提交到块设备层进行写入。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int do_direct_IO(struct dio *dio, struct dio_submit *sdio,</span></div><div class="token-line"><span class="token plain">    			struct buffer_head *map_bh)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	const unsigned blkbits = sdio-&gt;blkbits;</span></div><div class="token-line"><span class="token plain">    	const unsigned i_blkbits = blkbits + sdio-&gt;blkfactor;</span></div><div class="token-line"><span class="token plain">    	int ret = 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	while (sdio-&gt;block_in_file &lt; sdio-&gt;final_block_in_request) {</span></div><div class="token-line"><span class="token plain">    		struct page *page;</span></div><div class="token-line"><span class="token plain">    		size_t from, to;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		page = dio_get_page(dio, sdio);</span></div><div class="token-line"><span class="token plain">            from = sdio-&gt;head ? 0 : sdio-&gt;from;</span></div><div class="token-line"><span class="token plain">    		to = (sdio-&gt;head == sdio-&gt;tail - 1) ? sdio-&gt;to : PAGE_SIZE;</span></div><div class="token-line"><span class="token plain">    		sdio-&gt;head++;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		while (from &lt; to) {</span></div><div class="token-line"><span class="token plain">    			unsigned this_chunk_bytes;	/* # of bytes mapped */</span></div><div class="token-line"><span class="token plain">    			unsigned this_chunk_blocks;	/* # of blocks */</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">                ret = submit_page_section(dio, sdio, page,</span></div><div class="token-line"><span class="token plain">    						  from,</span></div><div class="token-line"><span class="token plain">    						  this_chunk_bytes,</span></div><div class="token-line"><span class="token plain">    						  sdio-&gt;next_block_for_io,</span></div><div class="token-line"><span class="token plain">    						  map_bh);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    			sdio-&gt;next_block_for_io += this_chunk_blocks;</span></div><div class="token-line"><span class="token plain">    			sdio-&gt;block_in_file += this_chunk_blocks;</span></div><div class="token-line"><span class="token plain">    			from += this_chunk_bytes;</span></div><div class="token-line"><span class="token plain">    			dio-&gt;result += this_chunk_bytes;</span></div><div class="token-line"><span class="token plain">    			sdio-&gt;blocks_available -= this_chunk_blocks;</span></div><div class="token-line"><span class="token plain">    			if (sdio-&gt;block_in_file == sdio-&gt;final_block_in_request)</span></div><div class="token-line"><span class="token plain">    				break;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>submit_page_section会调用dio_bio_submit，进而调用submit_bio向块设备层提交数据。其中，参数struct bio是将数据传给块设备的通用传输对象。定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * submit_bio - submit a bio to the block device layer for I/O</span></div><div class="token-line"><span class="token plain">     * @bio: The &amp;struct bio which describes the I/O</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    blk_qc_t submit_bio(struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">      return generic_make_request(bio);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="缓存io如何访问块设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#缓存io如何访问块设备"><span class="icon icon-link"></span></a>缓存I/O如何访问块设备？</h2><p>我们再来看第二种情况，缓存I/O调用到ext4_writepages。这个函数比较长，我们这里只截取最重要的部分来讲解。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int ext4_writepages(struct address_space *mapping,</span></div><div class="token-line"><span class="token plain">    			   struct writeback_control *wbc)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	struct mpage_da_data mpd;</span></div><div class="token-line"><span class="token plain">    	struct inode *inode = mapping-&gt;host;</span></div><div class="token-line"><span class="token plain">    	struct ext4_sb_info *sbi = EXT4_SB(mapping-&gt;host-&gt;i_sb);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	mpd.do_map = 0;</span></div><div class="token-line"><span class="token plain">    	mpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);</span></div><div class="token-line"><span class="token plain">    	ret = mpage_prepare_extent_to_map(&amp;mpd);</span></div><div class="token-line"><span class="token plain">    	/* Submit prepared bio */</span></div><div class="token-line"><span class="token plain">    	ext4_io_submit(&amp;mpd.io_submit);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里比较重要的一个数据结构是struct mpage_da_data。这里面有文件的inode、要写入的页的偏移量，还有一个重要的struct ext4_io_submit，里面有通用传输对象bio。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct mpage_da_data {</span></div><div class="token-line"><span class="token plain">    	struct inode *inode;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	pgoff_t first_page;	/* The first page to write */</span></div><div class="token-line"><span class="token plain">    	pgoff_t next_page;	/* Current page to examine */</span></div><div class="token-line"><span class="token plain">    	pgoff_t last_page;	/* Last page to examine */</span></div><div class="token-line"><span class="token plain">    	struct ext4_map_blocks map;</span></div><div class="token-line"><span class="token plain">    	struct ext4_io_submit io_submit;	/* IO submission data */</span></div><div class="token-line"><span class="token plain">    	unsigned int do_map:1;</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct ext4_io_submit {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	struct bio		*io_bio;</span></div><div class="token-line"><span class="token plain">    	ext4_io_end_t		*io_end;</span></div><div class="token-line"><span class="token plain">    	sector_t		io_next_block;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>在ext4_writepages中，mpage_prepare_extent_to_map用于初始化这个struct mpage_da_data结构。接下来的调用链为：mpage_prepare_extent_to_map-&gt;mpage_process_page_bufs-&gt;mpage_submit_page-&gt;ext4_bio_write_page-&gt;io_submit_add_bh。</p><p>在io_submit_add_bh中，此时的bio还是空的，因而我们要调用io_submit_init_bio，初始化bio。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static int io_submit_init_bio(struct ext4_io_submit *io,</span></div><div class="token-line"><span class="token plain">    			      struct buffer_head *bh)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct bio *bio;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);</span></div><div class="token-line"><span class="token plain">    	if (!bio)</span></div><div class="token-line"><span class="token plain">    		return -ENOMEM;</span></div><div class="token-line"><span class="token plain">    	wbc_init_bio(io-&gt;io_wbc, bio);</span></div><div class="token-line"><span class="token plain">    	bio-&gt;bi_iter.bi_sector = bh-&gt;b_blocknr * (bh-&gt;b_size &gt;&gt; 9);</span></div><div class="token-line"><span class="token plain">    	bio-&gt;bi_bdev = bh-&gt;b_bdev;</span></div><div class="token-line"><span class="token plain">    	bio-&gt;bi_end_io = ext4_end_bio;</span></div><div class="token-line"><span class="token plain">    	bio-&gt;bi_private = ext4_get_io_end(io-&gt;io_end);</span></div><div class="token-line"><span class="token plain">    	io-&gt;io_bio = bio;</span></div><div class="token-line"><span class="token plain">    	io-&gt;io_next_block = bh-&gt;b_blocknr;</span></div><div class="token-line"><span class="token plain">    	return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们再回到ext4_writepages中。在bio初始化完之后，我们要调用ext4_io_submit，提交I/O。在这里我们又是调用submit_bio，向块设备层传输数据。ext4_io_submit的实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void ext4_io_submit(struct ext4_io_submit *io)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct bio *bio = io-&gt;io_bio;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (bio) {</span></div><div class="token-line"><span class="token plain">    		int io_op_flags = io-&gt;io_wbc-&gt;sync_mode == WB_SYNC_ALL ?</span></div><div class="token-line"><span class="token plain">    				  REQ_SYNC : 0;</span></div><div class="token-line"><span class="token plain">    		io-&gt;io_bio-&gt;bi_write_hint = io-&gt;io_end-&gt;inode-&gt;i_write_hint;</span></div><div class="token-line"><span class="token plain">    		bio_set_op_attrs(io-&gt;io_bio, REQ_OP_WRITE, io_op_flags);</span></div><div class="token-line"><span class="token plain">    		submit_bio(io-&gt;io_bio);</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	io-&gt;io_bio = NULL;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h2 id="如何向块设备层提交请求"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#如何向块设备层提交请求"><span class="icon icon-link"></span></a>如何向块设备层提交请求？</h2><p>既然不管是直接I/O，还是缓存I/O，最后都到了submit_bio里面，那我们就来重点分析一下它。</p><p>submit_bio会调用generic_make_request。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">blk_qc_t generic_make_request(struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 * bio_list_on_stack[0] contains bios submitted by the current</span></div><div class="token-line"><span class="token plain">    	 * make_request_fn.</span></div><div class="token-line"><span class="token plain">    	 * bio_list_on_stack[1] contains bios that were submitted before</span></div><div class="token-line"><span class="token plain">    	 * the current make_request_fn, but that haven&#x27;t been processed</span></div><div class="token-line"><span class="token plain">    	 * yet.</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	struct bio_list bio_list_on_stack[2];</span></div><div class="token-line"><span class="token plain">    	blk_qc_t ret = BLK_QC_T_NONE;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (current-&gt;bio_list) {</span></div><div class="token-line"><span class="token plain">    		bio_list_add(&amp;current-&gt;bio_list[0], bio);</span></div><div class="token-line"><span class="token plain">    		goto out;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	bio_list_init(&amp;bio_list_on_stack[0]);</span></div><div class="token-line"><span class="token plain">    	current-&gt;bio_list = bio_list_on_stack;</span></div><div class="token-line"><span class="token plain">    	do {</span></div><div class="token-line"><span class="token plain">    		struct request_queue *q = bdev_get_queue(bio-&gt;bi_bdev);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		if (likely(blk_queue_enter(q, bio-&gt;bi_opf &amp; REQ_NOWAIT) == 0)) {</span></div><div class="token-line"><span class="token plain">    			struct bio_list lower, same;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    			/* Create a fresh bio_list for all subordinate requests */</span></div><div class="token-line"><span class="token plain">    			bio_list_on_stack[1] = bio_list_on_stack[0];</span></div><div class="token-line"><span class="token plain">    			bio_list_init(&amp;bio_list_on_stack[0]);</span></div><div class="token-line"><span class="token plain">    			ret = q-&gt;make_request_fn(q, bio);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    			blk_queue_exit(q);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    			/* sort new bios into those for a lower level</span></div><div class="token-line"><span class="token plain">    			 * and those for the same level</span></div><div class="token-line"><span class="token plain">    			 */</span></div><div class="token-line"><span class="token plain">    			bio_list_init(&amp;lower);</span></div><div class="token-line"><span class="token plain">    			bio_list_init(&amp;same);</span></div><div class="token-line"><span class="token plain">    			while ((bio = bio_list_pop(&amp;bio_list_on_stack[0])) != NULL)</span></div><div class="token-line"><span class="token plain">    				if (q == bdev_get_queue(bio-&gt;bi_bdev))</span></div><div class="token-line"><span class="token plain">    					bio_list_add(&amp;same, bio);</span></div><div class="token-line"><span class="token plain">    				else</span></div><div class="token-line"><span class="token plain">    					bio_list_add(&amp;lower, bio);</span></div><div class="token-line"><span class="token plain">    			/* now assemble so we handle the lowest level first */</span></div><div class="token-line"><span class="token plain">    			bio_list_merge(&amp;bio_list_on_stack[0], &amp;lower);</span></div><div class="token-line"><span class="token plain">    			bio_list_merge(&amp;bio_list_on_stack[0], &amp;same);</span></div><div class="token-line"><span class="token plain">    			bio_list_merge(&amp;bio_list_on_stack[0], &amp;bio_list_on_stack[1]);</span></div><div class="token-line"><span class="token plain">    		} </span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		bio = bio_list_pop(&amp;bio_list_on_stack[0]);</span></div><div class="token-line"><span class="token plain">    	} while (bio);</span></div><div class="token-line"><span class="token plain">    	current-&gt;bio_list = NULL; /* deactivate */</span></div><div class="token-line"><span class="token plain">    out:</span></div><div class="token-line"><span class="token plain">    	return ret;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里的逻辑有点复杂，我们先来看大的逻辑。在do-while中，我们先是获取一个请求队列request_queue，然后调用这个队列的make_request_fn函数。</p><h3 id="块设备队列结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#块设备队列结构"><span class="icon icon-link"></span></a>块设备队列结构</h3><p>如果再来看struct block_device结构和struct gendisk结构，我们会发现，每个块设备都有一个请求队列struct request_queue，用于处理上层发来的请求。</p><p>在每个块设备的驱动程序初始化的时候，会生成一个request_queue。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct request_queue {</span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 * Together with queue_head for cacheline sharing</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	struct list_head	queue_head;</span></div><div class="token-line"><span class="token plain">    	struct request		*last_merge;</span></div><div class="token-line"><span class="token plain">    	struct elevator_queue	*elevator;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	request_fn_proc		*request_fn;</span></div><div class="token-line"><span class="token plain">    	make_request_fn		*make_request_fn;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在请求队列request_queue上，首先是有一个链表list_head，保存请求request。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct request {</span></div><div class="token-line"><span class="token plain">    	struct list_head queuelist;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	struct request_queue *q;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	struct bio *bio;</span></div><div class="token-line"><span class="token plain">    	struct bio *biotail;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>每个request包括一个链表的struct bio，有指针指向一头一尾。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct bio {</span></div><div class="token-line"><span class="token plain">    	struct bio		*bi_next;	/* request queue link */</span></div><div class="token-line"><span class="token plain">    	struct block_device	*bi_bdev;</span></div><div class="token-line"><span class="token plain">    	blk_status_t		bi_status;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        struct bvec_iter	bi_iter;</span></div><div class="token-line"><span class="token plain">    	unsigned short		bi_vcnt;	/* how many bio_vec&#x27;s */</span></div><div class="token-line"><span class="token plain">    	unsigned short		bi_max_vecs;	/* max bvl_vecs we can hold */</span></div><div class="token-line"><span class="token plain">    	atomic_t		__bi_cnt;	/* pin count */</span></div><div class="token-line"><span class="token plain">    	struct bio_vec		*bi_io_vec;	/* the actual vec list */</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct bio_vec {</span></div><div class="token-line"><span class="token plain">    	struct page	*bv_page;</span></div><div class="token-line"><span class="token plain">    	unsigned int	bv_len;</span></div><div class="token-line"><span class="token plain">    	unsigned int	bv_offset;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在bio中，bi_next是链表中的下一项，struct bio_vec指向一组页面。</p><p><img src="/images/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AF%87%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/resourceimage3c0e3c473d163b6e90985d7301f115ab660e.jpeg" alt=""/></p><p>在请求队列request_queue上，还有两个重要的函数，一个是make_request_fn函数，用于生成request；另一个是request_fn函数，用于处理request。</p><h3 id="块设备的初始化"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#块设备的初始化"><span class="icon icon-link"></span></a>块设备的初始化</h3><p>我们还是以scsi驱动为例。在初始化设备驱动的时候，我们会调用scsi_alloc_queue，把request_fn设置为scsi_request_fn。我们还会调用blk_init_allocated_queue-&gt;blk_queue_make_request，把make_request_fn设置为blk_queue_bio。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * scsi_alloc_sdev - allocate and setup a scsi_Device</span></div><div class="token-line"><span class="token plain">     * @starget: which target to allocate a &amp;scsi_device for</span></div><div class="token-line"><span class="token plain">     * @lun: which lun</span></div><div class="token-line"><span class="token plain">     * @hostdata: usually NULL and set by -&gt;slave_alloc instead</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * Description:</span></div><div class="token-line"><span class="token plain">     *     Allocate, initialize for io, and return a pointer to a scsi_Device.</span></div><div class="token-line"><span class="token plain">     *     Stores the @shost, @channel, @id, and @lun in the scsi_Device, and</span></div><div class="token-line"><span class="token plain">     *     adds scsi_Device to the appropriate list.</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * Return value:</span></div><div class="token-line"><span class="token plain">     *     scsi_Device pointer, or NULL on failure.</span></div><div class="token-line"><span class="token plain">     **/</span></div><div class="token-line"><span class="token plain">    static struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,</span></div><div class="token-line"><span class="token plain">    					   u64 lun, void *hostdata)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct scsi_device *sdev;</span></div><div class="token-line"><span class="token plain">    	sdev = kzalloc(sizeof(*sdev) + shost-&gt;transportt-&gt;device_size,</span></div><div class="token-line"><span class="token plain">    		       GFP_ATOMIC);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	sdev-&gt;request_queue = scsi_alloc_queue(sdev);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct Scsi_Host *shost = sdev-&gt;host;</span></div><div class="token-line"><span class="token plain">    	struct request_queue *q;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	q = blk_alloc_queue_node(GFP_KERNEL, NUMA_NO_NODE);</span></div><div class="token-line"><span class="token plain">    	if (!q)</span></div><div class="token-line"><span class="token plain">    		return NULL;</span></div><div class="token-line"><span class="token plain">    	q-&gt;cmd_size = sizeof(struct scsi_cmnd) + shost-&gt;hostt-&gt;cmd_size;</span></div><div class="token-line"><span class="token plain">    	q-&gt;rq_alloc_data = shost;</span></div><div class="token-line"><span class="token plain">    	q-&gt;request_fn = scsi_request_fn;</span></div><div class="token-line"><span class="token plain">    	q-&gt;init_rq_fn = scsi_init_rq;</span></div><div class="token-line"><span class="token plain">    	q-&gt;exit_rq_fn = scsi_exit_rq;</span></div><div class="token-line"><span class="token plain">    	q-&gt;initialize_rq_fn = scsi_initialize_rq;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //调用blk_queue_make_request(q, blk_queue_bio);</span></div><div class="token-line"><span class="token plain">    	if (blk_init_allocated_queue(q) &lt; 0) {</span></div><div class="token-line"><span class="token plain">    		blk_cleanup_queue(q);</span></div><div class="token-line"><span class="token plain">    		return NULL;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	__scsi_init_queue(shost, q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	return q</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在blk_init_allocated_queue中，除了初始化make_request_fn函数，我们还要做一件很重要的事情，就是初始化I/O的电梯算法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int blk_init_allocated_queue(struct request_queue *q)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	q-&gt;fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q-&gt;cmd_size);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	blk_queue_make_request(q, blk_queue_bio);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	/* init elevator */</span></div><div class="token-line"><span class="token plain">    	if (elevator_init(q, NULL)) {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>电梯算法有很多种类型，定义为elevator_type。下面我来逐一说一下。</p><ul><li><strong>struct elevator_type elevator_noop</strong></li></ul><p>Noop调度算法是最简单的IO调度算法，它将IO请求放入到一个FIFO队列中，然后逐个执行这些IO请求。</p><ul><li><strong>struct elevator_type iosched_deadline</strong></li></ul><p>Deadline算法要保证每个IO请求在一定的时间内一定要被服务到，以此来避免某个请求饥饿。为了完成这个目标，算法中引入了两类队列，一类队列用来对请求按起始扇区序号进行排序，通过红黑树来组织，我们称为sort_list，按照此队列传输性能会比较高；另一类队列对请求按它们的生成时间进行排序，由链表来组织，称为fifo_list，并且每一个请求都有一个期限值。</p><ul><li><strong>struct elevator_type iosched_cfq</strong></li></ul><p>又看到了熟悉的CFQ完全公平调度算法。所有的请求会在多个队列中排序。同一个进程的请求，总是在同一队列中处理。时间片会分配到每个队列，通过轮询算法，我们保证了I/O带宽，以公平的方式，在不同队列之间进行共享。</p><p>elevator_init中会根据名称来指定电梯算法，如果没有选择，那就默认使用iosched_cfq。</p><h3 id="请求提交与调度"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#请求提交与调度"><span class="icon icon-link"></span></a>请求提交与调度</h3><p>接下来，我们回到generic_make_request函数中。调用队列的make_request_fn函数，其实就是调用blk_queue_bio。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static blk_qc_t blk_queue_bio(struct request_queue *q, struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct request *req, *free;</span></div><div class="token-line"><span class="token plain">    	unsigned int request_count = 0;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	switch (elv_merge(q, &amp;req, bio)) {</span></div><div class="token-line"><span class="token plain">    	case ELEVATOR_BACK_MERGE:</span></div><div class="token-line"><span class="token plain">    		if (!bio_attempt_back_merge(q, req, bio))</span></div><div class="token-line"><span class="token plain">    			break;</span></div><div class="token-line"><span class="token plain">    		elv_bio_merged(q, req, bio);</span></div><div class="token-line"><span class="token plain">    		free = attempt_back_merge(q, req);</span></div><div class="token-line"><span class="token plain">    		if (free)</span></div><div class="token-line"><span class="token plain">    			__blk_put_request(q, free);</span></div><div class="token-line"><span class="token plain">    		else</span></div><div class="token-line"><span class="token plain">    			elv_merged_request(q, req, ELEVATOR_BACK_MERGE);</span></div><div class="token-line"><span class="token plain">    		goto out_unlock;</span></div><div class="token-line"><span class="token plain">    	case ELEVATOR_FRONT_MERGE:</span></div><div class="token-line"><span class="token plain">    		if (!bio_attempt_front_merge(q, req, bio))</span></div><div class="token-line"><span class="token plain">    			break;</span></div><div class="token-line"><span class="token plain">    		elv_bio_merged(q, req, bio);</span></div><div class="token-line"><span class="token plain">    		free = attempt_front_merge(q, req);</span></div><div class="token-line"><span class="token plain">    		if (free)</span></div><div class="token-line"><span class="token plain">    			__blk_put_request(q, free);</span></div><div class="token-line"><span class="token plain">    		else</span></div><div class="token-line"><span class="token plain">    			elv_merged_request(q, req, ELEVATOR_FRONT_MERGE);</span></div><div class="token-line"><span class="token plain">    		goto out_unlock;</span></div><div class="token-line"><span class="token plain">    	default:</span></div><div class="token-line"><span class="token plain">    		break;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    get_rq:</span></div><div class="token-line"><span class="token plain">    	req = get_request(q, bio-&gt;bi_opf, bio, GFP_NOIO);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	blk_init_request_from_bio(req, bio);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	add_acct_request(q, req, where);</span></div><div class="token-line"><span class="token plain">    	__blk_run_queue(q);</span></div><div class="token-line"><span class="token plain">    out_unlock:</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	return BLK_QC_T_NONE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>blk_queue_bio首先做的一件事情是调用elv_merge来判断，当前这个bio请求是否能够和目前已有的request合并起来，成为同一批I/O操作，从而提高读取和写入的性能。</p><p>判断标准和struct bio的成员struct bvec_iter有关，它里面有两个变量，一个是起始磁盘簇bi_sector，另一个是大小bi_size。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">enum elv_merge elv_merge(struct request_queue *q, struct request **req,</span></div><div class="token-line"><span class="token plain">    		struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct elevator_queue *e = q-&gt;elevator;</span></div><div class="token-line"><span class="token plain">    	struct request *__rq;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	if (q-&gt;last_merge &amp;&amp; elv_bio_merge_ok(q-&gt;last_merge, bio)) {</span></div><div class="token-line"><span class="token plain">    		enum elv_merge ret = blk_try_merge(q-&gt;last_merge, bio);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    		if (ret != ELEVATOR_NO_MERGE) {</span></div><div class="token-line"><span class="token plain">    			*req = q-&gt;last_merge;</span></div><div class="token-line"><span class="token plain">    			return ret;</span></div><div class="token-line"><span class="token plain">    		}</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	__rq = elv_rqhash_find(q, bio-&gt;bi_iter.bi_sector);</span></div><div class="token-line"><span class="token plain">    	if (__rq &amp;&amp; elv_bio_merge_ok(__rq, bio)) {</span></div><div class="token-line"><span class="token plain">    		*req = __rq;</span></div><div class="token-line"><span class="token plain">    		return ELEVATOR_BACK_MERGE;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	if (e-&gt;uses_mq &amp;&amp; e-&gt;type-&gt;ops.mq.request_merge)</span></div><div class="token-line"><span class="token plain">    		return e-&gt;type-&gt;ops.mq.request_merge(q, req, bio);</span></div><div class="token-line"><span class="token plain">    	else if (!e-&gt;uses_mq &amp;&amp; e-&gt;type-&gt;ops.sq.elevator_merge_fn)</span></div><div class="token-line"><span class="token plain">    		return e-&gt;type-&gt;ops.sq.elevator_merge_fn(q, req, bio);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return ELEVATOR_NO_MERGE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>elv_merge尝试了三次合并。</p><p>第一次，它先判断和上一次合并的request能不能再次合并，看看能不能赶上马上要走的这部电梯。在blk_try_merge主要做了这样的判断：如果blk_rq_pos(rq) + blk_rq_sectors(rq) == bio-&gt;bi_iter.bi_sector，也就是说这个request的起始地址加上它的大小（其实是这个request的结束地址），如果和bio的起始地址能接得上，那就把bio放在request的最后，我们称为ELEVATOR_BACK_MERGE。</p><p>如果blk_rq_pos(rq) - bio_sectors(bio) == bio-&gt;bi_iter.bi_sector，也就是说，这个request的起始地址减去bio的大小等于bio的起始地址，这说明bio放在request的最前面能够接得上，那就把bio放在request的最前面，我们称为ELEVATOR_FRONT_MERGE。否则，那就不合并，我们称为ELEVATOR_NO_MERGE。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">enum elv_merge blk_try_merge(struct request *rq, struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">        if (blk_rq_pos(rq) + blk_rq_sectors(rq) == bio-&gt;bi_iter.bi_sector)</span></div><div class="token-line"><span class="token plain">    		return ELEVATOR_BACK_MERGE;</span></div><div class="token-line"><span class="token plain">    	else if (blk_rq_pos(rq) - bio_sectors(bio) == bio-&gt;bi_iter.bi_sector)</span></div><div class="token-line"><span class="token plain">    		return ELEVATOR_FRONT_MERGE;</span></div><div class="token-line"><span class="token plain">    	return ELEVATOR_NO_MERGE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第二次，如果和上一个合并过的request无法合并，那我们就调用elv_rqhash_find。然后按照bio的起始地址查找request，看有没有能够合并的。如果有的话，因为是按照起始地址找的，应该接在人家的后面，所以是ELEVATOR_BACK_MERGE。</p><p>第三次，调用elevator_merge_fn试图合并。对于iosched_cfq，调用的是cfq_merge。在这里面，cfq_find_rq_fmerge会调用elv_rb_find函数，里面的参数是bio的结束地址。我们还是要看，能不能找到可以合并的。如果有的话，因为是按照结束地址找的，应该接在人家前面，所以是ELEVATOR_FRONT_MERGE。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static enum elv_merge cfq_merge(struct request_queue *q, struct request **req,</span></div><div class="token-line"><span class="token plain">    		     struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct cfq_data *cfqd = q-&gt;elevator-&gt;elevator_data;</span></div><div class="token-line"><span class="token plain">    	struct request *__rq;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	__rq = cfq_find_rq_fmerge(cfqd, bio);</span></div><div class="token-line"><span class="token plain">    	if (__rq &amp;&amp; elv_bio_merge_ok(__rq, bio)) {</span></div><div class="token-line"><span class="token plain">    		*req = __rq;</span></div><div class="token-line"><span class="token plain">    		return ELEVATOR_FRONT_MERGE;</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return ELEVATOR_NO_MERGE;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static struct request *</span></div><div class="token-line"><span class="token plain">    cfq_find_rq_fmerge(struct cfq_data *cfqd, struct bio *bio)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct task_struct *tsk = current;</span></div><div class="token-line"><span class="token plain">    	struct cfq_io_cq *cic;</span></div><div class="token-line"><span class="token plain">    	struct cfq_queue *cfqq;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	cic = cfq_cic_lookup(cfqd, tsk-&gt;io_context);</span></div><div class="token-line"><span class="token plain">    	if (!cic)</span></div><div class="token-line"><span class="token plain">    		return NULL;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	cfqq = cic_to_cfqq(cic, op_is_sync(bio-&gt;bi_opf));</span></div><div class="token-line"><span class="token plain">    	if (cfqq)</span></div><div class="token-line"><span class="token plain">    		return elv_rb_find(&amp;cfqq-&gt;sort_list, bio_end_sector(bio));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	return NUL</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>等从elv_merge返回blk_queue_bio的时候，我们就知道，应该做哪种类型的合并，接着就要进行真的合并。如果没有办法合并，那就调用get_request，创建一个新的request，调用blk_init_request_from_bio，将bio放到新的request里面，然后调用add_acct_request，把新的request加到request_queue队列中。</p><p>至此，我们解析完了generic_make_request中最重要的两大逻辑：获取一个请求队列request_queue和调用这个队列的make_request_fn函数。</p><p>其实，generic_make_request其他部分也很令人困惑。感觉里面有特别多的struct bio_list，倒腾过来，倒腾过去的。这是因为，很多块设备是有层次的。</p><p>比如，我们用两块硬盘组成RAID，两个RAID盘组成LVM，然后我们就可以在LVM上创建一个块设备给用户用，我们称接近用户的块设备为<strong>高层次的块设备</strong>，接近底层的块设备为<strong>低层次</strong>（lower）<strong>的块设备</strong>。这样，generic_make_request把I/O请求发送给高层次的块设备的时候，会调用高层块设备的make_request_fn，高层块设备又要调用generic_make_request，将请求发送给低层次的块设备。虽然块设备的层次不会太多，但是对于代码generic_make_request来讲，这可是递归的调用，一不小心，就会递归过深，无法正常退出，而且内核栈的大小又非常有限，所以要比较小心。</p><p>这里你是否理解了struct bio_list bio_list_on_stack[2]的名字为什么叫stack呢？其实，将栈的操作变成对于队列的操作，队列不在栈里面，会大很多。每次generic_make_request被当前任务调用的时候，将current-&gt;bio_list设置为bio_list_on_stack，并在generic_make_request的一开始就判断current-&gt;bio_list是否为空。如果不为空，说明已经在generic_make_request的调用里面了，就不必调用make_request_fn进行递归了，直接把请求加入到bio_list里面就可以了，这就实现了递归的及时退出。</p><p>如果current-&gt;bio_list为空，那我们就将current-&gt;bio_list设置为bio_list_on_stack后，进入do-while循环，做咱们分析过的generic_make_request的两大逻辑。但是，当前的队列调用make_request_fn的时候，在make_request_fn的具体实现中，会生成新的bio。调用更底层的块设备，也会生成新的bio，都会放在bio_list_on_stack的队列中，是一个边处理还边创建的过程。</p><p>bio_list_on_stack[1] = bio_list_on_stack[0]这一句在make_request_fn之前，将之前队列里面遗留没有处理的保存下来，接着bio_list_init将bio_list_on_stack[0]设置为空，然后调用make_request_fn，在make_request_fn里面如果有新的bio生成，都会加到bio_list_on_stack[0]这个队列里面来。</p><p>make_request_fn执行完毕后，可以想象bio_list_on_stack[0]可能又多了一些bio了，接下来的循环中调用bio_list_pop将bio_list_on_stack[0]积攒的bio拿出来，分别放在两个队列lower和same中，顾名思义，lower就是更低层次的块设备的bio，same是同层次的块设备的bio。</p><p>接下来我们能将lower、same以及bio_list_on_stack[1] 都取出来，放在bio_list_on_stack[0]统一进行处理。当然应该lower优先了，因为只有底层的块设备的I/O做完了，上层的块设备的I/O才能做完。</p><p>到这里，generic_make_request的逻辑才算解析完毕。对于写入的数据来讲，其实仅仅是将bio请求放在请求队列上，设备驱动程序还没往设备里面写呢。</p><h3 id="请求的处理"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#请求的处理"><span class="icon icon-link"></span></a>请求的处理</h3><p>设备驱动程序往设备里面写，调用的是请求队列request_queue的另外一个函数request_fn。对于scsi设备来讲，调用的是scsi_request_fn。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static void scsi_request_fn(struct request_queue *q)</span></div><div class="token-line"><span class="token plain">    	__releases(q-&gt;queue_lock)</span></div><div class="token-line"><span class="token plain">    	__acquires(q-&gt;queue_lock)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">    	struct scsi_device *sdev = q-&gt;queuedata;</span></div><div class="token-line"><span class="token plain">    	struct Scsi_Host *shost;</span></div><div class="token-line"><span class="token plain">    	struct scsi_cmnd *cmd;</span></div><div class="token-line"><span class="token plain">    	struct request *req;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    	/*</span></div><div class="token-line"><span class="token plain">    	 * To start with, we keep looping until the queue is empty, or until</span></div><div class="token-line"><span class="token plain">    	 * the host is no longer able to accept any more requests.</span></div><div class="token-line"><span class="token plain">    	 */</span></div><div class="token-line"><span class="token plain">    	shost = sdev-&gt;host;</span></div><div class="token-line"><span class="token plain">    	for (;;) {</span></div><div class="token-line"><span class="token plain">    		int rtn;</span></div><div class="token-line"><span class="token plain">    		/*</span></div><div class="token-line"><span class="token plain">    		 * get next queueable request.  We do this early to make sure</span></div><div class="token-line"><span class="token plain">    		 * that the request is fully prepared even if we cannot</span></div><div class="token-line"><span class="token plain">    		 * accept it.</span></div><div class="token-line"><span class="token plain">    		 */</span></div><div class="token-line"><span class="token plain">    		req = blk_peek_request(q);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		/*</span></div><div class="token-line"><span class="token plain">    		 * Remove the request from the request list.</span></div><div class="token-line"><span class="token plain">    		 */</span></div><div class="token-line"><span class="token plain">    		if (!(blk_queue_tagged(q) &amp;&amp; !blk_queue_start_tag(q, req)))</span></div><div class="token-line"><span class="token plain">    			blk_start_request(req);</span></div><div class="token-line"><span class="token plain">    .....</span></div><div class="token-line"><span class="token plain">    		cmd = req-&gt;special;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    		/*</span></div><div class="token-line"><span class="token plain">    		 * Dispatch the command to the low-level driver.</span></div><div class="token-line"><span class="token plain">    		 */</span></div><div class="token-line"><span class="token plain">    		cmd-&gt;scsi_done = scsi_done;</span></div><div class="token-line"><span class="token plain">    		rtn = scsi_dispatch_cmd(cmd);</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    	}</span></div><div class="token-line"><span class="token plain">    	return;</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这里面是一个for无限循环，从request_queue中读取request，然后封装更加底层的指令，给设备控制器下指令，实施真正的I/O操作。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>这一节我们讲了如何将块设备I/O请求送达到外部设备。</p><p>对于块设备的I/O操作分为两种，一种是直接I/O，另一种是缓存I/O。无论是哪种I/O，最终都会调用submit_bio提交块设备I/O请求。</p><p>对于每一种块设备，都有一个gendisk表示这个设备，它有一个请求队列，这个队列是一系列的request对象。每个request对象里面包含多个BIO对象，指向page cache。所谓的写入块设备，I/O就是将page cache里面的数据写入硬盘。</p><p>对于请求队列来讲，还有两个函数，一个函数叫make_request_fn函数，用于将请求放入队列。submit_bio会调用generic_make_request，然后调用这个函数。</p><p>另一个函数往往在设备驱动程序里实现，我们叫request_fn函数，它用于从队列里面取出请求来，写入外部设备。</p><p><img src="/images/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AF%87%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/resourceimagec93cc9f6a08075ba4eae3314523fa258363c.png" alt=""/></p><p>至此，整个写入文件的过程才算完全结束。这真是个复杂的过程，涉及系统调用、内存管理、文件系统和输入输出。这足以说明，操作系统真的是一个非常复杂的体系，环环相扣，需要分层次层层展开来学习。</p><p>到这里，专栏已经过半了，你应该能发现，很多我之前说“后面会细讲”的东西，现在正在一点一点解释清楚，而文中越来越多出现“前面我们讲过”的字眼，你是否当时学习前面知识的时候，没有在意，导致学习后面的知识产生困惑了呢？没关系，及时倒回去复习，再回过头去看，当初学过的很多知识会变得清晰很多。</p><h2 id="课堂练习"><a aria-hidden="true" tabindex="-1" href="/blog-base/linux操作系统/07.核心原理篇第六部分输入输出系统/05#课堂练习"><span class="icon icon-link"></span></a>课堂练习</h2><p>你知道如何查看磁盘调度算法、修改磁盘调度算法以及I/O队列的长度吗？</p><p>欢迎留言和我分享你的疑惑和见解 ，也欢迎可以收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习和进步。</p><p><img src="/images/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AF%87%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/resourceimage8c378c0a95fa07a8b9a1abfd394479bdd637.jpg" alt=""/></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/linux操作系统/07.核心原理篇第六部分输入输出系统/05.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:09:15</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
