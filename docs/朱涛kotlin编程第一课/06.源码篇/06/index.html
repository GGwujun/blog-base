<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>29 | Dispatchers是如何工作的？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/06.源码篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Dispatchers" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#dispatchers"><span>Dispatchers</span></a></li><li title="CoroutineDispatcher拦截器" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#coroutinedispatcher拦截器"><span>CoroutineDispatcher拦截器</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="29--dispatchers是如何工作的"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#29--dispatchers是如何工作的"><span class="icon icon-link"></span></a>29 | Dispatchers是如何工作的？</h1><p>你好，我是朱涛。今天，我们来分析Kotlin协程当中的Dispatchers。</p><p>上节课里，我们分析了launch的源代码，从中我们知道，Kotlin的launch会调用startCoroutineCancellable()，接着又会调用createCoroutineUnintercepted()，最终会调用编译器帮我们生成SuspendLambda实现类当中的create()方法。这样，协程就创建出来了。不过，协程是创建出来了，可它是如何运行的呢？</p><p>另外我们也都知道，协程无法脱离线程运行，Kotlin当中所有的协程，最终都是运行在线程之上的。**那么，协程创建出来以后，它又是如何跟线程产生关联的？**这节课，我们将进一步分析launch的启动流程，去发掘上节课我们忽略掉的代码分支。</p><p>我相信，经过这节课的学习，你会对协程与线程之间的关系有一个更加透彻的认识。</p><h2 id="dispatchers"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#dispatchers"><span class="icon icon-link"></span></a>Dispatchers</h2><p>在上节课里我们学习过，launch<!-- -->{<!-- -->}<!-- -->本质上是调用了startCoroutineCancellable()当中的createCoroutineUnintercepted()方法创建了协程。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {</span></div><div class="token-line"><span class="token plain">        //                                        注意这里</span></div><div class="token-line"><span class="token plain">        //                                           ↓</span></div><div class="token-line"><span class="token plain">        createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么下面，我们就接着上节课的流程，继续分析createCoroutineUnintercepted(completion)之后的 <strong>intercepted()方法</strong>。</p><p>不过，在正式分析intercepted()之前，我们还需要弄清楚Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext之间的关系。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段2</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public actual object Dispatchers {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public actual val Default: CoroutineDispatcher = DefaultScheduler</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public val IO: CoroutineDispatcher = DefaultIoScheduler</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public fun shutdown() {    }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public abstract class CoroutineDispatcher :</span></div><div class="token-line"><span class="token plain">        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public interface ContinuationInterceptor : CoroutineContext.Element {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public interface Element : CoroutineContext {}</span></div></pre></div><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/488571">第17讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中，我们曾经分析过它们之间的继承关系。Dispatchers是一个单例对象，它当中的Default、Main、Unconfined、IO，类型都是CoroutineDispatcher，而它本身就是CoroutineContext。所以，它们之间的关系就可以用下面这个图来描述。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2cd12cf4c3c45b6f6838e5fyy16a4fce02d1.31692a22.jpg" alt=""/></p><p>让我们结合这张图，来看看下面这段代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() {</span></div><div class="token-line"><span class="token plain">        testLaunch()</span></div><div class="token-line"><span class="token plain">        Thread.sleep(2000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private fun testLaunch() {</span></div><div class="token-line"><span class="token plain">        val scope = CoroutineScope(Job())</span></div><div class="token-line"><span class="token plain">        scope.launch{</span></div><div class="token-line"><span class="token plain">            logX(&quot;Hello!&quot;)</span></div><div class="token-line"><span class="token plain">            delay(1000L)</span></div><div class="token-line"><span class="token plain">            logX(&quot;World!&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /**</span></div><div class="token-line"><span class="token plain">     * 控制台输出带协程信息的log</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    fun logX(any: Any?) {</span></div><div class="token-line"><span class="token plain">        println(</span></div><div class="token-line"><span class="token plain">            &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    $any</span></div><div class="token-line"><span class="token plain">    Thread:${Thread.currentThread().name}</span></div><div class="token-line"><span class="token plain">    ================================&quot;&quot;&quot;.trimIndent()</span></div><div class="token-line"><span class="token plain">        )</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    Hello!</span></div><div class="token-line"><span class="token plain">    Thread:DefaultDispatcher-worker-1 @coroutine#1</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    World!</span></div><div class="token-line"><span class="token plain">    Thread:DefaultDispatcher-worker-1 @coroutine#1</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在这段代码中，我们没有为launch()传入任何CoroutineContext参数，但通过执行结果，我们发现协程代码居然执行在DefaultDispatcher，并没有运行在main线程之上。这是为什么呢？</p><p>我们可以回过头来分析下launch的源代码，去看看上节课中我们刻意忽略的地方。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段4</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun CoroutineScope.launch(</span></div><div class="token-line"><span class="token plain">        context: CoroutineContext = EmptyCoroutineContext,</span></div><div class="token-line"><span class="token plain">        start: CoroutineStart = CoroutineStart.DEFAULT,</span></div><div class="token-line"><span class="token plain">        block: suspend CoroutineScope.() -&gt; Unit</span></div><div class="token-line"><span class="token plain">    ): Job {</span></div><div class="token-line"><span class="token plain">        // 1</span></div><div class="token-line"><span class="token plain">        val newContext = newCoroutineContext(context)</span></div><div class="token-line"><span class="token plain">        val coroutine = if (start.isLazy)</span></div><div class="token-line"><span class="token plain">            LazyStandaloneCoroutine(newContext, block) else</span></div><div class="token-line"><span class="token plain">            StandaloneCoroutine(newContext, active = true)</span></div><div class="token-line"><span class="token plain">        coroutine.start(start, coroutine, block)</span></div><div class="token-line"><span class="token plain">        return coroutine</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先，请留意launch的第一个参数，context，它的默认值是EmptyCoroutineContext。在第17讲里，我曾提到过，CoroutineContext就相当于Map，而EmptyCoroutineContext则相当于一个空的Map。所以，我们可以认为，这里的EmptyCoroutineContext传了也相当于没有传，它的目的只是为了让context参数不为空而已。<strong>这其实也体现出了Kotlin的空安全思维，Kotlin官方用EmptyCoroutineContext替代了null。</strong></p><p>接着，请留意上面代码的注释1，这行代码会调用newCoroutineContext(context)，将传入的context参数重新包装一下，然后返回。让我们看看它具体的逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段5</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {</span></div><div class="token-line"><span class="token plain">        // 1</span></div><div class="token-line"><span class="token plain">        val combined = coroutineContext.foldCopiesForChildCoroutine() + context</span></div><div class="token-line"><span class="token plain">        // 2</span></div><div class="token-line"><span class="token plain">        val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined</span></div><div class="token-line"><span class="token plain">        // 3</span></div><div class="token-line"><span class="token plain">        return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null)</span></div><div class="token-line"><span class="token plain">            debug + Dispatchers.Default else debug</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码一共有三个注释，我们来分析一下：</p><ul><li>注释1，由于newCoroutineContext()是CoroutineScope的扩展函数，因此，我们可以直接访问CoroutineScope的coroutineContext对象，它其实就是CoroutineScope对应的上下文。foldCopiesForChildCoroutine()的作用，其实就是将CoroutineScope当中的所有上下文元素都拷贝出来，然后跟传入的context参数进行合并。<strong>这行代码，可以让子协程继承父协程的上下文元素。</strong></li><li>注释2，它的作用是在调试模式下，为我们的协程对象增加唯一的ID。我们在代码段3的输出结果中看到的“@coroutine#1”，其中的数字“1”就是在这个阶段生成的。</li><li>注释3，如果合并过后的combined当中没有CoroutineDispatcher，那么，就会默认使用Dispatchers.Default。</li></ul><p>看到这里，你也许会有一个疑问，为什么协程默认的线程池是Dispatchers.Default，而不是Main呢？答案其实也很简单，因为Kotlin协程是支持多平台的，<strong>Main线程只在UI编程平台才有可用</strong>。因此，当我们的协程没有指定Dispatcher的时候，就只能使用Dispatchers.Default了。毕竟，协程是无法脱离线程执行的。</p><p>那么现在，代码段3当中的协程执行在Dispatchers.Default的原因也就找到了：由于我们定义的scope没有指定Dispatcher，同时launch的参数也没有传入Dispatcher，最终在newCoroutineContext()的时候，会被默认指定为Default线程池。</p><p>好，有了前面的基础以后，接下来，我们就可以开始intercepted()的逻辑了。</p><h2 id="coroutinedispatcher拦截器"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#coroutinedispatcher拦截器"><span class="icon icon-link"></span></a>CoroutineDispatcher拦截器</h2><p>让我们回到课程开头提到过的startCoroutineCancellable()方法的源代码，其中的createCoroutineUnintercepted()方法，我们在上节课已经分析过了，它的返回值类型就是Continuation。而<strong>intercepted()方法，其实就是Continuation的扩展函数</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段6</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {</span></div><div class="token-line"><span class="token plain">        //                                        注意这里</span></div><div class="token-line"><span class="token plain">        //                                           ↓</span></div><div class="token-line"><span class="token plain">        createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =</span></div><div class="token-line"><span class="token plain">        (this as? ContinuationImpl)?.intercepted() ?: this</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal abstract class ContinuationImpl(</span></div><div class="token-line"><span class="token plain">        completion: Continuation&lt;Any?&gt;?,</span></div><div class="token-line"><span class="token plain">        private val _context: CoroutineContext?</span></div><div class="token-line"><span class="token plain">    ) : BaseContinuationImpl(completion) {</span></div><div class="token-line"><span class="token plain">        constructor(completion: Continuation&lt;Any?&gt;?) : this(completion, completion?.context)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Transient</span></div><div class="token-line"><span class="token plain">        private var intercepted: Continuation&lt;Any?&gt;? = null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 1</span></div><div class="token-line"><span class="token plain">        public fun intercepted(): Continuation&lt;Any?&gt; =</span></div><div class="token-line"><span class="token plain">            intercepted</span></div><div class="token-line"><span class="token plain">                ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)</span></div><div class="token-line"><span class="token plain">                    .also { intercepted = it }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面的代码中，我们可以看到，startCoroutineCancellable()当中的intercepted()最终会调用BaseContinuationImpl的intercepted()方法。</p><p>这里，请你留意代码中我标记出的注释，intercepted()方法首先会判断它的成员变量 <strong>intercepted是否为空</strong>，如果为空，就会调用context[ContinuationInterceptor]，获取上下文当中的Dispatcher对象。以代码段3当中的逻辑为例，这时候的Dispatcher肯定是Default线程池。</p><p>然后，如果我们继续跟进interceptContinuation(this)方法的话，会发现程序最终会调用CoroutineDispatcher的interceptContinuation()方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段7</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public abstract class CoroutineDispatcher :</span></div><div class="token-line"><span class="token plain">        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 1</span></div><div class="token-line"><span class="token plain">        public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =</span></div><div class="token-line"><span class="token plain">            DispatchedContinuation(this, continuation)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>同样留意下这里的注释1，interceptContinuation()直接返回了一个DispatchedContinuation对象，并且将this、continuation作为参数传了进去。这里的this，其实就是Dispatchers.Default。</p><p>所以，如果我们把startCoroutineCancellable()改写一下，它实际上会变成下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段8</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {</span></div><div class="token-line"><span class="token plain">        createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 等价</span></div><div class="token-line"><span class="token plain">    //  ↓</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {</span></div><div class="token-line"><span class="token plain">        // 1</span></div><div class="token-line"><span class="token plain">        val continuation = createCoroutineUnintercepted(completion)</span></div><div class="token-line"><span class="token plain">        // 2</span></div><div class="token-line"><span class="token plain">        val dispatchedContinuation = continuation.intercepted()</span></div><div class="token-line"><span class="token plain">        // 3</span></div><div class="token-line"><span class="token plain">        dispatchedContinuation.resumeCancellableWith(Result.success(Unit))</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面的代码中，注释1，2我们都已经分析完了，现在只剩下注释3了。这里的resumeCancellableWith()，其实就是真正将协程任务分发到线程上的逻辑。让我们继续跟进分析源代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段9</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal class DispatchedContinuation&lt;in T&gt;(</span></div><div class="token-line"><span class="token plain">        @JvmField val dispatcher: CoroutineDispatcher,</span></div><div class="token-line"><span class="token plain">        @JvmField val continuation: Continuation&lt;T&gt;</span></div><div class="token-line"><span class="token plain">    ) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        inline fun resumeCancellableWith(</span></div><div class="token-line"><span class="token plain">            result: Result&lt;T&gt;,</span></div><div class="token-line"><span class="token plain">            noinline onCancellation: ((cause: Throwable) -&gt; Unit)?</span></div><div class="token-line"><span class="token plain">        ) {</span></div><div class="token-line"><span class="token plain">            // 省略，留到后面分析</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>也就是，DispatchedContinuation是实现了Continuation接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性continuation。通过之前代码段7的分析，我们知道它的成员属性 <strong>dispatcher对应的就是Dispatcher.Default</strong>，而成员属性 <strong>continuation对应的则是launch当中传入的SuspendLambda实现类</strong>。</p><p>另外，DispatchedContinuation还继承自DispatchedTask，我们来看看DispatchedTask到底是什么。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal abstract class DispatchedTask&lt;in T&gt;(</span></div><div class="token-line"><span class="token plain">        @JvmField public var resumeMode: Int</span></div><div class="token-line"><span class="token plain">    ) : SchedulerTask() {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal actual typealias SchedulerTask = Task</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal abstract class Task(</span></div><div class="token-line"><span class="token plain">        @JvmField var submissionTime: Long,</span></div><div class="token-line"><span class="token plain">        @JvmField var taskContext: TaskContext</span></div><div class="token-line"><span class="token plain">    ) : Runnable {</span></div><div class="token-line"><span class="token plain">        constructor() : this(0, NonBlockingContext)</span></div><div class="token-line"><span class="token plain">        inline val mode: Int get() = taskContext.taskMode // TASK_XXX</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，DispatchedContinuation继承自DispatchedTask，而它则是SchedulerTask的子类，SchedulerTask是Task的类型别名，而Task实现了Runnable接口。因此，<strong>DispatchedContinuation不仅是一个Continuation，同时还是一个Runnable。</strong></p><p>那么，既然它是Runnable，也就意味着它可以被分发到Java的线程当中去执行了。所以接下来，我们就来看看resumeCancellableWith()当中具体的逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段9</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal class DispatchedContinuation&lt;in T&gt;(</span></div><div class="token-line"><span class="token plain">        @JvmField val dispatcher: CoroutineDispatcher,</span></div><div class="token-line"><span class="token plain">        @JvmField val continuation: Continuation&lt;T&gt;</span></div><div class="token-line"><span class="token plain">    ) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        inline fun resumeCancellableWith(</span></div><div class="token-line"><span class="token plain">            result: Result&lt;T&gt;,</span></div><div class="token-line"><span class="token plain">            noinline onCancellation: ((cause: Throwable) -&gt; Unit)?</span></div><div class="token-line"><span class="token plain">        ) {</span></div><div class="token-line"><span class="token plain">            val state = result.toState(onCancellation)</span></div><div class="token-line"><span class="token plain">            // 1</span></div><div class="token-line"><span class="token plain">            if (dispatcher.isDispatchNeeded(context)) {</span></div><div class="token-line"><span class="token plain">                _state = state</span></div><div class="token-line"><span class="token plain">                resumeMode = MODE_CANCELLABLE</span></div><div class="token-line"><span class="token plain">                // 2</span></div><div class="token-line"><span class="token plain">                dispatcher.dispatch(context, this)</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                // 3</span></div><div class="token-line"><span class="token plain">                executeUnconfined(state, MODE_CANCELLABLE) {</span></div><div class="token-line"><span class="token plain">                    if (!resumeCancelled(state)) {</span></div><div class="token-line"><span class="token plain">                        resumeUndispatchedWith(result)</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public abstract class CoroutineDispatcher :</span></div><div class="token-line"><span class="token plain">        AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {</span></div><div class="token-line"><span class="token plain">        // 默认是true</span></div><div class="token-line"><span class="token plain">        public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public abstract fun dispatch(context: CoroutineContext, block: Runnable)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal object Unconfined : CoroutineDispatcher() {</span></div><div class="token-line"><span class="token plain">        // 只有Unconfined会重写成false</span></div><div class="token-line"><span class="token plain">        override fun isDispatchNeeded(context: CoroutineContext): Boolean = false</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码里也有三个注释，我们来分析一下：</p><ul><li>注释1，dispatcher.isDispatchNeeded()，通过查看CoroutineDispatcher的源代码，我们发现它的返回值始终都是true。在它的子类当中，只有Dispatchers.Unconfined会将其重写成false。这也就意味着，除了Unconfined以外，其他的Dispatcher都会返回true。对于我们代码段3当中的代码而言，我们的Dispatcher是默认的Default，所以，代码将会进入注释2对应的分支。</li><li>注释2，dispatcher.dispatch(context, this)，这里其实就相当于将代码的执行流程分发到Default线程池。dispatch()的第二个参数要求是Runnable，这里我们传入的是this，这是因为DispatchedContinuation本身就间接实现了Runnable接口。</li><li>注释3，executeUnconfined<!-- -->{<!-- -->}<!-- -->，它其实就对应着Dispather是Unconfined的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。</li></ul><p>接下来，让我们继续沿着注释2进行分析，这里的dispatcher.dispatch()其实就相当于调用了Dispatchers.Default.dispatch()。让我们看看它的逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public actual object Dispatchers {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @JvmStatic</span></div><div class="token-line"><span class="token plain">        public actual val Default: CoroutineDispatcher = DefaultScheduler</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal object DefaultScheduler : SchedulerCoroutineDispatcher(</span></div><div class="token-line"><span class="token plain">        CORE_POOL_SIZE, MAX_POOL_SIZE,</span></div><div class="token-line"><span class="token plain">        IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME</span></div><div class="token-line"><span class="token plain">    ) {}</span></div></pre></div><p>那么，从上面的代码中，我们可以看到，<strong>Dispatchers.Default本质上是一个单例对象DefaultScheduler</strong>，它是SchedulerCoroutineDispatcher的子类。<br/>我们也来看看SchedulerCoroutineDispatcher的源代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal open class SchedulerCoroutineDispatcher(</span></div><div class="token-line"><span class="token plain">        private val corePoolSize: Int = CORE_POOL_SIZE,</span></div><div class="token-line"><span class="token plain">        private val maxPoolSize: Int = MAX_POOL_SIZE,</span></div><div class="token-line"><span class="token plain">        private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,</span></div><div class="token-line"><span class="token plain">        private val schedulerName: String = &quot;CoroutineScheduler&quot;,</span></div><div class="token-line"><span class="token plain">    ) : ExecutorCoroutineDispatcher() {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private var coroutineScheduler = createScheduler()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>根据以上代码，我们可以看到Dispatchers.Default.dispatch()最终会调用SchedulerCoroutineDispatcher的dispatch()方法，而它实际上调用的是coroutineScheduler.dispatch()。</p><p>这里，我们同样再来看看CoroutineScheduler的源代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal class CoroutineScheduler(</span></div><div class="token-line"><span class="token plain">        @JvmField val corePoolSize: Int,</span></div><div class="token-line"><span class="token plain">        @JvmField val maxPoolSize: Int,</span></div><div class="token-line"><span class="token plain">        @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,</span></div><div class="token-line"><span class="token plain">        @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME</span></div><div class="token-line"><span class="token plain">    ) : Executor, Closeable {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        override fun execute(command: Runnable) = dispatch(command)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {</span></div><div class="token-line"><span class="token plain">            trackTask() </span></div><div class="token-line"><span class="token plain">            // 1</span></div><div class="token-line"><span class="token plain">            val task = createTask(block, taskContext)</span></div><div class="token-line"><span class="token plain">            // 2</span></div><div class="token-line"><span class="token plain">            val currentWorker = currentWorker()</span></div><div class="token-line"><span class="token plain">            // 3</span></div><div class="token-line"><span class="token plain">            val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)</span></div><div class="token-line"><span class="token plain">            if (notAdded != null) {</span></div><div class="token-line"><span class="token plain">                if (!addToGlobalQueue(notAdded)) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    throw RejectedExecutionException(&quot;$schedulerName was terminated&quot;)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            val skipUnpark = tailDispatch &amp;&amp; currentWorker != null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            if (task.mode == TASK_NON_BLOCKING) {</span></div><div class="token-line"><span class="token plain">                if (skipUnpark) return</span></div><div class="token-line"><span class="token plain">                signalCpuWork()</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                signalBlockingWork(skipUnpark = skipUnpark)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 内部类 Worker</span></div><div class="token-line"><span class="token plain">        internal inner class Worker private constructor() : Thread() {</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你发现了吗？CoroutineScheduler其实是Java并发包下的Executor的子类，它的execute()方法也被转发到了dispatch()。</p><p>上面的代码里也有三个注释，我们分别来看看：</p><ul><li>注释1，将传入的Runnable类型的block（也就是DispatchedContinuation），包装成Task。</li><li>注释2，currentWorker()，拿到当前执行的线程。这里的Worker其实是一个内部类，它本质上仍然是Java的Thread。</li><li>注释3，currentWorker.submitToLocalQueue()，将当前的Task添加到Worker线程的本地队列，等待执行。</li></ul><p>那么接下来，我们就来分析下Worker是如何执行Task的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal inner class Worker private constructor() : Thread() {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        override fun run() = runWorker()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @JvmField</span></div><div class="token-line"><span class="token plain">        var mayHaveLocalTasks = false</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        private fun runWorker() {</span></div><div class="token-line"><span class="token plain">            var rescanned = false</span></div><div class="token-line"><span class="token plain">            while (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) {</span></div><div class="token-line"><span class="token plain">                // 1</span></div><div class="token-line"><span class="token plain">                val task = findTask(mayHaveLocalTasks)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                if (task != null) {</span></div><div class="token-line"><span class="token plain">                    rescanned = false</span></div><div class="token-line"><span class="token plain">                    minDelayUntilStealableTaskNs = 0L</span></div><div class="token-line"><span class="token plain">                    // 2</span></div><div class="token-line"><span class="token plain">                    executeTask(task)</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    mayHaveLocalTasks = false</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                if (minDelayUntilStealableTaskNs != 0L) {</span></div><div class="token-line"><span class="token plain">                    if (!rescanned) {</span></div><div class="token-line"><span class="token plain">                        rescanned = true</span></div><div class="token-line"><span class="token plain">                    } else {</span></div><div class="token-line"><span class="token plain">                        rescanned = false</span></div><div class="token-line"><span class="token plain">                        tryReleaseCpu(WorkerState.PARKING)</span></div><div class="token-line"><span class="token plain">                        interrupted()</span></div><div class="token-line"><span class="token plain">                        LockSupport.parkNanos(minDelayUntilStealableTaskNs)</span></div><div class="token-line"><span class="token plain">                        minDelayUntilStealableTaskNs = 0L</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    continue</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                tryPark()</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            tryReleaseCpu(WorkerState.TERMINATED)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实际上，Worker会重写Thread的run()方法，然后把执行流程交给runWorker()，以上代码里有两个关键的地方，我也用注释标记了。</p><ul><li>注释1，在while循环当中，会一直尝试从Worker的本地队列取Task出来，如果存在需要执行的Task，就会进入下一步。</li><li>注释2，executeTask(task)，其实就是执行对应的Task。</li></ul><p>而接下来的逻辑，就是<strong>最关键的部分</strong>了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal inner class Worker private constructor() : Thread() {</span></div><div class="token-line"><span class="token plain">        private fun executeTask(task: Task) {</span></div><div class="token-line"><span class="token plain">            val taskMode = task.mode</span></div><div class="token-line"><span class="token plain">            idleReset(taskMode)</span></div><div class="token-line"><span class="token plain">            beforeTask(taskMode)</span></div><div class="token-line"><span class="token plain">            // 1</span></div><div class="token-line"><span class="token plain">            runSafely(task)</span></div><div class="token-line"><span class="token plain">            afterTask(taskMode)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun runSafely(task: Task) {</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            // 2</span></div><div class="token-line"><span class="token plain">            task.run()</span></div><div class="token-line"><span class="token plain">        } catch (e: Throwable) {</span></div><div class="token-line"><span class="token plain">            val thread = Thread.currentThread()</span></div><div class="token-line"><span class="token plain">            thread.uncaughtExceptionHandler.uncaughtException(thread, e)</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            unTrackTask()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    internal abstract class Task(</span></div><div class="token-line"><span class="token plain">        @JvmField var submissionTime: Long,</span></div><div class="token-line"><span class="token plain">        @JvmField var taskContext: TaskContext</span></div><div class="token-line"><span class="token plain">    ) : Runnable {</span></div><div class="token-line"><span class="token plain">        constructor() : this(0, NonBlockingContext)</span></div><div class="token-line"><span class="token plain">        inline val mode: Int get() = taskContext.taskMode // TASK_XXX</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在Worker的executeTask()方法当中，会调用runSafely()方法，而在这个方法当中，最终会调用task.run()。前面我们就提到过 <strong>Task本质上就是Runnable，而Runnable.run()其实就代表了我们的协程任务真正执行了！</strong></p><p>那么，task.run()具体执行的代码是什么呢？其实它是执行的 <strong>DispatchedTask.run()</strong>。这里的DispatchedTask实际上是DispatchedContinuation的父类。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">internal class DispatchedContinuation&lt;in T&gt;(</span></div><div class="token-line"><span class="token plain">        @JvmField val dispatcher: CoroutineDispatcher,</span></div><div class="token-line"><span class="token plain">        @JvmField val continuation: Continuation&lt;T&gt;</span></div><div class="token-line"><span class="token plain">    ) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public final override fun run() {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            val taskContext = this.taskContext</span></div><div class="token-line"><span class="token plain">            var fatalException: Throwable? = null</span></div><div class="token-line"><span class="token plain">            try {</span></div><div class="token-line"><span class="token plain">                val delegate = delegate as DispatchedContinuation&lt;T&gt;</span></div><div class="token-line"><span class="token plain">                val continuation = delegate.continuation</span></div><div class="token-line"><span class="token plain">                withContinuationContext(continuation, delegate.countOrElement) {</span></div><div class="token-line"><span class="token plain">                    val context = continuation.context</span></div><div class="token-line"><span class="token plain">                    val state = takeState() </span></div><div class="token-line"><span class="token plain">                    val exception = getExceptionalResult(state)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                    val job = if (exception == null &amp;&amp; resumeMode.isCancellableMode) context[Job] else null</span></div><div class="token-line"><span class="token plain">                    if (job != null &amp;&amp; !job.isActive) {</span></div><div class="token-line"><span class="token plain">                        // 1</span></div><div class="token-line"><span class="token plain">                        val cause = job.getCancellationException()</span></div><div class="token-line"><span class="token plain">                        cancelCompletedResult(state, cause)</span></div><div class="token-line"><span class="token plain">                        continuation.resumeWithStackTrace(cause)</span></div><div class="token-line"><span class="token plain">                    } else {</span></div><div class="token-line"><span class="token plain">                        if (exception != null) {</span></div><div class="token-line"><span class="token plain">                            // 2</span></div><div class="token-line"><span class="token plain">                            continuation.resumeWithException(exception)</span></div><div class="token-line"><span class="token plain">                        } else {</span></div><div class="token-line"><span class="token plain">                            // 3</span></div><div class="token-line"><span class="token plain">                            continuation.resume(getSuccessfulResult(state))</span></div><div class="token-line"><span class="token plain">                        }</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            } catch (e: Throwable) {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                fatalException = e</span></div><div class="token-line"><span class="token plain">            } finally {</span></div><div class="token-line"><span class="token plain">                val result = runCatching { taskContext.afterTask() }</span></div><div class="token-line"><span class="token plain">                handleFatalException(fatalException, result.exceptionOrNull())</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码有三个关键的注释，我们一起来分析：</p><ul><li>注释1，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用continuation.resumeWithStackTrace(cause)将具体的原因传出去。</li><li>注释2，判断协程是否发生了异常，如果已经发生了异常，则需要调用continuation.resumeWithException(exception)将异常传递出去。</li><li>注释3，如果一切正常，则会调用continuation.resume(getSuccessfulResult(state))，这时候，协程才会正式启动，并且执行launch当中传入的Lambda表达式。</li></ul><p>最后，按照惯例，我还是制作了一个视频，来向你展示整个Dispather的代码执行流程。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们围绕着launch，着重分析了它的Dispatchers执行流程。Dispatchers是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤：</p><ul><li>第一步，createCoroutineUnintercepted(completion)创建了协程的Continuation实例，紧接着就会调用它的intercepted()方法，将其封装成DispatchedContinuation对象。</li><li>第二步，DispatchedContinuation会持有CoroutineDispatcher、以及前面创建的Continuation对象。课程中的CoroutineDispatcher实际上就是Default线程池。</li><li>第三步，执行DispatchedContinuation的resumeCancellableWith()方法，这时候，就会执行dispatcher.dispatch()，这就会将协程的Continuation封装成Task添加到Worker的本地任务队列，等待执行。这里的Worker本质上就是Java的Thread。<strong>在这一步，协程就已经完成了线程的切换</strong>。</li><li>第四步，Worker的run()方法会调用runWork()，它会从本地的任务队列当中取出Task，并且调用task.run()。而它实际上调用的是DispatchedContinuation的run()方法，在这里，会调用continuation.resume()，它将执行原本launch当中生成的SuspendLambda子类。<strong>这时候，launch协程体当中的代码，就在线程上执行了</strong>。</li></ul><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>经过这节课的学习以后，请问你是否对协程的本质有了更深入的认识？请讲讲你的心得体会吧！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/06.源码篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:23:04</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
