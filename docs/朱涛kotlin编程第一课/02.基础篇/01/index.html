<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>01 | Kotlin基础语法：正式开启学习之旅 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/02.基础篇/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="开发环境" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#开发环境"><span>开发环境</span></a></li><li title="变量" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#变量"><span>变量</span></a></li><li title="基础类型" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#基础类型"><span>基础类型</span></a></li><li title="一切都是对象" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#一切都是对象"><span>一切都是对象</span></a></li><li title="空安全" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#空安全"><span>空安全</span></a></li><li title="数字类型" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#数字类型"><span>数字类型</span></a></li><li title="布尔类型" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#布尔类型"><span>布尔类型</span></a></li><li title="字符：Char" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#字符char"><span>字符：Char</span></a></li><li title="字符串：String" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#字符串string"><span>字符串：String</span></a></li><li title="数组" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#数组"><span>数组</span></a></li><li title="函数声明" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#函数声明"><span>函数声明</span></a></li><li title="函数调用" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#函数调用"><span>函数调用</span></a></li><li title="流程控制" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#流程控制"><span>流程控制</span></a></li><li title="if" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#if"><span>if</span></a></li><li title="when" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#when"><span>when</span></a></li><li title="循环迭代：while与for" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#循环迭代while与for"><span>循环迭代：while与for</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="01--kotlin基础语法正式开启学习之旅"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#01--kotlin基础语法正式开启学习之旅"><span class="icon icon-link"></span></a>01 | Kotlin基础语法：正式开启学习之旅</h1><p>你好，我是朱涛。从今天开始，我们就正式踏上Kotlin语言学习与实践的旅途了。这节课，我想先带你来学习下Kotlin的基础语法，包括变量、基础类型、函数和流程控制。这些基础语法是程序最基本的元素。</p><p>不过，如果你有使用Java的经验，可能会觉得今天的内容有点多余，毕竟Kotlin和Java的基础语法是比较相似的，它们都是基于JVM的语言。但其实不然，Kotlin作为一门新的语言，它包含了许多新的特性，由此也决定着Kotlin的代码风格。<strong>如果你不够了解Kotlin的这些新特性，你会发现自己只是换了种方式在写Java而已。</strong></p><p>并且，在具备Java语言的知识基础上，这节课的内容也可以帮你快速将已有的经验迁移过来。这样的话，针对相似的语法，你可以直接建立Kotlin与Java的对应关系，进而加深理解。当然，即使你没有其他编程经验也没关系，从头学即可，Kotlin的语法足够简洁，也非常适合作为第一门计算机语言来学习。</p><p>在课程中，我会用最通俗易懂的语言，来给你解释Kotlin的基础知识，并且会结合一些Java和Kotlin的代码案例，来帮助你直观地体会两种语言的异同点。而针对新的语法，我也会详细解释它存在的意义，以及都填补了Java的哪些短板，让你可以对Kotlin新语法的使用场景做到心中基本有数。</p><h2 id="开发环境"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#开发环境"><span class="icon icon-link"></span></a>开发环境</h2><p>在正式开始学习基础语法之前，我们还需要配置一下Kotlin语言的环境，因为直接从代码开始学能给我们带来最直观的体验。</p><p>那么要运行Kotlin代码，最快的方式，就是<strong>使用Kotlin官方的</strong><a target="_blank" rel="noopener noreferrer" href="https://play.kotlinlang.org/">PlayGround<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。通过这个在线工具，我们可以非常方便地运行Kotlin代码片段。当然，这种方式用来临时测试一小段代码是没有问题的，但对于复杂的工程就有些力不从心了。</p><p>另一种方式，也是<strong>我个人比较推荐的方式，那就是安装</strong><a target="_blank" rel="noopener noreferrer" href="https://www.jetbrains.com/idea/download/">IntelliJ IDEA<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。它是Kotlin官方提供的集成开发工具，也是世界上最好的IDE之一，如果你用过Android Studio，你一定会对它很熟悉，因为Android Studio就是由IntelliJ IDEA改造的。</p><p>如果你的电脑没有Java环境，在安装完最新版的IntelliJ IDEA以后，通过“File -&gt; Project Structure -&gt; SDKs”，然后点击“加号按钮”就可以选择第三方提供的OpenJDK 1.8版本进行下载了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage04a704cf1b899574ceff2ecd099e41af1fa7.a6928753.gif" alt="图片"/></p><p>当然，这里我更推荐你可以自己手动从<a target="_blank" rel="noopener noreferrer" href="https://www.oracle.com/java/technologies/downloads/">Oracle官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载JDK 1.6、1.7、1.8、11这几个版本，然后再安装、配置Java多版本环境。这在实际工作中也是必备的。</p><p>需要注意的是，IntelliJ IDEA分为Ultimate付费版和Community免费版，对于我们的Kotlin学习来说，免费版完全够用。</p><p>这样，在配置好了开发环境之后，我们就可以试着一边敲代码，一边体会、思考和学习Kotlin语言中这些最基础的语法知识了。那么下面我们就来看下，在Kotlin语言中是如何定义变量的吧。</p><h2 id="变量"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#变量"><span class="icon icon-link"></span></a>变量</h2><p>在Java/C当中，如果我们要声明变量，我们必须要声明它的类型，后面跟着变量的名称和对应的值，然后以分号结尾。就像这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Integer price = 100;</span></div></pre></div><p>而Kotlin则不一样，我们要使用“<strong>val</strong>”或者是“<strong>var</strong>”这样的关键字作为开头，后面跟“变量名称”，接着是“变量类型”和“赋值语句”，最后是分号结尾。就像这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*</span></div><div class="token-line"><span class="token plain">    关键字     变量类型</span></div><div class="token-line"><span class="token plain">     ↓          ↓           */</span></div><div class="token-line"><span class="token plain">    var price: Int = 100;   /*</span></div><div class="token-line"><span class="token plain">         ↑            ↑</span></div><div class="token-line"><span class="token plain">       变量名        变量值   */</span></div></pre></div><p>不过，像Java那样每写一行代码就写一个分号，其实也挺麻烦的。所以为了省事，在Kotlin里面，我们一般会把代码末尾的分号省略，就像这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var price: Int = 100</span></div></pre></div><p>另外，由于Kotlin支持<strong>类型推导</strong>，大部分情况下，我们的变量类型可以省略不写，就像这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var price = 100 // 默认推导类型为： Int</span></div></pre></div><p>还有一点我们要注意，就是在Kotlin当中，我们应该尽可能避免使用var，<strong>尽可能多地去使用val</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var price = 100</span></div><div class="token-line"><span class="token plain">    price = 101</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    val i = 0</span></div><div class="token-line"><span class="token plain">    i = 1 // 编译器报错</span></div></pre></div><p>原因其实很简单：</p><ul><li>val声明的变量，我们叫做<strong>不可变变量</strong>，它的值在初始化以后就无法再次被修改，它相当于Java里面的final变量。</li><li>var声明的变量，我们叫做<strong>可变变量</strong>，它对应Java里的普通变量。</li></ul><h2 id="基础类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#基础类型"><span class="icon icon-link"></span></a>基础类型</h2><p>了解了变量类型如何声明之后，我们再来看下Kotlin中的基础类型。</p><p>基础类型，包括我们常见的数字类型、布尔类型、字符类型，以及前面这些类型组成的数组。这些类型是我们经常会遇到的概念，因此我们把它统一归为“基础类型”。</p><h3 id="一切都是对象"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#一切都是对象"><span class="icon icon-link"></span></a>一切都是对象</h3><p>在Java里面，基础类型分为原始类型（Primitive Types）和包装类型（Wrapper Type）。比如，整型会有对应的int和Integer，前者是原始类型，后者是包装类型。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int i = 0; // 原始类型</span></div><div class="token-line"><span class="token plain">    Integer j = 1; // 包装类型</span></div></pre></div><p>Java之所以要这样做，是因为原始类型的开销小、性能高，但它不是对象，无法很好地融入到面向对象的系统中。而包装类型的开销大、性能相对较差，但它是对象，可以很好地发挥面向对象的特性。在 <a target="_blank" rel="noopener noreferrer" href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Integer.java">JDK源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中，我们可以看到Integer作为包装类型，它是有成员变量以及成员方法的，这就是它作为对象的优势。</p><p>然而，在Kotlin语言体系当中，是没有原始类型这个概念的。这也就意味着，<strong>在Kotlin里，一切都是对象。</strong></p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageyy3byyd95b04616943878351867c4d1e063b.f91b8500.jpg" alt=""/></p><p>实际上，从某种程度上讲，Java的类型系统并不是完全面向对象的，因为它存在原始类型，而原始类型并不属于对象。而Kotlin则不一样，它从语言设计的层面上就规避了这个问题，类型系统则是完全面向对象的。</p><p>我们看一段代码，来更直观地感受Kotlin的独特之处：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i: Double = 1.toDouble()</span></div></pre></div><p>可以发现，由于在Kotlin中，整型数字“1”被看作是对象了，所以我们可以调用它的成员方法toDouble()，而这样的代码在Java中是无法实现的。</p><h3 id="空安全"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#空安全"><span class="icon icon-link"></span></a>空安全</h3><p>既然Kotlin中的一切都是对象，那么对象就有可能为空。也许你会想到写这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i: Double = null // 编译器报错</span></div></pre></div><p>可事实上，以上的代码并不能通过Kotlin编译。这是因为Kotlin强制要求开发者<strong>在定义变量的时候，指定这个变量是否可能为null</strong>。对于可能为null的变量，我们需要在声明的时候，在变量类型后面加一个问号“?”：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i: Double = null // 编译器报错</span></div><div class="token-line"><span class="token plain">    val j: Double? = null // 编译通过</span></div></pre></div><p>并且由于Kotlin对可能为空的变量类型做了强制区分，这就意味着，“可能为空的变量”无法直接赋值给“不可为空的变量”，当然，反向赋值是没有问题的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var i: Double = 1.0</span></div><div class="token-line"><span class="token plain">    var j: Double? = null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    i = j  // 编译器报错</span></div><div class="token-line"><span class="token plain">    j = i  // 编译通过</span></div></pre></div><p>Kotlin这么设计的原因也很简单，如果我们将“可能为空的变量”直接赋值给了“不可为空的变量”，这会跟它自身的定义产生冲突。而如果我们实在有这样的需求，也不难实现，只要做个判断即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var i: Double = 1.0</span></div><div class="token-line"><span class="token plain">    val j: Double? = null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if (j != null) {</span></div><div class="token-line"><span class="token plain">        i = j  // 编译通过</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好，在了解了Kotlin和Java这两种语言的主要区别后，下面就让我们来全面认识下Kotlin的基础类型。</p><h3 id="数字类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#数字类型"><span class="icon icon-link"></span></a>数字类型</h3><p>首先，在数字类型上，Kotlin和Java几乎是一致的，包括它们对数字“字面量”的定义方式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val int = 1</span></div><div class="token-line"><span class="token plain">    val long = 1234567L</span></div><div class="token-line"><span class="token plain">    val double = 13.14</span></div><div class="token-line"><span class="token plain">    val float = 13.14F</span></div><div class="token-line"><span class="token plain">    val hexadecimal = 0xAF</span></div><div class="token-line"><span class="token plain">    val binary = 0b01010101</span></div></pre></div><p>这里我也来给你具体介绍下：</p><ul><li>整数默认会被推导为“Int”类型；</li><li>Long类型，我们则需要使用“L”后缀；</li><li>小数默认会被推导为“Double”，我们不需要使用“D”后缀；</li><li>Float类型，我们需要使用“F”后缀；</li><li>使用“0x”，来代表十六进制字面量；</li><li>使用“0b”，来代表二进制字面量。</li></ul><p>但是，对于数字类型的转换，Kotlin与Java的转换行为是不一样的。<strong>Java可以隐式转换数字类型，而Kotlin更推崇显式转换。</strong></p><p>举个简单的例子，在Java和C当中，我们经常直接把int类型赋值给long类型，编译器会自动为我们做类型转换，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int i = 100;</span></div><div class="token-line"><span class="token plain">    long j = i;</span></div></pre></div><p>这段代码按照Java的编程思维方式来看，的确好像是OK的。但是你要注意，虽然Java编译器不会报错，可它仍然可能会带来问题，因为它们本质上不是一个类型，int、long、float、double这些类型之间的互相转换是存在精度问题的。尤其是当这样的代码掺杂在复杂的逻辑中时，在碰到一些边界条件的情况下，即使出现了Bug也不容易排查出来。</p><p>所以，同样的代码，在Kotlin当中是行不通的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i = 100</span></div><div class="token-line"><span class="token plain">    val j: Long = i // 编译器报错</span></div></pre></div><p>在Kotlin里，这样的隐式转换被抛弃了。正确的做法应该是显式调用Int类型的toLong()函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i = 100</span></div><div class="token-line"><span class="token plain">    val j: Long = i.toLong() // 编译通过</span></div></pre></div><p>其实，如果我们仔细翻看Kotlin的源代码，会发现更多类似的函数，比如toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar()等等。Kotlin这样设计的优势也是显而易见的，<strong>我们代码的可读性更强了，将来也更容易维护了</strong>。</p><h3 id="布尔类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#布尔类型"><span class="icon icon-link"></span></a>布尔类型</h3><p>然后我们再来了解下Kotlin中布尔类型的变量，它只有两种值，分别是<strong>true<strong><strong>和</strong></strong>false</strong>。布尔类型支持一些逻辑操作，比如说：</p><ul><li>“&amp;”代表“与运算”；</li><li>“|”代表“或运算”；</li><li>“!”代表“非运算”；</li><li>“&amp;&amp;”和“||”分别代表它们对应的“短路逻辑运算”。</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i = 1</span></div><div class="token-line"><span class="token plain">    val j = 2</span></div><div class="token-line"><span class="token plain">    val k = 3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    val isTrue: Boolean = i &lt; j &amp;&amp; j &lt; k</span></div></pre></div><h3 id="字符char"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#字符char"><span class="icon icon-link"></span></a>字符：Char</h3><p>Char用于代表单个的字符，比如<code>&#x27;A&#x27;</code>、<code>&#x27;B&#x27;</code>、<code>&#x27;C&#x27;</code>，字符应该用单引号括起来。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val c: Char = &#x27;A&#x27;</span></div></pre></div><p>如果你有Java或C的使用经验，也许会写出这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val c: Char = &#x27;A&#x27;</span></div><div class="token-line"><span class="token plain">    val i: Int = c // 编译器报错</span></div></pre></div><p>这个问题其实跟前面Java的数字类型隐式转换的问题类似，所以针对这种情况，我们应该调用对应的函数来做类型转换。这一点我们一定要牢记在心。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val c: Char = &#x27;A&#x27;</span></div><div class="token-line"><span class="token plain">    val i: Int = c.toInt() // 编译通过</span></div></pre></div><h3 id="字符串string"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#字符串string"><span class="icon icon-link"></span></a>字符串：String</h3><p>字符串（String），顾名思义，就是一连串的字符。和Java一样，Kotlin中的字符串也是不可变的。在大部分情况下，我们会使用双引号来表示字符串的字面量，这一点跟Java也是一样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val s = &quot;Hello Kotlin!&quot;</span></div></pre></div><p>不过与此同时，Kotlin还为我们提供了非常简洁的<strong>字符串模板</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val name = &quot;Kotlin&quot;</span></div><div class="token-line"><span class="token plain">    print(&quot;Hello $name!&quot;)</span></div><div class="token-line"><span class="token plain">    /*            ↑</span></div><div class="token-line"><span class="token plain">        直接在字符串中访问变量</span></div><div class="token-line"><span class="token plain">    */</span></div><div class="token-line"><span class="token plain">    // 输出结果：</span></div><div class="token-line"><span class="token plain">    Hello Kotlin!</span></div></pre></div><p>这样的特性，在Java当中是没有的，这是Kotlin提供的新特性。虽然说这个字符串模板功能，我们用Java也同样可以实现，但它远没有Kotlin这么简洁。在Java当中，我们必须使用两个“+”进行拼接，比如说<code>(&quot;Hello&quot; + name + &quot;!&quot;)</code>。这样一来，在字符串格式更复杂的情况下，代码就会很臃肿。</p><p>当然，如果我们需要在字符串当中引用更加复杂的变量，则需要使用花括号将变量括起来：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val array = arrayOf(&quot;Java&quot;, &quot;Kotlin&quot;)</span></div><div class="token-line"><span class="token plain">    print(&quot;Hello ${array.get(1)}!&quot;)</span></div><div class="token-line"><span class="token plain">    /*            ↑</span></div><div class="token-line"><span class="token plain">          复杂的变量，使用${}</span></div><div class="token-line"><span class="token plain">    */</span></div><div class="token-line"><span class="token plain">    // 输出结果：</span></div><div class="token-line"><span class="token plain">    Hello Kotlin!</span></div></pre></div><p>另外，Kotlin还新增了一个<strong>原始字符串</strong>，是用三个引号来表示的。它可以用于存放复杂的多行文本，并且它定义的时候是什么格式，最终打印也会是对应的格式。所以当我们需要复杂文本的时候，就不需要像Java那样写一堆的加号和换行符了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val s = &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">           当我们的字符串有复杂的格式时</span></div><div class="token-line"><span class="token plain">           原始字符串非常的方便</span></div><div class="token-line"><span class="token plain">           因为它可以做到所见即所得。 &quot;&quot;&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(s)</span></div></pre></div><h3 id="数组"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#数组"><span class="icon icon-link"></span></a>数组</h3><p>最后，我们再来看看Kotlin中数组的一些改变。</p><p>在Kotlin当中，我们一般会使用**arrayOf()**来创建数组，括号当中可以用于传递数组元素进行初始化，同时，Kotlin编译器也会根据传入的参数进行类型推导。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val arrayInt = arrayOf(1, 2, 3)</span></div><div class="token-line"><span class="token plain">    val arrayString = arrayOf(&quot;apple&quot;, &quot;pear&quot;)</span></div></pre></div><p>比如说，针对这里的arrayInt，由于我们赋值的时候传入了整数，所以它的类型会被推导为整型数组；对于arrayString，它的类型会被推导为字符串数组。</p><p>而你应该也知道，在Java当中，数组和其他集合的操作是不一样的。举个例子，如果要获取数组的长度，Java中应该使用“array.length”；但如果是获取List的大小，那么Java中则应该使用“list.size”。这主要是因为数组不属于Java集合。</p><p>不过，Kotlin在这个问题的处理上并不一样。<strong>虽然Kotlin的数组仍然不属于集合，但它的一些操作是跟集合统一的。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val array = arrayOf(&quot;apple&quot;, &quot;pear&quot;)</span></div><div class="token-line"><span class="token plain">    println(&quot;Size is ${array.size}&quot;)</span></div><div class="token-line"><span class="token plain">    println(&quot;First element is ${array[0]}&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 输出结果：</span></div><div class="token-line"><span class="token plain">    Size is 2</span></div><div class="token-line"><span class="token plain">    First element is apple</span></div></pre></div><p>就比如说，以上代码中，我们直接使用array.size就能拿到数组的长度。</p><h2 id="函数声明"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#函数声明"><span class="icon icon-link"></span></a>函数声明</h2><p>好，了解了Kotlin中变量和基础类型的相关概念之后，我们再来看看它的函数是如何定义的。</p><p>在Kotlin当中，函数的声明与Java不太一样，让我们看一段简单的Kotlin代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*</span></div><div class="token-line"><span class="token plain">    关键字    函数名          参数类型   返回值类型</span></div><div class="token-line"><span class="token plain">     ↓        ↓                ↓       ↓      */</span></div><div class="token-line"><span class="token plain">    fun helloFunction(name: String): String {</span></div><div class="token-line"><span class="token plain">        return &quot;Hello $name !&quot;</span></div><div class="token-line"><span class="token plain">    }/*   ↑</span></div><div class="token-line"><span class="token plain">       花括号内为：函数体</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>可以看到，在这段代码中：</p><ul><li>使用了<strong>fun关键字</strong>来定义函数；</li><li><strong>函数名称</strong>，使用的是<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/zh/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰命名法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（大部分情况下）；</li><li><strong>函数参数</strong>，是以(name: String)这样的形式传递的，这代表了参数类型为String类型；</li><li><strong>返回值类型</strong>，紧跟在参数的后面；</li><li>最后是<strong>花括号内的函数体</strong>，它代表了整个函数的逻辑。</li></ul><p>另外你可以再注意一个地方，前面代码中的helloFunction函数，它的函数体实际上只有一行代码。那么针对这种情况，我们其实就可以省略函数体的花括号，直接使用“=”来连接，将其变成一种类似变量赋值的函数形式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun helloFunction(name: String): String = &quot;Hello $name !&quot;</span></div></pre></div><p>这种写法，我们称之为<strong>单一表达式函数</strong>。需要注意的是，在这种情况下，表达式当中的“return”是需要去掉的。</p><p>另外，由于Kotlin支持类型推导，我们在使用单一表达式形式的时候，返回值的类型也可以省略：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun helloFunction(name: String) = &quot;Hello $name !&quot;</span></div></pre></div><p>看到这里，你一定能体会到Kotlin的魅力。它的语法非常得简洁，并且是符合人类的阅读直觉的，我们读这样的代码，就跟读自然语言一样轻松。</p><p>然而，Kotlin的优势不仅仅体现在函数声明上，在函数调用的地方，它也有很多独到之处。</p><h3 id="函数调用"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#函数调用"><span class="icon icon-link"></span></a>函数调用</h3><p>以我们前面定义的函数为例子，如果我们想要调用它，代码的风格和Java基本一致：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">helloFunction(&quot;Kotlin&quot;)</span></div></pre></div><p>不过，Kotlin提供了一些新的特性，那就是<strong>命名参数</strong>。简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">helloFunction(name = &quot;Kotlin&quot;)</span></div></pre></div><p>让我们看一个更具体的使用场景：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun createUser(</span></div><div class="token-line"><span class="token plain">        name: String,</span></div><div class="token-line"><span class="token plain">        age: Int,</span></div><div class="token-line"><span class="token plain">        gender: Int,</span></div><div class="token-line"><span class="token plain">        friendCount: Int,</span></div><div class="token-line"><span class="token plain">        feedCount: Int,</span></div><div class="token-line"><span class="token plain">        likeCount: Long,</span></div><div class="token-line"><span class="token plain">        commentCount: Int</span></div><div class="token-line"><span class="token plain">    ) {</span></div><div class="token-line"><span class="token plain">        //..</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这是一个包含了很多参数的函数，在Kotlin当中，针对参数较多的函数，我们一般会<strong>以纵向的方式排列</strong>，这样的代码更符合我们从上到下的阅读习惯，省去从左往右翻的麻烦。</p><p>但是，如果我们像Java那样调用createUser，代码就会非常难以阅读：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">createUser(&quot;Tom&quot;, 30, 1, 78, 2093, 10937, 3285)</span></div></pre></div><p>这里代码中的第一个参数，我们知道肯定是name，但是到了后面那一堆的数字，就会让人迷惑了。这样的代码不仅难懂，同时还不好维护。</p><p>但如果我们这样写呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">createUser(</span></div><div class="token-line"><span class="token plain">        name = &quot;Tom&quot;,</span></div><div class="token-line"><span class="token plain">        age = 30,</span></div><div class="token-line"><span class="token plain">        gender = 1,</span></div><div class="token-line"><span class="token plain">        friendCount = 78,</span></div><div class="token-line"><span class="token plain">        feedCount = 2093,</span></div><div class="token-line"><span class="token plain">        likeCount = 10937,</span></div><div class="token-line"><span class="token plain">        commentCount = 3285</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用“=”连接，建立了两者的对应关系。对比前面Java风格的写法，这样的代码可读性更强了。如果将来你想修改likeCount这个参数，也可以轻松做到。这其实就体现出了Kotlin命名参数的<strong>可读性</strong>与<strong>易维护性</strong>两个优势。</p><p>而除了命名参数这个特性，Kotlin还支持<strong>参数默认值</strong>，这个特性在参数较多的情况下同样有很大的优势：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun createUser(</span></div><div class="token-line"><span class="token plain">        name: String,</span></div><div class="token-line"><span class="token plain">        age: Int,</span></div><div class="token-line"><span class="token plain">        gender: Int = 1,</span></div><div class="token-line"><span class="token plain">        friendCount: Int = 0,</span></div><div class="token-line"><span class="token plain">        feedCount: Int = 0,</span></div><div class="token-line"><span class="token plain">        likeCount: Long = 0L,</span></div><div class="token-line"><span class="token plain">        commentCount: Int = 0</span></div><div class="token-line"><span class="token plain">    ) {</span></div><div class="token-line"><span class="token plain">        //..</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们可以看到，gender、friendCount、feedCount、likeCount、commentCount这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传3个参数，剩余的4个参数没有传，但是Kotlin编译器会自动帮我们填上默认值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">createUser(</span></div><div class="token-line"><span class="token plain">        name = &quot;Tom&quot;,</span></div><div class="token-line"><span class="token plain">        age = 30,</span></div><div class="token-line"><span class="token plain">        commentCount = 3285</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。Kotlin这样的特性，在一些场景下就可以极大地提升我们的开发效率。</p><p>而如果是在Java当中要实现类似的事情，我们就必须手动定义“3个参数的createUser函数”，或者是使用Builder设计模式。</p><h2 id="流程控制"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#流程控制"><span class="icon icon-link"></span></a>流程控制</h2><p>在Kotlin当中，流程控制主要有if、when、for、 while，这些语句可以控制代码的执行流程。它们也是体现代码逻辑的关键。下面我们就来一一学习下。</p><h3 id="if"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#if"><span class="icon icon-link"></span></a>if</h3><p>if语句，在程序当中主要是用于逻辑判断。Kotlin当中的if与Java当中的基本一致：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i = 1</span></div><div class="token-line"><span class="token plain">    if (i &gt; 0) {</span></div><div class="token-line"><span class="token plain">        print(&quot;Big&quot;)</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        print(&quot;Small&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Big</span></div></pre></div><p>可以看到，由于i大于0，所以程序会输出“Big”，这很好理解。不过Kotlin的if，并不是程序语句（Statement）那么简单，它还可以作为<strong>表达式</strong>（Expression）来使用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i = 1</span></div><div class="token-line"><span class="token plain">    val message = if (i &gt; 0) &quot;Big&quot; else &quot;Small&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(message)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Big</span></div></pre></div><p>以上的代码其实跟之前的代码差不多，它们做的是同一件事。不同的是，我们把if当作表达式在用，将if判断的结果，赋值给了一个变量。同时，Kotlin编译会根据if表达式的结果自动推导出变量“message”的类型为“String”。这种方式就使得Kotlin的代码更加简洁。</p><p>而类似的逻辑，如果要用Java来实现的话，我们就必须先在if外面定义一个变量message，然后分别在两个分支内对message赋值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int i = 1</span></div><div class="token-line"><span class="token plain">    String message = &quot;&quot;</span></div><div class="token-line"><span class="token plain">    if (i &gt; 0) {</span></div><div class="token-line"><span class="token plain">        message = &quot;Big&quot;</span></div><div class="token-line"><span class="token plain">    } else {</span></div><div class="token-line"><span class="token plain">        message = &quot;Small&quot;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(message)</span></div></pre></div><p>这样两相对比下，我们会发现Java的实现方式明显丑陋一些：<strong>不仅代码行数更多，逻辑也松散了</strong>。</p><p>另外，由于Kotlin当中明确规定了类型分为“可空类型”“不可空类型”，因此，我们会经常遇到可空的变量，并且要判断它们是否为空。我们直接来看个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun getLength(text: String?): Int {</span></div><div class="token-line"><span class="token plain">      return if (text != null) text.length else 0</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个例子当中，我们把if当作表达式，如果text不为空，我们就算出它的长度；如果它为空，长度就取0。</p><p>但是，如果你实际使用Kotlin写过代码，你会发现：在Kotlin中，类似这样的判断逻辑出现得非常频繁，如果每次都要写一个完整的if else分支，其实也很麻烦。</p><p>为此，Kotlin针对这种情况就提供了一种简写，叫做<strong>Elvis表达式</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun getLength(text: String?): Int {</span></div><div class="token-line"><span class="token plain">      return text?.length ?: 0</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，通过Elvis表达式，我们就再也不必写“<code>if (xxx != null) xxx else xxx</code>”这样的赋值代码了。它在提高代码可读性的同时，还能提高我们的编码效率。</p><h3 id="when"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#when"><span class="icon icon-link"></span></a>when</h3><p>when语句，在程序当中主要也是用于逻辑判断的。当我们的代码逻辑只有两个分支的时候，我们一般会使用if/else，而在大于两个逻辑分支的情况下，我们使用when。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i: Int = 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    when(i) {</span></div><div class="token-line"><span class="token plain">        1 -&gt; print(&quot;一&quot;)</span></div><div class="token-line"><span class="token plain">        2 -&gt; print(&quot;二&quot;)</span></div><div class="token-line"><span class="token plain">        else -&gt; print(&quot;i 不是一也不是二&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    一</span></div></pre></div><p>when语句有点像Java里的switch case语句，不过Kotlin的when更加强大，它同时也可以<strong>作为表达式，为变量赋值</strong>，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val i: Int = 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    val message = when(i) {</span></div><div class="token-line"><span class="token plain">        1 -&gt; &quot;一&quot;</span></div><div class="token-line"><span class="token plain">        2 -&gt; &quot;二&quot;</span></div><div class="token-line"><span class="token plain">        else -&gt; &quot;i 不是一也不是二&quot; // 如果去掉这行，会报错</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    print(message)</span></div></pre></div><p>另外，与switch不一样的是，when表达式要求它里面的逻辑分支必须是完整的。举个例子，以上的代码，如果去掉else分支，编译器将报错，原因是：i的值不仅仅只有1和2，这两个分支并没有覆盖所有的情况，所以会报错。</p><h3 id="循环迭代while与for"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#循环迭代while与for"><span class="icon icon-link"></span></a>循环迭代：while与for</h3><p>首先while循环，我们一般是用于重复执行某些代码，它在使用上和Java也没有什么区别：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">var i = 0</span></div><div class="token-line"><span class="token plain">    while (i &lt;= 2) {</span></div><div class="token-line"><span class="token plain">        println(i)</span></div><div class="token-line"><span class="token plain">        i++</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    var j = 0</span></div><div class="token-line"><span class="token plain">    do {</span></div><div class="token-line"><span class="token plain">        println(j)</span></div><div class="token-line"><span class="token plain">        j++</span></div><div class="token-line"><span class="token plain">    } while (j &lt;= 2)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    1</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    0</span></div><div class="token-line"><span class="token plain">    1</span></div><div class="token-line"><span class="token plain">    2</span></div></pre></div><p>但是对于for语句，Kotlin和Java的用法就明显不一样了。</p><p>在Java当中，for也会经常被用于循环，经常被用来替代while。不过，**Kotlin的for语句更多的是用于“迭代”。**比如，以下代码就代表了迭代array这个数组里的所有元素，程序会依次打印出：“1、2、3”。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val array = arrayOf(1, 2, 3)</span></div><div class="token-line"><span class="token plain">    for (i in array) {</span></div><div class="token-line"><span class="token plain">        println(i)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>而除了迭代数组和集合以外，Kotlin还支持迭代一个“区间”。</p><p>首先，要定义一个区间，我们可以使用“<code>..</code>”来连接数值区间的两端，比如“<code>1..3</code>”就代表从1到3的闭区间，左闭右闭：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val oneToThree = 1..3 // 代表 [1, 3]</span></div></pre></div><p>接着，我们就可以使用for语句，来对这个闭区间范围进行迭代：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (i in oneToThree) {</span></div><div class="token-line"><span class="token plain">        println(i)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    1</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    3</span></div></pre></div><p>甚至，我们还可以<strong>逆序迭代</strong>一个区间，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (i in 6 downTo 0 step 2) {</span></div><div class="token-line"><span class="token plain">        println(i)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    6</span></div><div class="token-line"><span class="token plain">    4</span></div><div class="token-line"><span class="token plain">    2</span></div><div class="token-line"><span class="token plain">    0</span></div></pre></div><p>以上代码的含义就是逆序迭代一个区间，从6到0，每次迭代的步长是2，这意味着6迭代过后，到4、2，最后到0。<strong>需要特别注意的是</strong>，逆序区间我们不能使用“<code>6..0</code>”来定义，如果用这样的方式来定义的话，代码将无法正常运行。</p><p>好了，那么到目前为止，Kotlin的变量、基础类型、函数、流程控制，我们就都已经介绍完了。掌握好这些知识点，我们就已经可以写出简单的程序了。当然，我们的Kotlin学习之路才刚刚开始，在下节课，我会带你来学习Kotlin面向对象相关的知识点。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#小结"><span class="icon icon-link"></span></a>小结</h2><p>学完了这节课，现在我们知道虽然Kotlin和Java的语法很像，但在一些细节之处，Kotlin总会有一些新的东西。如果你仔细琢磨这些不同点，你会发现它正是大部分程序员所需要的。举个例子，作为开发者，我们都讨厌写冗余的代码，喜欢简洁易懂的代码。那么在今天学完了基础语法之后，我们可以来看看Kotlin在这方面都做了哪些改进：</p><ul><li>支持类型推导；</li><li>代码末尾不需要分号；</li><li>字符串模板；</li><li>原始字符串，支持复杂文本格式；</li><li>单一表达式函数，简洁且符合直觉；</li><li>函数参数支持默认值，替代Builder模式的同时，可读性还很强；</li><li>if和when可以作为表达式。</li></ul><p>同时，JetBrains也非常清楚开发者在什么情况下容易出错，所以，它在语言层面也做了很多改进：</p><ul><li>强制区分“可为空变量类型”和“不可为空变量类型”，规避空指针异常；</li><li>推崇不可变性（val），对于没有修改需求的变量，IDE会智能提示开发者将“var”改为“val”；</li><li>基础类型不支持隐式类型转换，这能避免很多隐藏的问题；</li><li>数组访问行为与集合统一，不会出现array.length、list.size这种恼人的情况；</li><li>函数调用支持命名参数，提高可读性，在后续维护代码的时候不易出错；</li><li>when表达式，强制要求逻辑分支完整，让你写出来的逻辑永远不会有漏洞。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage326732ab3d37cd7f9650f4cba17736305c67.c609aef1.jpg" alt="图片"/></p><p>这些都是Kotlin的<strong>闪光点</strong>，也是它最珍贵的地方。</p><p>这一切，都得益于Kotlin的发明者JetBrains。作为最负盛名的IDE创造者，JetBrains能深刻捕捉到开发者的需求。它知道开发者喜欢什么、讨厌什么，它甚至知道开发者容易犯什么样的错误，从而在语言设计的层面规避错误。站在这个角度看，JetBrains能够创造出炙手可热的Kotlin语言，就一点都不奇怪了。</p><p>以上这么多的“闪光点”还仅仅只是局限于我们这节课的内容，如果放眼全局，这样的例子更是数不胜数。**Kotlin对比Java的提升，如果独立去看其中的某一个点，都不足以让一个开发者心动。不过，一旦这样的改善积少成多，Kotlin的优势就会显得尤为明显。**这也是很多程序员表示“Kotlin用过了就回不去”的原因。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>虽然Kotlin在语法层面摒弃了“原始类型”，但有时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</p><p>欢迎在评论区分享你的思路，这个问题我会在第三节课给出答案，我们下节课再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/02.基础篇/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
