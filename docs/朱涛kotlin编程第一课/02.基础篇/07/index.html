<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/02.基础篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Kotlin为什么要引入高阶函数？" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#kotlin为什么要引入高阶函数"><span>Kotlin为什么要引入高阶函数？</span></a></li><li title="理解高阶函数的相关概念" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#理解高阶函数的相关概念"><span>理解高阶函数的相关概念</span></a></li><li title="函数类型" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#函数类型"><span>函数类型</span></a></li><li title="高阶函数" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#高阶函数"><span>高阶函数</span></a></li><li title="Lambda" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#lambda"><span>Lambda</span></a></li><li title="SAM转换" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#sam转换"><span>SAM转换</span></a></li><li title="Lambda表达式引发的8种写法" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#lambda表达式引发的8种写法"><span>Lambda表达式引发的8种写法</span></a></li><li title="难点：带接收者的函数类型" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#难点带接收者的函数类型"><span>难点：带接收者的函数类型</span></a></li><li title="为什么要引入带接收者的函数类型？" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#为什么要引入带接收者的函数类型"><span>为什么要引入带接收者的函数类型？</span></a></li><li title="实战与思考" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#实战与思考"><span>实战与思考</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#小结"><span>小结</span></a></li><li title="小作业" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#小作业"><span>小作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07--高阶函数为什么说函数是kotlin的一等公民"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#07--高阶函数为什么说函数是kotlin的一等公民"><span class="icon icon-link"></span></a>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</h1><p>你好，我是朱涛。</p><p>高阶函数在Kotlin里有着举足轻重的地位。**它是Kotlin函数式编程的基石，是各种框架的关键元素。**高阶函数掌握好了，我们理解协程的launch、async函数就会轻松一些，阅读协程的源代码也会不那么吃力；高阶函数理解透彻了，我们学习Jetpack Compose也会得心应手，在特定业务场景下，我们甚至可以用它来实现自己的DSL（Domain Specific Language）。</p><p>不过，如果你没有函数式编程的相关经验，在初次接触高阶函数的时候，很可能会被绕晕。因为它是一个全新的概念，你很难从经典的C/Java里找到同等的概念迁移过来（Java从1.8开始才引入相关概念）。然而，对于高阶函数这么重要的概念，Kotlin官方文档又惜字如金。</p><p>文档里只是突兀地介绍了高阶函数、函数类型、Lambda表达式的简单用法，接着就丢出一段复杂的代码案例，然后丢出一个更复杂的概念，“带接收者的函数类型”（Function Types With Receiver），接着又丢出了一段更复杂的代码案例。说实话，这真的让人难以理解。</p><p>所以今天这节课，我会采用Java和Kotlin对照的方式，来给你讲解Kotlin高阶函数的核心概念。并且我会通过一个实际案例，来帮助你理解其中最晦涩难懂的“带接收者的函数类型”，为你今后的Kotlin学习之路打下坚实的基础。</p><h2 id="kotlin为什么要引入高阶函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#kotlin为什么要引入高阶函数"><span class="icon icon-link"></span></a>Kotlin为什么要引入高阶函数？</h2><p>想要掌握好高阶函数，我们首先要知道，Kotlin为什么要引入这一全新的概念。这个问题，Kotlin官方并没有给出解释，但是我们很容易在它的使用上找到蛛丝马迹。</p><p>我们来看个实际的例子，这是Android中的View定义，这里我省略了大部分代码，主要是想带你来看看Kotlin高阶函数的一个典型使用场景。</p><blockquote><p>补充：如果你不了解Android开发也没关系，Java Swing中也有类似的代码模式。如果两者你都不熟悉，借助我提供的注释，也不难理解。</p></blockquote><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// View.java</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 成员变量</span></div><div class="token-line"><span class="token plain">    private OnClickListener mOnClickListener;</span></div><div class="token-line"><span class="token plain">    private OnContextClickListener mOnContextClickListener;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 监听手指点击事件</span></div><div class="token-line"><span class="token plain">    public void setOnClickListener(OnClickListener l) {</span></div><div class="token-line"><span class="token plain">        mOnClickListener = l;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 为传递这个点击事件，专门定义了一个接口</span></div><div class="token-line"><span class="token plain">    public interface OnClickListener {</span></div><div class="token-line"><span class="token plain">        void onClick(View v);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 监听鼠标点击事件</span></div><div class="token-line"><span class="token plain">    public void setOnContextClickListener(OnContextClickListener l) {</span></div><div class="token-line"><span class="token plain">        getListenerInfo().mOnContextClickListener = l;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 为传递这个鼠标点击事件，专门定义了一个接口</span></div><div class="token-line"><span class="token plain">    public interface OnContextClickListener {</span></div><div class="token-line"><span class="token plain">        boolean onContextClick(View v);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码，其实是一个典型的“可以用高阶函数来优化”的例子。让我们来看看它都做了什么：</p><ul><li>首先，为了设置点击事件的监听，代码里特地定义了一个OnClickListener接口；</li><li>接着，为了设置鼠标点击事件的监听，又专门定义了一个OnContextClickListener接口。</li></ul><p>乍一看，我们貌似是可以复用同一个接口就行了，对吧？但事实上，<strong>借助高阶函数，我们一个接口都不必定义</strong>。</p><p>当然了，上面的代码是Android团队十几年前用Java写的，在那个场景下，这么写代码是完全没问题的。可是这段代码在使用的时候，问题更大。比如，我们可以来看看如下所示的Android里设置点击监听的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 设置手指点击事件</span></div><div class="token-line"><span class="token plain">    image.setOnClickListener(new View.OnClickListener() {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onClick(View v) {</span></div><div class="token-line"><span class="token plain">            gotoPreview();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    });</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 设置鼠标点击事件</span></div><div class="token-line"><span class="token plain">    image.setOnContextClickListener(new View.OnContextClickListener() {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void onContextClick(View v) {</span></div><div class="token-line"><span class="token plain">            gotoPreview();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    });</span></div></pre></div><p>看完了这两段代码之后，你有没有觉得这样的代码会很啰嗦？因为，真正逻辑只有一行代码：gotoPreview()，而实际上我们却写了6行代码。</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage18ac1876d635751fd11662fbfcc3285a0eac.jpg" alt="图片"/></p><p>如果我们将其中的核心逻辑提取出来，会发现这样才是最简单明了的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//                      { gotoPreview() } 就是 Lambda</span></div><div class="token-line"><span class="token plain">    //                             ↑</span></div><div class="token-line"><span class="token plain">    image.setOnClickListener({ gotoPreview() })</span></div><div class="token-line"><span class="token plain">    image.setOnContextClickListener({ gotoPreview() })</span></div></pre></div><p>那么，Kotlin语言的设计者是怎么做的呢？实际上他们是分成了两个部分：</p><ul><li>用函数类型替代接口定义；</li><li>用Lambda表达式作为函数参数。</li></ul><p>这里我们再来看看与前面View.java的等价Kotlin代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//View.kt</span></div><div class="token-line"><span class="token plain">    //                     (View) -&gt; Unit 就是「函数类型 」</span></div><div class="token-line"><span class="token plain">    //                       ↑        ↑ </span></div><div class="token-line"><span class="token plain">    var mOnClickListener: ((View) -&gt; Unit)? = null</span></div><div class="token-line"><span class="token plain">    var mOnContextClickListener: ((View) -&gt; Unit)? = null</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 高阶函数</span></div><div class="token-line"><span class="token plain">    fun setOnClickListener(l: (View) -&gt; Unit) {</span></div><div class="token-line"><span class="token plain">        mOnClickListener = l;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 高阶函数</span></div><div class="token-line"><span class="token plain">    fun setOnContextClickListener(l: (View) -&gt; Unit) {</span></div><div class="token-line"><span class="token plain">        mOnContextClickListener = l;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>那么通过对比，我们能看到，Kotlin中引入高阶函数会带来几个<strong>好处</strong>：一个是针对定义方，代码中减少了两个接口类的定义；另一个是对于调用方来说，代码也会更加简洁。这样一来，就大大减少了代码量，提高了代码可读性，并通过减少类的数量，提高了代码的性能。</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimagea7eba7yy974d95cd3938f0f36781afb425eb.jpg" alt="图片"/></p><blockquote><p>注：关于“inline”，我会在下节课中详细介绍。</p></blockquote><p>通过上面的例子，我们已经清楚高阶函数存在的意义和价值了。不过，前面出现的一些新的概念我们还没来得及详细解释，比如，<strong>函数类型、Lambda，它们到底是什么呢？还有高阶函数的具体定义是什么呢？</strong></p><p>接下来，我会通过一个具体的代码案例，来给你一一解读与高阶函数关系密切的概念及使用定义，让你能进一步夯实函数式编程的基础知识。</p><h2 id="理解高阶函数的相关概念"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#理解高阶函数的相关概念"><span class="icon icon-link"></span></a>理解高阶函数的相关概念</h2><p>首先，我们来了解下什么是函数类型。</p><h3 id="函数类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#函数类型"><span class="icon icon-link"></span></a>函数类型</h3><p>顾名思义，函数类型（Function Type）就是<strong>函数的类型</strong>。如果你之前没有函数式编程的经验，刚接触这个概念的话也许会觉得奇怪：函数也有类型吗？</p><p>是的，既然变量可以有类型，函数也可以有。在Kotlin的世界里，<a target="_blank" rel="noopener noreferrer" href="https://kotlinlang.org/docs/lambdas.html">函数是一等公民<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。你可以将其理解为Kotlin里的VIP，普通人有的东西，VIP当然也有。比如，我们可以仔细看看下面的函数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//         (Int,  Int) -&gt;Float 这就是 add 函数的类型</span></div><div class="token-line"><span class="token plain">    //           ↑     ↑      ↑</span></div><div class="token-line"><span class="token plain">    fun add(a: Int, b: Int): Float { return (a+b).toFloat() }</span></div></pre></div><p>请注意这里我给出代码注释，第二行注释里面的“↑”代表的是一种映射关系。其实，将第三行代码里的“Int Int Float”抽出来，就代表了该函数的类型。</p><p>我们可以用更精练的语言来描述函数类型的规律：<strong>将函数的“参数类型”和“返回值类型”抽象出来后，就得到了“函数类型”</strong>。(Int, Int) -&gt;Float就代表了参数类型是两个Int，返回值类型为Float的函数类型。</p><p>理解了函数类型以后，我们再来看<strong>函数的引用</strong>。普通的变量也有引用的概念，我们可以将一个变量赋值给另一个变量。而这一点，在函数上也是同样适用的，函数也有引用，并且也可以赋值给变量。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 函数赋值给变量                    函数引用</span></div><div class="token-line"><span class="token plain">    //    ↑                              ↑</span></div><div class="token-line"><span class="token plain">    val function: (Int, Int) -&gt; Float = ::add</span></div></pre></div><h3 id="高阶函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#高阶函数"><span class="icon icon-link"></span></a>高阶函数</h3><p>好，接着我们再来看看高阶函数的具体定义。当然，前面解释了这么多，现在我们对高阶函数应该已经有了比较清晰的认识了，我们用Kotlin实现的View点击事件函数，它就是一个高阶函数。</p><p>而它明确的定义其实是这样的：<strong>高阶函数是将函数用作参数或返回值的函数。</strong></p><p>这句话有点绕，我们还是直接看例子吧。如果我们将Android里点击事件的监听用Kotlin来实现的话，它其实就是一个典型的高阶函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//                      函数作为参数的高阶函数</span></div><div class="token-line"><span class="token plain">    //                              ↓</span></div><div class="token-line"><span class="token plain">    fun setOnClickListener(l: (View) -&gt; Unit) { ... }</span></div></pre></div><p>换句话说，一个函数的参数或是返回值，它们当中有一个是函数的情况下，这个函数就是高阶函数。</p><h3 id="lambda"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#lambda"><span class="icon icon-link"></span></a>Lambda</h3><p>而前面我们还提到过，Kotlin语言的设计者是用Lambda表达式作为函数参数的，那么这里的Lambda，就可以理解为是<strong>函数的简写</strong>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun onClick(v: View): Unit { ... }</span></div><div class="token-line"><span class="token plain">    setOnClickListener(::onClick)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 用 Lambda 表达式来替代函数引用</span></div><div class="token-line"><span class="token plain">    setOnClickListener({v: View -&gt; ...})</span></div></pre></div><p>那么，如果你够细心的话，可能已经发现了一个问题：Android并没有提供View.java的Kotlin实现，那么为什么我们的Demo里面可以用Lambda来简化事件监听呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 在实际开发中，我们经常使用这种简化方式</span></div><div class="token-line"><span class="token plain">    setOnClickListener({ gotoPreview() }</span></div></pre></div><p>原因是这样的，由于OnClickListener符合SAM转换的要求，因此编译器自动帮我们做了一层转换，让我们可以用Lambda表达式来简化我们的函数调用。</p><p>那么，SAM又是个什么鬼？</p><h3 id="sam转换"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#sam转换"><span class="icon icon-link"></span></a>SAM转换</h3><p>SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，<strong>SAM代表着只有一个抽象方法的接口</strong>。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。</p><p>注意，Java 8中的SAM有明确的名称，叫做<strong>函数式接口</strong>（FunctionalInterface）。FunctionalInterface的限制如下，缺一不可：</p><ul><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li></ul><p>也就是说，对于View.java来说，它虽然是Java代码，但Kotlin编译器知道它的参数OnClickListener符合SAM转换的条件，所以会自动做以下转换。</p><p>转换前：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void setOnClickListener(OnClickListener l)</span></div></pre></div><p>转换后：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun setOnClickListener(l: (View) -&gt; Unit)</span></div><div class="token-line"><span class="token plain">    // 实际上是这样：</span></div><div class="token-line"><span class="token plain">    fun setOnClickListener(l: ((View!) -&gt; Unit)?)</span></div></pre></div><p>其中，((View!) -&gt; Unit)?代表的是这个参数可能为空。</p><h2 id="lambda表达式引发的8种写法"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#lambda表达式引发的8种写法"><span class="icon icon-link"></span></a>Lambda表达式引发的8种写法</h2><p>当一个函数的参数是SAM的情况下，我们同样也可以使用Lambda作为参数。所以，<strong>我们既可以用匿名内部类的方式传参，也可以使用Lambda的方式传参</strong>。这两种方式在我们前面都已经提到过了。然而，在这两种写法的中间，还有6种“过渡状态”的写法。这对大部分初学者简直是噩梦：同样的代码，能有8种不同的写法，确实也挺懵的。</p><p>而要理解Lambda表达式的简写逻辑，其实很简单，那就是：<strong>多写</strong>。你也可以跟着我接下来的流程来一起写一写。</p><ul><li>第1种写法</li></ul><p>这是原始代码，它的本质是用 object 关键字定义了一个匿名内部类：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener(object: View.OnClickListener {</span></div><div class="token-line"><span class="token plain">        override fun onClick(v: View?) {</span></div><div class="token-line"><span class="token plain">            gotoPreview(v)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><ul><li>第2种写法</li></ul><p>在这种情况下，object关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是Lambda表达式了，因此它里面override的方法也要跟着删掉：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener(View.OnClickListener { v: View? -&gt;</span></div><div class="token-line"><span class="token plain">        gotoPreview(v)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><p>上面的<code>View.OnClickListener</code>被称为SAM Constructor（SAM构造器），它是编译器为我们生成的。</p><ul><li>第3种写法</li></ul><p>由于Kotlin的Lambda表达式是不需要SAM Constructor的，所以它也可以被删掉：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener({ v: View? -&gt;</span></div><div class="token-line"><span class="token plain">        gotoPreview(v)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><ul><li>第4种写法</li></ul><p>由于Kotlin支持类型推导，所以View可以被删掉：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener({ v -&gt;</span></div><div class="token-line"><span class="token plain">        gotoPreview(v)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><ul><li>第5种写法</li></ul><p>当Kotlin Lambda表达式只有一个参数的时候，它可以被写成it：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener({ it -&gt;</span></div><div class="token-line"><span class="token plain">        gotoPreview(it)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><ul><li>第6种写法</li></ul><p>Kotlin Lambda的it是可以被省略的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener({</span></div><div class="token-line"><span class="token plain">        gotoPreview(it)</span></div><div class="token-line"><span class="token plain">    })</span></div></pre></div><ul><li>第7种写法</li></ul><p>当Kotlin Lambda作为函数的最后一个参数时，Lambda可以被挪到外面：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener() {</span></div><div class="token-line"><span class="token plain">        gotoPreview(it)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><ul><li>第8种写法</li></ul><p>当Kotlin只有一个Lambda作为函数参数时，()可以被省略：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">image.setOnClickListener {</span></div><div class="token-line"><span class="token plain">        gotoPreview(it)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里，我把这8种写法的演进过程以动图的形式展现了出来，让你对Lambda这几种写法的差异有一个更加直观的认识。</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimagee4bfe441323968c0c061898257fd06db37bf.gif" alt="图片"/></p><p>按照这个流程，在IDE里多写几遍，你自然就会理解了。一定要写，光看是记不住的。</p><p>好了，到这里，你就搞明白这些概念是什么意思了。下面我们来做一个小的总结，在后续的Kotlin学习当中，这些都是要铭记在心的。</p><ul><li>将函数的参数类型和返回值类型抽象出来后，我们就得到了函数类型。比如<code>(View) -&gt; Unit</code> 就代表了参数类型是View，返回值类型为Unit的函数类型。</li><li>如果一个函数的“参数”或者“返回值”的类型是函数类型，那这个函数就是高阶函数。很明显，我们刚刚就写了一个高阶函数，只是它比较简单而已。</li><li>Lambda就是函数的一种简写。</li></ul><p>然后，你也可以再通过一张图来回顾下函数类型、高阶函数以及Lambda表达式三者之间的关系：</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimageec71ecf85d05f6fdc5ea2d015a61d7e64771.png" alt="图片"/></p><p>你也可以再回过头来看看官方文档提供的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun &lt;T, R&gt; Collection&lt;T&gt;.fold(</span></div><div class="token-line"><span class="token plain">        initial: R, </span></div><div class="token-line"><span class="token plain">        combine: (acc: R, nextElement: T) -&gt; R</span></div><div class="token-line"><span class="token plain">    ): R {</span></div><div class="token-line"><span class="token plain">        var accumulator: R = initial</span></div><div class="token-line"><span class="token plain">        for (element: T in this) {</span></div><div class="token-line"><span class="token plain">            accumulator = combine(accumulator, element)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return accumulator</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看到这个函数类型：(acc: R, nextElement: T) -&gt; R，是不是瞬间就懂了呢？这个函数接收了两个参数，第一个参数类型是R，第二个参数是T，函数的返回类型是R。</p><h2 id="难点带接收者的函数类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#难点带接收者的函数类型"><span class="icon icon-link"></span></a>难点：带接收者的函数类型</h2><p>那么现在，我们就把高阶函数这个知识点理解得有80%了。而在这节课一开始，我还提到，在Kotlin的函数类型这个知识点当中，还有一个特殊的概念，叫做<strong>带接收者的函数类型</strong>，它尤其晦涩难懂。</p><p>说实话，这个名字也对初学者不太友好，“带接收者的函数类型”，这里面的每一个字我都认识，可放到一块我就懵了。所以我们其实还是绕不开一个问题：为什么？</p><h3 id="为什么要引入带接收者的函数类型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#为什么要引入带接收者的函数类型"><span class="icon icon-link"></span></a>为什么要引入带接收者的函数类型？</h3><p>这里，让我们先来看一下Kotlin的标准函数apply的使用场景。</p><p>不用 apply：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">if (user != null) {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        username.text = user.name</span></div><div class="token-line"><span class="token plain">        website.text = user.blog</span></div><div class="token-line"><span class="token plain">        image.setOnClickListener { gotoImagePreviewActivity(user) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>使用apply：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">user?.apply {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">        username.text = name</span></div><div class="token-line"><span class="token plain">        website.text = blog</span></div><div class="token-line"><span class="token plain">        image.setOnClickListener { gotoImagePreviewActivity(this) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>请问这个apply方法应该怎么实现呢？</p><p>上面的写法其实是简化后的Lambda表达式，让我们来反推一下，看看它简化前是什么样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// apply 肯定是个函数，所以有 ()，只是被省略了</span></div><div class="token-line"><span class="token plain">    user?.apply() {</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // Lambda 肯定是在 () 里面</span></div><div class="token-line"><span class="token plain">    user?.apply({ ... })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 由于 gotoImagePreviewActivity(this) 里的 this 代表了 user</span></div><div class="token-line"><span class="token plain">    // 所以 user 应该是 apply 函数的一个参数，而且参数名为：this</span></div><div class="token-line"><span class="token plain">    user?.apply({ this: User -&gt; ... })</span></div></pre></div><p>所以，现在问题非常明确了，apply其实是接收了一个Lambda表达式：<code>{<!-- --> this: User \-&gt; ... <!-- -->}</code>。那么现在，我们就尝试来实现这个apply方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun User.apply(self: User, block: (self: User) -&gt; Unit): User{</span></div><div class="token-line"><span class="token plain">        block(self)</span></div><div class="token-line"><span class="token plain">        return this</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    user?.apply(self = user) { self: User -&gt;</span></div><div class="token-line"><span class="token plain">                username.text = self.name</span></div><div class="token-line"><span class="token plain">                website.text = self.blog</span></div><div class="token-line"><span class="token plain">                image.setOnClickListener { gotoImagePreviewActivity(this) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由于Kotlin里面的函数形参是不允许被命名为this的，因此我这里用的是self。另外，这里我们自己写出来的apply，仍然还要通过self.name这样的方式来访问成员变量，但Kotlin的语言设计者能做到这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//           改为this             改为this</span></div><div class="token-line"><span class="token plain">    //               ↓                    ↓ </span></div><div class="token-line"><span class="token plain">    fun User.apply(this: User, block: (this: User) -&gt; Unit): User{</span></div><div class="token-line"><span class="token plain">    //    这里还要传参数</span></div><div class="token-line"><span class="token plain">    //         ↓ </span></div><div class="token-line"><span class="token plain">        block(this)</span></div><div class="token-line"><span class="token plain">        return this</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    user?.apply(this = user) { this: User -&gt;</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    //               this 可以省略</span></div><div class="token-line"><span class="token plain">    //                   ↓ </span></div><div class="token-line"><span class="token plain">        username.text = this.name</span></div><div class="token-line"><span class="token plain">        website.text = blog</span></div><div class="token-line"><span class="token plain">        image.setOnClickListener { gotoImagePreviewActivity(this) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面的例子能看到，我们反推的apply实现会比较繁琐：</p><ul><li>需要我们传入this：user?.apply(this = user)。</li><li>需要我们自己调用：block(this)。</li></ul><p>因此，Kotlin就引入了带接收者的函数类型，可以简化apply的定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//              带接收者的函数类型</span></div><div class="token-line"><span class="token plain">    //                     ↓  </span></div><div class="token-line"><span class="token plain">    fun User.apply(block: User.() -&gt; Unit): User{</span></div><div class="token-line"><span class="token plain">    //  不用再传this</span></div><div class="token-line"><span class="token plain">    //       ↓ </span></div><div class="token-line"><span class="token plain">        block()</span></div><div class="token-line"><span class="token plain">        return this</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    user?.apply { this: User -&gt;</span></div><div class="token-line"><span class="token plain">    //               this 可以省略</span></div><div class="token-line"><span class="token plain">    //                   ↓</span></div><div class="token-line"><span class="token plain">        username.text = this.name</span></div><div class="token-line"><span class="token plain">        website.text = this.blog</span></div><div class="token-line"><span class="token plain">        image.setOnClickListener { gotoImagePreviewActivity(this) }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>现在，关键来了。上面的apply方法是不是看起来就像是在User里，增加了一个成员方法apply()？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class User() {</span></div><div class="token-line"><span class="token plain">        val name: String = &quot;&quot;</span></div><div class="token-line"><span class="token plain">        val blog: String = &quot;&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun apply() {</span></div><div class="token-line"><span class="token plain">            // 成员方法可以通过 this 访问成员变量</span></div><div class="token-line"><span class="token plain">            username.text = this.name</span></div><div class="token-line"><span class="token plain">            website.text = this.blog</span></div><div class="token-line"><span class="token plain">            image.setOnClickListener { gotoImagePreviewActivity(this) }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以，从外表上看，带接收者的函数类型，就等价于成员方法。但<strong>从本质上讲，它仍是通过编译器注入this来实现的</strong>。</p><p>我们可以再通过一张图，来理解下什么是带接收者的函数类型：</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage9a049acd54ac08d88c94ca52336a576b3304.png" alt="图片"/></p><p>看到这里，也许你会想起前面我们讲过的“扩展函数”。那么，带接收者的函数类型，是否也能代表扩展函数呢？</p><p>答案是肯定的。毕竟，<strong>从语法层面讲，扩展函数就相当于成员函数。</strong></p><h2 id="实战与思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#实战与思考"><span class="icon icon-link"></span></a>实战与思考</h2><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/475058">第5讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中，我们实现了“单例的抽象类模板”，在课程的最后，我还给你留了一个思考题：</p><blockquote><p>我们的抽象类模板BaseSingleton是否还有改进的空间？</p></blockquote><p>这里，让我们先回顾一下BaseSingleton的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">abstract class BaseSingleton&lt;in P, out T&gt; {</span></div><div class="token-line"><span class="token plain">        @Volatile</span></div><div class="token-line"><span class="token plain">        private var instance: T? = null</span></div><div class="token-line"><span class="token plain">        //                       ①</span></div><div class="token-line"><span class="token plain">        //                       ↓</span></div><div class="token-line"><span class="token plain">        protected abstract fun creator(param: P): T</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun getInstance(param: P): T =</span></div><div class="token-line"><span class="token plain">            instance ?: synchronized(this) {</span></div><div class="token-line"><span class="token plain">                instance ?: creator(param).also { instance = it }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class PersonManager private constructor(name: String) {</span></div><div class="token-line"><span class="token plain">        companion object : BaseSingleton&lt;String, PersonManager&gt;() {</span></div><div class="token-line"><span class="token plain">            override fun creator(param: String): PersonManager = PersonManager(param)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面的代码我们可以看到，BaseSingleton是单例抽象模板，而PersonManager则是实际的单例类。</p><p>在前面的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/473349">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里，我们就讨论过Person的isAdult应该是属性，而walk则应该是方法。那么现在，请看注释①，它是我们定义的一个抽象方法，名字叫做creator。这时候，相信你马上就能反应过来：creator应该定义成属性。</p><p>可是，**如何才能将一个方法改成属性呢？**答案当然就是刚学过的：<strong>高阶函数</strong>。</p><p>运用这节课学到的知识，我们很容易就能将creator改成一个类型为：<code>(P)-&gt;T</code>的属性，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">abstract class BaseSingleton&lt;in P, out T&gt; {</span></div><div class="token-line"><span class="token plain">        @Volatile</span></div><div class="token-line"><span class="token plain">        private var instance: T? = null</span></div><div class="token-line"><span class="token plain">        //               变化在这里，函数类型的属性</span></div><div class="token-line"><span class="token plain">        //                  ↓              ↓</span></div><div class="token-line"><span class="token plain">        protected abstract val creator: (P)-&gt; T</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun getInstance(param: P): T =</span></div><div class="token-line"><span class="token plain">            instance ?: synchronized(this) {</span></div><div class="token-line"><span class="token plain">                instance ?: creator(param).also { instance = it }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码中，我们将creator改成了一个抽象的属性，如果其他的单例类继承了BaseSingleton这个类，就必须实现这个creator属性。不过，这时候一个问题就出现了：<strong>PersonManager该怎么写呢？</strong></p><p>如果我们依葫芦画瓢，在实现creator的时候传入PersonManager的构造函数，会发现代码报错：类型不匹配。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class PersonManager private constructor(name: String) {</span></div><div class="token-line"><span class="token plain">        companion object : BaseSingleton&lt;String, PersonManager&gt;() {</span></div><div class="token-line"><span class="token plain">        //             报错，类型不匹配</span></div><div class="token-line"><span class="token plain">        //                  ↓ </span></div><div class="token-line"><span class="token plain">            override val creator = PersonManager(name)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码报错的原因其实也很简单，creator的类型是一个(String)-&gt; PersonManager，而PersonManager构造函数这个表达式的值类型，是PersonManager类型。<strong>前者是函数类型，后者是普通对象类型</strong>。那么，如何才能正确实现creator这个函数类型的属性呢？</p><p>答案就是我们前面刚学的：<strong>函数引用</strong>！</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">class PersonManager private constructor(name: String) {</span></div><div class="token-line"><span class="token plain">        companion object : BaseSingleton&lt;String, PersonManager&gt;() {</span></div><div class="token-line"><span class="token plain">        //                             函数引用</span></div><div class="token-line"><span class="token plain">        //                                ↓ </span></div><div class="token-line"><span class="token plain">            override val creator = ::PersonManager</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从上面的代码中可以看到，我们直接将PersonManager的构造函数，以函数引用的方式传给了creator这个属性，这样就成功地实现了这个函数类型的属性。</p><p>在这个案例里，我们将函数引用以及高阶函数应用到了单例抽象类模板当中，而在这个过程当中，我们也就能更加透彻地理解这两个特性的使用场景了。</p><p>这里我制作了一个代码的转换动图，帮你建立一个更加直观的认识。</p><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage495c49b134d723c11c7d50762497b44afa5c.gif" alt="图片"/></p><p>从这个动图里，我们可以清晰地看到某些元素的转移过程。比如泛型P、T，还有PersonManager的构造函数，这些都是代码中的关键元素。这些关键元素只是换了一种语法排列规则：<strong>从函数的语法变成了属性的语法，语法从复杂变得简洁，其中的关键元素并未丢失</strong>。</p><p>因此，这两种代码是完全等价的，但后者更加简洁易懂。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#小结"><span class="icon icon-link"></span></a>小结</h2><p>到现在为止，咱们高阶函数部分的内容就进入尾声了。让我们再来做一次总结：</p><ul><li>**为什么引入高阶函数？**答：为了简化。</li><li>**高阶函数是什么？**答：函数作为参数or返回值。</li><li>**函数类型是什么？**答：函数的类型。</li><li>**函数引用是什么？**答：类比变量的引用。</li><li>**Lambda是什么？**答：可以简单理解为“函数的简写”（官方定义我们以后再讨论）。</li><li>**带接收者的函数类型是什么？**答：可以简单理解为“成员函数的类型”。</li></ul><p><img src="/images/%E6%9C%B1%E6%B6%9Bkotlin%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage453e45e23ce48a64711943366fec784af23e.jpg" alt="图片"/></p><p>事实上，对于初学者来说，要一下子理解并掌握Kotlin“高阶函数”不是一件容易的事情。在掌握好这节课内容的基础上，我们可以尝试去读一些优秀的代码。</p><p>比如Kotlin官方的源代码<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以去分析其中的with、let、also、takeIf、repeat、apply，来进一步加深对高阶函数的理解。还有就是<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/common/src/generated/_Collections.kt">CollectionsKt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以去分析其中的map、flatMap、fold、groupBy等操作符，从而对高阶函数的应用场景有一个更具体的认知。</p><p>另外，在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/473349">第<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/473349">2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候，我们曾经提到过：理论上讲，Kotlin与Java是完全兼容的。那么问题来了，**Kotlin引入全新的高阶函数，最终变成JVM字节码后是怎么执行呢？**毕竟，JVM可不知道什么是高阶函数啊。</p><p>答案其实也很简单：<strong>匿名内部类</strong>。</p><p>而这样又引出了另一个问题：所以Kotlin弄了个这么高端的高阶函数，最终还是以匿名内部类的形式在运行呗？那它们两者的性能差不多？这不是多此一举吗？</p><p>答案当然是否定的，Kotlin高阶函数的性能，在极端情况下可以达到匿名内部类的100倍！具体是怎么回事儿呢？别着急，下节课讲“inline”时，我们就会来详细探讨。</p><h2 id="小作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07#小作业"><span class="icon icon-link"></span></a>小作业</h2><p>请你去阅读一下Kotlin官方的标准函数库<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt的源代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，尝试去解析其中任意一个高阶函数的原理和意义，并分享出来，我们一起探讨。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public inline fun &lt;R&gt; run(block: () -&gt; R): R {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return block()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return block()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return receiver.block()</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        block()</span></div><div class="token-line"><span class="token plain">        return this</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        block(this)</span></div><div class="token-line"><span class="token plain">        return this</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return block(this)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return if (predicate(this)) this else null</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? {</span></div><div class="token-line"><span class="token plain">        contract {</span></div><div class="token-line"><span class="token plain">            callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return if (!predicate(this)) this else null</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public inline fun repeat(times: Int, action: (Int) -&gt; Unit) {</span></div><div class="token-line"><span class="token plain">        contract { callsInPlace(action) }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for (index in 0 until times) {</span></div><div class="token-line"><span class="token plain">            action(index)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>好了，这节课就到这里，如果觉得有收获，非常欢迎你把今天的内容分享给更多的朋友，咱们下节课再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/02.基础篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:08:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
