<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>06 | 扩展：你的能力边界到底在哪里？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/02.基础篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是扩展函数和扩展属性？" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#什么是扩展函数和扩展属性"><span>什么是扩展函数和扩展属性？</span></a></li><li title="扩展函数的实现原理" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展函数的实现原理"><span>扩展函数的实现原理</span></a></li><li title="如何理解扩展属性？" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#如何理解扩展属性"><span>如何理解扩展属性？</span></a></li><li title="扩展的能力边界" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展的能力边界"><span>扩展的能力边界</span></a></li><li title="扩展能做什么？" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展能做什么"><span>扩展能做什么？</span></a></li><li title="扩展不能做什么？" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展不能做什么"><span>扩展不能做什么？</span></a></li><li title="实战与思考" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#实战与思考"><span>实战与思考</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="06--扩展你的能力边界到底在哪里"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#06--扩展你的能力边界到底在哪里"><span class="icon icon-link"></span></a>06 | 扩展：你的能力边界到底在哪里？</h1><p>你好，我是朱涛。</p><p>Kotlin的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改JDK当中的String，想在它的基础上增加一个方法“lastElement()”来获取末尾元素，如果使用Java，我们是无法通过常规手段实现的，因为我们没办法修改JDK的源代码。<strong>任何第三方提供的SDK，我们都无权修改。</strong></p><p>不过，借助Kotlin的扩展函数，我们就完全可以在语义层面，来为第三方SDK的类扩展新的成员方法和成员属性。不管是为JDK的String增加新的成员方法，还是为Android SDK的View增加新成员属性，我们都可以实现。</p><p>Kotlin的这个“扩展”功能看起来很神奇，它会不会很难学？其实不然，它的语法非常简洁。今天这节课，我们就一起来学习下Kotlin当中的扩展。通过研究它的原理，来探索它的能力边界，并在理解和掌握核心知识点之后，去思考它的实战应用场景。</p><h2 id="什么是扩展函数和扩展属性"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#什么是扩展函数和扩展属性"><span class="icon icon-link"></span></a>什么是扩展函数和扩展属性？</h2><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以JDK当中的String为例，来看看如何通过Kotlin的扩展特性，为它新增一个lastElement()方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Ext.kt</span></div><div class="token-line"><span class="token plain">    package com.boycoder.chapter06</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">     ①    ②      ③            ④</span></div><div class="token-line"><span class="token plain">     ↓     ↓       ↓            ↓      */</span></div><div class="token-line"><span class="token plain">    fun String.lastElement(): Char? {</span></div><div class="token-line"><span class="token plain">        //    ⑤</span></div><div class="token-line"><span class="token plain">        //    ↓</span></div><div class="token-line"><span class="token plain">        if (this.isEmpty()) {</span></div><div class="token-line"><span class="token plain">            return null</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return this[length - 1]</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 使用扩展函数</span></div><div class="token-line"><span class="token plain">    fun main() {</span></div><div class="token-line"><span class="token plain">        val msg = &quot;Hello Wolrd&quot;</span></div><div class="token-line"><span class="token plain">        // lastElement就像String的成员方法一样可以直接调用</span></div><div class="token-line"><span class="token plain">        val last = msg.lastElement() // last = d</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们先是定义了一个String的扩展函数“lastElement()”，然后在main函数当中调用了这个函数。并且，这个扩展函数是直接定义在Kotlin文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为“<strong>顶层扩展</strong>”，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释。</p><ul><li>注释①，<code>fun</code>关键字，代表我们要定义一个函数。也就是说，不管是定义普通Kotlin函数，还是定义扩展函数，我们都需要fun关键字。</li><li>注释②，“<code>String.</code>”，代表我们的扩展函数是为String这个类定义的。在Kotlin当中，它有一个名字，叫做接收者（Receiver），也就是扩展函数的接收方。</li><li>注释③，<code>lastElement()</code>，是我们定义的扩展函数的名称。</li><li>注释④，“<code>Char?</code>”，代表扩展函数的返回值是可能为空的Char类型。</li><li>注释⑤，“<code>this.</code>”，代表“具体的String对象”，当我们调用 <code>msg.lastElement()</code> 的时候，this就代表了msg。</li></ul><p>需要注意的是，**在整个扩展函数的方法体当中，this都是可以省略的。**这一点，Kotlin和Java是一样的，this代表当前作用域，它可写可不写。</p><p>另外，如果你足够细心的话，你会发现如果去掉注释②处的“<code>String.</code>”，这段代码就会变成一个普通的函数定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun lastElement(): Char? {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun String.lastElement(): Char? {}</span></div><div class="token-line"><span class="token plain">    // 普通函数与扩展函数之间的差别</span></div></pre></div><p>换句话说，就是如果我们在普通函数的名称前面加上一个“接收者类型”，比如“<code>String.</code>”，Kotlin的“普通函数”就变成了“扩展函数”。</p><p>可见，Kotlin扩展语法设计得非常巧妙，只要你记住了普通函数的语法，那么，只需要再记住一点点细微的区别，你就能记住扩展函数的语法。而通过这个细微的语法差异，你也可以体会到，所谓的扩展函数，就是多了个“扩展接收者”的函数。</p><h3 id="扩展函数的实现原理"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展函数的实现原理"><span class="icon icon-link"></span></a>扩展函数的实现原理</h3><p>在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/473529">第3讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中，我们学习了如何研究Kotlin的原理，也就是通过Java字节码来做反编译。那么在这里，我们就以刚才写的lastElement()为例，一起来看看它反编译后的Java代码是什么样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final class ExtKt {</span></div><div class="token-line"><span class="token plain">       // ①</span></div><div class="token-line"><span class="token plain">       public static final Character lastElement(String $this) {</span></div><div class="token-line"><span class="token plain">          CharSequence var1 = (CharSequence)$this;</span></div><div class="token-line"><span class="token plain">          if (var1.length() == 0) {</span></div><div class="token-line"><span class="token plain">            return null</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          return  var1.charAt(var1.length() - 1);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public static final void main() {</span></div><div class="token-line"><span class="token plain">      String msg = &quot;Hello Wolrd&quot;;</span></div><div class="token-line"><span class="token plain">      //                        ②</span></div><div class="token-line"><span class="token plain">      //                        ↓</span></div><div class="token-line"><span class="token plain">      Character last = ExtKt.lastElement(msg);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>以上代码有两个地方需要注意，我分别用两个注释标记出来了。</p><p>通过第一个注释，我们可以看到，原本定义在String类型上面的扩展函数lastElement()，变成了一个<strong>普通的静态方法</strong>。另外，之前定义的扩展函数lastElement()是没有参数的，但反编译后的Java代码中，lastElement(String $this) <strong>多了一个String类型的参数</strong>。</p><p>还有第二个注释，这是扩展函数的调用处，原本msg.lastElement()的地方，变成了ExtKt.lastElement(msg)。这说明，<strong>Kotlin编写的扩展函数调用代码，最终会变成静态方法的调用</strong>。</p><p>看到这里，也许你一下就能反应过来：Kotlin的扩展函数只是从表面上将lastElement()变成String的成员，但它实际上并没有修改String这个类的源代码，lastElement()也并没有真正变成String的成员方法。</p><p>也就是说，<strong>由于JVM不理解Kotlin的扩展语法，所以Kotlin编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。</strong></p><p>而如果我们将上面的ExtKt修改成StringUtils，它就变成了典型的Java工具类。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public final class StringUtils {</span></div><div class="token-line"><span class="token plain">       public static final Character lastElement(String $this) {</span></div><div class="token-line"><span class="token plain">         // 省略</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public static final void main() {</span></div><div class="token-line"><span class="token plain">      Character last = StringUtils.lastElement(msg);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="如何理解扩展属性"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#如何理解扩展属性"><span class="icon icon-link"></span></a>如何理解扩展属性？</h3><p>在学习了Kotlin的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以lastElement为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 接收者类型</span></div><div class="token-line"><span class="token plain">    //     ↓</span></div><div class="token-line"><span class="token plain">    val String.lastElement: Char?</span></div><div class="token-line"><span class="token plain">        get() = if (isEmpty()) {</span></div><div class="token-line"><span class="token plain">                null</span></div><div class="token-line"><span class="token plain">            } else {</span></div><div class="token-line"><span class="token plain">                get(length - 1)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() {</span></div><div class="token-line"><span class="token plain">        val msg = &quot;Hello Wolrd&quot;</span></div><div class="token-line"><span class="token plain">        // lastElement就像String的成员属性一样可以直接调用</span></div><div class="token-line"><span class="token plain">        val last = msg.lastElement // last = d</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段的代码中，我们为String类型扩展了一个新的成员属性“lastElement”。然后在main函数当中，我们直接通过“msg.lastElement”方式使用了这个扩展属性，就好像它是一个成员一样。而如果你将以上的代码进行反编译，你会发现它反编译后的Java代码几乎和我们前面扩展函数的一模一样。</p><p>为了让你看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2aed2a38487b61ec06e437c1425b2a69ffed.2c8ff00b.png" alt="图片"/></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被Kotlin编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被Kotlin编译器转换成静态方法的调用。</p><p>所以也就是说，Kotlin的扩展表面上看起来是为一个类扩展了新的成员，但是<strong>本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement就像是String类当中的属性一样，它代表了字符串里的最后一个字符。</p><h2 id="扩展的能力边界"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展的能力边界"><span class="icon icon-link"></span></a>扩展的能力边界</h2><p>在理解了扩展的使用与原理后，我们再来探讨一下扩展的能力边界：扩展能做什么，不能做什么。Kotlin的扩展看起来很神奇，但它并不是无所不能的，通过探索它的能力边界，我们就能对它有一个更加深入的认识。</p><h3 id="扩展能做什么"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展能做什么"><span class="icon icon-link"></span></a><strong>扩展能做什么？</strong></h3><p>我们先从“扩展能做什么”说起。</p><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在Kotlin当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的Java类。唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，Kotlin扩展的应用范围还是非常广的。它最主要的用途，就是<strong>用来取代Java当中的各种工具类</strong>，比如StringUtils、DateUtils等等。</p><p>所有Java工具类能做的事情，Kotlin扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage239c239e540b768560c6cd119b1bb9e1eb9c.75c2bf93.gif" alt="图片"/></p><h3 id="扩展不能做什么"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#扩展不能做什么"><span class="icon icon-link"></span></a><strong>扩展不能做什么？</strong></h3><p>我们再聊聊扩展不能做什么。</p><p>Kotlin的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制</strong>，Kotlin扩展不是真正的类成员，因此它无法被它的子类重写。举个例子，我们定义一个这样的Person类，并且分别为它扩展了一个isAdult属性和 walk()方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">open class Person {</span></div><div class="token-line"><span class="token plain">        var name: String = &quot;&quot;</span></div><div class="token-line"><span class="token plain">        var age: Int = 0</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    val Person.isAdult: Boolean</span></div><div class="token-line"><span class="token plain">        get() = age &gt;= 18</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun Person.walk() {</span></div><div class="token-line"><span class="token plain">        println(&quot;walk&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>由于Person类有open关键字修饰，所以我们可以继承这个Person类。不过，当我们尝试去重写它的成员时，会发现isAdult和walk()是无法被重写的，因为它们压根就不属于Person这个类。这个很好理解，让我们看下一个。</p><p><strong>第二个限制</strong>，扩展属性无法存储状态。就如前面代码当中的isAdult属性一般，它的值是由age这个成员属性决定的，它本身没有状态，也无法存储状态。这一点，和我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/473349">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学习的“接口成员属性”一样，背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制</strong>，扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。我们以前面的代码为例：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Ext.kt</span></div><div class="token-line"><span class="token plain">    package com.boycoder.chapter06</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // ①</span></div><div class="token-line"><span class="token plain">    private val msg: String = &quot;&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun String.lastElement(): Char? {</span></div><div class="token-line"><span class="token plain">        if (this.isEmpty()) {</span></div><div class="token-line"><span class="token plain">            //       ②</span></div><div class="token-line"><span class="token plain">            //       ↓</span></div><div class="token-line"><span class="token plain">            println(msg)</span></div><div class="token-line"><span class="token plain">            return null</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //            ③</span></div><div class="token-line"><span class="token plain">        //            ↓</span></div><div class="token-line"><span class="token plain">        return this[length - 1]</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码一共有三处注释，我们一个个看：</p><ul><li>在注释①的地方，我们在Ext这个Kotlin文件里定义了一个私有的变量msg。</li><li>由于lastElement()与msg是定义在同一个文件当中的，因此，在注释②处我们可以直接访问msg，即使它是私有的。</li><li>最后，是注释③，由于length是String类的公开属性，因此我们可以在扩展函数当中直接访问它。对应的，如果length是String的private、protected成员，那我们将无法在扩展函数当中访问它。归根结底，还是因为扩展函数并非真正的类成员。</li></ul><p>看到这里，也许你会冒出一个有趣的想法：<strong>如果将扩展定义在某个类的内部，它能够访问这个类的私有属性吗？</strong></p><p>让我们来试试看：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">open class Person {</span></div><div class="token-line"><span class="token plain">        var name: String = &quot;&quot;</span></div><div class="token-line"><span class="token plain">        var age: Int = 0</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class Helper {</span></div><div class="token-line"><span class="token plain">        private fun walkOnFoot() {</span></div><div class="token-line"><span class="token plain">            println(&quot;用脚走路&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        val Person.isAdult: Boolean</span></div><div class="token-line"><span class="token plain">            get() = age &gt;= 18</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun Person.walk() {</span></div><div class="token-line"><span class="token plain">            // 调用了Helper的私有方法</span></div><div class="token-line"><span class="token plain">            walkOnFoot()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        fun test() {</span></div><div class="token-line"><span class="token plain">            val person = Person()</span></div><div class="token-line"><span class="token plain">            // 仅可以在Helper类当中使用此扩展</span></div><div class="token-line"><span class="token plain">            person.walk()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们创建了一个Helper类，它内部有一个私有的成员方法，同时，我们在这个类的内部定义了一个扩展属性和一个扩展函数。可以看到，我们在扩展函数walk()方法当中，能直接调用Helper类的私有成员方法walkOnFoot()，这体现了类的内部定义扩展的优势。</p><p>但是与此同时，这种方式定义的扩展也存在一个劣势，那就是无法在Helper类的外部作为扩展被调用。如果你将上面的代码反编译成Java，你会发现，我们定义的内部扩展，最终都变成了Helper类的普通成员函数和成员属性。</p><p>所以，针对扩展的第三个限制来说：</p><ul><li>如果扩展是<strong>顶层的扩展</strong>，那么扩展的访问域仅限于该Kotlin文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</li><li>如果扩展是<strong>被定义在某个类当中</strong>的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</li></ul><h2 id="实战与思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#实战与思考"><span class="icon icon-link"></span></a>实战与思考</h2><p>到这里，我们就了解了Kotlin的扩展，包括扩展函数、扩展属性以及扩展的实现原理，同时我们也在了解它原理的基础上分析了它的能力边界。</p><p>不过，即使在学习完上面所有的知识点后，你也许还是不太清楚Kotlin扩展的实际使用场景。所以下面，我再带你来看两个案例，这两个工业界的实际案例，可以完美地向你展示Kotlin扩展的两个核心使用场景。你可以通过学习这两种思路，将其运用在实际的工作当中。</p><p>第一个案例，是来自Kotlin标准库当中的源代码。我们先看看在Kotlin当中，<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的源代码是什么样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// String.kt</span></div><div class="token-line"><span class="token plain">    public class String : Comparable&lt;String&gt;, CharSequence {</span></div><div class="token-line"><span class="token plain">        companion object {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public operator fun plus(other: Any?): String</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public override val length: Int</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public override fun get(index: Int): Char</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public override fun compareTo(other: String): Int</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你一定会很惊讶，Kotlin里面的String类竟然只有不到十行代码。那么，String类的那些字符操作的方法到哪里去了？比如，String.trim()、String.lowercase()它们定义在什么地方？</p><p>实际上，String相关的操作方法全都放到了<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// Strings.kt 部分代码</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public expect fun String.lowercase(): String</span></div></pre></div><p>那么，Kotlin官方能不能将“字符操作方法”放到String类当中合并到一起呢？源代码是Kotlin官方写的，他们当然能将所有的代码都合并到一个类当中去，形成一个几千行的String类，但他们却没有这么做。这是为啥呢？</p><p>这就是Kotlin扩展的<strong>第一个典型使用场景：</strong><a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的String类为例，<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这个类，只关注String的核心逻辑；而<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>则只关注String的操作符逻辑。</p><p>需要注意的是，只有借助Kotlin的扩展，我们才能实现这样的关注点分离设计。如果你去看Java的String类，你会发现它的源代码有三千多行。这是因为，Java的String核心属性跟它的操作方法全都混合在了一起。</p><p>第二个代码案例，是我工作当中用到的一段Android扩展函数代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">inline fun &lt;reified T : ViewGroup.LayoutParams&gt; View.updateLayoutParams(block: T.() -&gt; Unit) {</span></div><div class="token-line"><span class="token plain">        val params = layoutParams as T</span></div><div class="token-line"><span class="token plain">        block(params)</span></div><div class="token-line"><span class="token plain">        layoutParams = params</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun View.updateMargin(left: Int? = null, top: Int? = null, right: Int? = null, bottom: Int? = null) {</span></div><div class="token-line"><span class="token plain">        (layoutParams as? ViewGroup.MarginLayoutParams)?.let { param -&gt;</span></div><div class="token-line"><span class="token plain">            updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {</span></div><div class="token-line"><span class="token plain">                left?.let {</span></div><div class="token-line"><span class="token plain">                    marginStart = left</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                right?.let {</span></div><div class="token-line"><span class="token plain">                    marginEnd = right</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                top?.let {</span></div><div class="token-line"><span class="token plain">                    topMargin = top</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">                bottom?.let {</span></div><div class="token-line"><span class="token plain">                    bottomMargin = bottom</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码定义了两个扩展函数，updateLayoutParams()、updateMargin()，后者的方法体当中用到了前者。通过updateMargin()这个扩展函数，可以大大简化Android当中的margin更新。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">view.updateMargin(top = 100, bottom = 100)</span></div></pre></div><p>而如果不借助扩展函数，我们将不得不写一堆的模板代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">val params = view.layoutParams</span></div><div class="token-line"><span class="token plain">    if (params is ViewGroup.MarginLayoutParams) {</span></div><div class="token-line"><span class="token plain">        params.marginTop = 100</span></div><div class="token-line"><span class="token plain">        params.marginBottom = 100</span></div><div class="token-line"><span class="token plain">        view.layoutParams = params</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是<strong>成倍</strong>的提升：借助扩展函数，我们只需要写一行代码，IntelliJ还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写5行代码，这样的代码模式不仅枯燥繁琐，IntelliJ也无法智能提示，也更容易出错。</p><p>我们来小结一下，Kotlin扩展主要有两个核心使用场景。</p><ul><li><strong>主动使用扩展，通过它来优化软件架构。</strong></li></ul><p>对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>与<a target="_blank" rel="noopener noreferrer" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><ul><li><strong>被动使用扩展，提升可读性与开发效率。</strong></li></ul><p>当我们无法修改外部的SDK时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如view.updateMargin()。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>好，让我们来做个简单的总结吧。</p><ul><li>Kotlin的扩展，从<strong>语法角度</strong>来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从<strong>作用域角度</strong>来看，分为顶层扩展和类内扩展。</li><li>从<strong>本质</strong>上来看，扩展函数和扩展属性，它们都是Java静态方法，与Java当中的工具类别无二致。对比Java工具类，扩展最大的优势就在于，IDE可以为我们提供代码补全功能。</li><li>从<strong>能力</strong>的角度来看，Kotlin扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从<strong>使用场景</strong>的角度来看，Kotlin扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ul><p>最后在这里，我还想和你分享一下我在学Kotlin扩展的思考过程，希望这种思考的方式可以给你带来一些启发。</p><p>刚开始，我学习扩展的时候，脑子里其实是一片混乱的，就像下面这张图一样：扩展的每一个知识点都是散乱的。</p><p>这时候，我们就要将这些知识点做一个分类整理，同时，在学习扩展语法的时候，还要与前面的普通函数、普通属性的语法进行关联记忆。这样一来，我们零散的知识点就连接到一起，形成体系化的知识面。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3d5c3d0715ee9ba1461bcee1bea99de8e25c.35d86190.jpg" alt="图片"/></p><p>当我们的知识形成一个体系之后，记忆起来就很容易了，这样，一个简单的<strong>浅层知识结构</strong>就形成了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage5bac5b2f0b9560d9198a9166f5e9016c83ac.05dd58e6.jpg" alt="图片"/></p><p>接着，在这个基础上，我们再进行深度的思考，去探索扩展的底层原理，还有它的能力边界，从而形成一个更加<strong>深层次的知识结构</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage3e183e42099e82472869f87e33e9202c1218.83569451.jpg" alt=""/></p><p>到目前为止，这些都是理论层面的一些知识，我们还需要进一步探索Kotlin扩展的实际应用场景。这时候，就会发现它的两个主要使用场景，一个是<strong>主动的</strong>，<strong>一个是被动的</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb410b4a3ce7c3e0b2228161faa4769618a10.32458414.jpg" alt=""/></p><p>其实，学习就是一个不断向下挖掘探索的过程。学习Kotlin是这样，学习其他计算机知识也是这样，甚至学习其他领域的知识也是这个道理。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在这节课中的所有案例中，我们的“扩展接收者”都是不为空的类型。但实际上，Kotlin的扩展是允许我们为“可为空的类型”进行扩展的。比如说：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 不为空的接收者类型</span></div><div class="token-line"><span class="token plain">    //     ↓</span></div><div class="token-line"><span class="token plain">    fun String.lastElement(): Char? {}</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 可为空的接收者类型</span></div><div class="token-line"><span class="token plain">    //     ↓</span></div><div class="token-line"><span class="token plain">    fun String?.lastElement(): Char? {}</span></div></pre></div><p>那么，请问这两种扩展有什么不同？欢迎在评论区分享你的思路，我们下节课再见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/02.基础篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
