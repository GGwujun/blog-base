<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>22 | 并发：协程不需要处理同步吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/04.协程篇/12" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="协程与并发" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#协程与并发"><span>协程与并发</span></a></li><li title="借鉴Java的并发思路" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#借鉴java的并发思路"><span>借鉴Java的并发思路</span></a></li><li title="协程的并发思路" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#协程的并发思路"><span>协程的并发思路</span></a></li><li title="单线程并发" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#单线程并发"><span>单线程并发</span></a></li><li title="Mutex" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#mutex"><span>Mutex</span></a></li><li title="Actor" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#actor"><span>Actor</span></a></li><li title="反思：可变状态" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#反思可变状态"><span>反思：可变状态</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="22--并发协程不需要处理同步吗"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#22--并发协程不需要处理同步吗"><span class="icon icon-link"></span></a>22 | 并发：协程不需要处理同步吗？</h1><p>你好，我是朱涛。今天我们来讲讲协程的并发。</p><p>在大型软件的架构当中，并发也是一个不可避免的问题。然而，在传统的Java编程当中，并发却是个令人生畏的话题。因为Java的线程模型、内存模型、同步机制太复杂了，而当复杂的业务逻辑与复杂的并发模型混合在一起的时候，情况就更糟糕了！如果你用Java做过中大型软件，对此一定会深有体会。</p><p>我们都知道，Kotlin的协程仍然是基于线程运行的。但是，经过一层封装以后，Kotlin协程面对并发问题的时候，它的处理手段其实跟Java就大不一样。所以这节课，我们就来看看协程在并发问题上的处理，一起来探究下Kotlin协程的并发思路，从而真正解决并发的难题。</p><h2 id="协程与并发"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#协程与并发"><span class="icon icon-link"></span></a>协程与并发</h2><p>在Java世界里，并发往往需要多个线程一起工作，而多线程往往就会有共享的状态，这时候程序就要处理同步问题了。很多初学者在这一步，都会把协程与线程的概念混淆在一起。比如你可以来看看下面这段代码，你觉得有多线程同步的问题吗？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // Default 线程池</span></div><div class="token-line"><span class="token plain">        launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">            repeat(1000) {</span></div><div class="token-line"><span class="token plain">                i++</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        delay(1000L)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码里，我是在Default线程池上创建了一个协程，然后对变量i进行了1000次自增操作，接着我又delay了一小会儿，防止程序退出，最后输出结果。</p><p>那么，在面对这段代码的时候，你也许会觉得，Default线程池内部是多个线程，因此就需要考虑多线程同步的问题。其实，这就是典型的把协程、线程混淆的例子。</p><p>如果你仔细分析上面的代码，会发现<strong>代码中压根就没有并发执行的任务</strong>，除了runBlocking，我只在launch当中创建了一个协程，所有的计算都发生在一个协程当中。所以，在这种情况下你根本就不需要考虑同步的问题。</p><p>我们再来看看多个协程并发执行的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段2</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 重复十次</span></div><div class="token-line"><span class="token plain">        repeat(10){</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    i++</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 等待计算完成</span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果</span></div><div class="token-line"><span class="token plain">    i = 9972</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在上面的代码中，我创建了10个协程任务，每个协程任务都会工作在Default线程池，这10个协程任务，都会分别对i进行1000次自增操作。如果一切正常的话，代码的输出结果应该是10000。但如果你实际运行这段代码，你会发现结果大概率不会是10000。</p><p>出现这个问题的原因也很简单，这10个协程分别运行在不同的线程之上，与此同时，这10个协程之间还共享着i这个变量，并且它们还会以并发的形式对i进行自增，所以自然就会产生同步的问题。</p><blockquote><p>补充：为了不偏离主题，这里我们不去深究出现这个问题的底层原因。这涉及到Java内存模型之类的底层细节，如果你不熟悉Java并发相关的知识点，可以自行去做一些了解。</p></blockquote><p>所以在这里，我们就可以回答这节课标题里的问题了：<strong>Kotlin协程也需要处理多线程同步的问题</strong>。</p><p>那么下面，我们就以这个简单的代码为例，一起来分析下Kotlin协程面对并发时，都有哪些可用的手段。</p><h2 id="借鉴java的并发思路"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#借鉴java的并发思路"><span class="icon icon-link"></span></a>借鉴Java的并发思路</h2><p>首先，由于Kotlin协程也是基于JVM的，所以，当我们面对并发问题的时候，脑子里第一时间想到的肯定是Java当中的同步手段，比如synchronized、Atomic、Lock，等等。</p><p>在Java当中，最简单的同步方式就是synchronized同步了。那么换到Kotlin里，我们就可以使用 <strong>@Synchronized注解</strong>来修饰函数，也可以使用 <strong>synchronized()<!-- -->{<!-- -->}</strong> 的方式来实现同步代码块。</p><p>让我们用synchronized来改造一下上面的代码段2：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val lock = Any() // 变化在这里</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10){</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    // 变化在这里</span></div><div class="token-line"><span class="token plain">                    synchronized(lock) {</span></div><div class="token-line"><span class="token plain">                        i++</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果</span></div><div class="token-line"><span class="token plain">    i = 10000</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>以上代码中，我们创建了一个lock对象，然后使用synchronized()<!-- -->{<!-- -->}<!-- --> 将“i++”包裹了起来。这样就可以确保在自增的过程中不会出现同步问题。这时候，如果你再来运行代码，就会发现结果已经是10000了。</p><p>不过，如果你在实际生产环境使用过协程的话，应该会感觉synchronized在协程当中也不是一直都很好用的。毕竟，<strong>synchronized是线程模型下的产物</strong>。</p><p>就比如说，假设我们这里的自增操作需要一些额外的操作，需要用到挂起函数prepare()。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段4</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        suspend fun prepare(){</span></div><div class="token-line"><span class="token plain">            // 模拟准备工作</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val lock = Any()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10){</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    synchronized(lock) {</span></div><div class="token-line"><span class="token plain">                        // 编译器报错！</span></div><div class="token-line"><span class="token plain">                        prepare()</span></div><div class="token-line"><span class="token plain">                        i++</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这时候，你就不能天真地把协程看作是“Java线程池的封装”，然后继续照搬Java的同步手段了。你会发现：<strong>synchronized()<!-- -->{<!-- -->}<!-- --> 当中调用挂起函数，编译器会给你报错！</strong></p><p>这是为什么呢？其实，如果你理解了<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/487085">第15讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中“协程挂起恢复”的思维模型的话，那么编译器报错的原因你一定可以轻松理解。因为这里的挂起函数会被翻译成带有Continuation的异步函数，从而就造成了synchronid代码块无法正确处理同步。</p><p>另外从这个例子里，我们也可以看出：即使Kotlin协程是基于Java线程的，但它其实已经脱离Java原本的范畴了。所以，单纯使用Java的同步手段，是无法解决Kotlin协程里所有问题的。</p><p>那么接下来，我们就来看看Kotlin协程当中的并发思路。</p><h2 id="协程的并发思路"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#协程的并发思路"><span class="icon icon-link"></span></a>协程的并发思路</h2><p>前面我也提到过，由于Java的线程模型是阻塞式的，比如说Thread.sleep()，所以在Java当中，并发往往就意味着多线程，而多线程则往往会有状态共享，而状态共享就意味着要处理同步问题。</p><p>但是，因为Kotlin协程具备挂起、恢复的能力，而且还有非阻塞的特点，所以在使用协程处理并发问题的时候，我们的思路其实可以更宽。比如，我们可以使用<strong>单线程并发</strong>。</p><h3 id="单线程并发"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#单线程并发"><span class="icon icon-link"></span></a>单线程并发</h3><p>在Kotlin当中，单线程并发的实现其实非常轻松。不过如果你有Java经验的话，也许会对这个说法产生疑问，因为在Java当中，并发往往就意味着多线程。</p><p>实际上，在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/487930">第16讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里我们就涉及到“单线程并发”这个概念了。让我们回过头，重新看看那段并发的代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段5</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        suspend fun getResult1(): String {</span></div><div class="token-line"><span class="token plain">            logX(&quot;Start getResult1&quot;)</span></div><div class="token-line"><span class="token plain">            delay(1000L) // 模拟耗时操作</span></div><div class="token-line"><span class="token plain">            logX(&quot;End getResult1&quot;)</span></div><div class="token-line"><span class="token plain">            return &quot;Result1&quot;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        suspend fun getResult2(): String {</span></div><div class="token-line"><span class="token plain">            logX(&quot;Start getResult2&quot;)</span></div><div class="token-line"><span class="token plain">            delay(1000L) // 模拟耗时操作</span></div><div class="token-line"><span class="token plain">            logX(&quot;End getResult2&quot;)</span></div><div class="token-line"><span class="token plain">            return &quot;Result2&quot;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        suspend fun getResult3(): String {</span></div><div class="token-line"><span class="token plain">            logX(&quot;Start getResult3&quot;)</span></div><div class="token-line"><span class="token plain">            delay(1000L) // 模拟耗时操作</span></div><div class="token-line"><span class="token plain">            logX(&quot;End getResult3&quot;)</span></div><div class="token-line"><span class="token plain">            return &quot;Result3&quot;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val results: List&lt;String&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val time = measureTimeMillis {</span></div><div class="token-line"><span class="token plain">            val result1 = async { getResult1() }</span></div><div class="token-line"><span class="token plain">            val result2 = async { getResult2() }</span></div><div class="token-line"><span class="token plain">            val result3 = async { getResult3() }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            results = listOf(result1.await(), result2.await(), result3.await())</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;Time: $time&quot;)</span></div><div class="token-line"><span class="token plain">        println(results)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    Start getResult1</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    Start getResult2</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    Start getResult3</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    End getResult1</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    End getResult2</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    End getResult3</span></div><div class="token-line"><span class="token plain">    Thread:main</span></div><div class="token-line"><span class="token plain">    ================================</span></div><div class="token-line"><span class="token plain">    Time: 1066</span></div><div class="token-line"><span class="token plain">    [Result1, Result2, Result3]</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在上面的代码中启动了三个协程，它们之间是并发执行的，每个协程执行耗时是1000毫秒，程序总耗时也是接近1000毫秒。而且，这几个协程是运行在同一个线程main之上的。</p><p>所以，当我们在协程中面临并发问题的时候，首先可以考虑：<strong>是否真的需要多线程</strong>？如果不需要的话，其实是可以不考虑多线程同步问题的。</p><p>那么，对于前面代码段2的例子来说，我们则可以把计算的逻辑分发到单一的线程之上。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段6</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val mySingleDispatcher = Executors.newSingleThreadExecutor {</span></div><div class="token-line"><span class="token plain">            Thread(it, &quot;MySingleThread&quot;).apply { isDaemon = true }</span></div><div class="token-line"><span class="token plain">        }.asCoroutineDispatcher()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val job = launch(mySingleDispatcher) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    i++</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果</span></div><div class="token-line"><span class="token plain">    i = 10000</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>可见，在这段代码中，我们使用“launch(mySingleDispatcher)”，把所有的协程任务都分发到了单线程的Dispatcher当中，这样一来，我们就不必担心同步问题了。另外，如果仔细分析的话，上面创建的10个协程之间，其实仍然是并发执行的。</p><p>所以这时候，如果你运行上面的代码，就一定可以得到正确的结果了：i = 10000。</p><h3 id="mutex"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#mutex"><span class="icon icon-link"></span></a>Mutex</h3><p>在Java当中，其实还有Lock之类的同步锁。但由于Java的锁是阻塞式的，会大大影响协程的非阻塞式的特性。所以，在Kotlin协程当中，我们也是<strong>不推荐</strong>直接使用传统的同步锁的，甚至在某些场景下，在协程中使用Java的锁也会遇到意想不到的问题。</p><p>为此，Kotlin官方提供了“非阻塞式”的锁：Mutex。下面我们就来看看，如何用Mutex来改造代码段2。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段7</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val mutex = Mutex()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    // 变化在这里</span></div><div class="token-line"><span class="token plain">                    mutex.lock()</span></div><div class="token-line"><span class="token plain">                    i++</span></div><div class="token-line"><span class="token plain">                    mutex.unlock()</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面的代码中，我们使用mutex.lock()、mutex.unlock()包裹了需要同步的计算逻辑，这样一来，代码就可以实现多线程同步了，程序的输出结果也会是10000。</p><p>实际上，Mutex对比JDK当中的锁，最大的优势就在于<strong>支持挂起和恢复</strong>。让我们来看看它的源码定义：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段8</span></div><div class="token-line"><span class="token plain">    public interface Mutex {</span></div><div class="token-line"><span class="token plain">        public val isLocked: Boolean</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //     注意这里</span></div><div class="token-line"><span class="token plain">        //        ↓</span></div><div class="token-line"><span class="token plain">        public suspend fun lock(owner: Any? = null)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public fun unlock(owner: Any? = null)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，Mutex是一个接口，它的lock()方法其实是一个挂起函数。而这就是实现非阻塞式同步锁的根本原因。</p><p>不过，在代码段7当中，我们对于Mutex的使用其实是<strong>错误</strong>的。因为这样的做法并不安全，我们可以来看一个场景：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段9</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val mutex = Mutex()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    try {</span></div><div class="token-line"><span class="token plain">                        mutex.lock()</span></div><div class="token-line"><span class="token plain">                        i++</span></div><div class="token-line"><span class="token plain">                        i/0 // 故意制造异常</span></div><div class="token-line"><span class="token plain">                        mutex.unlock()</span></div><div class="token-line"><span class="token plain">                    } catch (e: Exception) {</span></div><div class="token-line"><span class="token plain">                        println(e)</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 程序无法退出</span></div></pre></div><p>以上代码会在mutex.lock()、mutex.unlock()之间发生异常，从而导致mutex.unlock()无法被调用。这个时候，整个程序的执行流程就会一直卡住，无法结束。</p><p>所以，为了避免出现这样的问题，我们应该使用Kotlin提供的一个扩展函数：<strong>mutex.withLock<!-- -->{<!-- -->}</strong>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段10</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val mutex = Mutex()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var i = 0</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    // 变化在这里</span></div><div class="token-line"><span class="token plain">                    mutex.withLock {</span></div><div class="token-line"><span class="token plain">                        i++</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $i&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // withLock的定义</span></div><div class="token-line"><span class="token plain">    public suspend inline fun &lt;T&gt; Mutex.withLock(owner: Any? = null, action: () -&gt; T): T {</span></div><div class="token-line"><span class="token plain">        lock(owner)</span></div><div class="token-line"><span class="token plain">        try {</span></div><div class="token-line"><span class="token plain">            return action()</span></div><div class="token-line"><span class="token plain">        } finally {</span></div><div class="token-line"><span class="token plain">            unlock(owner)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>可以看到，withLock<!-- -->{<!-- -->}<!-- --> 的本质，其实是在finally<!-- -->{<!-- -->}<!-- --> 当中调用了unlock()。这样一来，我们就再也不必担心因为异常导致unlock()无法执行的问题了。</p><h3 id="actor"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#actor"><span class="icon icon-link"></span></a>Actor</h3><p>Actor，其实是在很多编程语言当中都存在的一个并发同步模型。在Kotlin当中，也同样存在这样的模型，它本质上是<strong>基于Channel管道消息实现</strong>的。下面我们还是来看一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段11</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    sealed class Msg</span></div><div class="token-line"><span class="token plain">    object AddMsg : Msg()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    class ResultMsg(</span></div><div class="token-line"><span class="token plain">        val result: CompletableDeferred&lt;Int&gt;</span></div><div class="token-line"><span class="token plain">    ) : Msg()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        suspend fun addActor() = actor&lt;Msg&gt; {</span></div><div class="token-line"><span class="token plain">            var counter = 0</span></div><div class="token-line"><span class="token plain">            for (msg in channel) {</span></div><div class="token-line"><span class="token plain">                when (msg) {</span></div><div class="token-line"><span class="token plain">                    is AddMsg -&gt; counter++</span></div><div class="token-line"><span class="token plain">                    is ResultMsg -&gt; msg.result.complete(counter)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val actor = addActor()</span></div><div class="token-line"><span class="token plain">        val jobs = mutableListOf&lt;Job&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val job = launch(Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    actor.send(AddMsg)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            jobs.add(job)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        jobs.joinAll()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val deferred = CompletableDeferred&lt;Int&gt;()</span></div><div class="token-line"><span class="token plain">        actor.send(ResultMsg(deferred))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        val result = deferred.await()</span></div><div class="token-line"><span class="token plain">        actor.close()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = ${result}&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码中，我们定义了addActor()这个挂起函数，而它其实调用了actor()这个高阶函数。而这个函数的返回值类型其实是SendChannel。由此可见，**Kotlin当中的Actor其实就是Channel的简单封装。**Actor的多线程同步能力都源自于Channel。</p><p>这里，我们借助<strong>密封类</strong>定义了两种消息类型，AddMsg、ResultMsg，然后在 <strong>actor<!-- -->{<!-- -->}<!-- --> 内部</strong>，我们处理这两种消息类型，如果我们收到了AddMsg，则计算“i++”；如果收到了ResultMsg，则返回计算结果。</p><p>而在 <strong>actor<!-- -->{<!-- -->}<!-- --> 的外部</strong>，我们则只需要发送10000次的AddMsg消息，最后再发送一次ResultMsg，取回计算结果即可。</p><p>由于Actor的结构比较抽象，这里我做了一个小视频，帮你更好地理解它。</p><p>需要注意的是，虽然在上面的演示视频中，AddMsg、ResultMsg是串行发送的，但实际上，它们是在多线程并行发送的，而Channel可以保证接收到的消息可以同步接收并处理。</p><p>这也就证明了我们前面的说法：Actor本质上是基于Channel管道消息实现的。</p><blockquote><p>补充：Kotlin目前的Actor实现其实还比较简陋，在不远的将来，Kotlin官方会对Actor API进行重构，具体可以参考这个<a target="_blank" rel="noopener noreferrer" href="https://github.com/Kotlin/kotlinx.coroutines/issues/87">链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。虽然它的API可能会改变，但我相信它的核心理念是不会变的。</p></blockquote><p>好，到现在为止，我们已经学习了三种协程并发的思路。不过我们还要反思一个问题：<strong>多线程并发，一定需要同步机制吗？</strong></p><h2 id="反思可变状态"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#反思可变状态"><span class="icon icon-link"></span></a>反思：可变状态</h2><p>前面我们提到过，多线程并发，往往会有共享的可变状态，而共享可变状态的时候，就需要考虑同步问题。</p><p>弄清楚这一点后，我们其实会找到一个新的思路：<strong>避免共享可变状态</strong>。有了这个思路以后，我们的代码其实就非常容易实现了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段12</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val deferreds = mutableListOf&lt;Deferred&lt;Int&gt;&gt;()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(10) {</span></div><div class="token-line"><span class="token plain">            val deferred = async (Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                var i = 0</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                        i++</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                return@async i</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">            deferreds.add(deferred)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        var result = 0</span></div><div class="token-line"><span class="token plain">        deferreds.forEach {</span></div><div class="token-line"><span class="token plain">            result += it.await()</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $result&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在上面的代码中，我们不再共享可变状态i，对应的，在每一个协程当中，都有一个局部的变量i，同时将launch都改为了async，让每一个协程都可以返回计算结果。</p><p>这种方式，相当于将10000次计算，平均分配给了10个协程，让它们各自计算1000次。这样一来，每个协程都可以进行独立的计算，然后我们将10个协程的结果汇总起来，最后累加在一起。</p><p>其实，我们上面的思路，也是借鉴自函数式编程的思想，因为在函数式编程当中，就是追求<strong>不变性、无副作用</strong>。不过，以上代码其实还是命令式的代码，如果我们用函数式风格来重构的话，代码会更加简洁。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码段13</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val result = (1..10).map {</span></div><div class="token-line"><span class="token plain">            async (Dispatchers.Default) {</span></div><div class="token-line"><span class="token plain">                var i = 0</span></div><div class="token-line"><span class="token plain">                repeat(1000) {</span></div><div class="token-line"><span class="token plain">                    i++</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                return@async i</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }.awaitAll()</span></div><div class="token-line"><span class="token plain">            .sum()</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        println(&quot;i = $result&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码中，我们使用函数式风格代码重构了代码段12，我们仍然创建了10个协程，并发了计算了10000次自增操作。</p><p>在加餐一当中，我曾提到过，函数式编程的一大优势就在于，它具有不变性、无副作用的特点，所以<strong>无惧并发编程</strong>。上面的这个代码案例，其实就体现出了Kotlin函数式编程的这个优势。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们学习了Kotlin协程解决并发的两大思路，分别是Java思路、协程思路。要注意，对于Java当中的同步手段，我们并不能直接照搬到Kotlin协程当中来，其中最大的问题，就是 <strong>synchronized不支持挂起函数。</strong></p><p>而对于协程并发手段，我也给你介绍了4种手段，这些你都需要掌握好。</p><ul><li>第一种手段，<strong>单线程并发</strong>，在Java世界里，并发往往意味着多线程，但在Kotlin协程当中，我们可以轻松实现单线程并发，这时候我们就不用担心多线程同步的问题了。</li><li>第二种手段，Kotlin官方提供的协程同步锁，<strong>Mutex</strong>，由于它的lock方法是挂起函数，所以它跟JDK当中的锁不一样，Mutex是非阻塞的。需要注意的是，我们在使用Mutex的时候，应该使用withLock<!-- -->{<!-- -->}<!-- --> 这个高阶函数，而不是直接使用lock()、unlock()。</li><li>第三种手段，Kotlin官方提供的<strong>Actor</strong>，这是一种普遍存在的并发模型。在目前的版本当中，Kotlin的Actor只是Channel的简单封装，它的API会在未来的版本发生改变。</li><li>第四种手段，借助<strong>函数式思维</strong>。我们之所以需要处理多线程同步问题，主要还是因为存在<strong>共享的可变状态</strong>。其实，共享可变状态，既不符合<strong>无副作用</strong>的特性，也不符合<strong>不变性</strong>的特性。当我们借助函数式编程思维，实现无副作用和不变性以后，并发代码也会随之变得安全。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage99c299497ab151d77415c3fd2f5fc2fyy0c2.6777b414.jpg" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>Kotlin提供的Mutex，它会比JDK的锁性能更好吗？为什么？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/04.协程篇/12.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:22:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
