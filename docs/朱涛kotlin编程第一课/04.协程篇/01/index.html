<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>13 | 什么是“协程思维模型”？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/朱涛kotlin编程第一课/04.协程篇/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/01.开篇词/01"><span>开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/01"><span>01 | Kotlin基础语法：正式开启学习之旅</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/02"><span>02 | 面向对象：理解Kotlin设计者的良苦用心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/03"><span>03 | Kotlin原理：编译器在幕后干了哪些“好事”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/04"><span>04 | 实战：构建一个Kotlin版本的四则运算计算器</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/05"><span>05 | object关键字：你到底有多少种用法？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/06"><span>06 | 扩展：你的能力边界到底在哪里？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/07"><span>07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/08"><span>08 | 实战：用Kotlin写一个英语词频统计程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/09"><span>加餐一 | 初识Kotlin函数式编程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/10"><span>09 | 委托：你为何总是被低估？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/11"><span>10 | 泛型：逆变or协变，傻傻分不清？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/12"><span>11 | 注解与反射：进阶必备技能</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/13"><span>12 | 实战：用Kotlin实现一个网络请求框架KtHttp</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/14"><span>加餐二 | 什么是“表达式思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/15"><span>加餐三 | 什么是“不变性思维”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/02.基础篇/16"><span>加餐四 | 什么是“空安全思维”？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送">03.春节特别放送</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/01"><span>春节刷题计划（一）| 当Kotlin遇上LeetCode</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/02"><span>春节刷题计划（二）| 一题三解，搞定版本号判断</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/03"><span>春节刷题计划（三）| 一题双解，搞定求解方程</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/03.春节特别放送/04"><span>春节刷题计划（四）| 一题三解，搞定分式加减法</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/04.协程篇">04.协程篇</a><ul><li><a aria-current="page" class="active" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01"><span>13 | 什么是“协程思维模型”？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/02"><span>14 | 如何启动协程？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/03"><span>15 | 挂起函数：Kotlin协程的核心</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/04"><span>16 | Job：协程也有生命周期吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/05"><span>17 | Context：万物皆为Context？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/06"><span>18 | 实战：让KtHttp支持挂起函数</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/07"><span>期中考试 | 用Kotlin实现图片处理程序</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/08"><span>题目解答 | 期中考试版本参考实现</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/09"><span>19 | Channel：为什么说Channel是“热”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/10"><span>20 | Flow：为什么说Flow是“冷”的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/11"><span>21 | select：到底是在选择什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/12"><span>22 | 并发：协程不需要处理同步吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/13"><span>24 | 实战：让KtHttp支持Flow</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇">05.答疑篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/05.答疑篇/01"><span>答疑（一）| Java和Kotlin到底谁好谁坏？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇">06.源码篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/01"><span>25 | 集合操作符：你也会“看完就忘”吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/02"><span>26 | 协程源码的地图：如何读源码才不会迷失？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/03"><span>27 | 图解挂起函数：原来你就是个状态机？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/04"><span>加餐五 | 深入理解协程基础元素</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/05"><span>28 | launch的背后到底发生了什么？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/06"><span>29 | Dispatchers是如何工作的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/07"><span>30 | CoroutineScope是如何管理协程的？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/08"><span>31 | 图解Channel：如何理解它的CSP通信模型？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/06.源码篇/09"><span>32 | 图解Flow：原来你是只纸老虎？</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇">07.Android项目篇</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/01"><span>33 | Java Android开发者还会有未来吗？</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/02"><span>34 | Kotlin与Jetpack简直是天生一对！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/07.android项目篇/03"><span>35 | 用Kotlin写一个GitHub Trending App</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语">08.结束语</a><ul><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/01"><span>结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！</span></a></li><li><a href="/blog-base/朱涛kotlin编程第一课/08.结束语/02"><span>结束语 | 不忘初心</span></a></li></ul></li><li><a href="/blog-base/朱涛kotlin编程第一课/summary">朱涛kotlin编程第一课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="为什么协程如此重要？" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#为什么协程如此重要"><span>为什么协程如此重要？</span></a></li><li title="什么是协程？" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#什么是协程"><span>什么是协程？</span></a></li><li title="如何理解Kotlin的协程？" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#如何理解kotlin的协程"><span>如何理解Kotlin的协程？</span></a></li><li title="协程的轻量" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#协程的轻量"><span>协程的轻量</span></a></li><li title="协程的“非阻塞”" data-depth="3"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#协程的非阻塞"><span>协程的“非阻塞”</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13--什么是协程思维模型"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#13--什么是协程思维模型"><span class="icon icon-link"></span></a>13 | 什么是“协程思维模型”？</h1><p>你好，我是朱涛。</p><p>学完基础篇以后，相信现在你对Kotlin的基础语法和特性都有了全面的认识。那么从今天开始，我们就要进入一个新的模块，一起来学习Kotlin当中<strong>最重要、最难学</strong>，也是最受期待的特性——协程。</p><h2 id="为什么协程如此重要"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#为什么协程如此重要"><span class="icon icon-link"></span></a>为什么协程如此重要？</h2><p><strong>协程是Kotlin对比Java的最大优势</strong>，这也是我说协程是Kotlin中最重要特性的主要原因。虽说Java也在计划着实现自己的协程：<a target="_blank" rel="noopener noreferrer" href="https://openjdk.java.net/projects/loom/">Loom<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，不过这个毕竟还处于相当初级的阶段。而Kotlin的协程，可以帮我们极大地<strong>简化异步、并发编程、优化软件架构</strong>。通过协程，我们不仅可以提高开发效率，还能提高代码的可读性，由此也就可以降低代码出错的概率。</p><p>不过，遗憾的是，Kotlin协程在业界的普及率并不高。因为，你如果对协程没有足够的认识，贸然在生产环境里使用协程，一定会遇到各种各样的问题，并要为之付出昂贵的代价（典型的反面例子就是滥用GlobalScope，导致大量的计算资源浪费以及出现生命周期错乱的问题）。</p><p>Kotlin的协程就是这样，表面上看，它的语法很简单，但行为模式却让人难以捉摸。举个简单的例子，同样是5行代码，普通的程序，这5行代码的运行顺序一般会是1、2、3、4、5；但对于协程来说，代码执行顺序可能会是1、4、5、3、2这样错乱的。如果我们不能在脑子里建立协程的思维模型，那我们将很难理解协程的行为模式。</p><p>所以说，协程也是一个典型的“<strong>易学难精</strong>”的框架。</p><p>如果你之前尝试过自学Kotlin协程，你一定会跟我有相似的体会：要记住协程的几个API很容易，困难的是形成一套完整的协程知识体系。不过，我想告诉你的是：形成知识体系也不算什么，更难的是建立一个具体的协程思维模型，来辅助自己理解协程背后的运行机制；甚至，建立协程思维模型也没什么了不起，更难的是理解协程背后的设计理念。</p><p>换句话说，如果我们能站在Kotlin协程设计者的角度，去评判、欣赏它背后的设计理念，并且能体会到协程设计的精妙之处，那才算是达到了最高的境界。</p><p>那么，学习Kotlin协程，到底意味着什么呢？</p><p>其实，学习协程，相当于一次<strong>编程思维的升级</strong>。协程思维，它与我们常见的线程思维迥然不同，当我们能够用协程的思维来分析问题以后，<strong>线程当中某些棘手的问题在协程面前都会变成小菜一碟</strong>。因此，我们相当于多了一种解决问题的手段。</p><p>另外，学习Kotlin协程，也相当于为我们打开了一扇新世界的大门，当我们对Kotlin协程有了透彻的认识以后，再去看C#、Python、Dart、JS、Golang、Rust、C++20、Java Loom当中的“类协程”概念，就会觉得无比亲切。这时候我们就会发现：<strong>原来协程的世界是如此广阔</strong>。</p><p>到这里，相信你已经认识到了Kotlin协程的重要性，也知道了学习协程的好处了。</p><p>不过，在正式开始学习Kotlin协程之前，我想先给你打一剂“预防针”：这个部分的学习难度会比前面基础篇更大，虽然我还是会尽量用简单直白的方式来向你介绍协程，但由于它本身是一种颠覆性的技术，因此，刚开始肯定是会有些难以接受的。在这里，我也建议你在遇到问题的时候多思考，并去反复琢磨和理解课程当中的知识点与示例代码。</p><p>好，接下来，我们先来了解一下协程的发展史，这会有助于我们理解协程到底是个什么东西。</p><h2 id="什么是协程"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#什么是协程"><span class="icon icon-link"></span></a>什么是协程？</h2><p>Kotlin的协程，是2017年初在1.1版本加入进来的，那时协程还只是实验性的（Experimental）；等到2018年底，Kotlin更新到1.3版本的时候，协程才成为Kotlin的正式特性；接着又过了一年，到2019年Kotlin协程才推出Flow相关的API。我们常说Kotlin是一门年轻的语言，那么Kotlin协程这个特性，就更加显得年轻了。毕竟从它正式推出到现在，也才三年多。</p><p>虽然Kotlin协程很年轻，但“协程”这个概念本身并不年轻。早在1967年的 <a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/Simula">Simula语言<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当中，就已经出现了协程。不过，在之后的几十年里，协程并没有被推广开，后续涌现出的C、C++、Java之类的语言，更多的是使用线程来进行异步和并发。直到2012年左右，C#重新拾起了协程这个特性，实现了async、await、yield。之后，JavaScript、Python、Kotlin等语言才继续跟进实现了对应的协程。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage554e5570b21ba1cd63103ae5bfaf579a434e.jpg" alt=""/></p><p>很多人在刚开始接触协程的时候，都觉得协程很难学，因为从学校一路学习C、Java过来以后，我们只知道线程是什么，对协程根本没有任何概念。</p><p>其实，如果要用简单的语言来描述协程的话，我们可以将其称为：“互相<strong>协</strong>作的<strong>程</strong>序”。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage126a121f70df4206972e88de427ef5157f6a.jpg" alt=""/></p><p>为了帮你弄清楚普通的程序（Routine）与协程（Coroutine）之间的差异，我们来看一个具体的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() {</span></div><div class="token-line"><span class="token plain">        val list = getList()</span></div><div class="token-line"><span class="token plain">        printList(list)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun getList(): List&lt;Int&gt; {</span></div><div class="token-line"><span class="token plain">        val list = mutableListOf&lt;Int&gt;()</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 1&quot;)</span></div><div class="token-line"><span class="token plain">        list.add(1)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 2&quot;)</span></div><div class="token-line"><span class="token plain">        list.add(2)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 3&quot;)</span></div><div class="token-line"><span class="token plain">        list.add(3)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 4&quot;)</span></div><div class="token-line"><span class="token plain">        list.add(4)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return list</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun printList(list: List&lt;Int&gt;) {</span></div><div class="token-line"><span class="token plain">        val i = list[0]</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$i&quot;)</span></div><div class="token-line"><span class="token plain">        val j = list[1]</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$j&quot;)</span></div><div class="token-line"><span class="token plain">        val k = list[2]</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$k&quot;)</span></div><div class="token-line"><span class="token plain">        val m = list[3]</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$m&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 运行结果：</span></div><div class="token-line"><span class="token plain">    Add 1</span></div><div class="token-line"><span class="token plain">    Add 2</span></div><div class="token-line"><span class="token plain">    Add 3</span></div><div class="token-line"><span class="token plain">    Add 4</span></div><div class="token-line"><span class="token plain">    Get1</span></div><div class="token-line"><span class="token plain">    Get2</span></div><div class="token-line"><span class="token plain">    Get3</span></div><div class="token-line"><span class="token plain">    Get4</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>以上代码非常简单，程序会先运行getList()，然后再运行printList()。从运行的结果我们可以看出来，程序是按照顺序执行的，这没什么特别的。这就是一个典型的<strong>普通程序</strong>的例子。</p><p>下面让我们来看一个<strong>协程</strong>的例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val sequence = getSequence()</span></div><div class="token-line"><span class="token plain">        printSequence(sequence)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun getSequence() = sequence {</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 1&quot;)</span></div><div class="token-line"><span class="token plain">        yield(1)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 2&quot;)</span></div><div class="token-line"><span class="token plain">        yield(2)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 3&quot;)</span></div><div class="token-line"><span class="token plain">        yield(3)</span></div><div class="token-line"><span class="token plain">        println(&quot;Add 4&quot;)</span></div><div class="token-line"><span class="token plain">        yield(4)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun printSequence(sequence: Sequence&lt;Int&gt;) {</span></div><div class="token-line"><span class="token plain">        val iterator = sequence.iterator()</span></div><div class="token-line"><span class="token plain">        val i = iterator.next()</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$i&quot;)</span></div><div class="token-line"><span class="token plain">        val j = iterator.next()</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$j&quot;)</span></div><div class="token-line"><span class="token plain">        val k = iterator.next()</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$k&quot;)</span></div><div class="token-line"><span class="token plain">        val m = iterator.next()</span></div><div class="token-line"><span class="token plain">        println(&quot;Get$m&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Add 1</span></div><div class="token-line"><span class="token plain">    Get1</span></div><div class="token-line"><span class="token plain">    Add 2</span></div><div class="token-line"><span class="token plain">    Get2</span></div><div class="token-line"><span class="token plain">    Add 3</span></div><div class="token-line"><span class="token plain">    Get3</span></div><div class="token-line"><span class="token plain">    Add 4</span></div><div class="token-line"><span class="token plain">    Get4</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>这段代码做的事情和前面的代码其实差不多，只是我们是借助了Kotlin当中的Sequence来实现的。这次，我们从程序的运行结果会发现，getSequence()与printSequence()这两个函数，它们是交替执行的。为了方便你理解，我用一张图来描述它们之间的调用顺序。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea32ca3caffed1ced7663c0595c9ce2800a2c.png" alt="图片"/></p><p>这段程序，给人的感觉就像是两位彬彬有礼的绅士，每个人执行一会代码以后，就会<strong>让出执行权</strong>给对方，让对方执行一会。这样的运行模式，就好像两个人在<strong>协作</strong>一样。</p><p>而对应的，前面的getList()和printList()的执行流程则完全不一样，getList()执行完以后，才会轮到printList()来执行。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea17da1052f9ce56bb228e82da4cc4218137d.png" alt="图片"/></p><p>这两种迥然不同的代码运行方式，其实就是协程与普通程序之间最大的差异。</p><ul><li>普通程序在被调用以后，只会在末尾的地方返回，并且只会返回一次，比如前面的getList()函数；而协程则不受此限制，协程的代码可以在任意yield的地方挂起（Suspend）让出执行权，然后等到合适的时机再恢复（Resume）。在这个情况下，yield是代表了“让步”的意思。</li><li>普通程序需要一次性收集完所有的值，然后统一返回；而协程则可以每次只返回（yield）一个值，比如我们前面写的getSequence()方法。在这个情况下，yield既有“让步”的意思，也有“<strong>产出</strong>”的意思。它不仅能让出执行权，还同时产生一个值，比如前面的yield(1)，就代表产出的值为1。</li></ul><p>除了yield以外，我们也可以借助Kotlin协程当中的Channel来实现类似的代码模式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        val channel = getProducer(this)</span></div><div class="token-line"><span class="token plain">        testConsumer(channel)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    fun getProducer(scope: CoroutineScope) = scope.produce {</span></div><div class="token-line"><span class="token plain">        println(&quot;Send:1&quot;)</span></div><div class="token-line"><span class="token plain">        send(1)</span></div><div class="token-line"><span class="token plain">        println(&quot;Send:2&quot;)</span></div><div class="token-line"><span class="token plain">        send(2)</span></div><div class="token-line"><span class="token plain">        println(&quot;Send:3&quot;)</span></div><div class="token-line"><span class="token plain">        send(3)</span></div><div class="token-line"><span class="token plain">        println(&quot;Send:4&quot;)</span></div><div class="token-line"><span class="token plain">        send(4)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    suspend fun testConsumer(channel: ReceiveChannel&lt;Int&gt;) {</span></div><div class="token-line"><span class="token plain">        delay(100)</span></div><div class="token-line"><span class="token plain">        val i = channel.receive()</span></div><div class="token-line"><span class="token plain">        println(&quot;Receive$i&quot;)</span></div><div class="token-line"><span class="token plain">        delay(100)</span></div><div class="token-line"><span class="token plain">        val j = channel.receive()</span></div><div class="token-line"><span class="token plain">        println(&quot;Receive$j&quot;)</span></div><div class="token-line"><span class="token plain">        delay(100)</span></div><div class="token-line"><span class="token plain">        val k = channel.receive()</span></div><div class="token-line"><span class="token plain">        println(&quot;Receive$k&quot;)</span></div><div class="token-line"><span class="token plain">        delay(100)</span></div><div class="token-line"><span class="token plain">        val m = channel.receive()</span></div><div class="token-line"><span class="token plain">        println(&quot;Receive$m&quot;)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Send:1</span></div><div class="token-line"><span class="token plain">    Receive1</span></div><div class="token-line"><span class="token plain">    Send:2</span></div><div class="token-line"><span class="token plain">    Receive2</span></div><div class="token-line"><span class="token plain">    Send:3</span></div><div class="token-line"><span class="token plain">    Receive3</span></div><div class="token-line"><span class="token plain">    Send:4</span></div><div class="token-line"><span class="token plain">    Receive4</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>可见，以上代码中的getProducer()和testConsumer()之间，它们也是交替执行的。</p><p>所以，**从广义上来讲，协程就代表了“互相协作的程序”。**这样的标准，几乎适用于所有语言的协程。不管是Python的协程还是C#的协程，还是其他语言的协程，它们都是以这样的模式来实现的。而且，很多语言的协程都支持yield。理解了这一点以后，将来不管你是遇到Python的协程，还是其他语言的协程也好，相信你也可以很快地把Kotlin协程当中的概念迁移过去。</p><p>聊完广义的协程以后，我们再来看看Kotlin协程的另外两个概念：协程、协程框架。<strong>注意</strong>，这是两个不一样的概念，前者是代表了程序当中被创建的协程；后者，则是一个整体的框架。</p><h2 id="如何理解kotlin的协程"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#如何理解kotlin的协程"><span class="icon icon-link"></span></a>如何理解Kotlin的协程？</h2><p>在Kotlin当中，协程是一个独立的框架。跟Kotlin的反射库类似，协程并不是直接集成在标准库当中的。如果我们想要使用Kotlin的协程，就必须手动进行依赖：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">implementation &#x27;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0&#x27;</span></div></pre></div><p>Kotlin官方之所以将协程作为一个单独的框架独立出来，也是为了减小标准库的体积，给开发者更多的灵活性。另外，Kotlin协程框架也是开源的，我们可以去GitHub上去浏览它的<a target="_blank" rel="noopener noreferrer" href="https://github.com/Kotlin/kotlinx.coroutines">源代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。在这里，我们可以找到许多前沿的信息，也可以跟世界顶级的开发者交流。</p><p>业界一直有一种说法：<strong>Kotlin协程其实就是一个封装的线程框架</strong>。如果我们站在框架的层面来看的话，这种说法也有一定道理：协程框架将线程池进一步封装，对开发者暴露出统一的协程API。</p><p>不过，这种说法无法解释另一个语境下的问题，让我们来看一个代码例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码中一共启动了两个线程</span></div><div class="token-line"><span class="token plain">    fun main() {</span></div><div class="token-line"><span class="token plain">        println(Thread.currentThread().name)</span></div><div class="token-line"><span class="token plain">        thread {</span></div><div class="token-line"><span class="token plain">            println(Thread.currentThread().name)</span></div><div class="token-line"><span class="token plain">            Thread.sleep(100)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        Thread.sleep(1000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    main</span></div><div class="token-line"><span class="token plain">    Thread-0</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>上面这段代码的逻辑很简单，就是在main函数当中启动了一个新的线程。“代码中一共启动了两个线程”，这句话的意思也很容易理解：main()函数本身会启动一个主线程main，然后在 <code>thread<!-- -->{<!-- -->}</code> 当中，又启动了一个新的线程“Thread-0”。所以，以上代码一共会启动两个线程。这没什么问题，关键是下一个例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 代码中一共启动了两个协程</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        println(Thread.currentThread().name)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            println(Thread.currentThread().name)</span></div><div class="token-line"><span class="token plain">            delay(100L)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Thread.sleep(1000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    main @coroutine#1</span></div><div class="token-line"><span class="token plain">    main @coroutine#2</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    这里要配置特殊的VM参数：-Dkotlinx.coroutines.debug</span></div><div class="token-line"><span class="token plain">    这样一来，Thread.currentThread().name就能会包含：协程的名字@coroutine#1</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在这段代码的注释当中，有这样一句话：<strong>代码中一共启动了两个协程</strong>。请问，这个语境下的“两个协程”，到底是什么？通过程序的输出结果，我们可以看到，main函数当中出现了两个协程，一个是“coroutine#1”，一个是“coroutine#2”。</p><p>那么，这里的“协程”，到底是什么呢？它看起来好像跟Java的线程有点类似，但又好像是两个完全不一样的东西。这其实就是很多初学者会困扰的地方。</p><p>Kotlin的协程，它要比线程更加抽象，因为Java的线程，我们起码可以找到Thread的源代码，同时，线程也是操作系统当中的一个概念，所以理解起来并不困难。而Kotlin的协程则没有类似的知识点可以建立关联。所以，我自己在学习Kotlin协程的时候，做法就是建立起<strong>协程的思维模型</strong>（Mental Model）。</p><p>很多人可能不太理解思维模型到底是什么，它在有些语境下，也被称为<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B">心智模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。人为了理解真实世界的运作规律，会自然而然地在脑子里建立起对应的模型。举个例子，我们为了理解公司内部的组织架构，经常会在脑子里建立一个类似这样的树状思维模型：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage38a138d10ff8262caacae94733d77a6f88a1.jpg" alt=""/></p><p>那么，我们该如何为Kotlin的协程建立思维模型呢？其实，Kotlin的协程，我们可以将其想象成一个“更加轻量的线程”。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagedf62dfab62d3f0c8558de5768e359fcb0462.png" alt="图片"/></p><p>从包含关系上看，协程跟线程的关系，有点像线程与进程的关系，毕竟协程不可能脱离线程运行。所以，协程可以理解为<strong>运行在线程当中的、更加轻量的Task</strong>。</p><h3 id="协程的轻量"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#协程的轻量"><span class="icon icon-link"></span></a>协程的轻量</h3><p>那么，协程的轻量，到底意味着什么呢？我们可以先来看一段这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 仅用作研究，工作中别这么写</span></div><div class="token-line"><span class="token plain">    fun main() {</span></div><div class="token-line"><span class="token plain">        repeat(1000_000_000) {</span></div><div class="token-line"><span class="token plain">            thread {</span></div><div class="token-line"><span class="token plain">                Thread.sleep(1000000)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        Thread.sleep(10000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span></div><div class="token-line"><span class="token plain">        at java.lang.Thread.start0(Native Method)</span></div><div class="token-line"><span class="token plain">        at java.lang.Thread.start(Thread.java:717)</span></div><div class="token-line"><span class="token plain">        at kotlin.concurrent.ThreadsKt.thread(Thread.kt:42)</span></div><div class="token-line"><span class="token plain">        at kotlin.concurrent.ThreadsKt.thread$default(Thread.kt:20)</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在上面的代码中，我们尝试启动10亿个线程，这样的代码运行在大部分的机器上都是会因为内存不足等原因而异常退出的。而如果我们将代码改用协程来实现的话，结果会怎样呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 仅用作研究，工作中别这么写</span></div><div class="token-line"><span class="token plain">    fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        repeat(1000_000_000) {</span></div><div class="token-line"><span class="token plain">            launch {</span></div><div class="token-line"><span class="token plain">                delay(1000000)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        delay(10000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    运行结果：</span></div><div class="token-line"><span class="token plain">    正常</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在这段代码中，我们启动了10亿个协程。由于协程是非常轻量的，所以代码不会因为内存不足而异常退出。</p><blockquote><p>注意：虽然协程非常轻量，但在工作当中，我们也应该尽量避免写出类似上面这样的代码。</p></blockquote><p>另外，协程虽然运行在线程之上，但协程并不会和某个线程绑定，在某些情况下，协程是可以在不同的线程之间切换的。我们可以来看看下面的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() = runBlocking(Dispatchers.IO) {</span></div><div class="token-line"><span class="token plain">        repeat(3) {</span></div><div class="token-line"><span class="token plain">            launch {</span></div><div class="token-line"><span class="token plain">                repeat(3) {</span></div><div class="token-line"><span class="token plain">                    println(Thread.currentThread().name)</span></div><div class="token-line"><span class="token plain">                    delay(100)</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        delay(5000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-3 @coroutine#2</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-2 @coroutine#3</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-4 @coroutine#4</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-1 @coroutine#2 // 线程切换了</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-4 @coroutine#4</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-2 @coroutine#3</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-2 @coroutine#2 // 线程切换了</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-1 @coroutine#4</span></div><div class="token-line"><span class="token plain">    DefaultDispatcher-worker-4 @coroutine#3</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>以上代码的运行结果是随机的，这里以我运行的结果来分析的话，可以看到，“coroutine#2”的三次执行，每一次都在不同的线程上。第一次，它在“worker-3”执行，第二次在“worker-1”执行，第三次在“worker-2”执行。</p><p>这时候，我们就可以进一步更新脑海中的思维模型了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimaged8a9d89e8744663d45635a5125829a9037a9.gif" alt="图片"/></p><p>让我们来做个小结：</p><ul><li>协程，可以理解为更加轻量的线程，成千上万个协程可以同时运行在一个线程当中；</li><li>协程，其实是运行在线程当中的轻量的Task；</li><li>协程，不会与特定的线程绑定，它可以在不同的线程之间灵活切换。</li></ul><h3 id="协程的非阻塞"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#协程的非阻塞"><span class="icon icon-link"></span></a>协程的“非阻塞”</h3><p>另外，协程对比线程还有一个特点，那就是<strong>非阻塞</strong>（Non Blocking），而线程则往往是阻塞式的。这个概念有点抽象，我们来看个具体的例子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() {</span></div><div class="token-line"><span class="token plain">        repeat(3) {</span></div><div class="token-line"><span class="token plain">            Thread.sleep(1000L)</span></div><div class="token-line"><span class="token plain">            println(&quot;Print-1:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        repeat(3) {</span></div><div class="token-line"><span class="token plain">            Thread.sleep(900L)</span></div><div class="token-line"><span class="token plain">            println(&quot;Print-2:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Print-1:main</span></div><div class="token-line"><span class="token plain">    Print-1:main</span></div><div class="token-line"><span class="token plain">    Print-1:main</span></div><div class="token-line"><span class="token plain">    Print-2:main</span></div><div class="token-line"><span class="token plain">    Print-2:main</span></div><div class="token-line"><span class="token plain">    Print-2:main</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在上面的代码里有两个repeat，第一个repeat当中，我们每次调用sleep()方法，让线程休眠1秒钟，而第二个repeat当中，我们每次只休眠0.9秒。由于线程的sleep()方法是阻塞式的，所以程序的执行流程是线性的。也就是说，“Print-1”会连续输出三次，然后“Print-2”会连续输出三次。即使Print-2休眠的时间更短。</p><p>让我们来看看协程代码的表现有哪些不一样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                delay(1000L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-1:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                delay(900L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-2:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        delay(3000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>在上面的代码中，我们用协程实现了类似的逻辑，但这次的执行结果却完全不一样。可以看到，Print-2和Print-1是交替输出的，“coroutine#2”、“coroutine#3”这两个协程是并行的（Concurrent）。同时，由于协程的delay()方法是非阻塞的，所以，即使Print-1会先执行delay(1000L)，但它也并不会阻塞Print-2的delay(900L)的运行。</p><p>而如果我们将代码中的delay修改成sleep，程序的运行结果就会不一样。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                Thread.sleep(1000L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-1:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                Thread.sleep(900L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-2:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        delay(3000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><p>由此可见，Kotlin协程的“非阻塞”其实<strong>只是语言层面</strong>的，当我们调用JVM层面的Thread.sleep()的时候，它仍然会变成阻塞式的。与此同时，这也意味着我们在协程当中应该尽量避免出现阻塞式的行为。尽量使用delay，而不是sleep。</p><p>那么，我们该如何理解Kotlin协程的“非阻塞”？答案是：<strong>挂起和恢复</strong>。这两个能力也是协程才拥有的特殊能力，普通的程序是不具备的。</p><p>挂起和恢复，初学者看到这两个概念可能会比较陌生。它俩的字面意思我们都能看懂，但当发生在程序世界里之后，就无法理解了，因为我们根本就看不见，也摸不着。那怎么办呢？</p><p>我的做法还是：<strong>建立思维模型</strong>。</p><p>对于执行在普通线程当中的程序来说，如果我们站在CPU的角度上看，最终它会以类似这样的方式执行：</p><p><img src="/images/httpsstatic001geekbangorgresourceimageddbcdd4cfa1246e6141262a9de48d31dbcbc.gif" alt="图片"/></p><p>这时候，当某个任务发生了阻塞行为的时候，比如sleep，当前执行的Task就会阻塞后面所有任务的执行。就像下面这张动图所展示的一样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagee841e862e19363f44c56a01709643791ee41.gif" alt="图片"/></p><p><strong>那么，协程是如何通过挂起和恢复来实现非阻塞的呢？</strong></p><p>大部分的语言当中都会存在一个类似“调度中心”的东西，它会来实现Task任务的执行和调度。如下图所示：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagef2f9f28fa6fb2ba6d147de33ccb649969cf9.png" alt="图片"/></p><p>而协程除了拥有“调度中心”以外，对于每个协程的Task，还会多出一个类似“抓手”“挂钩”的东西，可以方便我们对它进行“挂起和恢复”。协程任务的总体执行流程，大致会像下图描述的这样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage502650ayycf2b8d015cf8cef7dcde541ae26.gif" alt="图片"/></p><p>通过对比可以看出，线程的sleep之所以是阻塞式的，是因为它会阻挡后续Task的执行。而协程之所以是非阻塞式的，是因为它可以支持挂起和恢复。当Task由于某种原因被挂起后，后续的Task并不会因此被阻塞。</p><p>这时候，如果我们回过头再来看之前的代码，相信也会有新的体会：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">fun main() = runBlocking {</span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                delay(1000L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-1:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        launch {</span></div><div class="token-line"><span class="token plain">            repeat(3) {</span></div><div class="token-line"><span class="token plain">                delay(900L)</span></div><div class="token-line"><span class="token plain">                println(&quot;Print-2:${Thread.currentThread().name}&quot;)</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        delay(3000L)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /*</span></div><div class="token-line"><span class="token plain">    输出结果：</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    Print-2:main @coroutine#3</span></div><div class="token-line"><span class="token plain">    Print-1:main @coroutine#2</span></div><div class="token-line"><span class="token plain">    */</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#小结"><span class="icon icon-link"></span></a>小结</h2><p>好了，到这里，我们今天的内容就差不多结束了。这节课我并没有给你介绍任何具体的协程API，而是先带你建立协程的思维模型，目的就是让你在这个过程中，真正理解协程的核心概念，并建立起一个清晰的认知，从而为后面API的学习打下基础。毕竟，磨刀不误砍柴工嘛！</p><p>那么在学完这节课之后，你也需要掌握以下几个要点：</p><ul><li>广义的协程，可以理解为“互相协作的程序”，也就是“Cooperative-routine”。</li><li>协程框架，是独立于Kotlin标准库的一套框架，它封装了Java的线程，对开发者暴露了协程的API。</li><li>程序当中运行的“协程”，可以理解为<strong>轻量的线程</strong>；</li><li>一个线程当中，可以运行成千上万个协程；</li><li>协程，也可以理解为运行在线程当中的<strong>非阻塞的Task</strong>；</li><li>协程，通过<strong>挂起和恢复</strong>的能力，实现了“非阻塞”；</li><li>协程不会与特定的线程绑定，它可以在不同的线程之间灵活切换，而这其实也是通过“挂起和恢复”来实现的。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimagebd9dbd90de594f1209631cec647a876eee9d.jpg" alt=""/></p><p>说实话，学习协程，真的不是一件容易的事情。如果这节课我不介绍协程的思维模型，一上来就介绍协程的API，你一定会觉得云里雾里、找不着方向。所以，也请你不要轻视这节课的重要性，一定要充分理解本节课的内容，再去学习后面的知识点。</p><p>下节课开始，我会正式介绍Kotlin协程相关的API，同时，也会进一步完善我们的协程思维模型。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/朱涛kotlin编程第一课/04.协程篇/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>有人说：协程会比线程更加高效，请问你认同这种说法吗？为什么？ 欢迎在留言区分享你的看法和见解，也欢迎你把今天的内容分享给更多的朋友，我们一起交流探讨。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/朱涛kotlin编程第一课/04.协程篇/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:46:10</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
