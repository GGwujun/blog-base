<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>31 | 内存计算：对海量数据做计算，到底可以有多快？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理之美/08.实现一门编译型语言·应用篇/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a aria-current="page" class="active" href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a aria-current="page" class="active" href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理之美/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/编译原理之美/01.开篇词/01"><span>开篇词 | 为什么你要学习编译原理？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇">02.实现一门脚本语言·原理篇</a><ul><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/01"><span>01 | 理解代码：编译器的前端技术</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/02"><span>02 | 正则文法和有限自动机：纯手工打造词法分析器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/03"><span>03 | 语法分析（一）：纯手工打造公式计算器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/04"><span>04 | 语法分析（二）：解决二元表达式中的难点</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/05"><span>05 | 语法分析（三）：实现一门简单的脚本语言</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/06"><span>06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/07"><span>07 | 编译器前端工具（二）：用Antlr重构脚本语言</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/08"><span>08 | 作用域和生存期：实现块作用域和函数</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09"><span>09 | 面向对象：实现数据和方法的封装</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/10"><span>10 | 闭包： 理解了原理，它就不反直觉了</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/11"><span>11 | 语义分析（上）：如何建立一个完善的类型系统？</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/12"><span>12 | 语义分析（下）：如何做上下文相关情况的处理？</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/13"><span>13 | 继承和多态：面向对象运行期的动态特性</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇">03.实现一门脚本语言·应用篇</a><ul><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇/01"><span>14 | 前端技术应用（一）：如何透明地支持数据库分库分表？</span></a></li><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇/02"><span>15 | 前端技术应用（二）：如何设计一个报表工具？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇">04.实现一门脚本语言·算法篇</a><ul><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/01"><span>16 | NFA和DFA：如何自己实现一个正则表达式工具？</span></a></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/02"><span>17 | First和Follow集合：用LL算法推演一个实例</span></a></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/03"><span>18 | 移进和规约：用LR算法推演一个实例</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事">05.实现一门脚本语言·热点答疑与用户故事</a><ul><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/01"><span>19 | 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？</span></a></li><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/02"><span>用户故事 | 因为热爱，所以坚持</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/06.编译原理·期中考试周">06.编译原理·期中考试周</a><ul><li><a href="/blog-base/编译原理之美/06.编译原理·期中考试周/01"><span>期中考试 |  来赴一场100分的约定吧！</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇">07.实现一门编译型语言·原理篇</a><ul><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/01"><span>20 | 高效运行：编译器的后端技术</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/02"><span>21 | 运行时机制：突破现象看本质，透过语法看运行时</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/03"><span>22 | 生成汇编代码（一）：汇编语言其实不难学</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/04"><span>加餐 | 汇编代码编程与栈帧管理</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/05"><span>23 | 生成汇编代码（二）：把脚本编译成可执行文件</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/06"><span>24 | 中间代码：兼容不同的语言和硬件</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/07"><span>25 | 后端技术的重用：LLVM不仅仅让你高效</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/08"><span>26 | 生成IR：实现静态编译的语言</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/09"><span>27 | 代码优化：为什么你的代码比他的更高效？</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/10"><span>28 | 数据流分析：你写的程序，它更懂</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/11"><span>29 | 目标代码的生成和优化（一）：如何适应各种硬件架构？</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/12"><span>30 | 目标代码的生成和优化（二）：如何适应各种硬件架构？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇">08.实现一门编译型语言·应用篇</a><ul><li><a aria-current="page" class="active" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01"><span>31 | 内存计算：对海量数据做计算，到底可以有多快？</span></a></li><li><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/02"><span>32 | 字节码生成：为什么Spring技术很强大？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇">09.实现一门编译型语言·扩展篇</a><ul><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/01"><span>33 | 垃圾收集：能否不停下整个世界？</span></a></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/02"><span>34 | 运行时优化：即时编译的原理和作用</span></a></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/03"><span>35 | 案例总结与热点问题答疑：后端部分真的比前端部分难吗？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言">10.面向未来的编程语言</a><ul><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/01"><span>36 | 当前技术的发展趋势以及其对编译技术的影响</span></a></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/02"><span>37  | 云编程：云计算会如何改变编程模式？</span></a></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/03"><span>38 | 元编程：一边写程序，一边写语言</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/11.结束语">11.结束语</a><ul><li><a href="/blog-base/编译原理之美/11.结束语/01"><span>结束语 | 用程序语言，推动这个世界的演化</span></a></li><li><a href="/blog-base/编译原理之美/11.结束语/02"><span>第二季回归 | 这次，我们一起实战解析真实世界的编译器</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/12.结课测试">12.结课测试</a><ul><li><a href="/blog-base/编译原理之美/12.结课测试/01"><span>结课测试 | 编译原理的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/summary">编译原理之美</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="了解SIMD" data-depth="2"><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#了解simd"><span>了解SIMD</span></a></li><li title="LLVM的自动矢量化功能（Auto-Vectorization）" data-depth="2"><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#llvm的自动矢量化功能auto-vectorization"><span>LLVM的自动矢量化功能（Auto-Vectorization）</span></a></li><li title="高速缓存和局部性" data-depth="2"><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#高速缓存和局部性"><span>高速缓存和局部性</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#一课一思"><span>一课一思</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="31--内存计算对海量数据做计算到底可以有多快"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#31--内存计算对海量数据做计算到底可以有多快"><span class="icon icon-link"></span></a>31 | 内存计算：对海量数据做计算，到底可以有多快？</h1><p>内存计算是近十几年来，在数据库和大数据领域的一个热点。随着内存越来越便宜，CPU的架构越来越先进，整个数据库都可以放在内存中，并通过SIMD和并行计算技术，来提升数据处理的性能。</p><p>**我问你一个问题：**做1.6亿条数据的汇总计算，需要花费多少时间呢？几秒？几十秒？还是几分钟？如果你经常使用数据库，肯定会知道，我们不会在数据库的一张表中保存上亿条的数据，因为处理速度会很慢。</p><p>但今天，我会带你采用内存计算技术，提高海量数据处理工作的性能。与此同时，我还会介绍SIMD指令、高速缓存和局部性、动态优化等知识点。这些知识点与编译器后端技术息息相关，掌握这些内容，会对你从事基础软件研发工作，有很大的帮助。</p><h2 id="了解simd"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#了解simd"><span class="icon icon-link"></span></a>了解SIMD</h2><p>本节课所采用的CPU，支持一类叫做SIMD（Single Instruction Multiple Data）的指令，**它的字面意思是：**单条指令能处理多个数据。相应的，你可以把每次只处理一个数据的指令，叫做SISD（Single Instruction Single Data）。</p><p>SISD使用普通的寄存器进行操作，比如加法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">addl $10, %eax</span></div></pre></div><p>这行代码是把一个32位的整型数字，加到%eax寄存器上（在x86-64架构下，这个寄存器一共有64位，但这个指令只用它的低32位，高32位是闲置的）。</p><p>这种一次只处理一个数据的计算，**叫做标量计算；**一次可以同时处理多个数据的计算，**叫做矢量计算。**它在一个寄存器里可以并排摆下4个、8个甚至更多标量，构成一个矢量。图中ymm寄存器是256位的，可以支持同时做4个64位数的计算（xmm寄存器是它的低128位）。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagee057e0b3f9d6a0726021f224b1b7910e9257.c43c314b.png" alt=""/></p><p>如果不做64位整数，而做32位整数计算，一次能计算8个，如果做单字节（8位）数字的计算，一次可以算32个！</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage6146612e429fe459db3d80e13970e4194046.ddefdc5b.png" alt=""/></p><p>1997年，Intel公司推出了奔腾处理器，带有MMX指令集，意思是多媒体扩展。当时，让计算机能够播放多媒体（比如播放视频），是一个巨大的进步。但播放视频需要大量的浮点计算，依靠原来CPU的浮点运算功能并不够。</p><p>所以，Intel公司就引入了MMX指令集，和容量更大的寄存器来支持一条指令，同时计算多个数据，这是在PC上最早的SIMD指令集。后来，SIMD又继续发展，陆续产生了SSE（流式SIMD扩展）、AVX（高级矢量扩展）指令集，处理能力越来越强大。</p><p>2017年，Intel公司发布了一款至强处理器，支持AVX-512指令（也就是它的一个寄存器有512位）。每次能处理8个64位整数，或16个32位整数，或者32个双精度数、64个单精度数。你想想，一条指令顶64条指令，几十倍的性能提升，是不是很厉害！</p><p>那么你的电脑是否支持SIMD指令？又支持哪些指令集呢？在命令行终端，打下面的命令，你可以查看CPU所支持的指令集。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sysctl -a | grep features | grep cpu   //macOs操作系统</span></div><div class="token-line"><span class="token plain">    cat /proc/cpuinfo   //Linux操作系统</span></div></pre></div><p>现在，想必你已经知道了SIMD指令的强大之处了。<strong>而它的实际作用主要有以下几点：</strong></p><ul><li><p>SIMD有助于多媒体的处理，比如在电脑上流畅地播放视频，或者开视频会议；</p></li><li><p>在游戏领域，图形渲染主要靠GPU，但如果你没有强大的GPU，还是要靠CPU的SIMD指令来帮忙；</p></li><li><p>在商业领域，数据库系统会采用SIMD来快速处理海量的数据；</p></li><li><p>人工智能领域，机器学习需要消耗大量的计算量，SIMD指令可以提升机器学习的速度。</p></li><li><p>你平常写的程序，编译器也会优化成，尽量使用SIMD指令来提高性能。</p></li></ul><p>所以，我们所用到的程序，其实天天在都在执行SIMD指令。</p><p>**接下来，我来演示一下如何使用SIMD指令，**与传统的数据处理技术做性能上的对比，并探讨如何在编译器中生成SIMD指令，这样你可以针对自己的项目充分发挥SIMD指令的优势。</p><p>Intel公司为SIMD指令提供了一个标准的库，可以生成SIMD的汇编指令。我们写一个简单的程序（参考<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd1.c">simd1.c<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）来对两组数据做加法运算，每组8个整数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &quot;immintrin.h&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    void sum(){</span></div><div class="token-line"><span class="token plain">       //初始化两个矢量 ，8个32位整数</span></div><div class="token-line"><span class="token plain">       __m256i a=_mm256_set_epi32(20,30,40,60,342,34523,474,123);</span></div><div class="token-line"><span class="token plain">       __m256i b=_mm256_set_epi32(234,234,456,78,2345,213,76,88);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       //矢量加法</span></div><div class="token-line"><span class="token plain">       __m256i sum=_mm256_add_epi32(a, b);</span></div><div class="token-line"><span class="token plain">       </span></div><div class="token-line"><span class="token plain">       //打印每个值</span></div><div class="token-line"><span class="token plain">       int32_t* s = (int32_t*)&amp;sum;</span></div><div class="token-line"><span class="token plain">       for (int i = 0; i&lt; 8; i++){</span></div><div class="token-line"><span class="token plain">           printf(&quot;s[%d] : %d\n&quot;, i, s[i]);</span></div><div class="token-line"><span class="token plain">       }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>把矢量加法运算翻译成汇编语言的话，采用的指令是vpaddd（其中的p是pack的意思，对一组数据操作）。寄存器的名字是ymm（y开头意思是256位的）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">vpaddd %ymm0, %ymm1, %ymm0</span></div></pre></div><p>在这个示例中，我们构建了两个矢量数据，这个计算很简单。<strong>接下来，我们挑战一个有难度的题目：把1.6亿个64位的整数做加法！</strong></p><p>1.6亿个64位整数要占据大约1.2G的内存，你要把这1.2G的数据全部汇总一遍！要实现这个功能，你首先要申请一块1.2G大小的内存，并且要是32位对齐的（因为后面加载数据到寄存器的指令需要内存对齐，这样加载速度更快）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">unsigned  totalNums = 160000000;</span></div><div class="token-line"><span class="token plain">    //申请一块32位对齐的内存。</span></div><div class="token-line"><span class="token plain">    //注意：aligned_alloc函数C11标准才支持</span></div><div class="token-line"><span class="token plain">    int64_t * nums = aligned_alloc(32, totalNums * sizeof(int64_t));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //初始化sum值</span></div><div class="token-line"><span class="token plain">    __m256i sum=_mm256_setzero_si256();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    __m256i * vectorptr = (__m256i *) nums;</span></div><div class="token-line"><span class="token plain">    for (int i = 0; i &lt; totalNums/4; i++) {</span></div><div class="token-line"><span class="token plain">       //从内存加载256位进来</span></div><div class="token-line"><span class="token plain">       __m256i a = _mm256_load_si256(vectorptr+i);</span></div><div class="token-line"><span class="token plain">       //矢量加法</span></div><div class="token-line"><span class="token plain">       sum=_mm256_add_epi64(sum,a);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p><strong>完整的代码见<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd2.c">simd2.c<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</strong></p><p>最后，要用下面的命令，编译成可执行文件（-mavx2参数是告诉编译器，要使用CPU的AVX2特性）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">gcc -mavx2 simd2.c -o simd2</span></div><div class="token-line"><span class="token plain">    或</span></div><div class="token-line"><span class="token plain">    clang -mavx2 simd2.c -o simd2</span></div></pre></div><p>你可以运行一下，看看用了多少时间。</p><p>我的MacBook Pro大约用了0.15秒。**注意，**这还是只用了一个内核做计算的情况。我提供的simd3.c示例程序，是计算1.6亿个双精度浮点数，所用的时间也差不多，都是亚秒级。而计算速度之所以这么快，<strong>主要有两个原因：</strong></p><ul><li>采用了SIMD；</li><li>高速缓存和数据局部性所带来的帮助。</li></ul><p>我们先把SIMD讨论完，然后再讨论高速缓存和数据局部性。</p><p>矢量化功能可以一个指令当好几个用，但刚才编写的SIMD示例代码使用了特别的库，这些库函数本身就是用嵌入式的汇编指令写的，所以，相当于我们直接使用了SIMD的指令。</p><p>如果我们不调用这几个库，直接做加减乘除运算，能否获得SIMD的好处呢？也可以。不过要靠编译器的帮助，所以，接下来来看看LLVM是怎样帮我们使用SIMD指令的。</p><h2 id="llvm的自动矢量化功能auto-vectorization"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#llvm的自动矢量化功能auto-vectorization"><span class="icon icon-link"></span></a>LLVM的自动矢量化功能（Auto-Vectorization）</h2><p>各个编译器都在自动矢量化功能上下了功夫，以LLVM为例，它支持循环的矢量化（Loop Vectorizer）和SLP矢量化功能。</p><p>**循环的矢量化很容易理解。**如果我们处理一个很大的数组，肯定是顺序读取内存的，就如<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop.c">loop1()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int loop1(int totalNums, int * nums){</span></div><div class="token-line"><span class="token plain">        int sum = 0;</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i&lt; totalNums; i++){</span></div><div class="token-line"><span class="token plain">            sum += nums[i];</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return sum;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>不过，如果你用不同的参数去生成汇编代码，<strong>结果会不一样：</strong></p><ul><li>clang -S loop.c -o <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop-scalar.s">loop-scalar.s<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>这是最常规的汇编代码，老老实实地用add指令和%eax寄存器做加法。</p><ul><li>clang -S -O2 loop.c -o <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop-O2.s">loop-O2.s<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>它在使用paddd指令和xmm寄存器，这已经在使用SIMD指令了。</p><ul><li>clang -S -O2 -fno-vectorize loop.c -o <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop-O2-scalar.s">loop-O2-scalar.s<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>这次带上了-O2参数，要求编译器做优化，但又带上了-fno-vectorize参数，要求编译器不要通过矢量化做优化。那么生成的代码会是这个样子：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">addl    (%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   4(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   8(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   12(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   16(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   20(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   24(%rsi,%rdx,4), %eax</span></div><div class="token-line"><span class="token plain">    addl   28(%rsi,%rdx,4), %eax</span></div></pre></div><p>也就是它一次循环就做了8次加法计算，减少了循环的次数，也更容易利用高速缓存，来提高数据读入的效率，所以会导致性能上的优化。</p><ul><li>clang -S -O2 -mavx2 loop.c -o <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop-avx2.s">loop-avx2.s<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>这次带上-mavx2参数，编译器就会使用AVX2指令来做矢量化，你查看代码会看到对vpaddd指令和ymm寄存器的使用。</p><p>**其实，**在simd2.c中，我们有<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd2.c#L45">一段循环语句<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，对标量数字进行加总。这段代码在缺省的情况下，也会被编译器矢量化（你可以看看汇编代码<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd2-O2-avx2.s">simd2-O2-avx2.s<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>确认一下）。</p><p>在做自动矢量化的时候，编译器要避免一些潜在的问题，看看<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop.c#L19">loop2()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void loop2(int totalNums, int * nums1, int * nums2){</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i&lt; totalNums; i++){</span></div><div class="token-line"><span class="token plain">            nums2[i] += nums1[i];</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码中的nums1和nums2是两个指针，指向内存中的两个整数数组的位置。但我们从代码里看不出nums1和nums2是否有重叠，一旦它们有重叠的话，矢量化的计算结果会出错。</p><p>**所以，编译程序会生成矢量和标量两个版本的目标代码，**在运行时检测nums1和nums2是否重叠，从而判断是否跳转到矢量化的计算代码。**从这里你也可以看出：**写编译器真的要有工匠精神，要把各种可能性都想到。</p><p>实际上，在编译器里有很多这样的实现。你可以将循环次数改为一个常量，看一下<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop.c#L32">loop3()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>函数，它所生成的汇编代码会根据常量的值做优化，甚至完全不做循环：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int loop3(int * nums){</span></div><div class="token-line"><span class="token plain">        int sum = 0;</span></div><div class="token-line"><span class="token plain">        for (int i = 0; i&lt; 160; i++){</span></div><div class="token-line"><span class="token plain">            sum += nums[i];</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return sum;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>**除了循环的矢量化器，LLVM还有一个SLP矢量化器，**它能在做全局优化时，寻找可被矢量化的代码来做转换。比如下面的代码，对A[0]和A[1]的操作非常相似，可以考虑按照矢量的方式来计算：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void foo(int a1, int a2, int b1, int b2, int *A) {</span></div><div class="token-line"><span class="token plain">      A[0] = a1*(a1 + b1)/b1 + 50*b1/a1;</span></div><div class="token-line"><span class="token plain">      A[1] = a2*(a2 + b2)/b2 + 50*b2/a2;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>所以，LLVM确实在自动矢量化方面做了大量工作。**在你设计一个新的编译器的时候，可以充分利用这些已有的成果。**否则，在每个优化算法上，你都需要投入大量的精力，还不一定能做得足够稳定。</p><p>到目前为止，我们针对SIMD和矢量化谈得足够多了。2011年左右，我第一次做内存计算方面的编程时，被如此快的处理速度吓了一跳。因为如果你经常操作数据库，肯定会知道从数据库里做1.6亿个数据的汇总是什么概念。</p><p>一般来说，一张表有上亿条数据之前，我们就已经要做分拆了。大多数情况下，表中的数据要比1.6亿低一个数量级，就算是这样，你对一个有着一两千万行数据表做统计，仍然要花费不少的时间。</p><p>**而毫不费力地进行海量数据的计算，就是内存计算的魅力。**当然了，这里面有高速缓存和局部性的帮助。所以，我们继续讨论一下，跟内存计算有关的第二个问题：高速缓存和局部性。</p><h2 id="高速缓存和局部性"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#高速缓存和局部性"><span class="icon icon-link"></span></a>高速缓存和局部性</h2><p>我们知道，计算机的存储是分成多个级别的：</p><ul><li>速度最快的是寄存器，通常在寄存器之间复制数据只需要1个时钟周期。</li><li>其次是高速缓存，它根据速度和容量分为多个层级，读取所花费的时间从几个时钟周期到几十个时钟周期不等。</li><li>内存则要用上百到几百个时钟周期。</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage263c2666961ee1728d4b77e9dd8b0fc9693c.29d9134f.png" alt=""/></p><p>在图中的存储层次结构中，越往下，存取速度越慢，但是却可以有更大的容量，从寄存器的K级，到高速缓存的M级，到内存的G级，到磁盘的T级（灰色标的数据是Intel公司的<a target="_blank" rel="noopener noreferrer" href="https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf">Ice Lake<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>架构的CPU的数据）。</p><p>一般的计算机指令1到几个时钟周期就可以执行完毕。所以，如果等待内存中读取，获得数据的话，CPU的性能可能只能发挥出1%。不过由于高速缓存的存在，读取数据的平均时间会缩短到几个时钟周期，这样CPU的能力可以充分发挥出来。所以，我在讲程序的运行时环境的时候，让你关注CPU上两个重要的部件：<strong>一个是寄存器，另一个就是高速缓存。</strong></p><p>在代码里，我们会用到寄存器，并且还会用专门的寄存器分配的算法来优化寄存器。可是对于高速缓存，我们没有办法直接控制。</p><p>因为当你用mov指令从内存中，加载数据到寄存器时，或者用add指令把内存中的一个数据，加到寄存器中，一个已有的值上面时，CPU会自动控制是从内存里取，还是在高速缓存中取，并控制高速缓存的刷新。</p><p>那我们有什么办法呢？答案是**提高程序的局部性（locality），**这个局部性又分为两个：</p><ul><li><p>一是时间局部性。一个数据一旦被加载到高速缓存甚至寄存器，我们后序的代码都能集中访问这个数据，别等着这个数据失效了再访问，那就又需要从低级别的存储中加载一次。</p></li><li><p>第二个是空间局部性。当我们访问了一条数据之后，很可能马上访问跟这个数据挨着的其他数据。CPU在一次读入数据的时候，会把相邻的数据都加载到高速缓存，这样会增加后面代码在高速缓存中命中的概率。</p></li></ul><p>提高局部性这件事情，更多的是程序员的责任，编译器能做的事情不多。不过，有一种编译优化技术，**叫做循环互换优化（loop interchange optimization）**可以让程序更好地利用高速缓存和寄存器。</p><p>下面的例子中有内循环和外循环，内循环次数较少，外循环次数很大。如果内循环里的临时变量比较多，需要占用寄存器和高速缓存，那么i就可能被挤掉，等下一次用到i的时候，需要重新从低一级的存储中获取，从而造成性能的降低：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for(i=0; i&lt;1000000; i++)</span></div><div class="token-line"><span class="token plain">      for(j=0; j&lt;10; j++){</span></div><div class="token-line"><span class="token plain">        a[i] *= b[i]</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>编译器可以把内外层循环交换，这样就提高了局部性：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for(j=0; i&lt;10; j++)</span></div><div class="token-line"><span class="token plain">      for(i= 0; i&lt;1000000; i++){</span></div><div class="token-line"><span class="token plain">        a[i] *= b[i]</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>不过，在大多数情况下，i和j循环的次数不是一个常量，而是一个变量，在编译时不知道内层循环次数更多还是外层循环。这样的话，可能就需要生成两套代码，在运行时根据情况决定跳转到哪个代码块去执行，<strong>这样会导致目标代码的膨胀。</strong></p><p>如果不想让代码膨胀，又能获得优化的目标代码，你可以尝试在运行时做动态的优化（也就是动态编译），这也是LLVM的设计目标之一。因为在静态编译期，我们确实没办法知道运行时的信息，从而也没有办法生成最优化的目标代码。</p><p>作为一名优秀的程序员，你有责任让程序保持更好的局部性。比如，假设你要设计一个内存数据库，并且经常做汇总计算，那么你会把每个字段的数据按行存储在一起，还是按列存储？当然是后者，因为这样才具备更好的数据局部性。</p><p>最后，除了SIMD和数据局部性，促成内存计算这个领域发展的还有两个因素：</p><ul><li><p>多内核并行计算。现在的CPU内核越来越多，特别是用于服务器的CPU。多路CPU几十上百个内核，能够让单机处理能力再次提升几十，甚至上百倍。</p></li><li><p>内存越来越便宜。在服务器上配置几十个G的内存已经是常规配置，配置上T的内存，也不罕见。这使得大量与数据处理有关的工作，可以基于内存，而不是磁盘。除了要更新数据，几乎可以不访问相对速度很低的磁盘。</p></li></ul><p>在这些因素的共同作用下，内存计算的使用越来越普遍。在你的项目里，你可以考虑采用这个技术，来加速海量数据的处理。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>本节课，我带你了解了内存计算的特点，以及与编译技术的关系，我希望你能记住几点：</p><ul><li><p>SIMD是一种指令级并行技术，它能够矢量化地一次计算多条数据，从而提升计算性能，在计算密集型的需求中，比如多媒体处理、海量数据处理、人工智能、游戏等领域，你可以考虑充分利用SIMD技术。</p></li><li><p>充分保持程序的局部性，能够更好地利用计算机的高速缓存，从而提高程序的性能。</p></li><li><p>SIMD，加上数据局部性，和多个CPU内核的并行处理能力，再加上低价的海量的内存，推动了内存计算技术的普及，它能够同时满足计算密集，和海量数据的需求。</p></li><li><p>有时候，我们必须在运行期，根据一些数据来做优化，生成更优的目标代码，在编译期不可能做到尽善尽美。</p></li></ul><p>我想强调的是，熟悉编译器的后端技术将会有利于你参与基础平台的研发。如果你想设计一款内存数据库产品，一款大数据产品，或者其他产品，将计算机的底层架构知识，和编译技术结合起来，会让你有机会发挥更大的作用！</p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>你是否在自己的领域里使用过内存计算技术？它能带来什么好处？欢迎分享你的观点。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p><strong>示例代码我放在文末，供你参考。</strong></p><ul><li>lab/31-simd（示例代码目录） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/tree/master/lab/31-simd">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/tree/master/lab/31-simd">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>simd1.c（两个矢量常数相加） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/31-simd/simd1.c">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd1.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>simd2.c（1.6亿个32位整数汇总） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/31-simd/simd2.c">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd2.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>simd3.c（1.6亿个双精度浮点数汇总） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/31-simd/simd3.c">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/simd3.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>loop.c（测试对循环的自动矢量化） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/31-simd/loop.c">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>loop.avx2.s（自动矢量化成AVX2指令后的汇编代码） <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/31-simd/loop.avx2.s">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/31-simd/loop-avx2.s">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理之美/08.实现一门编译型语言·应用篇/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
