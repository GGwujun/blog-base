<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>09 | 面向对象：实现数据和方法的封装 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理之美/02.实现一门脚本语言·原理篇/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a aria-current="page" class="active" href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a aria-current="page" class="active" href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理之美/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/编译原理之美/01.开篇词/01"><span>开篇词 | 为什么你要学习编译原理？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇">02.实现一门脚本语言·原理篇</a><ul><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/01"><span>01 | 理解代码：编译器的前端技术</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/02"><span>02 | 正则文法和有限自动机：纯手工打造词法分析器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/03"><span>03 | 语法分析（一）：纯手工打造公式计算器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/04"><span>04 | 语法分析（二）：解决二元表达式中的难点</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/05"><span>05 | 语法分析（三）：实现一门简单的脚本语言</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/06"><span>06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/07"><span>07 | 编译器前端工具（二）：用Antlr重构脚本语言</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/08"><span>08 | 作用域和生存期：实现块作用域和函数</span></a></li><li><a aria-current="page" class="active" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09"><span>09 | 面向对象：实现数据和方法的封装</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/10"><span>10 | 闭包： 理解了原理，它就不反直觉了</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/11"><span>11 | 语义分析（上）：如何建立一个完善的类型系统？</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/12"><span>12 | 语义分析（下）：如何做上下文相关情况的处理？</span></a></li><li><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/13"><span>13 | 继承和多态：面向对象运行期的动态特性</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇">03.实现一门脚本语言·应用篇</a><ul><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇/01"><span>14 | 前端技术应用（一）：如何透明地支持数据库分库分表？</span></a></li><li><a href="/blog-base/编译原理之美/03.实现一门脚本语言·应用篇/02"><span>15 | 前端技术应用（二）：如何设计一个报表工具？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇">04.实现一门脚本语言·算法篇</a><ul><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/01"><span>16 | NFA和DFA：如何自己实现一个正则表达式工具？</span></a></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/02"><span>17 | First和Follow集合：用LL算法推演一个实例</span></a></li><li><a href="/blog-base/编译原理之美/04.实现一门脚本语言·算法篇/03"><span>18 | 移进和规约：用LR算法推演一个实例</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事">05.实现一门脚本语言·热点答疑与用户故事</a><ul><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/01"><span>19 | 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？</span></a></li><li><a href="/blog-base/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/02"><span>用户故事 | 因为热爱，所以坚持</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/06.编译原理·期中考试周">06.编译原理·期中考试周</a><ul><li><a href="/blog-base/编译原理之美/06.编译原理·期中考试周/01"><span>期中考试 |  来赴一场100分的约定吧！</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇">07.实现一门编译型语言·原理篇</a><ul><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/01"><span>20 | 高效运行：编译器的后端技术</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/02"><span>21 | 运行时机制：突破现象看本质，透过语法看运行时</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/03"><span>22 | 生成汇编代码（一）：汇编语言其实不难学</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/04"><span>加餐 | 汇编代码编程与栈帧管理</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/05"><span>23 | 生成汇编代码（二）：把脚本编译成可执行文件</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/06"><span>24 | 中间代码：兼容不同的语言和硬件</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/07"><span>25 | 后端技术的重用：LLVM不仅仅让你高效</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/08"><span>26 | 生成IR：实现静态编译的语言</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/09"><span>27 | 代码优化：为什么你的代码比他的更高效？</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/10"><span>28 | 数据流分析：你写的程序，它更懂</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/11"><span>29 | 目标代码的生成和优化（一）：如何适应各种硬件架构？</span></a></li><li><a href="/blog-base/编译原理之美/07.实现一门编译型语言·原理篇/12"><span>30 | 目标代码的生成和优化（二）：如何适应各种硬件架构？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇">08.实现一门编译型语言·应用篇</a><ul><li><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/01"><span>31 | 内存计算：对海量数据做计算，到底可以有多快？</span></a></li><li><a href="/blog-base/编译原理之美/08.实现一门编译型语言·应用篇/02"><span>32 | 字节码生成：为什么Spring技术很强大？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇">09.实现一门编译型语言·扩展篇</a><ul><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/01"><span>33 | 垃圾收集：能否不停下整个世界？</span></a></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/02"><span>34 | 运行时优化：即时编译的原理和作用</span></a></li><li><a href="/blog-base/编译原理之美/09.实现一门编译型语言·扩展篇/03"><span>35 | 案例总结与热点问题答疑：后端部分真的比前端部分难吗？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言">10.面向未来的编程语言</a><ul><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/01"><span>36 | 当前技术的发展趋势以及其对编译技术的影响</span></a></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/02"><span>37  | 云编程：云计算会如何改变编程模式？</span></a></li><li><a href="/blog-base/编译原理之美/10.面向未来的编程语言/03"><span>38 | 元编程：一边写程序，一边写语言</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/11.结束语">11.结束语</a><ul><li><a href="/blog-base/编译原理之美/11.结束语/01"><span>结束语 | 用程序语言，推动这个世界的演化</span></a></li><li><a href="/blog-base/编译原理之美/11.结束语/02"><span>第二季回归 | 这次，我们一起实战解析真实世界的编译器</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/12.结课测试">12.结课测试</a><ul><li><a href="/blog-base/编译原理之美/12.结课测试/01"><span>结课测试 | 编译原理的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-base/编译原理之美/summary">编译原理之美</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="面向对象的语义特征" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#面向对象的语义特征"><span>面向对象的语义特征</span></a></li><li title="设计类的语法，并解析它" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#设计类的语法并解析它"><span>设计类的语法，并解析它</span></a></li><li title="对象是怎么实例化的" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#对象是怎么实例化的"><span>对象是怎么实例化的</span></a></li><li title="如何在内存里管理对象的数据" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#如何在内存里管理对象的数据"><span>如何在内存里管理对象的数据</span></a></li><li title="访问对象的属性和方法" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#访问对象的属性和方法"><span>访问对象的属性和方法</span></a></li><li title="课程小结" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#一课一思"><span>一课一思</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09--面向对象实现数据和方法的封装"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#09--面向对象实现数据和方法的封装"><span class="icon icon-link"></span></a>09 | 面向对象：实现数据和方法的封装</h1><p>在现代计算机语言中，面向对象是非常重要的特性，似乎常用的语言都支持面向对象特性，比如Swift、C++、Java……不支持的反倒是异类了。</p><p>而它重要的特点就是封装。也就是说，对象可以把数据和对数据的操作封装在一起，构成一个不可分割的整体，尽可能地隐藏内部的细节，只保留一些接口与外部发生联系。 在对象的外部只能通过这些接口与对象进行交互，无需知道对象内部的细节。这样能降低系统的耦合，实现内部机制的隐藏，不用担心对外界的影响。那么它们是怎样实现的呢？</p><p>本节课，我将从语义设计和运行时机制的角度剖析面向对象的特性，带你深入理解面向对象的实现机制，让你能在日常编程工作中更好地运用面向对象的特性。比如，在学完这讲之后，你会对对象的作用域和生存期、对象初始化过程等有更清晰的了解。而且你不会因为学习了Java或C++的面向对象机制，在学习JavaScript和Ruby的面向对象机制时觉得别扭，因为它们的本质是一样的。</p><p>接下来，我们先简单地聊一下什么是面向对象。</p><h2 id="面向对象的语义特征"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#面向对象的语义特征"><span class="icon icon-link"></span></a>面向对象的语义特征</h2><p>我的一个朋友，在10多年前做过培训师，为了吸引学员的注意力，他在讲“什么是面向对象”时说：“面向对象是世界观，是方法论。”</p><p>虽然有点儿语不惊人死不休的意思，但我必须承认，所有的计算机语言都是对世界进行建模的方式，只不过建模的视角不同罢了。面向对象的设计思想，在上世纪90年代被推崇，几乎被视为最好的编程模式。实际上，各种不同的编程思想，都会表现为这门语言的语义特征，所以，我就从语义角度，利用类型、作用域、生存期这样的概念带你深入剖析一下面向对象的封装特性，其他特性在后面的课程中再去讨论。</p><ul><li><strong>从类型角度</strong></li></ul><p>类型处理是语义分析时的重要工作。现代计算机语言可以用自定义的类来声明变量，这是一个巨大的进步。因为早期的计算机语言只支持一些基础的数据类型，比如各种长短不一的整型和浮点型，像字符串这种我们编程时离不开的类型，往往是在基础数据类型上封装和抽象出来的。所以，我们要扩展语言的类型机制，让程序员可以创建自己的类型。</p><ul><li><strong>从作用域角度</strong></li></ul><p>首先是类的可见性。作为一种类型，它通常在整个程序的范围内都是可见的，可以用它声明变量。当然，一些像Java的语言，也能限制某些类型的使用范围，比如只能在某个命名空间内，或者在某个类内部。</p><p>对象的成员的作用域是怎样的呢？我们知道，对象的属性（“属性”这里指的是类的成员变量）可以在整个对象内部访问，无论在哪个位置声明。也就是说，对象属性的作用域是整个对象的内部，方法也是一样。这跟函数和块中的本地变量不一样，它们对声明顺序有要求，像C和Java这样的语言，在使用变量之前必须声明它。</p><ul><li><strong>从生存期的角度</strong></li></ul><p>对象的成员变量的生存期，一般跟对象的生存期是一样的。在创建对象的时候，就对所有成员变量做初始化，在销毁对象的时候，所有成员变量也随着一起销毁。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放，或者由垃圾收集机制释放。</p><p>但还有一些成员，不是与对象绑定的，而是与类型绑定的，比如Java中的静态成员。静态成员跟普通成员的区别，就是作用域和生存期不同，它的作用域是类型的所有对象实例，被所有实例共享。生存期是在任何一个对象实例创建之前就存在，在最后一个对象销毁之前不会消失。</p><p>你看，我们用这三个语义概念，就把面向对象的封装特性解释清楚了，无论语言在顶层怎么设计，在底层都是这么实现的。</p><p>了解了面向对象在语义上的原理之后，我们来实际动手解析一下代码中的类，这样能更深刻地体会这些原理。</p><h2 id="设计类的语法并解析它"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#设计类的语法并解析它"><span class="icon icon-link"></span></a>设计类的语法，并解析它</h2><p>我们要在语言中支持类的定义，在PlayScript.g4中，可以这样定义类的语法规则：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">classDeclaration</span></div><div class="token-line"><span class="token plain">        : CLASS IDENTIFIER</span></div><div class="token-line"><span class="token plain">          (EXTENDS typeType)?</span></div><div class="token-line"><span class="token plain">          (IMPLEMENTS typeList)?</span></div><div class="token-line"><span class="token plain">          classBody</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    classBody</span></div><div class="token-line"><span class="token plain">        : &#x27;{&#x27; classBodyDeclaration* &#x27;}&#x27;</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    classBodyDeclaration</span></div><div class="token-line"><span class="token plain">        : &#x27;;&#x27;</span></div><div class="token-line"><span class="token plain">        | memberDeclaration</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    memberDeclaration</span></div><div class="token-line"><span class="token plain">        : functionDeclaration</span></div><div class="token-line"><span class="token plain">        | fieldDeclaration</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    functionDeclaration</span></div><div class="token-line"><span class="token plain">        : typeTypeOrVoid IDENTIFIER formalParameters (&#x27;[&#x27; &#x27;]&#x27;)*</span></div><div class="token-line"><span class="token plain">          (THROWS qualifiedNameList)?</span></div><div class="token-line"><span class="token plain">          functionBody</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>我来简单地讲一下这个语法规则：</p><ul><li>类声明以class关键字开头，有一个标识符是类型名称，后面跟着类的主体。</li><li>类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。我们故意把类的方法也叫做function，而不是method，是想把对象方法和函数做一些统一的设计。</li><li>函数声明现在的角色是类的方法。</li><li>类的成员变量的声明和普通变量声明在语法上没什么区别。</li></ul><p>你能看到，我们构造像class这样高级别的结构时，越来越得心应手了，之前形成的一些基础的语法模块都可以复用，比如变量声明、代码块（block）等。</p><p>用上面的语法写出来的playscript脚本的效果如下，在示例代码里也有，你可以运行它：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*</span></div><div class="token-line"><span class="token plain">    ClassTest.play 简单的面向对象特性。</span></div><div class="token-line"><span class="token plain">    */</span></div><div class="token-line"><span class="token plain">    class Mammal{</span></div><div class="token-line"><span class="token plain">      //类属性</span></div><div class="token-line"><span class="token plain">      string name = &quot;&quot;;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      //构造方法</span></div><div class="token-line"><span class="token plain">      Mammal(string str){</span></div><div class="token-line"><span class="token plain">        name = str;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      //方法</span></div><div class="token-line"><span class="token plain">      void speak(){</span></div><div class="token-line"><span class="token plain">        println(&quot;mammal &quot; + name +&quot; speaking...&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Mammal mammal = Mammal(&quot;dog&quot;); //playscript特别的构造方法，不需要new关键字</span></div><div class="token-line"><span class="token plain">    mammal.speak();                          //访问对象方法</span></div><div class="token-line"><span class="token plain">    println(&quot;mammal.name = &quot; + mammal.name); //访问对象的属性</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //没有构造方法，创建的时候用缺省构造方法</span></div><div class="token-line"><span class="token plain">    class Bird{</span></div><div class="token-line"><span class="token plain">      int speed = 50;    //在缺省构造方法里初始化</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      void fly(){</span></div><div class="token-line"><span class="token plain">        println(&quot;bird flying...&quot;);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Bird bird = Bird();              //采用缺省构造方法</span></div><div class="token-line"><span class="token plain">    println(&quot;bird.speed : &quot; + bird.speed + &quot;km/h&quot;);</span></div><div class="token-line"><span class="token plain">    bird.fly();</span></div></pre></div><p>接下来，我们让playscript解释器处理这些看上去非常现代化的代码，怎么处理呢？</p><p>做完词法分析和语法分析之后，playscript会在语义分析阶段扫描AST，识别出所有自定义的类型，以便在其他地方引用这些类型来声明变量。因为类型的声明可以在代码中的任何位置，所以最好用单独的一次遍历来识别和记录类型（类型扫描的代码在TypeAndScopeScanner.java里）。</p><p>接着，我们在声明变量时，就可以引用这个类型了。语义分析的另一个工作，就是做变量类型的消解。当我们声明“Bird bird = Bird(); ”时，需要知道Bird对象的定义在哪里，以便正确地访问它的成员（变量类型的消解在TypeResolver.java里）。</p><p>在做语义分析时，要把类型的定义保存在一个数据结构中，我们来实现一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class Class extends Scope implements Type{</span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public abstract class Scope extends Symbol{</span></div><div class="token-line"><span class="token plain">        // 该Scope中的成员，包括变量、方法、类等。</span></div><div class="token-line"><span class="token plain">        protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;(</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    public interface Type {</span></div><div class="token-line"><span class="token plain">        public String getName();    //类型名称</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public Scope getEnclosingScope();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个设计中，我们看到Class就是一个Scope，Scope里面原来就能保存各种成员，现在可以直接复用，用来保存类的属性和方法，画成类图如下：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage86b1864926c69c3c85c7df771374f78942b1.5c1dad27.jpg" alt=""/></p><p>图里有几个类，比如Symbol、Variable、Scope、Function和BlockScope，它们是我们的符号体系的主要成员。在做词法分析时，我们会解析出很多标识符，这些标识符出现在不同的语法规则里，包括变量声明、表达式，以及作为类名、方法名等出现。</p><p>在语义分析阶段，我们要把这些标识符一一识别出来，这个是一个变量，指的是一个本地变量；那个是一个方法名等。</p><p>变量、类和函数的名称，我们都叫做符号，比如示例程序中的Mammal、Bird、mammal、bird、name、speed等。编译过程中的一项重要工作就是建立符号表，它帮助我们进一步地编译或执行程序，而符号表就用上面几个类来保存信息。</p><p>在符号表里，我们保存它的名称、类型、作用域等信息。对于类和函数，我们也有相应的地方来保存类变量、方法、参数、返回值等信息。你可以看一看示例代码里面是如何解析和记录这些符号的。</p><p>解析完这些语义信息以后，我们来看运行期如何执行具有面向对象特征的程序，比如如何实例化一个对象？如何在内存里管理对象的数据？以及如何访问对象的属性和方法？</p><h2 id="对象是怎么实例化的"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#对象是怎么实例化的"><span class="icon icon-link"></span></a>对象是怎么实例化的</h2><p>首先通过构造方法来创建对象。</p><p>在语法中，我们没有用new这个关键字来表示对象的创建，而是省略掉了new，直接调用一个跟类名称相同的函数，这是我们独特的设计，示例代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Mammal mammal = Mammal(&quot;dog&quot;); //playscript特别的构造方法，不需要new关键字</span></div><div class="token-line"><span class="token plain">    Bird bird = Bird();            //采用缺省构造方法</span></div></pre></div><p>但在语义检查的时候，在当前作用域中是肯定找不到这样一个函数的，因为类的初始化方法是在类的内部定义的，我们只要检查一下，Mammal和Bird是不是一个类名就可以了。</p><p>再进一步，Mammal类中确实有个构造方法Mammal()，而Bird类中其实没有一个显式定义的构造方法，但这并不意味着变量成员不会被初始化。我们借鉴了Java的初始化机制，就是提供缺省初始化方法，在缺省初始化方法里，会执行对象成员声明时所做的初始化工作。所以，上面的代码里，我们调用Bird()，实际上就是调用了这个缺省的初始化方法。无论有没有显式声明的构造方法，声明对象的成员变量时的初始化部分，一定会执行。对于Bird类，实际上就会执行“int speed = 50;”这个语句。</p><p>在RefResolver.java中做语义分析的时候，下面的代码能够检测出某个函数调用其实是类的构造方法，或者是缺省构造方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 看看是不是类的构建函数，用相同的名称查找一个class</span></div><div class="token-line"><span class="token plain">    Class theClass = at.lookupClass(scope, idName);</span></div><div class="token-line"><span class="token plain">    if (theClass != null) {</span></div><div class="token-line"><span class="token plain">        function = theClass.findConstructor(paramTypes);</span></div><div class="token-line"><span class="token plain">        if (function != null) {</span></div><div class="token-line"><span class="token plain">            at.symbolOfNode.put(ctx, function);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //如果是与类名相同的方法，并且没有参数，那么就是缺省构造方法</span></div><div class="token-line"><span class="token plain">        else if (ctx.expressionList() == null){</span></div><div class="token-line"><span class="token plain">            at.symbolOfNode.put(ctx, theClass); // TODO 直接赋予class</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else{</span></div><div class="token-line"><span class="token plain">            at.log(&quot;unknown class constructor: &quot; + ctx.getText(), ctx);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        at.typeOfNode.put(ctx, theClass); // 这次函数调用是返回一个对象</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>当然，类的构造方法跟普通函数还是有所不同的，例如我们不允许构造方法定义返回值，因为它的返回值一定是这个类的一个实例对象。</p><p>对象做了缺省初始化以后，再去调用显式定义的构造方法，这样才能完善整个对象实例化的过程。不过问题来了，我们可以把普通的本地变量的数据保存在栈里，那么如何保存对象的数据呢？</p><h2 id="如何在内存里管理对象的数据"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#如何在内存里管理对象的数据"><span class="icon icon-link"></span></a>如何在内存里管理对象的数据</h2><p>其实，我们也可以把对象的数据像其他数据一样，保存在栈里。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage571b572da99aeee859f8b7cbcf6ebfe9ea1b.4e2a78a7.jpg" alt=""/></p><p>C语言的结构体struct和C++语言的对象，都可以保存在栈里。保存在栈里的对象是直接声明并实例化的，而不是用new关键字来创建的。如果用new关键字来创建，实际上是在堆里申请了一块内存，并赋值给一个指针变量，如下图所示：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage157215313f8205fa80912e72718685755072.db725efa.jpg" alt=""/></p><p>当对象保存在堆里的时候，可以有多个变量都引用同一个对象，比如图中的变量a和变量b就可以引用同一个对象object1。类的成员变量也可以引用别的对象，比如object1中的类成员引用了object2对象。对象的生存期可以超越创建它的栈桢的生存期。</p><p>我们可以对比一下这两种方式的优缺点。如果对象保存在栈里，那么它的生存期与作用域是一样的，可以自动的创建和销毁，因此不需要额外的内存管理。缺点是对象没办法长期存在并共享。而在堆里创建的对象虽然可以被共享使用，却增加了内存管理的负担。</p><p>所以在C语言和C++语言中，要小心管理从堆中申请的内存，在合适的时候释放掉这些内存。在Java语言和其他一些语言中，采用的是垃圾收集机制，也就是说当一个对象不再被引用时，就把内存收集回来。</p><p>分析到这儿的时候，我们其实可以帮Java语言优化一下内存管理。比如我们在分析代码时，如果发现某个对象的创建和使用都局限在某个块作用域中，并没有跟其他作用域共享，那么这个对象的生存期与当前栈桢是一致的，可以在栈里申请内存，而不是在堆里。这样可以免除后期的垃圾收集工作。</p><p>分析完对象的内存管理方式之后，回到playscript的实现。在playscript的Java版本里，我们用一个ClassObject对象来保存对象数据，而ClassObject是PlayObject的子类。上一讲，我们已经讲过PlayObject，它被栈桢用来保存本地变量，可以通过传入Variable来访问对象的属性值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//类的实例</span></div><div class="token-line"><span class="token plain">    public class ClassObject extends PlayObject{</span></div><div class="token-line"><span class="token plain">         //类型</span></div><div class="token-line"><span class="token plain">        protected Class type = null;</span></div><div class="token-line"><span class="token plain">        ... </span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    //保存对象数据</span></div><div class="token-line"><span class="token plain">    public class PlayObject {</span></div><div class="token-line"><span class="token plain">        //成员变量</span></div><div class="token-line"><span class="token plain">        protected Map&lt;Variable, Object&gt; fields = new HashMap&lt;Variable, Object&gt;();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public Object getValue(Variable variable){</span></div><div class="token-line"><span class="token plain">            Object rtn = fields.get(variable);</span></div><div class="token-line"><span class="token plain">            return rtn;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        public void setValue(Variable variable, Object value){</span></div><div class="token-line"><span class="token plain">            fields.put(variable, value);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在运行期，当需要访问一个对象时，我们也会用ClassObject来做一个栈桢，这样就可以像访问本地变量一样访问对象的属性了。而不需要访问这个对象的时候，就把它从栈中移除，如果没有其他对象引用这个对象，那么它会被Java的垃圾收集机制回收。</p><h2 id="访问对象的属性和方法"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#访问对象的属性和方法"><span class="icon icon-link"></span></a>访问对象的属性和方法</h2><p>在示例代码中，我们用点操作符来访问对象的属性和方法，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">mammal.speak();                          //访问对象方法</span></div><div class="token-line"><span class="token plain">    println(&quot;mammal.name = &quot; + mammal.name); //访问对象的属性</span></div></pre></div><p>属性和方法的引用也是一种表达式，语法定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">expression</span></div><div class="token-line"><span class="token plain">        : ...</span></div><div class="token-line"><span class="token plain">        | expression bop=&#x27;.&#x27;</span></div><div class="token-line"><span class="token plain">          ( IDENTIFIER       //对象属性</span></div><div class="token-line"><span class="token plain">          | functionCall     //对象方法</span></div><div class="token-line"><span class="token plain">          )</span></div><div class="token-line"><span class="token plain">         ...</span></div><div class="token-line"><span class="token plain">         ;</span></div></pre></div><p>注意，点符号的操作可以是级联的，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">obj1.obj2.field1;</span></div><div class="token-line"><span class="token plain">    obj1.getObject2().field1;</span></div></pre></div><p>所以，对表达式的求值，要能够获得正确的对象引用，你可以运行一下ClassTest.play脚本，或者去看看我的参考实现。</p><p>另外，对象成员还可以设置可见性。也就是说，有些成员只有对象内部才能用，有些可以由外部访问。这个怎么实现呢？这只是个语义问题，是在编译阶段做语义检查的时候，不允许私有的成员被外部访问，报编译错误就可以了，在其他方面，并没有什么不同。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>我们针对面向对象的封装特性，从类型、作用域和生存期的角度进行了重新解读，这样能够更好地把握面向对象的本质特征。我们还设计了与面向对象的相关的语法并做了解析，然后讨论了面向对象程序的运行期机制，例如如何实例化一个对象，如何在内存里管理对象的数据，以及如何访问对象的属性和方法。</p><p>通过对类的语法和语义的剖析和运行机制的落地，我相信你会对面向对象的机制有更加本质的认识，也能更好地使用语言的面向对象特性了。</p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog-base/编译原理之美/02.实现一门脚本语言·原理篇/09#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>我们用比较熟悉的语法实现了面向对象的基础特性，像Ruby、Go这样的语言，还有另外的机制来实现面向对象。思考一下，你所熟悉的语言的面向对象机制，在底层是如何实现的？它们在类型、作用域和生存期三个方面的特点是什么？欢迎在留言区分享你的发现。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>我将本节课相关代码的链接放在了文末，供你参考。</p><ul><li>playscript-java（项目目录）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/tree/master/playscript-java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/tree/master/playscript-java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>PlayScript.java（入口程序）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>PlayScript.g4（语法规则）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/PlayScript.g4">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>ASTEvaluator.java（解释器）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/ASTEvaluator.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>TypeAndScopeScanner.java（识别对象声明）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeAndScopeScanner.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>TypeResolver.java（消解变量声明中引用的类型）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/TypeResolver.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>RefResolver.java（消解变量引用和函数调用）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/RefResolver.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>ClassTest.play（演示面向对象的基本特征）： <a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/ClassTest.play">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/ClassTest.play">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/编译原理之美/02.实现一门脚本语言·原理篇/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:20:59</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
