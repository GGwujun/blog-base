<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03 | 语法分析（一）：纯手工打造公式计算器 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/编译原理之美/02.实现一门脚本语言·原理篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a aria-current="page" class="active" href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a aria-current="page" class="active" href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理之美/01.开篇词">01.开篇词</a><ul><li><a href="/blog/编译原理之美/01.开篇词/01"><span>开篇词 | 为什么你要学习编译原理？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇">02.实现一门脚本语言·原理篇</a><ul><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/01"><span>01 | 理解代码：编译器的前端技术</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/02"><span>02 | 正则文法和有限自动机：纯手工打造词法分析器</span></a></li><li><a aria-current="page" class="active" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03"><span>03 | 语法分析（一）：纯手工打造公式计算器</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/04"><span>04 | 语法分析（二）：解决二元表达式中的难点</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/05"><span>05 | 语法分析（三）：实现一门简单的脚本语言</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/06"><span>06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/07"><span>07 | 编译器前端工具（二）：用Antlr重构脚本语言</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/08"><span>08 | 作用域和生存期：实现块作用域和函数</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/09"><span>09 | 面向对象：实现数据和方法的封装</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/10"><span>10 | 闭包： 理解了原理，它就不反直觉了</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/11"><span>11 | 语义分析（上）：如何建立一个完善的类型系统？</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/12"><span>12 | 语义分析（下）：如何做上下文相关情况的处理？</span></a></li><li><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/13"><span>13 | 继承和多态：面向对象运行期的动态特性</span></a></li></ul></li><li><a href="/blog/编译原理之美/03.实现一门脚本语言·应用篇">03.实现一门脚本语言·应用篇</a><ul><li><a href="/blog/编译原理之美/03.实现一门脚本语言·应用篇/01"><span>14 | 前端技术应用（一）：如何透明地支持数据库分库分表？</span></a></li><li><a href="/blog/编译原理之美/03.实现一门脚本语言·应用篇/02"><span>15 | 前端技术应用（二）：如何设计一个报表工具？</span></a></li></ul></li><li><a href="/blog/编译原理之美/04.实现一门脚本语言·算法篇">04.实现一门脚本语言·算法篇</a><ul><li><a href="/blog/编译原理之美/04.实现一门脚本语言·算法篇/01"><span>16 | NFA和DFA：如何自己实现一个正则表达式工具？</span></a></li><li><a href="/blog/编译原理之美/04.实现一门脚本语言·算法篇/02"><span>17 | First和Follow集合：用LL算法推演一个实例</span></a></li><li><a href="/blog/编译原理之美/04.实现一门脚本语言·算法篇/03"><span>18 | 移进和规约：用LR算法推演一个实例</span></a></li></ul></li><li><a href="/blog/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事">05.实现一门脚本语言·热点答疑与用户故事</a><ul><li><a href="/blog/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/01"><span>19 | 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？</span></a></li><li><a href="/blog/编译原理之美/05.实现一门脚本语言·热点答疑与用户故事/02"><span>用户故事 | 因为热爱，所以坚持</span></a></li></ul></li><li><a href="/blog/编译原理之美/06.编译原理·期中考试周">06.编译原理·期中考试周</a><ul><li><a href="/blog/编译原理之美/06.编译原理·期中考试周/01"><span>期中考试 |  来赴一场100分的约定吧！</span></a></li></ul></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇">07.实现一门编译型语言·原理篇</a><ul><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/01"><span>20 | 高效运行：编译器的后端技术</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/02"><span>21 | 运行时机制：突破现象看本质，透过语法看运行时</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/03"><span>22 | 生成汇编代码（一）：汇编语言其实不难学</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/04"><span>加餐 | 汇编代码编程与栈帧管理</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/05"><span>23 | 生成汇编代码（二）：把脚本编译成可执行文件</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/06"><span>24 | 中间代码：兼容不同的语言和硬件</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/07"><span>25 | 后端技术的重用：LLVM不仅仅让你高效</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/08"><span>26 | 生成IR：实现静态编译的语言</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/09"><span>27 | 代码优化：为什么你的代码比他的更高效？</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/10"><span>28 | 数据流分析：你写的程序，它更懂</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/11"><span>29 | 目标代码的生成和优化（一）：如何适应各种硬件架构？</span></a></li><li><a href="/blog/编译原理之美/07.实现一门编译型语言·原理篇/12"><span>30 | 目标代码的生成和优化（二）：如何适应各种硬件架构？</span></a></li></ul></li><li><a href="/blog/编译原理之美/08.实现一门编译型语言·应用篇">08.实现一门编译型语言·应用篇</a><ul><li><a href="/blog/编译原理之美/08.实现一门编译型语言·应用篇/01"><span>31 | 内存计算：对海量数据做计算，到底可以有多快？</span></a></li><li><a href="/blog/编译原理之美/08.实现一门编译型语言·应用篇/02"><span>32 | 字节码生成：为什么Spring技术很强大？</span></a></li></ul></li><li><a href="/blog/编译原理之美/09.实现一门编译型语言·扩展篇">09.实现一门编译型语言·扩展篇</a><ul><li><a href="/blog/编译原理之美/09.实现一门编译型语言·扩展篇/01"><span>33 | 垃圾收集：能否不停下整个世界？</span></a></li><li><a href="/blog/编译原理之美/09.实现一门编译型语言·扩展篇/02"><span>34 | 运行时优化：即时编译的原理和作用</span></a></li><li><a href="/blog/编译原理之美/09.实现一门编译型语言·扩展篇/03"><span>35 | 案例总结与热点问题答疑：后端部分真的比前端部分难吗？</span></a></li></ul></li><li><a href="/blog/编译原理之美/10.面向未来的编程语言">10.面向未来的编程语言</a><ul><li><a href="/blog/编译原理之美/10.面向未来的编程语言/01"><span>36 | 当前技术的发展趋势以及其对编译技术的影响</span></a></li><li><a href="/blog/编译原理之美/10.面向未来的编程语言/02"><span>37  | 云编程：云计算会如何改变编程模式？</span></a></li><li><a href="/blog/编译原理之美/10.面向未来的编程语言/03"><span>38 | 元编程：一边写程序，一边写语言</span></a></li></ul></li><li><a href="/blog/编译原理之美/11.结束语">11.结束语</a><ul><li><a href="/blog/编译原理之美/11.结束语/01"><span>结束语 | 用程序语言，推动这个世界的演化</span></a></li><li><a href="/blog/编译原理之美/11.结束语/02"><span>第二季回归 | 这次，我们一起实战解析真实世界的编译器</span></a></li></ul></li><li><a href="/blog/编译原理之美/12.结课测试">12.结课测试</a><ul><li><a href="/blog/编译原理之美/12.结课测试/01"><span>结课测试 | 编译原理的这些知识，你都掌握了吗？</span></a></li></ul></li><li><a href="/blog/编译原理之美/summary">编译原理之美</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="解析变量声明语句：理解“下降”的含义" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#解析变量声明语句理解下降的含义"><span>解析变量声明语句：理解“下降”的含义</span></a></li><li title="用上下文无关文法描述算术表达式" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#用上下文无关文法描述算术表达式"><span>用上下文无关文法描述算术表达式</span></a></li><li title="解析算术表达式：理解“递归”的含义" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#解析算术表达式理解递归的含义"><span>解析算术表达式：理解“递归”的含义</span></a></li><li title="实现表达式求值" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#实现表达式求值"><span>实现表达式求值</span></a></li><li title="课程小结" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#课程小结"><span>课程小结</span></a></li><li title="一课一思" data-depth="2"><a href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#一课一思"><span>一课一思</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03--语法分析一纯手工打造公式计算器"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#03--语法分析一纯手工打造公式计算器"><span class="icon icon-link"></span></a>03 | 语法分析（一）：纯手工打造公式计算器</h1><p>我想你应该知道，公式是Excel电子表格软件的灵魂和核心。除此之外，在HR软件中，可以用公式自定义工资。而且，如果你要开发一款通用报表软件，也会大量用到自定义公式来计算报表上显示的数据。总而言之，很多高级一点儿的软件，都会用到自定义公式功能。</p><p>既然公式功能如此常见和重要，我们不妨实现一个公式计算器，给自己的软件添加自定义公式功能吧！</p><p>本节课将继续“手工打造”之旅，让你纯手工实现一个公式计算器，借此掌握<strong>语法分析的原理</strong>和<strong>递归下降算法（Recursive Descent Parsing），<strong>并初步了解</strong>上下文无关文法（Context-free Grammar，CFG）。</strong></p><p>我所举例的公式计算器支持加减乘除算术运算，比如支持“2 + 3 * 5”的运算。</p><p>在学习语法分析时，我们习惯把上面的公式称为表达式。这个表达式看上去很简单，但你能借此学到很多语法分析的原理，例如左递归、优先级和结合性等问题。</p><p>当然了，要实现上面的表达式，你必须能分析它的语法。不过在此之前，我想先带你解析一下变量声明语句的语法，以便让你循序渐进地掌握语法分析。</p><h2 id="解析变量声明语句理解下降的含义"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#解析变量声明语句理解下降的含义"><span class="icon icon-link"></span></a>解析变量声明语句：理解“下降”的含义</h2><p>在“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/118132">01 | 理解代码：编译器的前端技术<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”里，我提到语法分析的结果是生成AST。算法分为自顶向下和自底向上算法，其中，递归下降算法是一种常见的自顶向下算法。</p><p>与此同时，我给出了一个简单的代码示例，也针对“int age = 45”这个语句，画了一个语法分析算法的示意图：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/02.%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%C2%B7%E5%8E%9F%E7%90%86%E7%AF%87/resourceimagecb16cbf2b953cb84ef30b154470804262c16.jpg" alt=""/></p><p>我们首先把变量声明语句的规则，用形式化的方法表达一下。它的左边是一个非终结符（Non-terminal）。右边是它的产生式（Production Rule）。在语法解析的过程中，左边会被右边替代。如果替代之后还有非终结符，那么继续这个替代过程，直到最后全部都是终结符（Terminal），也就是Token。只有终结符才可以成为AST的叶子节点。这个过程，也叫做推导（Derivation）过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">intDeclaration : Int Identifier (&#x27;=&#x27; additiveExpression)?;</span></div></pre></div><p>你可以看到，int类型变量的声明，需要有一个Int型的Token，加一个变量标识符，后面跟一个可选的赋值表达式。我们把上面的文法翻译成程序语句，伪代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//伪代码</span></div><div class="token-line"><span class="token plain">    MatchIntDeclare(){</span></div><div class="token-line"><span class="token plain">      MatchToken(Int)；        //匹配Int关键字</span></div><div class="token-line"><span class="token plain">      MatchIdentifier();       //匹配标识符</span></div><div class="token-line"><span class="token plain">      MatchToken(equal);       //匹配等号</span></div><div class="token-line"><span class="token plain">      MatchExpression();       //匹配表达式</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>实际代码在SimpleCalculator.java类的IntDeclare()方法中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SimpleASTNode node = null;</span></div><div class="token-line"><span class="token plain">    Token token = tokens.peek();    //预读</span></div><div class="token-line"><span class="token plain">    if (token != null &amp;&amp; token.getType() == TokenType.Int) {   //匹配Int</span></div><div class="token-line"><span class="token plain">        token = tokens.read();      //消耗掉int</span></div><div class="token-line"><span class="token plain">        if (tokens.peek().getType() == TokenType.Identifier) { //匹配标识符</span></div><div class="token-line"><span class="token plain">            token = tokens.read();  //消耗掉标识符</span></div><div class="token-line"><span class="token plain">            //创建当前节点，并把变量名记到AST节点的文本值中，</span></div><div class="token-line"><span class="token plain">            //这里新建一个变量子节点也是可以的</span></div><div class="token-line"><span class="token plain">            node = new SimpleASTNode(ASTNodeType.IntDeclaration, token.getText());</span></div><div class="token-line"><span class="token plain">            token = tokens.peek();  //预读</span></div><div class="token-line"><span class="token plain">            if (token != null &amp;&amp; token.getType() == TokenType.Assignment) {</span></div><div class="token-line"><span class="token plain">                tokens.read();      //消耗掉等号</span></div><div class="token-line"><span class="token plain">                SimpleASTNode child = additive(tokens);  //匹配一个表达式</span></div><div class="token-line"><span class="token plain">                if (child == null) {</span></div><div class="token-line"><span class="token plain">                    throw new Exception(&quot;invalide variable initialization, expecting an expression&quot;);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                else{</span></div><div class="token-line"><span class="token plain">                    node.addChild(child);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">            throw new Exception(&quot;variable name expected&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>直白地描述一下上面的算法：</p><blockquote><p>解析变量声明语句时，我先看第一个Token是不是int。如果是，那我创建一个AST节点，记下int后面的变量名称，然后再看后面是不是跟了初始化部分，也就是等号加一个表达式。我们检查一下有没有等号，有的话，接着再匹配一个表达式。</p></blockquote><p>我们通常会对产生式的每个部分建立一个子节点，比如变量声明语句会建立四个子节点，分别是int关键字、标识符、等号和表达式。后面的工具就是这样严格生成AST的。但是我这里做了简化，只生成了一个子节点，就是表达式子节点。变量名称记到ASTNode的文本值里去了，其他两个子节点没有提供额外的信息，就直接丢弃了。</p><p>另外，从上面的代码中我们看到，程序是从一个Token的流中顺序读取。代码中的peek()方法是预读，只是读取下一个Token，但并不把它从Token流中移除。在代码中，我们用peek()方法可以预先看一下下一个Token是否是等号，从而知道后面跟着的是不是一个表达式。而read()方法会从Token流中移除，下一个Token变成了当前的Token。</p><p>这里需要注意的是，通过peek()方法来预读，实际上是对代码的优化，这有点儿预测的意味。我们后面会讲带有预测的自顶向下算法，它能减少回溯的次数。</p><p>我们把解析变量声明语句和表达式的算法分别写成函数。在语法分析的时候，调用这些函数跟后面的Token串做模式匹配。匹配上了，就返回一个AST节点，否则就返回null。如果中间发现跟语法规则不符，就报编译错误。</p><p>在这个过程中，上级文法嵌套下级文法，上级的算法调用下级的算法。表现在生成AST中，上级算法生成上级节点，下级算法生成下级节点。<strong>这就是“下降”的含义。</strong></p><p>分析上面的伪代码和程序语句，你可以看到这样的特点：<strong>程序结构基本上是跟文法规则同构的。这就是递归下降算法的优点，非常直观。</strong></p><p>接着说回来，我们继续运行这个示例程序，输出AST：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Programm Calculator</span></div><div class="token-line"><span class="token plain">        IntDeclaration age</span></div><div class="token-line"><span class="token plain">            AssignmentExp =</span></div><div class="token-line"><span class="token plain">                IntLiteral 45</span></div></pre></div><p>前面的文法和算法都很简单，这样级别的文法没有超出正则文法。也就是说，并没有超出我们做词法分析时用到的文法。</p><p>好了，解析完变量声明语句，带你理解了“下降”的含义之后，我们来看看如何用上下文无关文法描述算术表达式。</p><h2 id="用上下文无关文法描述算术表达式"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#用上下文无关文法描述算术表达式"><span class="icon icon-link"></span></a>用上下文无关文法描述算术表达式</h2><p>我们解析算术表达式的时候，会遇到更复杂的情况，这时，正则文法不够用，我们必须用上下文无关文法来表达。你可能会问：“正则文法为什么不能表示算术表达式？”别着急，我们来分析一下算术表达式的语法规则。</p><p>算术表达式要包含加法和乘法两种运算（简单起见，我们把减法与加法等同看待，把除法也跟乘法等同看待），加法和乘法运算有不同的优先级。我们的规则要能匹配各种可能的算术表达式：</p><ul><li>2+3*5</li><li>2*3+5</li><li>2*3</li><li>……</li></ul><p>思考一番之后，我们把规则分成两级：第一级是加法规则，第二级是乘法规则。把乘法规则作为加法规则的子规则，这样在解析形成AST时，乘法节点就一定是加法节点的子节点，从而被优先计算。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">additiveExpression</span></div><div class="token-line"><span class="token plain">        :   multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        |   additiveExpression Plus multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        ;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        :   IntLiteral</span></div><div class="token-line"><span class="token plain">        |   multiplicativeExpression Star IntLiteral</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>你看，我们可以通过文法的嵌套，实现对运算优先级的支持。这样我们在解析“2 + 3 * 5”这个算术表达式时会形成类似下面的AST：</p><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E/02.%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%97%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%C2%B7%E5%8E%9F%E7%90%86%E7%AF%87/resourceimage5e1c5ed231aced0b65b8c0d343b86634401c.jpg" alt=""/></p><p>如果要计算表达式的值，只需要对根节点求值就可以了。为了完成对根节点的求值，需要对下级节点递归求值，所以我们先完成“3 * 5 = 15”，然后再计算“2 + 15 = 17”。</p><p>有了这个认知，我们在解析算术表达式的时候，便能拿加法规则去匹配。在加法规则中，会嵌套地匹配乘法规则。我们通过文法的嵌套，实现了计算的优先级。</p><p>应该注意的是，加法规则中还递归地又引用了加法规则。通过这种递归的定义，我们能展开、形成所有各种可能的算术表达式。比如“2+3*5” 的推导过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">--&gt;additiveExpression + multiplicativeExpression</span></div><div class="token-line"><span class="token plain">    --&gt;multiplicativeExpression + multiplicativeExpression</span></div><div class="token-line"><span class="token plain">    --&gt;IntLiteral + multiplicativeExpression</span></div><div class="token-line"><span class="token plain">    --&gt;IntLiteral + multiplicativeExpression * IntLiteral </span></div><div class="token-line"><span class="token plain">    --&gt;IntLiteral + IntLiteral * IntLiteral</span></div></pre></div><p>这种文法已经没有办法改写成正则文法了，它比正则文法的表达能力更强，叫做**“上下文无关文法”。**正则文法是上下文无关文法的一个子集。它们的区别呢，就是上下文无关文法允许递归调用，而正则文法不允许。</p><p>上下文无关的意思是，无论在任何情况下，文法的推导规则都是一样的。比如，在变量声明语句中可能要用到一个算术表达式来做变量初始化，而在其他地方可能也会用到算术表达式。不管在什么地方，算术表达式的语法都一样，都允许用加法和乘法，计算优先级也不变。好在你见到的大多数计算机语言，都能用上下文无关文法来表达它的语法。</p><p>那有没有上下文相关的情况需要处理呢？也是有的，但那不是语法分析阶段负责的，而是放在语义分析阶段来处理的。</p><h2 id="解析算术表达式理解递归的含义"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#解析算术表达式理解递归的含义"><span class="icon icon-link"></span></a>解析算术表达式：理解“递归”的含义</h2><p>在讲解上下文无关文法时，我提到了文法的递归调用，你也许会问，是否在算法上也需要递归的调用呢？要不怎么叫做“递归下降算法”呢？</p><p>的确，我们之前的算法只算是用到了“下降”，没有涉及“递归”，现在，我们就来看看如何用递归的算法翻译递归的文法。</p><p>我们先按照前面说的，把文法直观地翻译成算法。但是，我们遇到麻烦了。这个麻烦就是出现了无穷多次调用的情况。我们来看个例子。</p><p>为了简单化，我们采用下面这个简化的文法，去掉了乘法的层次：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">additiveExpression</span></div><div class="token-line"><span class="token plain">        :   IntLiteral</span></div><div class="token-line"><span class="token plain">        |   additiveExpression Plus IntLiteral</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>在解析 “2 + 3”这样一个最简单的加法表达式的时候，我们直观地将其翻译成算法，结果出现了如下的情况：</p><ul><li>首先匹配是不是整型字面量，发现不是；</li><li>然后匹配是不是加法表达式，这里是递归调用；</li><li>会重复上面两步，无穷无尽。</li></ul><p>“additiveExpression Plus multiplicativeExpression”这个文法规则的第一部分就递归地引用了自身，这种情况叫做**左递归。**通过上面的分析，我们知道左递归是递归下降算法无法处理的，这是递归下降算法最大的问题。</p><p>怎么解决呢？把“additiveExpression”调换到加号后面怎么样？我们来试一试。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">additiveExpression</span></div><div class="token-line"><span class="token plain">        :   multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        |   multiplicativeExpression Plus additiveExpression</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>我们接着改写成算法，这个算法确实不会出现无限调用的问题：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private SimpleASTNode additive(TokenReader tokens) throws Exception {</span></div><div class="token-line"><span class="token plain">        SimpleASTNode child1 = multiplicative();  //计算第一个子节点</span></div><div class="token-line"><span class="token plain">        SimpleASTNode node = child1;  //如果没有第二个子节点，就返回这个</span></div><div class="token-line"><span class="token plain">        Token token = tokens.peek();</span></div><div class="token-line"><span class="token plain">        if (child1 != null &amp;&amp; token != null) {</span></div><div class="token-line"><span class="token plain">            if (token.getType() == TokenType.Plus) {</span></div><div class="token-line"><span class="token plain">                token = tokens.read();</span></div><div class="token-line"><span class="token plain">                SimpleASTNode child2 = additive(); //递归地解析第二个节点</span></div><div class="token-line"><span class="token plain">                if (child2 != null) {</span></div><div class="token-line"><span class="token plain">                    node = new SimpleASTNode(ASTNodeType.AdditiveExp, token.getText());</span></div><div class="token-line"><span class="token plain">                    node.addChild(child1);</span></div><div class="token-line"><span class="token plain">                    node.addChild(child2);</span></div><div class="token-line"><span class="token plain">                } else {</span></div><div class="token-line"><span class="token plain">                    throw new Exception(&quot;invalid additive expression, expecting the right part.&quot;);</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return node;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了便于你理解，我解读一下上面的算法：</p><blockquote><p>我们先尝试能否匹配乘法表达式，如果不能，那么这个节点肯定不是加法节点，因为加法表达式的两个产生式都必须首先匹配乘法表达式。遇到这种情况，返回null就可以了，调用者就这次匹配没有成功。如果乘法表达式匹配成功，那就再尝试匹配加号右边的部分，也就是去递归地匹配加法表达式。如果匹配成功，就构造一个加法的ASTNode返回。</p></blockquote><p>同样的，乘法的文法规则也可以做类似的改写：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        :   IntLiteral</span></div><div class="token-line"><span class="token plain">        |   IntLiteral Star multiplicativeExpression</span></div><div class="token-line"><span class="token plain">        ;</span></div></pre></div><p>现在我们貌似解决了左递归问题，运行这个算法解析 “2+3*5”，得到下面的AST：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Programm Calculator</span></div><div class="token-line"><span class="token plain">        AdditiveExp +</span></div><div class="token-line"><span class="token plain">            IntLiteral 2</span></div><div class="token-line"><span class="token plain">            MulticativeExp *</span></div><div class="token-line"><span class="token plain">                IntLiteral 3</span></div><div class="token-line"><span class="token plain">                IntLiteral 5</span></div></pre></div><p>是不是看上去一切正常？可如果让这个程序解析“2+3+4”呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Programm Calculator</span></div><div class="token-line"><span class="token plain">        AdditiveExp +</span></div><div class="token-line"><span class="token plain">            IntLiteral 2</span></div><div class="token-line"><span class="token plain">            AdditiveExp +</span></div><div class="token-line"><span class="token plain">                IntLiteral 3</span></div><div class="token-line"><span class="token plain">                IntLiteral 4</span></div></pre></div><p>问题是什么呢？计算顺序发生错误了。连续相加的表达式要从左向右计算，这是加法运算的结合性规则。但按照我们生成的AST，变成从右向左了，先计算了“3+4”，然后才跟“2”相加。这可不行！</p><p>为什么产生上面的问题呢？是因为我们修改了文法，把文法中加号左右两边的部分调换了一下。造成的影响是什么呢？你可以推导一下“2+3+4”的解析过程：</p><ul><li>首先调用乘法表达式匹配函数multiplicative()，成功，返回了一个字面量节点2。</li><li>接着看看右边是否能递归地匹配加法表达式。</li><li>匹配的结果，真的返回了一个加法表达式“3+4”，这个变成了第二个子节点。错误就出在这里了。这样的匹配顺序，“3+4”一定会成为子节点，在求值时被优先计算。</li></ul><p>所以，我们前面的方法其实并没有完美地解决左递归，因为它改变了加法运算的结合性规则。那么，我们能否既解决左递归问题，又不产生计算顺序的错误呢？答案是肯定的。不过我们下一讲再来解决它。目前先忍耐一下，凑合着用这个“半吊子”的算法吧。</p><h2 id="实现表达式求值"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#实现表达式求值"><span class="icon icon-link"></span></a>实现表达式求值</h2><p>上面帮助你理解了“递归”的含义，接下来，我要带你实现表达式的求值。其实，要实现一个表达式计算，只需要基于AST做求值运算。这个计算过程比较简单，只需要对这棵树做深度优先的遍历就好了。</p><p>深度优先的遍历也是一个递归算法。以上文中“2 + 3 * 5”的AST为例看一下。</p><ul><li>对表达式的求值，等价于对AST根节点求值。</li><li>首先求左边子节点，算出是2。</li><li>接着对右边子节点求值，这时候需要递归计算下一层。计算完了以后，返回是15（3*5）。</li><li>把左右节点相加，计算出根节点的值17。</li></ul><p>代码参见SimpleCalculator.Java中的evaluate()方法。</p><p>还是以“2+3*5”为例。它的求值过程输出如下，你可以看到求值过程中遍历了整棵树：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Calculating: AdditiveExp          //计算根节点</span></div><div class="token-line"><span class="token plain">            Calculating: IntLiteral      //计算第一个子节点</span></div><div class="token-line"><span class="token plain">            Result: 2                     //结果是2</span></div><div class="token-line"><span class="token plain">            Calculating: MulticativeExp   //递归计算第二个子节点</span></div><div class="token-line"><span class="token plain">                Calculating: IntLiteral</span></div><div class="token-line"><span class="token plain">                Result: 3</span></div><div class="token-line"><span class="token plain">                Calculating: IntLiteral</span></div><div class="token-line"><span class="token plain">                Result: 5</span></div><div class="token-line"><span class="token plain">            Result: 15                //忽略递归的细节，得到结果是15</span></div><div class="token-line"><span class="token plain">        Result: 17                    //根节点的值是17</span></div></pre></div><p>你可以运行一下示例程序看看输出结果，而且我十分建议你修改表达式，自己做做实验，并试着让表达式不符合语法，看看语法分析程序能不能找出错误来。</p><h2 id="课程小结"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#课程小结"><span class="icon icon-link"></span></a>课程小结</h2><p>今天我们实现了一个简单的公式计算器，尽管简单，相信你已经有了收获。那么我来总结一下今天的重点：</p><ul><li>初步了解上下文无关文法，知道它能表达主流的计算机语言，以及与正则文法的区别。</li><li>理解递归下降算法中的“下降”和“递归”两个特点。它跟文法规则基本上是同构的，通过文法一定能写出算法。</li><li>通过遍历AST对表达式求值，加深对计算机程序执行机制的理解。</li></ul><p>在后面的课程中，我们会在此基础上逐步深化，比如在变量声明中可以使用表达式，在表达式中可以使用变量，例如能够执行像这样的语句：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int A = 17；</span></div><div class="token-line"><span class="token plain">    int B = A + 10*2;</span></div></pre></div><p>实现了上述功能以后，这个程序就越来越接近一个简单的脚本解释器了！当然，在此之前，我们还必须解决左递归的问题。所以下一讲，我会带你填掉左递归这个坑。我们学习和工作的过程，就是在不停地挖坑、填坑，你要有信心，只要坚强走过填坑这段路，你的职业生涯将会愈发平坦！</p><h2 id="一课一思"><a aria-hidden="true" tabindex="-1" href="/blog/编译原理之美/02.实现一门脚本语言·原理篇/03#一课一思"><span class="icon icon-link"></span></a>一课一思</h2><p>递归算法是很好的自顶向下解决问题的方法，是计算机领域的一个核心的思维方式。拥有这种思维方式，可以说是程序员相对于非程序员的一种优势。</p><p>那么，你是否用递归算法或递归思维解决过工作中或者生活中存在的某些问题？你能否再找一些证据证明一下，哪些语法规则只能用上下文无关文法表达，用正则文法是怎样都写不出来的？ 欢迎在留言区和我一起讨论。</p><p>最后，十分感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p><p>另外，为了便于你更好地学习，我将本节课的示例程序放到了<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/lab/craft/SimpleCalculator.java">码云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a target="_blank" rel="noopener noreferrer" href="https://github.com/RichardGong/PlayWithCompiler/blob/master/lab/craft/SimpleCalculator.java">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上，你可以看一下。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/编译原理之美/02.实现一门脚本语言·原理篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
