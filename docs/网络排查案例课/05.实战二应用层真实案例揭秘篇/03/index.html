<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>16 | 服务器为什么回复HTTP 400？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/网络排查案例课/05.实战二应用层真实案例揭秘篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/网络排查案例课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/网络排查案例课/01.开篇词/01"><span>开篇词 | 网络排查是工程师的必备能力</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/02.预习篇">02.预习篇</a><ul><li><a href="/blog-base/网络排查案例课/02.预习篇/01"><span>01 | 网络模型和工具：网络为什么要分层？</span></a></li><li><a href="/blog-base/网络排查案例课/02.预习篇/02"><span>02 | 抓包分析技术初探：你会用tcpdump和Wireshark吗？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇">03.实战一TCP真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/01"><span>03 | 握手：TCP连接都是用TCP协议沟通的吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/02"><span>04 | 挥手：Nginx日志报connection reset by peer是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/03"><span>05 | 定位防火墙（一）：传输层的对比分析</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/04"><span>答疑（一）| 第1~5讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/05"><span>06 | 定位防火墙（二）：网络层的精确打击</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/06"><span>07 | 保活机制：心跳包异常导致应用重启？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/07"><span>08 | 分段：MTU引发的血案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/08"><span>09 | 长肥管道：为何文件传输速度这么慢？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09"><span>10 | 窗口：TCP Window Full会影响传输效率吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/10"><span>答疑（二）| 第6~10讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/11"><span>11 | 拥塞：TCP是如何探测到拥塞的？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/12"><span>12 | 重传的认识：重传到底是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/13"><span>13 | 重传的再认识：没有任何丢包却也一直重传？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/14"><span>14 | 安全：用Wireshark把DDoS攻击照出原形</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送">04.春节特别放送</a><ul><li><a href="/blog-base/网络排查案例课/04.春节特别放送/01"><span>春节特别放送（一）| 书单推荐</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/02"><span>春节特别放送（二）| 聊聊能力陷阱和终身学习</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/03"><span>春节特别放送（三）| 我的学习资料和工具</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/04"><span>春节特别放送（四）| 测一测你的网络排查能力</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇">05.实战二应用层真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/01"><span>15 | Nginx的499状态码是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/02"><span>答疑（三）| 第11~15讲思考题答案</span></a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03"><span>16 | 服务器为什么回复HTTP 400？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/04"><span>17 | 为什么前端页面里多选一个城市就报错？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/05"><span>18 | 偶发性问题如何排查？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06"><span>19 | TLS的各种特性：TLS握手为什么会失败？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/07"><span>20 | TLS加解密：如何解密HTTPS流量？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/08"><span>答疑（四）| 第16~20讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/09"><span>21 | 为什么用了负载均衡更加不均衡？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10"><span>22 | 为什么压力测试TPS总是上不去？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇">06.实战三不用抓包就能做的网络排查篇</a><ul><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/01"><span>23 | 路径排查：没有网络设备权限要如何做排查？</span></a></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/02"><span>24 | 丢包：如何确定丢包的存在及其程度？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐">07.不定期加餐</a><ul><li><a href="/blog-base/网络排查案例课/07.不定期加餐/01"><span>不定期加餐（一） | 八仙过海，各显神通：透传真实源IP的各种方法</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/02"><span>用户故事 | 小S：学习是人生路上生生不息的活泉</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/03"><span>用户故事 | 王未：网络排查能力是一名合格运维工程师的必备技能</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/08.总结篇">08.总结篇</a><ul><li><a href="/blog-base/网络排查案例课/08.总结篇/01"><span>25 | 抓包分析的回顾、拾遗，和提高</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/02"><span>结束语 | 珍惜握手，难说再见</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/03"><span>结课测试 | “网络排查案例课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/summary">网络排查案例课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="HTTP协议的前世今生" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#http协议的前世今生"><span>HTTP协议的前世今生</span></a></li><li title="案例：服务器为什么回复HTTP 400？" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#案例服务器为什么回复http-400"><span>案例：服务器为什么回复HTTP 400？</span></a></li><li title="开始排查" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#开始排查"><span>开始排查</span></a></li><li title="究竟什么是HTTP 400？" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#究竟什么是http-400"><span>究竟什么是HTTP 400？</span></a></li><li title="寻找突破口" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#寻找突破口"><span>寻找突破口</span></a></li><li title="Authorization头部" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#authorization头部"><span>Authorization头部</span></a></li><li title="HTTP报文分隔" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#http报文分隔"><span>HTTP报文分隔</span></a></li><li title="定位不合规处" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#定位不合规处"><span>定位不合规处</span></a></li><li title="实验" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验"><span>实验</span></a></li><li title="实验1：对HTTP发送不合规的请求" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验1对http发送不合规的请求"><span>实验1：对HTTP发送不合规的请求</span></a></li><li title="实验2：对HTTPS发送不合规的请求" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验2对https发送不合规的请求"><span>实验2：对HTTPS发送不合规的请求</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="16--服务器为什么回复http-400"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#16--服务器为什么回复http-400"><span class="icon icon-link"></span></a>16 | 服务器为什么回复HTTP 400？</h1><p>你好，我是胜辉。</p><p>在上节课里，我们回顾了一个与HTTP协议相关的Nginx 499的案例。在应用层的众多“明星”里，HTTP协议无疑是“顶流”了，可以说目前互联网上的大部分业务（电商、社交等），都是基于HTTP协议，当然也包括我们用极客时间学习的时候，也是在用HTTP。那么相应的，<strong>HTTP方面的排查能力</strong>，对于我们做开发和运维技术工作来说，就更加重要了。因为不少现实场景中的故障和难题，就与我们对HTTP的理解以及排查能力，有着密切的联系。</p><p>所以这一讲，我们会来看一个HTTP相关的报错案例，深入学习这其中的排查技巧。同时，我也会带你学习HTTP这个重要协议的规范部分。这样，以后你处理类似的像HTTP 4xx、5xx的报错，或者其他跟HTTP协议本身相关的问题时，就有分寸，知道问题大概的方向在哪里、如何开展排查了。</p><p>那么在介绍案例之前，我们先简单地回顾一下HTTP协议。</p><h2 id="http协议的前世今生"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#http协议的前世今生"><span class="icon icon-link"></span></a>HTTP协议的前世今生</h2><p>HTTP的英文全称是Hypertext Transfer Protocol，中文是超文本传输协议，它的奠基者是英国计算机科学家蒂姆·博纳斯·李（Tim Berners-Lee）。1990年，他为了解决任职的欧洲核子研究组织（CERN）里，科学家们无法方便地分享文件和信息的问题，由此创造了HTTP协议。</p><p>实际上，在当时也有其他一些协议能实现信息共享的功能，比如FTP、SMTP、NNTP等，为什么还要另外创造HTTP呢？这是因为这些协议并不满足博纳斯·李的需求，比如：</p><ul><li>FTP只是用来传输和获取文件，它无法方便地展示文本和图片；</li><li>NNTP用来传输新闻，但不适合展示存档资料；</li><li>SMTP是邮件传输协议，缺乏目录结构。</li></ul><p>而博纳斯·李需要的是“图形化的、只要点击一下就能进入到其他资料的系统”。鉴于以上协议无法实现，他就设计了HTTP。也因为这个巨大的贡献，博纳斯·李获得了2016年的图灵奖，可以说是图灵奖的一次“回国”。</p><p>在2015年之前，HTTP先后有0.9、1.0、1.1三个版本，其中HTTP/1.0和1.1合称HTTP/1.x。虽然谷歌在2009年就提出了SPDY，但最终被接纳成为HTTP/2，也已经是2015年的事了。最近几年蓬勃发展的还有HTTP/3（也就是QUIC上的HTTP/2）。**但从语义上说，HTTP/2跟HTTP/1.x是保持一致的。**HTTP/2不同，主要是在传输过程中，在TCP和HTTP之间，增加了一层传输方面的逻辑。</p><blockquote><p>补充：<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7540">RFC7540<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>定义了HTTP/2的协议规范，而HTTP/1.1在1999年6月的<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc2616">RFC2616<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里已经确定了大部分内容。</p></blockquote><p>什么叫做“语义上是一致的”呢？举个例子，在HTTP/2里面，header和body的定义和规则，就跟HTTP/1.x一样。比如 <code>User-agent: curl/7.68.0</code> 这样一个header，在HTTP/1.x里是代表了这次访问的客户端的名称和版本，而在HTTP/2里，依然是这个含义，没有任何变化。</p><p>从这一点上看，你甚至可以把HTTP/2理解为是在HTTP/1.x的语义的基础上，增加了一个介于TCP和HTTP之间的新的“传输层”。也就是下图这样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage7812784ef6da887086ef500b955b90dc2512.jpg" alt=""/></p><p>目前最新的HTTP/3仍在讨论过程中，还未正式发布。它也依然保持了之前版本HTTP的语义，但在传输层上做了彻底的“革命”：把传输层协议从TCP换成了 <strong>UDP</strong>。根据w3techs.com（一家网络技术调查网站）的<a target="_blank" rel="noopener noreferrer" href="https://w3techs.com/technologies/details/ce-http3">数据<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，截至2022年2月22日，有25.2%的站点已经支持了HTTP/3。</p><p>好，回顾完HTTP的历史，我们已经比较清楚它的来龙去脉了。那么接下来要讲的案例，就会帮助我们拆解HTTP协议的一些细节，梳理对这种类型的问题的排查思路。</p><h2 id="案例服务器为什么回复http-400"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#案例服务器为什么回复http-400"><span class="icon icon-link"></span></a>案例：服务器为什么回复HTTP 400？</h2><p>这是前几年我在公有云服务时候的一个案例。当时一个客户测试我们的对象存储服务，这个服务是通过HTTP协议存放和读取文件的。它比较适合存放非结构化的数据，比如日志文件、图片文件等。因为依托于HTTP协议，浏览这种存储的方法很方便，比如用浏览器就可以直接访问。</p><p>但是，在客户的测试结果中报告大量HTTP 400的报错。我们也很意外，其他客户用的都挺好，为什么这个客户就不行呢？</p><h3 id="开始排查"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#开始排查"><span class="icon icon-link"></span></a>开始排查</h3><p>按照惯例，我们还是进行了抓包。这次是在客户端抓取的，我们看一下Expert Information：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagecbe7cb1521098f852a9642462d4e0a36cee7.jpg" alt="图片"/></p><p>其中，我们需要重点关注HTTP事务，也就是上图中的<code>Chat HTTP/1.1 200 OK\r\n</code>这部分，这里面都是HTTP事务的报文。由于第一个被Wireshark判定为HTTP事务的报文，是一个HTTP 200 OK的返回报文，所以就显示为这里的Summary栏的信息。</p><blockquote><p>补充：这里我修改过抓包，所以展现在Expert Information里面的样子，跟正常抓取完整报文的情况略有不同。比如这个示例文件里，第一个HTTP报文其实是POST，那么Summary栏显示的，应该是POST请求而不是HTTP/1.1 200 OK。但是，这不影响排查和分析。</p></blockquote><p>既然这次是明确要排查HTTP 400报错，所以我们直接点开这些HTTP事务：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage9eb09eaa90c8d33c5b4f73b600ba4530a1b0.jpg" alt="图片"/></p><p>可见，这里有200 OK这样的正常响应，也有400 Bad Request这样的异常响应。</p><p>我们找一个请求，Follow TCP Stream来看一下详细情况。比如，我们选中23号报文，此时主界面也自动跳转到了这个报文的位置。我们选中它，右单击后选择Follow -&gt; TCP Stream：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage140d14564a4652fcb3ea42639ede9e36920d.jpg" alt="图片"/></p><p>我们来看一下整个TCP流：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage615f61fe4d82d3fc9e02137e8f3e572d0c5f.jpg" alt="图片"/></p><p>在Wireshark里，HTTP请求是红色字体，而HTTP响应是蓝色字体。显然，紧随在请求之后就是响应了，而蓝色字的第一行就是HTTP/1.1 400 Bad Request。这就是我们要排查的问题。</p><p>然后我们需要搞清楚问题的定义了：HTTP 400到底是什么？</p><h3 id="究竟什么是http-400"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#究竟什么是http-400"><span class="icon icon-link"></span></a>究竟什么是HTTP 400？</h3><p>要回答这个问题，最准确的办法，还是<strong>阅读RFC</strong>，看看标准里面到底怎么说。HTTP的RFC有过好几版，1999年6月的<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc2616">RFC2616<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>确定了HTTP的大部分规范，而后在<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7230">7230<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7231">7231<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc7232">7232<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等RFC中做了更新和细化。RFC2616是这样定义400 Bad Request的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">400 Bad Request</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">       The request could not be understood by the server due to malformed</span></div><div class="token-line"><span class="token plain">       syntax. The client SHOULD NOT repeat the request without</span></div><div class="token-line"><span class="token plain">       modifications.</span></div></pre></div><p>也就是：这个请求因为语法错误而无法被服务端理解。客户端不可以不做修改就重复同样的请求。</p><p>此外，RFC2616里还定义了几种必须返回400的情况，比如：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">A client MUST include a Host header field in all HTTP/1.1 request</span></div><div class="token-line"><span class="token plain">       messages . If the requested URI does not include an Internet host</span></div><div class="token-line"><span class="token plain">       name for the service being requested, then the Host header field MUST</span></div><div class="token-line"><span class="token plain">       be given with an empty value. An HTTP/1.1 proxy MUST ensure that any</span></div><div class="token-line"><span class="token plain">       request message it forwards does contain an appropriate Host header</span></div><div class="token-line"><span class="token plain">       field that identifies the service being requested by the proxy. All</span></div><div class="token-line"><span class="token plain">       Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)</span></div><div class="token-line"><span class="token plain">       status code to any HTTP/1.1 request message which lacks a Host header</span></div><div class="token-line"><span class="token plain">       field.</span></div></pre></div><p>其他还有好几种情况，就不一一罗列了。</p><p>那么显然，400 Bad Request的语义，就是让服务端告诉客户端：<strong>你发过来的请求不合规，我无法理解，所以我用400来告诉你这一点</strong>。</p><p>但是，我们也不可能去穷举所有可能出现的不合规类型。那么在这个案例里面，究竟是哪里出了问题呢？</p><h3 id="寻找突破口"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#寻找突破口"><span class="icon icon-link"></span></a>寻找突破口</h3><p>有时候，我们做排查工作，需要一点灵感，也需要一点耐心。对着这个页面，如果你对HTTP协议并不是很熟悉，那么很难直接用肉眼就“看出”问题来。</p><p>那我们来玩个游戏怎么样：“大家来找茬”。你应该已经明白我的意思了，我们要做的是：<strong>对比分析</strong>。我们只需要把一个正常和一个异常的响应报文放在一起比较，也许就能找到原因了。</p><p>正巧，这次客户做的测试里，也有成功的请求。比如这个抓包文件里的HTTP 200 OK。那么，我们就借助这样的一个200 OK的TCP流，来对比分析下。</p><p>说到这里，你可能已经想起我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/481042">第5讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候，也用过这种对比分析的方法。当时是排查一个乱序引起应用层故障的问题，我们对比了客户端抓包文件和服务端抓包文件这两个文件，而它们代表的是同一个TCP流，我们也因此找到了问题的关键，也就是防火墙引发了报文乱序的现象。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagec047c0a13a14a7ab884e0439c78c124f0d47.jpg" alt=""/></p><p>当前的案例跟第5讲的案例就有所不同了，这次比较的是同一个抓包文件里的两个不同的TCP流，也可以说是两个不同的应用层事务。这两个事务，一个成功，一个失败。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea4f3a4324897b7f11c9285ff1807fcef6ff3.jpg" alt=""/></p><p>我们还是需要一个大一点的显示屏，把HTTP 200的报文找到后，Follow TCP Stream，随后的弹窗里就展示了这次成功的应用层消息的细节；然后选取HTTP 400的报文，也同样做一遍。然后我们把两个窗口挪到齐平的位置。</p><p>好，我们的对比开始了：</p><p><img src="/images/httpsstatic001geekbangorgresourceimageb659b6d491f6b8a5085163650129a9dc1559.jpg" alt="图片"/></p><p>你能找到几个“茬”呢？因为这是两次不同的事务，所以请求和回复的字符肯定也十分不同，所以我们应该集中在<strong>格式</strong>上，而不是字符。</p><p>你可能首先注意到了两次的HTTP方法不同：左边是PUT，右边是POST。</p><p>这是否说明，问题就是服务端不支持PUT方法导致了HTTP 400呢？这个很容易排除。因为，如果真的是服务端对PUT的处理有问题，那么其他客户还怎么使用PUT呢？所以，即使这个问题跟PUT还是有点关系的话，我们也要转换一下问题描述，变成：<strong>为什么这个客户端发送的PUT请求会引起HTTP 400？</strong></p><p>然后，你可能会发现，左边的PUT请求里有Authorization头部，而右边POST请求里没有这个头部。</p><p>左边这个Authorization请求的头部格式是这样的：</p><ul><li>一开始是 <code>PUT /123456 HTTP/1.1</code>，然后换行；</li><li>接着是 <code>Authorization: UCloud</code> 这样一个头部，然后换行；</li><li>然后是 <code>abc@def.com:blahblah</code> 这种形式，看起来是一个邮箱地址后接冒号，然后是一串编码过的字符串。</li></ul><p>你是不是觉得这部分的格式有点问题？这其实也是一个知识点了：HTTP Authorization头部的格式。</p><h3 id="authorization头部"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#authorization头部"><span class="icon icon-link"></span></a>Authorization头部</h3><p>我们看看<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc2616#section-14.8">RFC2616<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里，对Authorization头部是怎么规定的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">14.8 Authorization</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          A user agent that wishes to authenticate itself with a server--</span></div><div class="token-line"><span class="token plain">          usually, but not necessarily, after receiving a 401 response--does</span></div><div class="token-line"><span class="token plain">          so by including an Authorization request-header field with the</span></div><div class="token-line"><span class="token plain">          request.  The Authorization field value consists of credentials</span></div><div class="token-line"><span class="token plain">          containing the authentication information of the user agent for</span></div><div class="token-line"><span class="token plain">          the realm of the resource being requested.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">              Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials</span></div></pre></div><p>简单来说，它也跟其他的HTTP头部的规定一样，也是 <code>key:value</code> 的形式。语法格式是这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Authorization: &lt;auth-scheme&gt; &lt;authorization-parameters&gt;</span></div></pre></div><blockquote><p>补充：如果要了解关于这个头部的更多细节，还可以参考Mozilla Developer Network关于这个头部的更多的<a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">详细介绍<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote><p>这里的 <code>&lt;auth-scheme&gt;</code>，比较常见的是Basic和Digest。如果是Basic类型，那么它的格式是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Authorization: Basic &lt;credentials&gt;</span></div></pre></div><p>这里的credentials，可以是 <code>username@site.com:hashedPassword</code> 这种形式。</p><p>而我们在抓包里看到的是什么格式呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Authorization: UCloud</span></div><div class="token-line"><span class="token plain">    ucloudabcdef.yu@testtest.com144731865200013974915:gABCDEFGQSLLsdyOjIlo21fap6o=</span></div><div class="token-line"><span class="token plain">            #这里是一个空行</span></div></pre></div><p>这个 <code>Authorization: UCloud</code> 后面多了一个换行，这就已经是一个问题了。</p><p>更严重的是，在第二行的后面，有两次回车，或者说两次CRLF，而这个问题更加严重。说到这里，我们就需要复习一下HTTP报文格式的知识了。</p><h3 id="http报文分隔"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#http报文分隔"><span class="icon icon-link"></span></a>HTTP报文分隔</h3><p>跟IP、TCP类似，HTTP也分为头部（headers）和载荷（body或者payload）。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage7cef7c8f99a2ee15a21da8a1d60da1c6eeef.jpg" alt=""/></p><p>既然分成了两个部分，那么显然，接收者需要知道header和payload的分界线，要不然就会导致信息解读错误，这是致命的。</p><p><strong>在IP协议里</strong>，IP header是用一个Total Length字段，表示了包含IP头部在内的整个IP报文的长度。那怎么区分IP头部和载荷呢？IP头部还有一个字段是Header Length，表示了头部自身的长度。这样两个Length值的差，就是IP载荷的大小了。</p><p><strong>在TCP协议里</strong>，TCP header里的Data offset，表示了TCP载荷开始的位置（也是TCP头部截止的位置），也就相应地可以计算出TCP头部的长度。那么TCP载荷长度是怎么来的呢？我们用一个简单的减法就好了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">TCP payload Length = IP Total Length - IP Header Length - TCP Header Length</span></div></pre></div><p>这些头部长度的关系，我用了一张示意图来概括，供你参考：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage58d3588f8a3ec1f6b5e9ed30d77a546112d3.jpg" alt=""/></p><p><strong>而在HTTP里</strong>，载荷的长度一般也是由一个HTTP header（这里指的是某一个头部项，而不是整个HTTP头部），也就是Content-length来表示的。假设你有一次PUT或者POST请求，比如上传一个文件，那么这个文件的大小，就会被你的HTTP客户端程序（无论是curl还是Chrome等）获取到，并设置为Content-Length头部的值，然后把这个header封装到整体的HTTP请求报文中去。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebe2abe79d3c36ae164284yycc2cef58cf42a.jpg" alt="图片"/></p><p>既然HTTP报文内容，分成了头部（headers）和载荷（Payload或者body）两部分，那么这两者的分界线在哪呢？</p><p><strong>HTTP规定，头部和载荷的分界线是两次CRLF。</strong></p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">A request message from a client to a server includes, within the</span></div><div class="token-line"><span class="token plain">       first line of that message, the method to be applied to the resource,</span></div><div class="token-line"><span class="token plain">       the identifier of the resource, and the protocol version in use.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            Request       = Request-Line              ; Section 5.1</span></div><div class="token-line"><span class="token plain">                            *(( general-header        ; Section 4.5</span></div><div class="token-line"><span class="token plain">                             | request-header         ; Section 5.3</span></div><div class="token-line"><span class="token plain">                             | entity-header ) CRLF)  ; Section 7.1</span></div><div class="token-line"><span class="token plain">                            CRLF</span></div><div class="token-line"><span class="token plain">                            [ message-body ]          ; Section 4.3</span></div></pre></div><p>也就是在最后一个header之后，需要有两个CRLF，这就是头部和载荷之间的分割线。之后就是载荷（message body）的开始了。</p><p>那么，前面引发HTTP 400的PUT请求，其Authorization后面也出现了两个CRLF，这就会被认为是headers的结束，payload的开始。但实际上，后面跟的又是剩余的HTTP头部项，在最后一个头部之后，又是两个CRLF。所以这对于Web服务端来说就懵了：“你这说的可不是人话啊！我只能表示我不理解。”</p><p><img src="/images/httpsstatic001geekbangorgresourceimage41bb41ebb0e77beb6219a4acdee855f947bb.jpg" alt="图片"/></p><h3 id="定位不合规处"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#定位不合规处"><span class="icon icon-link"></span></a>定位不合规处</h3><p>原来如此，这次的<strong>400 Bad Request的根因，是客户发送的HTTP PUT请求的格式出现了问题</strong>。它违背了HTTP/1.1（RFC2616）的规定，在Authorization头部后面，错误地添加了两次回车（CRLF）。这样就导致服务端认为，后续的数据都属于payload，也就导致服务器无法正常读取这个请求，只能用HTTP 400来反馈这种状况了。</p><p>既然咱们的课程叫“网络排查案例课”，那么这次案例的根因，跟网络有没有关系呢？</p><p>我觉得要看你怎么定义“网络”。</p><p>如果是传统和狭义上的网络，只包含交换机、路由器、防火墙、负载均衡等环节，那么这里并没有什么问题。没什么重传，也不丢包，更不影响应用消息本身。</p><p>如果是广义的网络，那就包含了至少以下几个领域：</p><ul><li>对应用层协议的理解；</li><li>对传输层和应用层两者协同的理解；</li><li>对操作系统的网络部分的理解。</li></ul><p>在这个案例里，我们依托于<strong>对应用层协议的理解</strong>，找到了网络行为以外的根因。这个根因虽然可能根源是开发方面的问题，但无论是开发、运维或者SRE，在处理这种问题的时候，如果能具备比较全面的知识，从而推导出根因，那么无论是对组织效率的提升，还是个人能力的提升，是不是都更有意义呢？</p><h2 id="实验"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验"><span class="icon icon-link"></span></a>实验</h2><p>现在，我们也来做几个简便的小实验，模拟出HTTP 400 Bad Request这样的响应。</p><h3 id="实验1对http发送不合规的请求"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验1对http发送不合规的请求"><span class="icon icon-link"></span></a>实验1：对HTTP发送不合规的请求</h3><p>如果我们直接用高级语言来调用HTTP库，可能反而不容易做到这种“非法”请求。因为这些库的设计目的之一，就是要尽量避免人工的编码错误以及提升开发效率，我们想借助它去构造非法请求，恐怕不太容易。</p><p>当然，如果你熟悉Python的话，可能会想到用Scapy库等工具来实现。但这个步骤就稍多了点。</p><p>其实，我们也可以用最简单的方法，就是直接用 <strong>telnet命令</strong>。我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/478189">第2讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里，用视频的形式介绍了如何一边用telnet模拟发送HTTP请求，一边用tcpdump的-X参数，展示抓取的报文里面的文本细节。</p><p>那么这里，我们也用类似的方法，只要手动执行下面的命令，就可以向目标站点发送一个不合规的请求：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ telnet www.baidu.com 80</span></div><div class="token-line"><span class="token plain">    Trying 180.101.49.12...</span></div><div class="token-line"><span class="token plain">    Connected to www.a.shifen.com.</span></div><div class="token-line"><span class="token plain">    Escape character is &#x27;^]&#x27;.</span></div><div class="token-line"><span class="token plain">    GET / HTTP/1.1</span></div><div class="token-line"><span class="token plain">    Authorization  #这里是一次回车</span></div><div class="token-line"><span class="token plain">                   #这里是又一次回车</span></div><div class="token-line"><span class="token plain">    HTTP/1.1 400 Bad Request</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Connection closed by foreign host.</span></div></pre></div><p>也就是telnet目标站点的80端口，在提示符下输入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">GET / HTTP/1.1</span></div></pre></div><p>然后回车，再输入：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Authorization</span></div></pre></div><p>注意这里不要输入更多内容，直接<strong>回车两次</strong>。这时，两次回车被对端Web服务器收到后，它是这么解读的：</p><ul><li>这是一个GET /的HTTP/1.1版本的请求。</li><li>有一个Authorization头部，但是这个头部并没有值。</li><li>两次回车就表示这次请求发送结束。</li></ul><p>由于请求不合规，目标站点立刻回复了HTTP 400 Bad Request。</p><p>而如果我们在输入Authorization时，后面加上“: Basic”，会收到HTTP 500。这是因为服务端认为Authorization: Basic这个格式本身是正确的，只是后面缺少了真正的凭据（Credential），所以报告了HTTP 500。</p><p>所以，两者的区别就是：</p><ul><li><strong>Authorization后面直接回车</strong>，就表示它并没有带上 <code>&lt;auth-scheme&gt;</code>，所以属于不合规，应该回复HTTP 400。</li><li><strong>Authorization: Basic后直接回车</strong>，它的Authorization头部有 <code>&lt;auth-scheme&gt;</code>，但是没有带上有效的凭据，应该回复HTTP 500。</li></ul><h3 id="实验2对https发送不合规的请求"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#实验2对https发送不合规的请求"><span class="icon icon-link"></span></a>实验2：对HTTPS发送不合规的请求</h3><p>前面实验的是HTTP站点，我们用telnet发送明文请求比较直观。而要是对方站点是HTTPS的话，如果还是用telnet，会遇到TLS握手，这一关就过不去了。那么该怎么办呢？</p><p>其实，我们可以用<strong>openssl命令</strong>。执行<code>openssl s_client \-connect 站点名:443</code>，就可以跟对端站点建立TLS握手。比如像下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ openssl s_client -connect www.baidu.com:443</span></div><div class="token-line"><span class="token plain">    CONNECTED(00000006)</span></div><div class="token-line"><span class="token plain">    depth=2 C = BE, O = GlobalSign nv-sa, OU = Root CA, CN = GlobalSign Root CA</span></div><div class="token-line"><span class="token plain">    verify return:1</span></div><div class="token-line"><span class="token plain">    depth=1 C = BE, O = GlobalSign nv-sa, CN = GlobalSign Organization Validation CA - SHA256 - G2</span></div><div class="token-line"><span class="token plain">    verify return:1</span></div><div class="token-line"><span class="token plain">    depth=0 C = CN, ST = beijing, L = beijing, OU = service operation department, O = &quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot;, CN = baidu.com</span></div><div class="token-line"><span class="token plain">    verify return:1</span></div><div class="token-line"><span class="token plain">    ---</span></div><div class="token-line"><span class="token plain">    ......</span></div></pre></div><p>另外还有一点，我们这个时候怎么发送HTTP请求呢？不少人会在这里卡住。其实，openssl也是一个交互式的命令，跟telnet一样，直接键入HTTP请求就好了！</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">---</span></div><div class="token-line"><span class="token plain">    GET / HTTP/1.1</span></div><div class="token-line"><span class="token plain">    Authorization  #这里是一次回车</span></div><div class="token-line"><span class="token plain">                   #这里是又一次回车</span></div><div class="token-line"><span class="token plain">    HTTP/1.1 400 Bad Request</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    closed</span></div></pre></div><p>这样一来，也可以得到跟telnet 80一样的响应。</p><p>其实，**网络协议就是这样，是一种“方言”，互相要用对方听得懂的方式对话。**如果语法出现了问题，我们的自然语言就是“不明白你的意思，你说啥”。在HTTP这个“方言”里，就是用HTTP 400表达了同样的意思。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们通过一个服务器回复HTTP 400的案例，学习了这种对HTTP返回码进行排查的方法。</p><p>使用这种方法的前提，还是需要你对HTTP协议本身有比较深入的掌握，然后结合对HTTP语义的理解，分析出根因。而熟悉HTTP协议的方法，就是熟读RFC2616，以及2014年6月的更新RFC（7230, 7231, 7232, 7233, 7234, 7235）。</p><p>具体的方法，我们可以借鉴这样的方式：</p><ul><li>我们可以把错误的报文跟成功的报文放一起，进行<strong>对比分析</strong>。这样会比较快地发现两者之间的差别，从而更快地定位到根因。</li><li>我们也可以通过telnet和openssl，分别<strong>模拟复现HTTP和HTTPS的</strong>请求，重放给服务端，观察其是否也返回同样的报错。</li><li>对比协议规范和报文中抓取到的实际行为，找到不符合规范之处，很可能这就是根因。</li></ul><p>同时，我们也回顾了不少HTTP协议的知识，包括：</p><ul><li>HTTP的各种版本的知识点：<strong>HTTP/2和HTTP/3的语义跟HTTP/1.x是一致的</strong>，不同的是HTTP/2和HTTP/3在传输效率方面，采用了更加先进的方案。</li><li>Authorization头部的知识点：它的格式为 <code>Authorization: &lt;auth-scheme&gt; &lt;authorization-parameters&gt;</code>，如果缺少了某一部分，就可能引发服务端报HTTP 400或者500。</li><li>HTTP报文的知识点：<strong>两次回车（两个CRLF）是分隔HTTP头部和载荷的分隔符</strong>。</li><li>HTTP返回码的知识点：HTTP 400 Bad Request在语义上表示的是<strong>请求不符合HTTP规范</strong>的情况，各种不合规的请求都可能导致服务端回复HTTP 400。</li></ul><p>最后，我们通过两个小实验，学习了用简单的方式模拟HTTP请求的方法。如果服务端是HTTP，我们用telnet；如果服务端是HTTPS，就用openssl。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>给你留两道思考题：</p><ul><li>在HTTP请求里，我们用Content-Length表示了HTTP载荷，或者说HTTP body的长度，那有时候无法提前计算出这种长度，HTTP是如何表示这种“动态”的长度呢？</li><li>HTTP请求的动词加URL部分，比如GET /abc，它是属于headers，还是属于body，或者哪种都不属于，是独立的呢？</li></ul><p>你可以在留言区说说你的想法和思考，我们一起交流。另外也欢迎你把今天的内容分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/网络排查案例课/05.实战二应用层真实案例揭秘篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:35:51</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
