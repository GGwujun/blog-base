<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | TLS的各种特性：TLS握手为什么会失败？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/网络排查案例课/05.实战二应用层真实案例揭秘篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/网络排查案例课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/网络排查案例课/01.开篇词/01"><span>开篇词 | 网络排查是工程师的必备能力</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/02.预习篇">02.预习篇</a><ul><li><a href="/blog-base/网络排查案例课/02.预习篇/01"><span>01 | 网络模型和工具：网络为什么要分层？</span></a></li><li><a href="/blog-base/网络排查案例课/02.预习篇/02"><span>02 | 抓包分析技术初探：你会用tcpdump和Wireshark吗？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇">03.实战一TCP真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/01"><span>03 | 握手：TCP连接都是用TCP协议沟通的吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/02"><span>04 | 挥手：Nginx日志报connection reset by peer是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/03"><span>05 | 定位防火墙（一）：传输层的对比分析</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/04"><span>答疑（一）| 第1~5讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/05"><span>06 | 定位防火墙（二）：网络层的精确打击</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/06"><span>07 | 保活机制：心跳包异常导致应用重启？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/07"><span>08 | 分段：MTU引发的血案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/08"><span>09 | 长肥管道：为何文件传输速度这么慢？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09"><span>10 | 窗口：TCP Window Full会影响传输效率吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/10"><span>答疑（二）| 第6~10讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/11"><span>11 | 拥塞：TCP是如何探测到拥塞的？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/12"><span>12 | 重传的认识：重传到底是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/13"><span>13 | 重传的再认识：没有任何丢包却也一直重传？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/14"><span>14 | 安全：用Wireshark把DDoS攻击照出原形</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送">04.春节特别放送</a><ul><li><a href="/blog-base/网络排查案例课/04.春节特别放送/01"><span>春节特别放送（一）| 书单推荐</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/02"><span>春节特别放送（二）| 聊聊能力陷阱和终身学习</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/03"><span>春节特别放送（三）| 我的学习资料和工具</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/04"><span>春节特别放送（四）| 测一测你的网络排查能力</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇">05.实战二应用层真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/01"><span>15 | Nginx的499状态码是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/02"><span>答疑（三）| 第11~15讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03"><span>16 | 服务器为什么回复HTTP 400？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/04"><span>17 | 为什么前端页面里多选一个城市就报错？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/05"><span>18 | 偶发性问题如何排查？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06"><span>19 | TLS的各种特性：TLS握手为什么会失败？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/07"><span>20 | TLS加解密：如何解密HTTPS流量？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/08"><span>答疑（四）| 第16~20讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/09"><span>21 | 为什么用了负载均衡更加不均衡？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10"><span>22 | 为什么压力测试TPS总是上不去？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇">06.实战三不用抓包就能做的网络排查篇</a><ul><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/01"><span>23 | 路径排查：没有网络设备权限要如何做排查？</span></a></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/02"><span>24 | 丢包：如何确定丢包的存在及其程度？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐">07.不定期加餐</a><ul><li><a href="/blog-base/网络排查案例课/07.不定期加餐/01"><span>不定期加餐（一） | 八仙过海，各显神通：透传真实源IP的各种方法</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/02"><span>用户故事 | 小S：学习是人生路上生生不息的活泉</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/03"><span>用户故事 | 王未：网络排查能力是一名合格运维工程师的必备技能</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/08.总结篇">08.总结篇</a><ul><li><a href="/blog-base/网络排查案例课/08.总结篇/01"><span>25 | 抓包分析的回顾、拾遗，和提高</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/02"><span>结束语 | 珍惜握手，难说再见</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/03"><span>结课测试 | “网络排查案例课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/summary">网络排查案例课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是HTTPS？" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#什么是https"><span>什么是HTTPS？</span></a></li><li title="加密技术基础" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#加密技术基础"><span>加密技术基础</span></a></li><li title="TLS基础" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls基础"><span>TLS基础</span></a></li><li title="案例1：TLS握手失败" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#案例1tls握手失败"><span>案例1：TLS握手失败</span></a></li><li title="排除服务端问题" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#排除服务端问题"><span>排除服务端问题</span></a></li><li title="Cipher Suite" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#cipher-suite"><span>Cipher Suite</span></a></li><li title="案例2：有效期内的证书为什么报告无效？" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#案例2有效期内的证书为什么报告无效"><span>案例2：有效期内的证书为什么报告无效？</span></a></li><li title="TLS证书链" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls证书链"><span>TLS证书链</span></a></li><li title="TLS证书签名" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls证书签名"><span>TLS证书签名</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--tls的各种特性tls握手为什么会失败"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#19--tls的各种特性tls握手为什么会失败"><span class="icon icon-link"></span></a>19 | TLS的各种特性：TLS握手为什么会失败？</h1><p>你好，我是胜辉。</p><p>在前面三节课里，我带你排查了HTTP协议相关的问题。不知你有没有注意到，这三个案例里的HTTP都没有做加密，这就使得我们的排查工作省去了不少的麻烦，在抓包文件里直接就可以看清楚应用层的信息了。但在现实场景下，越来越多的站点已经做了HTTPS加密，所以像前面的三讲那样，在Wireshark里直接看到应用层信息的情况，已经越来越少了。</p><p>根据w3techs.com的<a target="_blank" rel="noopener noreferrer" href="https://w3techs.com/technologies/details/ce-httpsdefault">调查数据<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，目前Internet上78%以上的站点，都默认使用了HTTPS。显而易见，要对Internet上的问题做应用层方面的分析，TLS是一道绕不开的坎。</p><p>那你可能会问了：“我主要处理内网的问题，应该不用关心太多HTTPS的事了吧？”</p><p>这句话也许目前还勉强算对，但是随着各大企业不断推进零信任（<a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Zero_trust_security_model">Zero Trust<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）安全策略，越来越多的内网流量也终将运行在HTTPS上，内网和公网将没有区别。</p><p>所以说，掌握HTTPS/TLS的相关知识和排查技巧，对于我们开展网络排查来说，是一项必备的技能了。</p><p>那么接下来的两节课，我们会集中到HTTPS/TLS这个主题上，来全面学习一下它的工作原理、常见问题和排查思路。这样以后面临HTTPS/TLS的问题时，你就可以运用这两讲里学到的知识和方法，展开排查工作了。</p><h2 id="什么是https"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#什么是https"><span class="icon icon-link"></span></a>什么是HTTPS？</h2><p>首先我们要认识一下HTTPS。它其实不是某个独立的协议，而是HTTP over TLS，也就是把HTTP消息用TLS进行加密传输。两者相互协同又各自独立，依然遵循了网络分层模型的思想：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagee872e84ea94b614dcb227ecfeeb158cc9a72.aa9d04bf.jpg" alt=""/></p><blockquote><p>补充：这也就是我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/477510">第1讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>学习网络分层模型时候的图。</p></blockquote><p>为了更好地理解HTTPS，我们也来简单学习一下加密技术，因为它是HTTPS的核心。</p><h3 id="加密技术基础"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#加密技术基础"><span class="icon icon-link"></span></a>加密技术基础</h3><p>加密技术其实也是一个古老的话题。早在公元前400年，斯巴达人就创造了密码棒加密法。就是把纸条缠绕在一根木棒上，然后在纸上写字，这张纸条离开这根木棒后，就无法正确读取了。要“破解”它，就得找到同样粗细的木棒，然后把纸条绕上去后，才能解读。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage944a949941bea434b5b7a9407fd2d73c134a.e151e064.png" alt=""/></p><p>那么在这里，纸条就相当于密文，而木棒，就相当于密钥了。而因为加密和解密用的木棒是相同的，所以它属于<strong>对称加密算法</strong>。</p><p>时间推进到现代，密码专家们已经开发出了众多优秀的对称加密算法，比如AES、DES。与木棒加密法类似，Alice和Bob都知道同一把密钥，Alice用这个密钥做加密，Bob收到密文后，也是用这把密钥做解密，就得到了明文。如下图所示：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage971b975da34817e7154f4fyy27b943862c1b.a90409d4.jpg" alt=""/></p><p>另外一类算法就是<strong>非对称算法</strong>，这也是PKI（<a target="_blank" rel="noopener noreferrer" href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD">公开密钥架构<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）的基础。在非对称算法中，加密和解密用了不同的密钥，这两个密钥形成了密钥对。比如Bob和Alice都各自生成了密钥对，然后互相交换了公钥。Alice用Bob的公钥对明文做了加密，变成密文传给Bob。Bob收到后，用自己的私钥解密，就还原出了明文。如下图所示：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage52e952aceaa7c0c2b358b1db90fa94dc63e9.4e05980e.jpg" alt=""/></p><h3 id="tls基础"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls基础"><span class="icon icon-link"></span></a>TLS基础</h3><p>那么TLS跟加密技术的关系具体是怎样的呢？实际上，<strong>TLS同时使用了对称算法和非对称算法</strong>。TLS的整个过程大致可以分为两个主要阶段：</p><ul><li>握手阶段，完成验证，协商出密码套件，进而生成对称密钥，用于后续的加密通信。</li><li>加密通信阶段，数据由对称加密算法来加解密。</li></ul><p>TLS综合利用了对称算法和非对称算法的优点，因为对称算法的效率高，而非对称算法的安全性高，所以两者结合，就兼顾到了效率和安全性。不得不说，TLS确实是一个很精妙的设计。</p><p>那么同样地，我们对TLS相关问题的排查，也就面临着<strong>两类问题</strong>：一类是TLS握手阶段的问题，一类是TLS通信过程中的问题。</p><p>在TLS握手阶段，真正的加密还没开始，所以依托于明文形式的握手信息，我们还有可能找到握手失败的原因。在这一阶段，我们需要掌握TLS握手的原理和技术细节，这样才能指导我们展开排查工作。</p><p>而在TLS数据交互阶段，加密已经开始，所有的数据已经是密文了。假如应用层发生了什么，而我们又看不到，那如何做排查呢？这个时候，我们需要<strong>把密文解密</strong>，才能找到根因。不过你可能会问：“TLS要是能随便解密，是不是说明这个协议还有漏洞啊？”</p><p>放心，TLS是很安全的。我说的解密，当然是有前提条件的，跟数据安全性并不冲突。具体的细节，我到下节课会给你详细展开。</p><p>下面呢，我们就来看看案例，一起来学习下TLS握手失败的问题排查思路。</p><h2 id="案例1tls握手失败"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#案例1tls握手失败"><span class="icon icon-link"></span></a>案例1：TLS握手失败</h2><p>TLS握手失败，估计你也遇到过。引起这个问题的原因还是比较多的，比如域名不匹配、证书过期等等。不过，这些问题一般都可以通过“忽略验证”这个简单的操作来跳过。比如，在浏览器的警告弹窗里点击“忽略”，就可以让整个TLS的过程继续下去。</p><p>而还有一些问题，就无法跳过了。</p><p>我们曾经遇到的一个例子就是这样。当时，我们有一个应用需要访问Kubernetes集群的API server。因为我们有很多个集群，所以相应的API server也有很多个。这个问题是，从同一台客户端去访问API server 1是可以的，但访问API server 2就不行。进而发现，失败原因就是TLS握手失败。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage8e528e4fb5692af4f8b36f62b4b70c8af952.b80e8484.jpg" alt=""/></p><p>在客户端的应用日志里，报告的是这段错误：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure</span></div></pre></div><p>这段日志有没有告诉我们有价值的信息呢？好像并不多，只是告诉我们握手失败了。这也是我反复提及的，网络排查中两大鸿沟之一的<strong>应用现象跟网络现象之间的鸿沟</strong>：你可能看得懂应用层的日志，但是不知道网络上具体发生了什么。</p><blockquote><p>补充：我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/480068">第4讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里有介绍这两大鸿沟，我们要在网络排查方面取得实质性的进步，关键在于突破这两个鸿沟。</p></blockquote><p>同样的，这里的日志也无法告诉我们：到底TLS握手哪里出了问题。所以我们需要做点别的事情。</p><h3 id="排除服务端问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#排除服务端问题"><span class="icon icon-link"></span></a>排除服务端问题</h3><p>首先，我们用另外一个趁手的小工具 <strong>curl</strong>，从这台客户端发起对API server 2（也就是握手失败的那个）的TLS握手，发现其实是可以成功的。这说明，API server 2至少在某些条件下是可以正常工作的。我们来看一下当时的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">curl -vk https://api.server.777.abcd.io</span></div><div class="token-line"><span class="token plain">    * Rebuilt URL to: https://api.server.777.abcd.io/</span></div><div class="token-line"><span class="token plain">    * Trying 10.100.20.200...</span></div><div class="token-line"><span class="token plain">    * Connected to api.server.777.abcd.io (10.100.20.200) port 443 (#0)</span></div><div class="token-line"><span class="token plain">    * found 153 certificates in /etc/ssl/certs/ca-certificates.crt</span></div><div class="token-line"><span class="token plain">    * found 617 certificates in /etc/ssl/certs</span></div><div class="token-line"><span class="token plain">    * ALPN, offering http/1.1</span></div><div class="token-line"><span class="token plain">    * SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256</span></div><div class="token-line"><span class="token plain">    * server certificate verification SKIPPED</span></div><div class="token-line"><span class="token plain">    * server certificate status verification SKIPPED</span></div><div class="token-line"><span class="token plain">    * common name: server (does not match &#x27;api.server.777.abcd.io&#x27;)</span></div><div class="token-line"><span class="token plain">    * server certificate expiration date OK</span></div><div class="token-line"><span class="token plain">    * server certificate activation date OK</span></div><div class="token-line"><span class="token plain">    * certificate public key: RSA</span></div><div class="token-line"><span class="token plain">    * certificate version: #3</span></div><div class="token-line"><span class="token plain">    * subject: CN=server</span></div><div class="token-line"><span class="token plain">    * start date: Thu, 24 Sep 2020 21:42:00 GMT</span></div><div class="token-line"><span class="token plain">    * expire date: Tue, 23 Sep 2025 21:42:00 GMT</span></div><div class="token-line"><span class="token plain">    * issuer: C=US,ST=San Francisco,L=CA,O=My Company Name,OU=Org Unit 2,CN=kubernetes-certs</span></div><div class="token-line"><span class="token plain">    * compression: NULL</span></div></pre></div><blockquote><p>补充：在第8行可以看到协商出的密码套件 <code>* SSL connection using TLS1.2 / ECDHE_RSA_AES_128_GCM_SHA256</code>。</p></blockquote><p>既然curl是可以TLS握手成功的，那是不是客户端程序本身有点问题呢？我们就进行了“问题复现”。在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/491017">上节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里我们讨论了偶发性问题的“复现+抓包”的策略，而这里的问题是必现的，所以只要发起一次请求，同时做好抓包就可以了。</p><p>我们来看一下抓包文件：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage37dd37326f7b60d56b9c7dc0yy74afd430dd.faba6472.jpg" alt="图片"/></p><p>还真是“话不投机半句多”，客户端也就发了一个Client Hello报文，服务端就回复TLS Alert报文，结束了这次对话。那为啥聊不起来呢？我们看一下这个Alert报文：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage217621381c953b6b3b33cc49d34d29e93676.623688dc.jpg" alt="图片"/></p><p>这个TLS Alert报文显示，它的编号是40，指代的是Handshake Failure这个错误类型。到这一步，我们需要去了解这个错误类型的具体定义。<strong>正确的做法是：去RFC里寻找答案</strong>，而不是随意地去网络上搜索，因为很可能你会被一些似是而非的信息误导。</p><p>因为这次握手用的是TLS1.2协议，我们就来看它的<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。在这个RFC里，找到Alert Protocol部分，我们看看它是怎么说的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">handshake_failure</span></div><div class="token-line"><span class="token plain">          Reception of a handshake_failure alert message indicates that the</span></div><div class="token-line"><span class="token plain">          sender was unable to negotiate an acceptable set of security</span></div><div class="token-line"><span class="token plain">          parameters given the options available.  This is a fatal error.</span></div></pre></div><p>结合这里的实际场景，这段话的意思就是：“基于已经收到的Client Hello报文中的选项，TLS服务端无法协商出一个可以接受的安全参数集”。而这个所谓的安全参数集，在这里具体指的就是加密算法套件 <strong>Cipher Suite</strong>。我们来认识一下它。</p><blockquote><p>补充：这里的suite读音是sweet而不是suit，我也错读过很多年。另外，suite还有旅馆套房的意思。</p></blockquote><h3 id="cipher-suite"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#cipher-suite"><span class="icon icon-link"></span></a>Cipher Suite</h3><p>前面提到过，在TLS中，真正的数据传输用的加密方式是<strong>对称加密</strong>；而对称密钥的交换，才是使用了<strong>非对称加密</strong>。实际上，TLS的握手阶段需要在下面四个环节里实现不同类型的安全性，它们可以说是TLS的“四大护法”。</p><ul><li><strong>密钥交换算法</strong>：保证对称密钥的交换是安全的，典型算法包括DHE、ECDHE。</li><li><strong>身份验证和签名算法</strong>：确认服务端的身份，其实就是对证书的验证，非对称算法就用在这里。典型算法包括RSA、ECDSA。</li></ul><blockquote><p>补充：如果是双向验证（mTLS），服务端会验证客户端的证书。</p></blockquote><ul><li><strong>对称加密算法</strong>：对应用层数据进行加密，典型算法包括AES、DES。</li><li><strong>消息完整性校验算法</strong>：确保消息不被篡改，典型算法包括SHA1、SHA256。</li></ul><p>每一个类型都有很多不同的具体算法实现，它们的组合，就是密码套件Cipher Suite。你可能以前也见过它，这次咱们来拆解认识一下它的组成结构。</p><p>先看一个典型的密码套件：</p><p><strong>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA（0xc013）</strong></p><ul><li>TLS不用多说，代表了TLS协议。</li><li>ECDHE是密钥交换算法，双方通过它就不用直接传输对称密钥，而只需通过交换双方生成的随机数等信息，就可以各自计算出对称密钥。</li><li>RSA是身份验证和签名算法，主要是客户端来验证服务端证书的有效性，确保服务端是本尊，非假冒。</li><li>AES128_CBC是对称加密算法，应用层的数据就是用这个算法来加解密的。这里的CBC属于块式加密模式，另外一类模式是流式加密。</li><li>SHA就是最后的完整性校验算法（哈希算法）了，它用来保证密文不被篡改。</li><li>0xc013呢，是这个密码套件的编号，每种密码套件都有独立的编号。完整的编号列表在 <a target="_blank" rel="noopener noreferrer" href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">IANA的网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上可以找到。</li></ul><p>另外，在不同的客户端和服务端软件上，这些密码套件也各不相同。所以，TLS握手的重要任务之一，就是<strong>找到双方共同支持的那个密码套件</strong>，也就是找到大家的“共同语言”，否则握手就必定会失败。</p><p>所以这个案例排查的下一步，就是要搞清楚，客户端和服务端到底都支持了哪些Cipher Suite。</p><p>那么客户端的密码套件有哪些呢？你可能很快想到了前面curl命令里的输出。确实，那里就明确显示，双方协商出来的是 <strong>ECDHE_RSA_AES_128_GCM_SHA256</strong>。但是，这里有两个问题：</p><ul><li>这个是协商后达成的结果，只是一个套件，而不是套件列表。</li><li>更加关键的是，这个密码套件是curl这个客户端的，而不是出问题的客户端。</li></ul><p>所谓出问题的客户端，就是实际的业务代码去连接API server时候用的客户端，它是一个Java库，而不是curl，这一点一定要分清。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage09d409fd882c5222d05cfae9ce3f753633d4.7c7800db.jpg" alt=""/></p><p>那么，我们怎么获得这个Java库能支持的密码套件列表呢？其实最直接的办法，还是用<strong>抓包分析</strong>。我们回到前面那个抓包文件，检查一下Client Hello报文。在那里，就有Java库支持的密码套件列表。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageeb2aeb521f76bd305904098d6f76c6188e2a.108f03f2.jpg" alt="图片"/></p><blockquote><p>补充：这个列表往下还有，因为屏幕小，我没有全部展示。</p></blockquote><p>找到了客户端的密码套件列表，接下来是不是就去找服务端的密码套件的列表呢？不过，这个抓包里，服务端直接回复了Alert消息，并没有提供它支持的密码套件列表。那我们的排查如何继续推进呢？</p><p>其实，可以换个思路：看看服务端在TLS握手成功后用了哪个密码套件，而不是去拿到它的全部列表。前面curl已经成功了，<strong>我们来看下curl那次协商出来的套件是哪个，看它是否被Java库支持，就可以判定了</strong>。</p><p>我们要导出这次Client Hello里面的密码套件列表，可以这样做：选中Cipher Suite，右单击，选中Copy，在次级菜单中选中All Visible Selected Tree Items：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage48b0484f4d01d57635fa3de48eda952794b0.f656ae5d.jpg" alt="图片"/></p><p>这样，我们就得到了下面这个列表：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Cipher Suites (28 suites)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 (0xc025)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 (0xc029)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (0x0067)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 (0x0040)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA (0xc004)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_RSA_WITH_AES_128_CBC_SHA (0xc00e)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x0033)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_DSS_WITH_AES_128_CBC_SHA (0x0032)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA (0xc008)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA (0xc012)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA (0xc003)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA (0xc00d)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA (0x0016)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA (0x0013)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_RC4_128_SHA (0xc007)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDHE_RSA_WITH_RC4_128_SHA (0xc011)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_RSA_WITH_RC4_128_SHA (0x0005)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_ECDSA_WITH_RC4_128_SHA (0xc002)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_ECDH_RSA_WITH_RC4_128_SHA (0xc00c)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_RSA_WITH_RC4_128_MD5 (0x0004)</span></div><div class="token-line"><span class="token plain">        Cipher Suite: TLS_EMPTY_RENEGOTIATION_INFO_SCSV (0x00ff)</span></div></pre></div><p>可见，里面确实没有 <strong>ECDHE_RSA_AES_128_GCM_SHA256</strong> 这个套件。所以到这里，我们可以确认问题根因了：因为这个Java库和API server 2之间，没有找到共同的密码套件，所以TLS握手失败。</p><p>根因找到了，下一步就是升级Java库，让双方能够协商成功。</p><blockquote><p>补充：API server 1能兼容这个相对旧的Java库，所以没有问题。</p></blockquote><p>你觉得这个问题难吗？其实还好，对吧？这是因为我们一旦对协议本身有准确的理解，那么很多问题就容易被“看穿”。这也说明了理论知识的重要性。</p><p>好，我们再来看一个复杂一点的案例。</p><h2 id="案例2有效期内的证书为什么报告无效"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#案例2有效期内的证书为什么报告无效"><span class="icon icon-link"></span></a>案例2：有效期内的证书为什么报告无效？</h2><p>有一次，一个产品开发团队向我们运维团队报告了一个问题：他们的应用在做了代码发布后，就无法正常访问一个内部的HTTPS站点了，报错信息是：certificate has expired。</p><p>这就很奇怪了，我们日常对证书都做了自动更新处理，不会有“漏网之鱼”。然后我们也手工检查了这个HTTPS站点的证书，确定是在有效期内的，这就使得这个报错显得尤其古怪。</p><p>既然是代码发布后新出现的问题，那我们自然认为问题是跟发布有关。我们了解到：这次确实有个变更，会在客户端打开服务端证书校验的特性，而这个特性在以前是不打开的。但这还是无法解释，为什么客户端居然会认为，一个明明在有效期内的证书是过期的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagefbf3fb642fyy4cf4caf2f72a5b11c779ddf3.32b9fe5d.jpg" alt=""/></p><p>真是“秀才遇到兵”，感觉“讲理”是行不通了，于是我们换了个思路，不纠结在有效期的问题上。跟前一个案例类似，我们用交叉验证的方式来推进排查。具体做法是：在这台客户端和另一台客户端上，用OpenSSL向这个HTTPS站点发起TLS握手。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage353735c4d5314cd8b71f3e91c03bc8f53137.63477582.jpg" alt=""/></p><p>结果我们发现了更有意思的情况：从另外一台客户端的OpenSSL去连接这个HTTPS站点，也报告certificate has expired。</p><p>这给了我们很大的信心：既然OpenSSL可以复现这个问题，那我们就可以做进一步的检查了！因为OpenSSL属于OS上的命令，虽然我们不了解如何在Node.js上做debug，但是我们对如何在OS上做排查是很有经验的。</p><p>于是，我们在OpenSSL命令前面加上 <strong>strace</strong>，以便于追踪OpenSSL在执行过程中，特别是在报告certificate has expired之前，具体发生了什么。执行这个命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">strace openssl s_client -tlsextdebug -showcerts -connect abc.ebay.com:443</span></div></pre></div><p>输出的关键部分如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">stat(&quot;/usr/lib/ssl/certs/a1b2c3d4.1&quot;, {st_mode=S_IFREG|0644, st_size=2816, ...}) = 0</span></div><div class="token-line"><span class="token plain">    openat(AT_FDCWD, &quot;/usr/lib/ssl/certs/a1b2c3d4.1&quot;, O_RDONLY) = 6</span></div><div class="token-line"><span class="token plain">    ......</span></div><div class="token-line"><span class="token plain">    write(2, &quot;verify return:1\n&quot;, 16verify return:1</span></div><div class="token-line"><span class="token plain">    )       = 16</span></div><div class="token-line"><span class="token plain">    .......</span></div><div class="token-line"><span class="token plain">    write(2, &quot;verify error:num=10:certificate &quot;..., 44verify error:num=10:certificate has expired</span></div><div class="token-line"><span class="token plain">    ) = 44</span></div><div class="token-line"><span class="token plain">    write(2, &quot;notAfter=&quot;, 9notAfter=)                = 9</span></div><div class="token-line"><span class="token plain">    write(2, &quot;Oct 14 18:45:33 2020 GMT&quot;, 24Oct 14 18:45:33 2020 GMT) = 24</span></div></pre></div><p>这里的关键信息是：</p><ul><li>OpenSSL读取了<code>/usr/lib/ssl/certs</code>目录下的文件 <code>a1b2c3d4.1</code>。</li><li>接着，OpenSSL就报告了certificate has expired的错误，expire的日期是2020年10月24日（输出中的“24Oct 14”）。</li></ul><p>这又是一个明显的进展：很可能就是这个文件导致了错误。这是个什么文件，为什么会导致错误呢？</p><p>其实，它就是TLS客户端本地的Trust store里，存放的中间证书文件。Trust store一般用来存放根证书和中间证书文件，你可能对这几个名词还不太熟悉，我给你介绍一下TLS证书校验的原理。</p><blockquote><p>补充：一般来说，证书先存入文件系统，然后通过命令或者代码，导入到应用的Trust store。</p></blockquote><h3 id="tls证书链"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls证书链"><span class="icon icon-link"></span></a>TLS证书链</h3><p>TLS证书验证是“链式”的机制。比如，客户端存有根证书和它签发的中间证书，那么由中间证书签发的叶子证书，就可以被客户端信任了，也就是这样一条信任链：</p><p><strong>信任根证书 -&gt; 信任中间证书 -&gt; 信任叶子证书</strong></p><p>我画了三种不同情况下的信任链的示意图，供你参考：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage32a6324934a90cef3531ca2b46faf70e86a6.a29e05b8.jpg" alt=""/></p><p>场景1和3中，信任链是完整的，证书验证就可以通过。场景2中，由于中间证书既不在客户端的Trust store里，也不在服务端回复的证书链中，这就导致信任链断裂，验证就会失败。</p><p>而我们发现在这个案例里，服务端发送的证书链中包含了正确的中间证书，那为什么还会失败呢？其实这是因为，从前面strace openssl的输出里已经发现，客户端本地也有一张中间证书，而且是<strong>过期的</strong>，示意图如下：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage66f366bf55b67efb27ff084b9dec871acaf3.b86809c8.jpg" alt=""/></p><p>这两张中间证书，签发机构是同一个CA，证书名称也相同，这就导致了OpenSSL在做信任链校验时，优先用了本地的中间证书，进而因为这张本地的中间证书确实已经过期，导致OpenSSL抛出了certificate has expired的错误！</p><p>这个结论你看明白了吗？你也许觉得还是有哪里不对，比如你可能会问：“照理说叶子证书是新的中间证书签发的，那用老的中间证书去验证叶子证书的签名的时候，应该会失败啊？”</p><p>你说得没错。这里最烧脑的地方在于：这两张中间证书，不仅签发机构一样，名称一样，而且<strong>私钥也一样</strong>！</p><p>如果你对TLS不熟悉，学到这里可能已经觉得有点“爆炸”了。先别急，下面有详细的解释。</p><p>这里的核心秘密在于：每次证书在更新的时候，<strong>它对应的私钥不是必须要更新的，而是可以保持不变的</strong>。</p><p>我们把本地的已经过期的中间证书，称为old_cert，新的中间证书称为new_cert。整个故事就是这样：</p><ul><li>几年前，old_cert被根证书签发了出来，名称为inter-CA，并被保存在这台客户端的Trust store里。</li><li>在2020年，old_cert到期，根证书机构重新签发了一张新的中间证书new_cert，它用了新的有效期，而<strong>证书名称inter-CA</strong>和对应的<strong>私钥</strong>都保持不变。</li><li>CA用这张new_cert签发了这次的叶子证书。因为客户端程序没有打开证书校验机制，所以没有报错。</li><li>这一天，新的代码发布上去，证书校验机制被打开了，于是客户端开始做校验。它发现这张叶子证书的签发者名称是inter-CA，而自己本地就有一张也叫inter-CA的证书，于是尝试用这张证书的公钥去解开叶子证书的签名部分，可以成功解开，于是确认old_cert就是对应的中间证书（而没有用收到的new_cert，这很关键）。但是由于old_cert已经过期了，结果客户端抛出certificate has expired的错误！</li></ul><p>如果你还没有完全看明白，说明你真的在思考了，因为我确实还没有讲完。接下来介绍核心知识点：TLS证书签名。</p><h3 id="tls证书签名"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#tls证书签名"><span class="icon icon-link"></span></a>TLS证书签名</h3><p>你应该也知道，TLS证书都有签名部分，这个签名就是用签发者的私钥加密的。客户端为什么会相信叶子证书真的是这个CA签发的呢？就是因为，客户端的Trust store里就有这个CA的公钥（在CA证书里），它用这个公钥去尝试解开签名，能成功的话，就说明这张叶子证书确实是这个CA签发的。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage97dc977f0b985d96d3cdc2a17d0b6a253fdc.62f26d6f.jpg" alt=""/></p><p>这里最关键的部分在于，新老中间证书用的私钥是同一把，所以这张叶子证书的签名部分，<strong>用老的中间证书的公钥也能解开</strong>，这就使得下图中的橙色的验证链条得以“打通”，不过，谁也没料到打通的是一条“死胡同”。</p><blockquote><p>补充：PKI里有交叉签名的技术，就是新老根证书对同一个新的中间证书进行签名，但并不适用于这个案例。</p></blockquote><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage66f366bf55b67efb27ff084b9dec871acaf3.b86809c8.jpg" alt=""/></p><p>OpenSSL报错的原因找到了，根据这个发现，我们也确认了Node.js的Trust store也存在同样的问题。我们把它的Trust store里的过期证书全部删除后，问题就被解决了。</p><p>另外在排查过程中，我们偶然发现Stack Overflow上也有人报告了类似的问题。于是<a target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/questions/24992976/openssl-telling-certificate-has-expired-when-it-has-not/68151948#68151948">我在Stack Overflow上也做了回复<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，期望可以对遇到类似问题的人提供帮助。</p><blockquote><p>补充：我的留言在三楼，署名VictorYang。</p></blockquote><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们通过两个典型案例，学习了TLS相关的知识，你可以重点关注和掌握以下知识点。</p><ul><li><strong>加密算法的类型</strong></li></ul><p>对称加密算法：加密和解密用同一个密钥，典型算法有AES、DES。</p><p>非对称加密算法：加密和解密用不同的密钥，典型的非对称加密算法有RSA、ECDSA。</p><ul><li><strong>TLS基础</strong></li></ul><p>TLS是先完成握手，然后进行加密通信。非对称算法用于交换随机数等信息，以便生成对称密钥；对称算法用于信息的加解密。</p><ul><li><strong>Cipher Suite</strong></li></ul><p>在握手阶段，TLS需要四类算法的参与，分别是：密钥交换算法、身份验证和签名算法、对称加密算法、消息完整性校验算法。这四类算法的组合，就形成了密码套件，英文叫Cipher Suite。这是TLS握手中的重要内容，我们的案例1就是因为无法协商出公用的密码套件，所以TLS握手失败了。</p><ul><li><strong>TLS证书链</strong></li></ul><p>TLS的信任是通过对证书链的验证：</p><p><strong>信任根证书 -&gt; 信任中间证书 -&gt; 信任叶子证书</strong></p><p>本地证书加上收到的证书，就形成了证书链，如果其中有问题，那么证书校验将会失败。我们的案例2，就是因为一些极端情况交织在一起，造成了信任链过期的问题，导致证书验证失败了。</p><ul><li><strong>Trust store</strong></li></ul><p>它是客户端使用的本地CA证书存储，其中的文件过期的话可能导致一些问题，在排查时可以重点关注。</p><ul><li><strong>排查技巧</strong></li></ul><p>在排查技巧方面，你要知道使用 <strong>curl命令</strong>，检查HTTPS交互过程的方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">curl -vk https://站点名</span></div></pre></div><p>以及使用 <strong>OpenSSL命令</strong>来检查证书的方法，也就是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">openssl s_client -tlsextdebug -showcerts -connect 站点名:443</span></div></pre></div><p>另外在需要分析OpenSSL为什么报错的时候，你可以在前面加上 <strong>strace</strong>，这对于排查根因有不少的帮助。</p><p>然后，我也带你学习了<strong>如何在Wireshark里导出Cipher Suite的方法</strong>，就是在TLS详情中选中Cipher Suite，右单击，选中Copy，在次级菜单中选中All Visible Selected Tree Items。这时，列表就被复制出来了。</p><p>除此之外，我们还在排查TLS Alert 40这个信息时，通过查阅<a target="_blank" rel="noopener noreferrer" href="https://datatracker.ietf.org/doc/html/rfc5246">RFC5246<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>得到了答案。所以，在遇到一些协议类型、定义相关的问题时，<strong>最好查阅权威的RFC文档，这样可以获得最准确的信息</strong>。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后还是给你留两道思考题：</p><ul><li>我们知道TCP是三次握手，那么TLS握手是几次呢？</li><li>假设服务端返回的证书链是根证书+中间证书+叶子证书，客户端没有这个根证书，但是有这个中间证书。你认为客户端会信任这个证书链吗？</li></ul><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/网络排查案例课/05.实战二应用层真实案例揭秘篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:23:20</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
