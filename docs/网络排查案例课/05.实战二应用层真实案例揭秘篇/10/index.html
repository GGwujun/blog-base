<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>22 | 为什么压力测试TPS总是上不去？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/网络排查案例课/05.实战二应用层真实案例揭秘篇/10" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/网络排查案例课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/网络排查案例课/01.开篇词/01"><span>开篇词 | 网络排查是工程师的必备能力</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/02.预习篇">02.预习篇</a><ul><li><a href="/blog-base/网络排查案例课/02.预习篇/01"><span>01 | 网络模型和工具：网络为什么要分层？</span></a></li><li><a href="/blog-base/网络排查案例课/02.预习篇/02"><span>02 | 抓包分析技术初探：你会用tcpdump和Wireshark吗？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇">03.实战一TCP真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/01"><span>03 | 握手：TCP连接都是用TCP协议沟通的吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/02"><span>04 | 挥手：Nginx日志报connection reset by peer是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/03"><span>05 | 定位防火墙（一）：传输层的对比分析</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/04"><span>答疑（一）| 第1~5讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/05"><span>06 | 定位防火墙（二）：网络层的精确打击</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/06"><span>07 | 保活机制：心跳包异常导致应用重启？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/07"><span>08 | 分段：MTU引发的血案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/08"><span>09 | 长肥管道：为何文件传输速度这么慢？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09"><span>10 | 窗口：TCP Window Full会影响传输效率吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/10"><span>答疑（二）| 第6~10讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/11"><span>11 | 拥塞：TCP是如何探测到拥塞的？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/12"><span>12 | 重传的认识：重传到底是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/13"><span>13 | 重传的再认识：没有任何丢包却也一直重传？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/14"><span>14 | 安全：用Wireshark把DDoS攻击照出原形</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送">04.春节特别放送</a><ul><li><a href="/blog-base/网络排查案例课/04.春节特别放送/01"><span>春节特别放送（一）| 书单推荐</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/02"><span>春节特别放送（二）| 聊聊能力陷阱和终身学习</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/03"><span>春节特别放送（三）| 我的学习资料和工具</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/04"><span>春节特别放送（四）| 测一测你的网络排查能力</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇">05.实战二应用层真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/01"><span>15 | Nginx的499状态码是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/02"><span>答疑（三）| 第11~15讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03"><span>16 | 服务器为什么回复HTTP 400？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/04"><span>17 | 为什么前端页面里多选一个城市就报错？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/05"><span>18 | 偶发性问题如何排查？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06"><span>19 | TLS的各种特性：TLS握手为什么会失败？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/07"><span>20 | TLS加解密：如何解密HTTPS流量？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/08"><span>答疑（四）| 第16~20讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/09"><span>21 | 为什么用了负载均衡更加不均衡？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10"><span>22 | 为什么压力测试TPS总是上不去？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇">06.实战三不用抓包就能做的网络排查篇</a><ul><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/01"><span>23 | 路径排查：没有网络设备权限要如何做排查？</span></a></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/02"><span>24 | 丢包：如何确定丢包的存在及其程度？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐">07.不定期加餐</a><ul><li><a href="/blog-base/网络排查案例课/07.不定期加餐/01"><span>不定期加餐（一） | 八仙过海，各显神通：透传真实源IP的各种方法</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/02"><span>用户故事 | 小S：学习是人生路上生生不息的活泉</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/03"><span>用户故事 | 王未：网络排查能力是一名合格运维工程师的必备技能</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/08.总结篇">08.总结篇</a><ul><li><a href="/blog-base/网络排查案例课/08.总结篇/01"><span>25 | 抓包分析的回顾、拾遗，和提高</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/02"><span>结束语 | 珍惜握手，难说再见</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/03"><span>结课测试 | “网络排查案例课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/summary">网络排查案例课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="压测要做什么？" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#压测要做什么"><span>压测要做什么？</span></a></li><li title="案例1：压测TPS上不去" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例1压测tps上不去"><span>案例1：压测TPS上不去</span></a></li><li title="性能工具sar" data-depth="3"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#性能工具sar"><span>性能工具sar</span></a></li><li title="案例2：LoadRunner压测发现部分失败" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例2loadrunner压测发现部分失败"><span>案例2：LoadRunner压测发现部分失败</span></a></li><li title="案例3：压测报cannot assign requested address错误" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例3压测报cannot-assign-requested-address错误"><span>案例3：压测报cannot assign requested address错误</span></a></li><li title="案例4：压测遇到connection reset by peer" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例4压测遇到connection-reset-by-peer"><span>案例4：压测遇到connection reset by peer</span></a></li><li title="实验" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#实验"><span>实验</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#思考题"><span>思考题</span></a></li><li title="附录" data-depth="2"><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#附录"><span>附录</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="22--为什么压力测试tps总是上不去"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#22--为什么压力测试tps总是上不去"><span class="icon icon-link"></span></a>22 | 为什么压力测试TPS总是上不去？</h1><p>你好，我是胜辉。</p><p>在上一讲里，我们排查了一个跟操作系统紧密相关的性能问题。我们结合top和strace这两个工具，抓住了关键点，从而解决了问题。性能问题，确实也是我们日常技术工作中的一个重要话题。在出现性能问题以后，我们要有能力搞定它；而在出现性能问题之前，最好能提前预见到它。而要“预见”性能瓶颈，最好的方法就是做<strong>压力测试</strong>。</p><p>但是，我们在做压力测试的过程中也时常出现预料不到的情况。比如在离预期的瓶颈值还很远的时候，系统就出现了各种意外，影响到压力测试的继续进行。</p><p>那么在这节课里，我们会回顾几个典型的压力测试场景中的网络问题，一起来学习其中的关键要点。同时，我们还会学习一系列跟网络性能相关的压测工具和检测工具，这样以后你遇到类似的问题时，就有所准备了。</p><h2 id="压测要做什么"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#压测要做什么"><span class="icon icon-link"></span></a>压测要做什么？</h2><p>压力测试的诉求实际上多种多样，不过大体上可以分为这几种。</p><p><strong>应用的承受能力</strong>：这主要在第七层应用层，比如发起了压测，把服务端的CPU打到95%甚至100%，观察这时候的请求的TPS、请求耗时、并发量等等。而这些对于不同的业务场景，又会有不同的侧重点。比如：</p><ul><li>对于时间敏感型业务来说，请求耗时（Latency）这个指标就是关键了。</li><li>对于经常做秒杀的电商来说，并发处理量TPS（Transaction Per Second）就是一个核心关注点了。</li></ul><p><strong>LB的连接处理能力</strong>：这主要在第四层TCP，看LB能最大支持的TCP并发连接数。这时候，发起压测的客户端一般会指定比较大的并发数，这样就可以发起尽量多的TCP连接。</p><p><strong>网络的承受能力</strong>：这可能主要在第三层IP层了，比如测试上行和下行带宽能否跑满、是否有丢包和额外的延迟，等等。特别是对于一些流量比较大的场景，很可能服务端计算能力都还在，但带宽已经不够用了，所以我们要提前发现这些隐患。</p><h2 id="案例1压测tps上不去"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例1压测tps上不去"><span class="icon icon-link"></span></a>案例1：压测TPS上不去</h2><p>我们有个客户是传统企业转型做电商，有一次准备搞大促。为了确保大促顺利，他们要提前对网站进行压测。</p><p>客户用的压测工具比较简单，是Apache ab。ab是Apache Benchmark的缩写，它的用途就是对HTTP服务端发起测试，以获得性能指标（Benchmark）。ab本身不是独立安装的，而是在apache2-utils工具包里，所以你可以这样来安装它：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt install apache2-utils</span></div></pre></div><p>ab是一个轻量级的工具，因为相对其他重量级的工具比如LoadRunner或者JMeter来说，ab只要一行命令就可以发起压测了，是不是很省事？比如你可以这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ab -c 100 -n 10000 目标URL</span></div></pre></div><p>通过上面的命令，你就用-c 100这个参数，让ab发起了100个并发的请求，而-n 10000指定了总共发送的请求量。</p><blockquote><p>补充：这里有一个小的注意点。如果目标URL只是站点名本身，还是需要在结尾处加上“<code>&gt;/</code>”，要不然ab会报这个错误：<code>ab: invalid URL</code></p></blockquote><p>比如我用下面这条ab命令，对一个著名网站发起“压测”，当然我的参数选择的很小，只有10个并发，一共100次请求，尽量避免打扰到这个网站。我们可以看一下输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ ab -c 10 -n 100 https://www.baidu.com/abc</span></div><div class="token-line"><span class="token plain">    This is ApacheBench, Version 2.3 &lt;$Revision: 1843412 $&gt;</span></div><div class="token-line"><span class="token plain">    Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span></div><div class="token-line"><span class="token plain">    Licensed to The Apache Software Foundation, http://www.apache.org/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Benchmarking www.baidu.com (be patient).....done</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Server Software:        Apache</span></div><div class="token-line"><span class="token plain">    Server Hostname:        www.baidu.com</span></div><div class="token-line"><span class="token plain">    Server Port:            443</span></div><div class="token-line"><span class="token plain">    SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span></div><div class="token-line"><span class="token plain">    Server Temp Key:        ECDH P-256 256 bits</span></div><div class="token-line"><span class="token plain">    TLS Server Name:        www.baidu.com</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Document Path:          /abc</span></div><div class="token-line"><span class="token plain">    Document Length:        201 bytes</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Concurrency Level:      10</span></div><div class="token-line"><span class="token plain">    Time taken for tests:   9.091 seconds</span></div><div class="token-line"><span class="token plain">    Complete requests:      100</span></div><div class="token-line"><span class="token plain">    Failed requests:        0</span></div><div class="token-line"><span class="token plain">    Non-2xx responses:      100</span></div><div class="token-line"><span class="token plain">    Total transferred:      34600 bytes</span></div><div class="token-line"><span class="token plain">    HTML transferred:       20100 bytes</span></div><div class="token-line"><span class="token plain">    Requests per second:    11.00 [#/sec] (mean)</span></div><div class="token-line"><span class="token plain">    Time per request:       909.051 [ms] (mean)</span></div><div class="token-line"><span class="token plain">    Time per request:       90.905 [ms] (mean, across all concurrent requests)</span></div><div class="token-line"><span class="token plain">    Transfer rate:          3.72 [Kbytes/sec] received</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Connection Times (ms)</span></div><div class="token-line"><span class="token plain">                  min  mean[+/-sd] median   max</span></div><div class="token-line"><span class="token plain">    Connect:      141  799 429.9    738    4645</span></div><div class="token-line"><span class="token plain">    Processing:    19   67 102.0     23     416</span></div><div class="token-line"><span class="token plain">    Waiting:       17   67 101.8     23     416</span></div><div class="token-line"><span class="token plain">    Total:        162  866 439.7    796    4666</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Percentage of the requests served within a certain time (ms)</span></div><div class="token-line"><span class="token plain">      50%    796</span></div><div class="token-line"><span class="token plain">      66%    877</span></div><div class="token-line"><span class="token plain">      75%    944</span></div><div class="token-line"><span class="token plain">      80%   1035</span></div><div class="token-line"><span class="token plain">      90%   1093</span></div><div class="token-line"><span class="token plain">      95%   1339</span></div><div class="token-line"><span class="token plain">      98%   1530</span></div><div class="token-line"><span class="token plain">      99%   4666</span></div><div class="token-line"><span class="token plain">     100%   4666 (longest request)</span></div></pre></div><p>结尾部分的多个Percentage，确切地说就是Percentile，也就是百分位。比如50% 796这一行的意思是：第50个请求（因为总数是100个）的耗时小于等于796毫秒，另外50个请求大于796毫秒。那么我们也可以知道，耗时最长的那个就是排最后一名的4666，它的耗时是4666毫秒。</p><p>这次，客户用ab时指定的具体参数是这样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ab -k -c 500 -n 100000 http://site.name.com/path</span></div></pre></div><p>也就是并发数为500，总次数为10万，而-k参数是启用长连接。然后就是查看以下两个主要指标：</p><ul><li>ab这个客户端的耗时分布，也就是前面刚介绍过的各个百分位的耗时数值。</li><li>服务端的性能指标，也就是在这个压力下面，服务端的CPU、内存、网络丢包率等的统计数值。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimage8c9d8ce9cb87baccc568020963321f3ff39d.jpg" alt=""/></p><p>压测过程中，客户发现测试端的带宽用到400Mbps后，TPS就上不去了，无论把并发量或者总量的数值进行怎样的调整，TPS都会维持在一个稳定的数值。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Transfer rate:          52087.82 [Kbytes/sec] received</span></div></pre></div><p>那究竟是不是购买的服务端主机的性能不够的原因呢？要知道，客户端和服务端都是1Gbps的网卡，客户是想压满100%的带宽，现在只用到了40%的带宽，TPS就上不去了。</p><p>为什么会这样呢？</p><p>我们就跟客户配合，一边做ab压测，一边做了4秒钟的tcpdump抓包，这对采样分析来说也够用了。然后打开抓包文件，查看专家信息（Expert Information），如下：</p><blockquote><p>补充：抓包示例文件已经上传至<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/steelvictor/network-analysis/tree/master/22">Gitee<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，建议结合抓包文件和文稿一起学习。</p></blockquote><p><img src="/images/httpsstatic001geekbangorgresourceimaged600d64b27b7a79ce3edcd702d0fcffdb900.jpg" alt="图片"/></p><p>这次我就不做标记了，你自己先找找看，能否找到一些问题？</p><p>你有没有发现，GET有1603次（倒数第三行），而RST有1982次（第三行），比GET这种HTTP请求的次数还更多。也就是说，平摊的话，每次GET请求对应了一次以上的RST。这个现象会不会跟TPS上不去的问题有关系呢？</p><p>我们选一个RST来看一下情况。比如14031号报文：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage46284610b0fd0352d03523f448480c256428.jpg" alt="图片"/></p><p>然后Follow -&gt; TCP Stream，就来到了这条TCP流：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagefad0fa6d59359e1044a4844b6a29c3a260d0.jpg" alt="图片"/></p><p>在这里，你有没有发现两个重传报文？一个是6504号报文，一个是7340号报文。我们再进一步看一下这两个的重传的原因是什么。一般来说，判断一个报文是否是重传，最方便的就是借助Wireshark本身提供的提示，Wireshark说是Retransmission，那就是了。</p><p>那么假设世界上还没有Wireshark，你又**如何判断一个报文是否是重传呢？**其实可以根据两个关键信息：<strong>序列号、载荷长度</strong>。</p><p>我在之前的课程里提到过，序列号本身反映的就是字节位置，载荷的长度就表示这段报文的实际字节长度，这两个信息就确定了信息的<strong>起点和终点</strong>，也就是决定了一个报文是否是之前报文的重传。</p><p>在上面的截图里，我们根据序列号（Sequence Number列）和载荷长度（TCP Seglen列），判断出下面两次重传：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage10fa10e8909974fd01608f6f7a976949b7fa.jpg" alt=""/></p><p>可见，7340是3155报文的重传，因为它们的序列号都是9593，载荷长度都是1061。同样的道理，6504和3156也是一对重传关系。</p><p>当然，我们也可以直接在Wireshark里选中7340号报文，它的基础报文也就是3155的<strong>前面会出现一个小圆点</strong>，就像下图这样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagee457e460a19638fb3b633e1315cc02b07857.jpg" alt="图片"/></p><p>总之，我们确认TCP传输中是有丢包和重传现象的，我们可以回头从专家信息那里得到证实，这里显示有184个Suprious重传和2274个（超时）重传。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage2d9d2d44ff9320c8bf3e72ff8e907a9eyy9d.jpg" alt="图片"/></p><blockquote><p>补充：而出现RST的原因，是客户端在已经没有了这个TCP连接的情况下，收到了服务端的ACK报文。从现象来看，客户端应该是做了TIME_WAIT优化的设置，我们后面的实验里也会带到。</p></blockquote><p>考虑到这是在压测场景中出现的丢包现象，我们根据经验，想到了<strong>网卡包量</strong>的问题。</p><p>一般说到网络性能，我们会讨论的就是带宽、时延、网速等等这些指标。实际上，另外一个性能指标常常在达到带宽极限之前就已经触顶了，它就是包量。</p><p>**包量是对PPS（Packet Per Second）的简称，一般用来衡量一台主机的网络处理能力。**那么，这次是不是触及了服务端主机的包量上限了呢？我们又如何检查包量指标呢？</p><p>我们需要用的工具是sar。</p><h3 id="性能工具sar"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#性能工具sar"><span class="icon icon-link"></span></a>性能工具sar</h3><p>sar是sysstat工具集的一部分。这个工具集包含了一些很有用的工具，除了sar，还有mpstat、iostat等等。如果你平时经常做操作系统维护方面的工作，应该对它们比较熟悉了。这些工具还有一个共同的特点，运行的时候一般都是加上“间隔 次数”这样的参数的。也就是下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sar -n DEV 1 10   #查看网卡性能</span></div><div class="token-line"><span class="token plain">    iostat 1 10       #查看IO性能</span></div><div class="token-line"><span class="token plain">    mpstat 2 5        #查看CPU性能</span></div></pre></div><p>这些工具会按指定的时间间隔，运行指定的次数后再退出。这样我们就可以观察到这段时间内的多次输出了，很适合通过这种多次的观察，得到比较准确的性能数据趋势。</p><p>这次我们也在被压测的服务端云主机上运行了 <code>sar \-n DEV</code>，得到了以下的性能数据：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage55be5523ee0f7eba2cce7979620e4abccabe.jpg" alt="图片"/></p><p>前面说的包量，就是体现在两个pck/s指标中，一个是 <strong>rxpck/s</strong>，就是接收方向的包量；一个是 <strong>txpck/s</strong>，就是发送方向的包量。显然，图中的数值已经在5万左右，这个正是当时我们云主机性能的上限。难怪服务端已经无法提供更高的TPS了，因为网络包的处理都来不及做了。</p><p>那你可能会问了：“网络包也有大有小，这个包量指标说的是大包还是小包呢？”</p><p>其实，一般的包量测试，不是随便什么大小的报文都可以测试，而是普遍使用64字节长度的IP报文。另外，我们也要认识到，包的大小对包量性能的影响也不是很大。这是因为，对于网络处理来说，主要的开销在包的头部的处理上，而载荷本身的处理是很快的。</p><p>那么，对于客户遇到的这种包量达到上限的情况，我们可以选择的应对办法是这样的：</p><ul><li>选择更高网络性能的主机，比如硬件的RSS、软件的RPS等特性，都会大幅提升包量处理性能。</li><li>对服务集群进行水平扩展，也就是在LB后面增加服务器，这样VIP作为一个整体提供的包，处理能力也就提升了。</li></ul><h2 id="案例2loadrunner压测发现部分失败"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例2loadrunner压测发现部分失败"><span class="icon icon-link"></span></a>案例2：LoadRunner压测发现部分失败</h2><p>这是另外一个客户，他们没有用ab这样的简单工具，而是用了LoadRunner这样一个企业级的测试软件。LoadRunner的厉害之处在于，不仅可以发起巨大的请求量，而且可以模拟用户的复杂行为，比如登录、浏览、加入购物车等等。这一系列事务有前后状态关系，这就不是简单的ab可以做到的了。</p><p>但是测试结果中的小几十个Failed和Error引起了客户的疑虑。他们怀疑：是不是我们公有云的机器或者网络质量不行，所以才导致了这些失败呢？</p><p><img src="/images/httpsstatic001geekbangorgresourceimage91cb9185cd1c33463aa7594bf290547fb1cb.jpg" alt=""/></p><p>我们就尝试复现这个压测场景，同时也对测试机上的TCP资源情况做检查，其中最主要的就是源端口了。</p><p>为什么会想到这个呢？因为压测发起的请求，都是依托于TCP连接的。我们在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/477510">第1讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里就提到过：<strong>TCP连接是基于五元组的</strong>。那么对于客户端来说，源IP、目的IP、目的端口、协议，这四个元素都不会变化，<strong>唯一会变的就是自己的源端口</strong>了。那么我们来看看，当时测试机的源端口情况。</p><p>这是一台Window机器，跟Linux类似，我们执行这条命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">netstat -ant</span></div></pre></div><p>输出如下图：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagecea4cee3b9c775369dba1cfd2aaa2c6d8fa4.jpg" alt=""/></p><p>原来，确实有大量的TCP连接都在TIME_WAIT状态，尤其是源端口已经用到了<strong>65534</strong>。所以可以肯定，这次压测中出现失败的原因，就在于源端口耗尽。</p><p>那要如何处理呢？显然我们也变不出更多的端口来。这个时候，我们可以<strong>调整压测软件的设置，比如从短连接改成长连接</strong>。这样就可以避免源端口耗尽的情况，因为所有的请求是在长连接里完成的，只要连接池本身设置合理，源端口就不会被用完。</p><h2 id="案例3压测报cannot-assign-requested-address错误"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例3压测报cannot-assign-requested-address错误"><span class="icon icon-link"></span></a>案例3：压测报cannot assign requested address错误</h2><p>我们内部有一个团队在做业务压力测试，结果遇到了一个奇怪的报错：cannot assign requested address。这次的场景是这样的：这个团队从多台客户端机器向LB上的一个VIP，发送大量的请求，而LB的后面就是很多的服务器。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage6dfb6d0449c9c02b508eaa5bc7956c0194fb.jpg" alt=""/></p><p>但是，还没等到这些服务器的负载跑起来，客户端那边提前报错了。这是一个Go语言的程序，具体的报错信息如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">https://test.vip/a&quot;: dial tcp 10.123.123.12:443: connect: cannot assign requested address</span></div><div class="token-line"><span class="token plain">    http post Post \&quot;https://test.vip/b&quot;: dial tcp 10.123.123.12:443: connect: cannot assign requested address retry 1 times</span></div></pre></div><p>于是他们就怀疑：既然报错是连接出错，那是不是LB有什么问题呢？比如，是否LB本身处理能力不够，不能服务这么大量的连接请求？否则为什么客户端会报connect的错误呢？要知道，用来发起TCP连接的系统调用（syscall）就是connect。</p><p>确实，这个报错信息“dial tcp 10.123.123.12:443: connect: cannot assign requested address”说得不太清楚。表面上看，就是客户端往10.123.123.12:443这个VIP发起连接请求（用connect）然后遇到了报错，也难怪测试团队会找到我们来查看LB的问题。</p><p>我们检查了LB，发现一切正常。于是把排查方向换到客户端。在这次测试中，有一个参数是关于HTTP Keep-alive的。如果你对课程前面的内容还有印象的话，应该还记得我们在第7讲“<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/482610">保活机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”里，深入讨论过这个问题。</p><p>简单来说，这次的测试配置里，HTTP Keep-alive没有打开，导致这些TCP连接被视作短连接来处理了，也就是一次HTTP请求和响应完成后，这条连接就关闭了。由于发起关闭的是客户端自己，于是这条连接也就进入了TIME_WAIT状态。</p><p>而要查看TIME_WAIT状态的连接数量，我们可以用 <strong>netstat命令</strong>，配合管道和awk来完成统计。比如，这次我在一台客户端机器上执行了下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ netstat -ant |awk &#x27;{++a[$6]} END{for (i in a) print i, a[i]}&#x27;</span></div><div class="token-line"><span class="token plain">    TIME_WAIT 28231</span></div></pre></div><p>或者用下面的 <strong>ss命令</strong>会更快：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ss -ant | awk &#x27;{++s[$1]}END{for(k in s) print k,s[k]}&#x27;</span></div><div class="token-line"><span class="token plain">    TIME-WAIT 28231</span></div></pre></div><p>可见，处于TIME_WAIT状态的连接数接近3万个，差不多就是Linux的本地动态端口的范围了。我们随后检查这台Linux机器的本地源端口范围，执行了下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ cat /proc/sys/net/ipv4/ip_local_port_range</span></div><div class="token-line"><span class="token plain">    32768	60999</span></div></pre></div><p>于是发现它的下限是32768，上限是60999，范围正好就是28231，跟TIME_WAIT的数量一致，显然也是一次源端口耗尽导致的压测问题。</p><p>当然，用sysctl也一样可以查看这个范围：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sysctl net.ipv4.ip_local_port_range</span></div></pre></div><p>不过你可能会问：“难道压测中的网络排查，除了包量和源端口，就没有别的问题了吗？”</p><p>我们来看一个不一样的案例。</p><h2 id="案例4压测遇到connection-reset-by-peer"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#案例4压测遇到connection-reset-by-peer"><span class="icon icon-link"></span></a>案例4：压测遇到connection reset by peer</h2><p>这次的场景是一个应用团队用netty http client去调用一个VIP做压测。具体来说是9台客户端机器，向同一个LB VIP发起大量的请求。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagec49ec42770f906ab7yyf9b964757d120069e.jpg" alt=""/></p><p>结果遇到了connection reset by peer。蹊跷的是，这个报错是零零星星出现的。而像之前的例子，如果真的源端口用尽了，那么接下来一段时间内，这些请求都会因为本地没有源端口可用而宣告失败，也就是报错会是大面积出现，而不会零星出现。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea072a086cf71e10b0c1f41f79978f6bd1a72.png" alt="图片"/></p><p>从图上看，报错数量不超过50个，主要集中在11点20分到11点35分这个时间段，这正是压测的时段。因为报错只有50来个，这相比于这次压测发起的成千上万的请求来说，是很小的比例了。</p><blockquote><p>补充：Y轴就是报错的个数，最高值是10，我们把几个柱体的高度加起来，就是报错的总数量了。</p></blockquote><p>我们了解到，压测期间每个客户端的请求频率是700TPS，所以9台客户端一共会发起6300TPS的请求量。这个问题诡异的地方就是，大部分的请求都能得到正确及时的回复，但是隔了两三分钟，就会出现几次这种connection reset by peer的问题。</p><p>那我们需要理解一下，<strong>为什么会reset</strong>。</p><p>我们在做网络排查的时候，如果在Wireshark里看到TCP RST，往往会觉得它不是一个好的征兆。确实，有时候是RST引起了故障，有时候又是网络故障迫使TCP用RST来结束连接。无论RST是因还是果，它总是跟问题本身逃不脱关系。</p><p>那干脆在TCP里取消RST，是不是很多问题就会被解决呢？当然不是，RST在TCP里面是一个非常必要的组成部分。没有RST，其实就没有“坏”的结束，也就没有“好”的开始。</p><p>大体上，TCP RST的原因可以分为这么几个大类：</p><ul><li>找不到相关连接，那么接收端可以放心地直接发送RST。</li><li>找到了相关连接，但收到的报文不符合TCP规范，那么接收端也可以发送RST。</li><li>找到了相关连接，但传输状况恶劣，内核选择及时“止损”，发送RST。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimageded6de7ec3cb7ccdc5c7da395f271dc935d6.jpg" alt=""/></p><p>而这次案例里面的情况，就符合第一种。这是因为：</p><ul><li>我们的LB上的VIP有一个idle timeout的设置，如果客户端在一定时限内不发任何报文，那么这条连接将被回收。这个时限是180秒，而且回收时不向客户端发送FIN或者RST报文。</li><li>这次的压测客户端框架里，有一个设置值也是关于idle timeout的。不过这个值设置的是360秒。</li></ul><p>你有没有发现问题？这两个idle timeout值一边大一边小，配合不当，就会出现下面这样的问题：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage029d02372ef7e9f63a76aa9f1c8e82957d9d.jpg" alt=""/></p><p>某条TCP连接中完成一次HTTP请求和响应之后，连接没有被关闭。过了180秒，LB这一侧的连接被回收了，但客户端那边还没到360秒，所以还认为这条连接是活着的，于是在180秒之后发起了一次请求。报文到达LB，后者在连接表里没有查到这条连接，于是回复了RST。</p><p>根因清楚了，解决起来异常简单：把客户端的Idle timeout参数，从原先的360秒，改成比LB的180秒更低的值就好了。这次改到了120秒，RST就完全消失了。</p><p>你看，虽然在案例2里，我们知道了压测最好使用长连接，这样可以避免源端口耗尽的问题。但是不等于你设置了长连接就一劳永逸了，还需要考虑idle timeout的问题。这次压测的关键在于：要确保长连接本身是真正有效的，你需要<strong>确保客户端的idle timeout小于服务端的idle timeout，这样才能避免连接失效导致的RST</strong>。</p><blockquote><p>补充：这个库是Ractor-Netty，idle timeout对应的是<a target="_blank" rel="noopener noreferrer" href="https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#evictInBackground-java.time.Duration-">evictInBackground<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> + <a target="_blank" rel="noopener noreferrer" href="https://projectreactor.io/docs/netty/release/api/reactor/netty/resources/ConnectionProvider.ConnectionPoolSpec.html#maxLifeTime-java.time.Duration-">maxLifeTime<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></blockquote><h2 id="实验"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#实验"><span class="icon icon-link"></span></a>实验</h2><p>回顾完这些压测案例，你可能会发现其实难度并不太大，是不是也跃跃欲试了呢？接下来，我们就用ab来做个小实验，这次还捎带一个小任务：<strong>控制TIME_WAIT状态的连接的数量</strong>。</p><p>在案例2和3里面，源端口耗尽的问题，本质是TIME_WAIT需要停留2MSL的时长。要解决TIME_WAIT连接过多的问题，方法有很多。这次我们只实验其中的一种方法，就是修改 <code>net.ipv4.tcp_max_tw_buckets</code> 这个内核参数。</p><p>它的默认值为16384，改为更小的值后，超过这个数值的TIME_WAIT连接会被清除，这样，TIME_WAIT连接数就被控制住了。</p><p>这个实验在本地就可以完成，比如在你的笔记本上安装VirtualBox，然后在这个虚拟机里面完成实验。</p><p>步骤一：安装Nginx和Apache ab。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">apt install nginx</span></div><div class="token-line"><span class="token plain">    apt install apache2-utils</span></div></pre></div><p>步骤二：启动ab测试，执行下面的命令。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ab -c 500 -n 10000 http://localhost/</span></div></pre></div><p>步骤三：观察TCP连接的各种状态的统计数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ss -ant | awk &#x27;{++s[$1]}END{for(k in s) print k,s[k]}&#x27;</span></div></pre></div><p>此时你应该会看到1万多个TIME_WAIT的连接，然后等待2分钟后继续步骤四。</p><p>步骤四：修改内核参数 <code>tcp_max_tw_buckets</code> 为100。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sysctl net.ipv4.tcp_max_tw_buckets=100</span></div></pre></div><p>步骤五：再次ab测试。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ab -c 500 -n 10000 http://localhost/</span></div></pre></div><p>步骤六：再次观察TCP连接的各种状态的统计数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ss -ant | awk &#x27;{++s[$1]}END{for(k in s) print k,s[k]}&#x27;</span></div></pre></div><p>此时TIME_WAIT应该只有100了。</p><p>当然，TIME_WAIT本身被设计出来是有原因的，建议你在改动它之前，把自己的场景想清楚，然后再改不迟。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们回顾了几个典型的压力测试场景中的网络问题，你需要重点掌握以下这些知识点。</p><p>**关于压测指标和工具。**轻量级的工具是ab，它十分方便，而且也可以发起大量的请求，在简单的压测场景下很有用。比如下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ab -k -c 100 -n 10000 目标URL</span></div></pre></div><p>重量级工具是LoadRunner和JMeter，它们可以实现复杂的交互行为，也提供更加详细的报告。</p><p>在网络性能领域，**包量是对PPS的简称，一般用来衡量一台主机的网络处理能力。**而评估包量的工具是sar，我们可以运行下面的命令获取到实时的包量值：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sar -n DEV 1 10</span></div></pre></div><p>**关于TCP的知识。**这节课里我们也再次温习了TCP相关的知识，包括：</p><ul><li>判断一个报文是否是之前报文的重传，可以根据两个关键信息：<strong>序列号、载荷长度</strong>。这两个值分别相同的多个报文，互相就是重传关系了。</li><li>压测数据起不来的一个常见原因是<strong>源端口耗尽</strong>，要验证这一点，可以执行以下命令，来查看TIME_WAIT或者ESTABLISHED状态的连接数是否到达了上限：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">ss -ant | awk &#x27;{++s[$1]}END{for(k in s) print k,s[k]}&#x27;</span></div></pre></div><p>或者：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">netstat -ant |awk &#x27;{++a[$6]} END{for (i in a) print i, a[i]}&#x27;</span></div></pre></div><ul><li>而连接数到达上限值的问题，往往跟可用的<strong>本地源端口范围</strong>有关。要查看端口范围，我们可以执行这条命令：</li></ul><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sysctl net.ipv4.ip_local_port_range</span></div></pre></div><ul><li>压测中遇到RST的原因，可能跟两端的idle timeout不合理有关，建议把客户端的idle timeout设置为比服务端idle timeout更低的值。</li></ul><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后还是再给你留两道思考题：</p><ul><li>测试HTTP性能经常用ab，那测试带宽本身，一般用什么工具呢？</li><li>要把TIME_WAIT停留的时间2MSL改小，你知道用什么方法吗？</li></ul><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p><h2 id="附录"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10#附录"><span class="icon icon-link"></span></a>附录</h2><p>抓包示例文件：<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/steelvictor/network-analysis/tree/master/22">https://gitee.com/steelvictor/network-analysis/tree/master/22<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/网络排查案例课/05.实战二应用层真实案例揭秘篇/10.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:36:32</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
