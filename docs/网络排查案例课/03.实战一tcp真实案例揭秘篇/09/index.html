<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>10 | 窗口：TCP Window Full会影响传输效率吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/网络排查案例课/03.实战一tcp真实案例揭秘篇/09" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/网络排查案例课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/网络排查案例课/01.开篇词/01"><span>开篇词 | 网络排查是工程师的必备能力</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/02.预习篇">02.预习篇</a><ul><li><a href="/blog-base/网络排查案例课/02.预习篇/01"><span>01 | 网络模型和工具：网络为什么要分层？</span></a></li><li><a href="/blog-base/网络排查案例课/02.预习篇/02"><span>02 | 抓包分析技术初探：你会用tcpdump和Wireshark吗？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇">03.实战一TCP真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/01"><span>03 | 握手：TCP连接都是用TCP协议沟通的吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/02"><span>04 | 挥手：Nginx日志报connection reset by peer是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/03"><span>05 | 定位防火墙（一）：传输层的对比分析</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/04"><span>答疑（一）| 第1~5讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/05"><span>06 | 定位防火墙（二）：网络层的精确打击</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/06"><span>07 | 保活机制：心跳包异常导致应用重启？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/07"><span>08 | 分段：MTU引发的血案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/08"><span>09 | 长肥管道：为何文件传输速度这么慢？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09"><span>10 | 窗口：TCP Window Full会影响传输效率吗？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/10"><span>答疑（二）| 第6~10讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/11"><span>11 | 拥塞：TCP是如何探测到拥塞的？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/12"><span>12 | 重传的认识：重传到底是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/13"><span>13 | 重传的再认识：没有任何丢包却也一直重传？</span></a></li><li><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/14"><span>14 | 安全：用Wireshark把DDoS攻击照出原形</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送">04.春节特别放送</a><ul><li><a href="/blog-base/网络排查案例课/04.春节特别放送/01"><span>春节特别放送（一）| 书单推荐</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/02"><span>春节特别放送（二）| 聊聊能力陷阱和终身学习</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/03"><span>春节特别放送（三）| 我的学习资料和工具</span></a></li><li><a href="/blog-base/网络排查案例课/04.春节特别放送/04"><span>春节特别放送（四）| 测一测你的网络排查能力</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇">05.实战二应用层真实案例揭秘篇</a><ul><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/01"><span>15 | Nginx的499状态码是怎么回事？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/02"><span>答疑（三）| 第11~15讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/03"><span>16 | 服务器为什么回复HTTP 400？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/04"><span>17 | 为什么前端页面里多选一个城市就报错？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/05"><span>18 | 偶发性问题如何排查？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/06"><span>19 | TLS的各种特性：TLS握手为什么会失败？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/07"><span>20 | TLS加解密：如何解密HTTPS流量？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/08"><span>答疑（四）| 第16~20讲思考题答案</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/09"><span>21 | 为什么用了负载均衡更加不均衡？</span></a></li><li><a href="/blog-base/网络排查案例课/05.实战二应用层真实案例揭秘篇/10"><span>22 | 为什么压力测试TPS总是上不去？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇">06.实战三不用抓包就能做的网络排查篇</a><ul><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/01"><span>23 | 路径排查：没有网络设备权限要如何做排查？</span></a></li><li><a href="/blog-base/网络排查案例课/06.实战三不用抓包就能做的网络排查篇/02"><span>24 | 丢包：如何确定丢包的存在及其程度？</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐">07.不定期加餐</a><ul><li><a href="/blog-base/网络排查案例课/07.不定期加餐/01"><span>不定期加餐（一） | 八仙过海，各显神通：透传真实源IP的各种方法</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/02"><span>用户故事 | 小S：学习是人生路上生生不息的活泉</span></a></li><li><a href="/blog-base/网络排查案例课/07.不定期加餐/03"><span>用户故事 | 王未：网络排查能力是一名合格运维工程师的必备技能</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/08.总结篇">08.总结篇</a><ul><li><a href="/blog-base/网络排查案例课/08.总结篇/01"><span>25 | 抓包分析的回顾、拾遗，和提高</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/02"><span>结束语 | 珍惜握手，难说再见</span></a></li><li><a href="/blog-base/网络排查案例课/08.总结篇/03"><span>结课测试 | “网络排查案例课”100分试卷等你来挑战！</span></a></li></ul></li><li><a href="/blog-base/网络排查案例课/summary">网络排查案例课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例：TCP Window Full是导致异地拷贝速度低的原因吗？" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#案例tcp-window-full是导致异地拷贝速度低的原因吗"><span>案例：TCP Window Full是导致异地拷贝速度低的原因吗？</span></a></li><li title="解读Expert Information" data-depth="3"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#解读expert-information"><span>解读Expert Information</span></a></li><li title="解读TCP Window Full" data-depth="3"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#解读tcp-window-full"><span>解读TCP Window Full</span></a></li><li title="自己验证TCP Window Full" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#自己验证tcp-window-full"><span>自己验证TCP Window Full</span></a></li><li title="下个序列号" data-depth="3"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#下个序列号"><span>下个序列号</span></a></li><li title="TCP Window Full对传输的影响" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#tcp-window-full对传输的影响"><span>TCP Window Full对传输的影响</span></a></li><li title="继续深挖窗口" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#继续深挖窗口"><span>继续深挖窗口</span></a></li><li title="验证传输公式" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#验证传输公式"><span>验证传输公式</span></a></li><li title="小结" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#思考题"><span>思考题</span></a></li><li title="附录" data-depth="2"><a href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#附录"><span>附录</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10--窗口tcp-window-full会影响传输效率吗"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#10--窗口tcp-window-full会影响传输效率吗"><span class="icon icon-link"></span></a>10 | 窗口：TCP Window Full会影响传输效率吗？</h1><p>你好，我是胜辉。</p><p>有时候，不少知识点在过段时间重新回看的时候，又会有新的体会和发现。比如在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484667">第8讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里，我们回顾了一个MTU造成传输失败的案例，虽然整个排查过程的步骤不算很多，但也算是TCP传输问题的一个缩影了。尤其是其中那个失败的TCP流中的一些现象，比如客户端发出的重复确认（DupAck），还有服务端启动的超时重传，都值得我们继续深挖，所以我会在后续的课程里继续这个话题。</p><p>然后在上节课里，我们还探讨了传输速度的相关知识，也初步学习了窗口的概念。最后，我们终于推导出了TCP传输的核心公式：速度=窗口/往返时间。这个公式，对于我们理解传输本质和排查传输问题，都有很强的指导意义。</p><p>然而，如果你足够细心的话，其实可能会对上节课里的细节有一些疑问，比如：既然接收窗口满了，那为什么当时没有看到TCP Window Full这种提示呢？</p><p>其实，我这边也有不少内容按住没有展开，包括核心公式的理解，我们在这节课里将有一个新的认识。另外，我也将带你继续挖掘窗口这个细分领域，这样你以后遇到跟窗口相关的问题，就知道如何破解了。</p><h2 id="案例tcp-window-full是导致异地拷贝速度低的原因吗"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#案例tcp-window-full是导致异地拷贝速度低的原因吗"><span class="icon icon-link"></span></a>案例：TCP Window Full是导致异地拷贝速度低的原因吗？</h2><p>也是在公有云服务的时候，有个客户有这么一个需求，就是要把文件从北京机房拷贝到上海机房。但是他们发现传输速度比较慢，就做了抓包。在查看抓包文件的时候，发现Wireshark有很多<strong>TCP Window Full</strong>这样的提示，不明白这些是否跟速度慢有关系，于是找我们来协助分析。</p><h3 id="解读expert-information"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#解读expert-information"><span class="icon icon-link"></span></a>解读Expert Information</h3><p>我们先要了解一下抓包文件的整体状况。怎么看呢？当然是看Expert Information了：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage728c7285f181c54e6f464836e8c44f43c88c.jpg" alt="图片"/></p><p>它确实提醒我们，有69个Warning级别报文，它们的问题是TCP Window specified by the receiver is now completely Full。在展开进一步排查之前，我们先对这个信息做一下解读。</p><ul><li>TCP Window：在上节课里，我介绍了TCP的三种窗口，分别是发送窗口、接收窗口、拥塞窗口。那么这里说的是哪个窗口呢？一般说到TCP Window，<strong>如果没有特别指明，就是指接收窗口</strong>。</li><li>specified by the receiver：这也很明确，这个窗口是接收方的，其实就是佐证了这个窗口就是接收窗口。</li><li>is now completely Full：窗口满了，这又怎么理解呢？你还记得在上节课里学过的在途数据，也就是Bytes in flight吗？<strong>当在途数据的大小等于接收窗口的大小时，这个窗口就是“满了”</strong>。</li></ul><p>好了，这个信息解读完毕，一句话说就是：发生了69次在途数据等于接收窗口的情况。</p><p>接下来我们看看TCP Window Full具体是个什么样子。比如我们选中224号报文，主界面也自动定位到了这个报文：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage494f4957d1a108c78d3f73eee9b85213864f.jpg" alt="图片"/></p><p>我们可以看到，除了224报文，也确实有很多其他报文也报了TCP Window Full的警告信息。</p><h3 id="解读tcp-window-full"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#解读tcp-window-full"><span class="icon icon-link"></span></a>解读TCP Window Full</h3><p>TCP Window Full这个信息非常直接明了，就是说“接收窗口满了”。不过，你可别以为这个信息是TCP报文里的某个字段。其实，它只是Wireshark通过分析得出的信息。你有没有注意到，TCP Window Full前后是有方括号的。一般来说，<strong>Wireshark自己分析得到的信息，都会用方括号括起来</strong>，而TCP报文本身的字段，是不会带这种方括号的。我们来看一个截图：</p><p><img src="/images/httpsstatic001geekbangorgresourceimageb7a5b76369d4ef7fe6f9dd49816247351fa5.jpg" alt="图片"/></p><p>上面是224号报文的TCP详情，里面有不少信息也带上了方括号，比如其中的 [Bytes in flight: 112000]，这也是解读出来的，而且它跟Window Full关系很大。</p><p>前面提到过，在途数据（或者叫在途字节数，Bytes in flight）等于接收窗口大小的时候，Wireshark就会解读为TCP Window Full了。不过，如果你在上图中找一下Window size，会发现它是19200，而不是Bytes in flight的112000，这又是为什么呢？</p><p><img src="/images/httpsstatic001geekbangorgresourceimage8298829ee4eda487862ed761cd0bafff8d98.jpg" alt="图片"/></p><p>这是因为，我们把发送方和接收方的接收窗口搞混啦。这里你需要搞清楚：如果说在途数据的发送方是A，接收方是B，那么这里Window Full的窗口，<strong>是B的接收窗口</strong>，而不是A的接收窗口。上图是A的报文，自然没有我们要找的B的接收窗口信息了，那怎么找到B的接收窗口呢？</p><p>因为这次通信是SCP文件传输，那么A就是客户端，它的端口是38979；B就是服务端，它的端口是22。我们的具体做法是：在抓包文件里，找到B（也就是源端口为22）的报文，而且应该是这个TCP Window Full报文之前的最近的一个，在这个报文里就有B的最近的接收窗口值。</p><p>单纯用文字，可能未必容易理解，我给你画了一张示意图：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage2e952e594ee968a7a62b307e5f22c08c4095.jpg" alt=""/></p><p>上图中，我还是用A指代发送端，用B指代接收端。当A的在途数据跟B的接收窗口大小相等时，Wireshark就会判断出，这个接收窗口满了，这意味着：A无法再从自己的发送缓冲区把数据发送出来了。只有当B回复ACK，确认了n字节的数据后，A才有可能发送最多n字节的数据（如果缓冲区有足够多的待发数据的话）。</p><p>让我们回到Wireshark窗口，找到离这个TCP Window Full最近的，从源端口22发送来的报文。我们发现，它就是下图这个222号报文：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage306030d13a6c4e4730742fe1bed79b6b0a60.jpg" alt="图片"/></p><p>可以看到，这个报文的接收窗口就是112000，正好等于前面224号报文的Bytes in flight的112000字节。所以，我把前面的示意图改进一下供你参考。这里面的信息比较多，建议你耐心多花几分钟时间来充分理解其中的机制：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage840f84453f815b643f6ac29062a3b9ccf90f.jpg" alt=""/></p><p>整个过程是这样的：</p><ul><li>B发送了报文222给A，其中带有B自己的接收窗口112000字节。由于这是一个纯的确认报文，所以没有TCP载荷，也没有在途数据。</li><li>报文抵达A端，进入A的接收缓冲区。</li><li>A从222号报文中得知，B现在的接收窗口是112000字节，由于发送缓冲区有足够多的待发的数据，A选择用满这个接收窗口，也就是连续发送112000字节。</li><li>A把这112000字节的数据发送出来，成为报文224，其中还带有A自己的接收窗口值19200字节，不过，由于这次主要是A向B传送数据，所以B发给A的基本都是纯确认报文，这些报文的载荷都是0。极端情况下，即使A的接收窗口为0，只要B回复的报文没有载荷，它们也是可以持续通信的。</li><li>224报文抵达B端，正好填满B的接收窗口112000字节。Wireshark分别从222报文中读取到B的接收窗口值，从224报文中读取到在途字节数，由于两者相等，所以Wiresahrk提示TCP Window Full。而这个信息是被Wiresahrk展示在224报文中的。</li></ul><h2 id="自己验证tcp-window-full"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#自己验证tcp-window-full"><span class="icon icon-link"></span></a>自己验证TCP Window Full</h2><p>对于在途数据，既然Wireshark可以解读出来，那只要理解了TCP的原理，我们同样可以自己来计算，这不仅可以考查我们对TCP知识的掌握程度，同时对日常排查也有帮助。有这么多好处，你是不是跃跃欲试了呢？不过在开始之前，我们要先学习一个新的概念。</p><h3 id="下个序列号"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#下个序列号"><span class="icon icon-link"></span></a>下个序列号</h3><p>下个序列号，也就是<strong>Next Sequence Number</strong>，缩写是<strong>NextSeq</strong>。它是指当前TCP段的结尾字节的位置，但不包含这个结尾字节本身。很显然，下个序列号的值就是当前序列号加上当前TCP段的长度，也就是<strong>NextSeq = Seq + Len</strong>。</p><p>这也不难理解，因为TCP字节流是连续的，那么既然Seq + Len是这个报文的数据截止点，自然也是下一个报文的起始点，你可以参考这个示意图：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagef7bff7864509fd7ff569ebbfa54e14a9e6bf.jpg" alt=""/></p><p>在Wireshark里，我们也可以找到NextSeq这个解读值，比如下图这样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagebd7ebd1093a136119ebf4166989e64b3637e.jpg" alt="图片"/></p><p>明白了NextSeq，我们来看如何手工验证TCP Window Full。比如，还是分析224号报文的这次TCP Window Full，我们可以这么做，来验证一下在途数据是否真的是112000字节。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage0e280ec8c879acb7526bbff8eb9650cyy928.jpg" alt="图片"/></p><p>首先，跟上面的步骤类似，我们要找到222号报文。在这个报文里，服务端（源端口22）告诉客户端：“我确认你发送来的198854字节的数据”。我们先把这个数字记为X。</p><p>然后，我们查看224号报文里，客户端发送的数据到了哪个位置：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage222e22f94b3933fb841705b28d11a3106b2e.jpg" alt="图片"/></p><p>我们可以在224号报文的TCP详情页，看到Next sequence number: 310854，而这个数字，就是客户端发送的数据的最新的位置。我们把这个数字记为Y。当然，你也可以像前面说的那样，把Seq和Len加起来，也就是308054 + 2800，得到的自然也是310854。</p><p>最后，我们做一个最简单的减法：Y - X = 310854 - 198854 = 112000！这正是前面说的在途数据的大小。</p><p>恭喜你，你已经学会了如何手工计算在途数据的方法，这也意味着你对TCP的了解又更深入了一点。你可以这么来总结计算在途数据的方法：</p><blockquote><p><strong>Bytes_in_flight = latest_nextSeq - latest_ack_from_receiver</strong></p></blockquote><p>不过，你会不会觉得，虽然这个计算方法对理解窗口有帮助，但是既然Wireshark会给我们提示，那这种计算也主要是自我练习而已，应该不会真的用得上吧？</p><p>这还真不好说。因为，Wireshark在不少场景下并不会给你提示。比如，在接收窗口接近满但又不是完全满的时候，哪怕是离窗口满只差1个字节，Wireshark也不会提示TCP Window Full了。但是，在途数据都已经逼近接收窗口的99.9%了，你还觉得这个肯定没有问题，或者一定没有隐患吗？</p><p>要知道，这种临界状况也很可能跟问题根因有关。那么你掌握了这个方法，就可以把排查做得更彻底了。或者，如果你想预防性能瓶颈，那么提前找到这种窗口临界满的状况，也是有益的。</p><p>到这里，我们可以回答开始时候的问题了：为什么上节课里，没有看到TCP Window Full这种提示呢？我们看一下当时的报文状况吧。</p><p>在22:30:39.067477，接收端的确认号为7105632：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage951595c7e978090178984b6cb27355021e15.jpg" alt="图片"/></p><p>然后在22:30:39.209712，接收端的确认号为7169872：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage4a774ae7928be673fd6d2c43c7289aed0077.jpg" alt="图片"/></p><p>这两个报文的时间跨度正好是141ms左右，也就是这次传输里面的<strong>往返时间</strong>。在这个往返时间里，接收端确认了多少数据呢？是7169872-7105632=64240，也就是64KB。这个就是99.9%逼近TCP Window Full了，但是因为还差小几十个字节，所以Wireshark并没有提示TCP Window Full！</p><p>你可能还想追问：那为什么不把这剩余的0.1%的窗口“榨干”，非要留一点呢？我们看一下当时的接收窗口和在途数据的具体情况，就以上面选择的5864报文附近为例：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage14d71439256885a585cebc96a139e41495d7.jpg" alt="图片"/></p><p>接收端（源端口为22）的接收窗口为65728，发送端（源端口为59159）的在途数据为65700，两者相差只有28字节。对于发送端来说，没有必要为了这区区28字节再发送一个小报文了，等接收窗口空余出多一点的空间后再动身不迟。</p><blockquote><p>如果你还没学习过上节课的内容，可能会对这些信息感到疑惑，建议先去把上节课学完，再来学习这一讲，效果更好。</p></blockquote><h2 id="tcp-window-full对传输的影响"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#tcp-window-full对传输的影响"><span class="icon icon-link"></span></a>TCP Window Full对传输的影响</h2><p>好了，现在我们已经对TCP Window Full做了充分的分析，而且也明白了：这就是<strong>接收端的接收窗口小于发送端的发送能力而出现的状况</strong>。我们也很容易得出推论：瓶颈在接收端，<strong>TCP Window Full也确实会影响传输速度</strong>。</p><p>春节刚过，你可能对高速公路上的状况也感受深刻吧！很多路段出现了堵车，这就相当于TCP Window Full，更多的车辆上不了高速了，只好堵在外面。如果高速公路的路更宽、车速更快，那么就相当于接收窗口变得更大，车辆就能进更多，也就相当于Bytes in flight更大了。这么说来，TCP流量控制和高速车流控制这两个领域也有不少共通之处，说不定双方都互有借鉴呢。</p><p>回到客户这次的案例。我们看看，这次的传输速度是多少呢？在上节课里，我介绍了在Wireshark里查看TCP传输速度的两种方法。比如，我们现在用I/O Graph来看一下：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage505f50bb15443878c7458035155f5a19425f.jpg" alt="图片"/></p><blockquote><p>补充：如果你的I/O Graph显示的不是这种图，那需要像图中这样：</p><ul><li>选中All Bytes指标；</li><li>Y轴的单位选为Bytes。</li></ul></blockquote><p>这个图不能说不对，但柱子比较粗，看起来不是很精确。这是因为，它默认是以1秒为间隔而计算的速度。但是TCP传输中途，很可能每过几毫秒都有所变化，所以，如果我们要看更加精细的图，可以调整一下粒度，把Interval从1sec改为100ms，看看会怎么样：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage91e191b410903c0b1f35fa0b88666ae012e1.jpg" alt="图片"/></p><p><img src="/images/httpsstatic001geekbangorgresourceimage555b5575a289a1aba0d303a0be0db968175b.jpg" alt="图片"/></p><p>这样看起来精确了很多。我已经把这个抓包文件上传到<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/steelvictor/network-analysis/tree/master/10">Gitee<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以下载后，依照这里的步骤，把我做过的排查工作也演练一遍，这对你掌握课程知识是很有帮助的。</p><blockquote><p>补充：如果你用Wireshark查看到的I/O Graph跟我这里的不同，那可以对比一下Interval和SMA period这两个配置是否跟图中的一致。</p></blockquote><p>这里有个小的注意点：因为我们选择的间隔是100ms，所以Y轴的数字就是Bytes/100ms，换算成Bytes/s的话，要把Y轴的数字再<strong>乘以10</strong>。从图上看，在一开始的8秒几乎没有数据传输发生，从第8秒开始速度上到了400KB/s（就是图上的40K*10）左右，一直到结束都大致维持在300~400KB/s这个区间里。</p><h2 id="继续深挖窗口"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#继续深挖窗口"><span class="icon icon-link"></span></a>继续深挖窗口</h2><p>一般来说，接收窗口、拥塞窗口、发送窗口，这些都不是一上来就是一个很大的值的，而是跟汽车起步阶段类似，逐步跑起来的。那么这就产生了一个很有意思的话题：这些窗口之间都是怎么协调的呢？直观上感觉，无论哪个更快了，另外两个就要受影响。</p><p>我们很容易理解，假设起始值相同，如果接收窗口增长的速度小于拥塞窗口的增长速度，那么接收窗口就成了瓶颈；反过来说，拥塞窗口增速更小，那么它就成了瓶颈。</p><p>当接收窗口成为瓶颈的时候，很容易就出现这里的TCP Window Full的现象。不过，我们这么多讨论都是基于文字，如果有更加直观的方式，让我们理解这个现象就更好了。这里，我们就可以再学一个Wireshark的小工具：TCP Stream Graphs里面的 <strong>Window Scaling</strong>。</p><p>我们还是打开Wireshark的Statistics下拉菜单，找到TCP Stream Graphs，在二级菜单中，选择Window Scaling：</p><p><img src="/images/httpsstatic001geekbangorgresourceimagecfe4cfa2f41e1e0a52f9yyd4d226c441a4e4.jpg" alt="图片"/></p><p>这时候就能看到Windows Scaling的趋势图了：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage0c820cda89fe0232b8515007fe1fc5e7aa82.jpg" alt="图片"/></p><p>我就直接给你把关键信息标注出来了。这里主要是两个关键点。</p><ul><li><strong>数据流的方向要找对</strong>：比如这次传输是从客户端向SSH服务端发送数据，所以要确认这是从一个高端口向22端口发送数据的流向。如果搞反了，那图就变成了SSH服务端回复的ACK报文了，不是你要分析的传输速度了。</li><li><strong>定位TCP Window Full</strong>：在这里，Receive Window是“阶梯”式的，每次变化后会保持在一个“平台”一小段时间，那么这时候Bytes Out（发送的数据，也就是Bytes in flight）就有可能触及这个“平台”，每次真的碰上的时候，就是一次TCP Window Full。</li></ul><p>我们可以看一个例子。图中的蓝线代表Bytes Out，绿线代表Receive Window。你可以像我这样，在这几个“平台”区域，找到蓝线和绿线的汇合点，然后在这些点上点击鼠标左键，就能定位到TCP Window Full事件了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage373e37cb41aa86cce8a437c13db7374d2a3e.jpg" alt="图片"/></p><p>上图中，我用鼠标放大了一个“平台”，然后选中了一个Receive Window和Bytes Out重合的点，它是1200号报文，主窗口也自动定位到了这个报文，果然它也是一次TCP Window Full。</p><h2 id="验证传输公式"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#验证传输公式"><span class="icon icon-link"></span></a>验证传输公式</h2><p>在上节课里，我们推导出了TCP传输的核心公式：<strong>速度=窗口/往返时间</strong>。既然当前案例里TCP Window Full的时候，Bytes in flight跟接收窗口相等，那么在这个公式里的窗口，是否就是Bytes in flight呢？我们来验证一下。</p><p>还是在Wireshark窗口里，我们要添加这么几个自定义列，以便进行数据比对：</p><ul><li>Acknowledgement Number：确认号</li><li>Next Sequence Number：下个序列号</li><li>Caculated Window Size：计算后的接收窗口</li><li>Bytes in flight：在途字节数</li></ul><blockquote><p>补充：如果对怎么添加自定义列还不清楚，可以复习<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/481042">第5讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的添加TTL自定义列的部分。</p></blockquote><p>另外，因为我们要集中检查发送端的Bytes in flight，就需要把源端口38979的报文过滤出来，这样就不会被另一个方向的报文给干扰了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageeb52ebf76c39e874a4350f8423485f0acd52.jpg" alt="图片"/></p><p>在这里，我们看到的Bytes in flight是112000字节左右。从右边滚动条的位置来看，这是在传输过程的初期。让我们滚动到中间和后期，看看这些在途字节数是多少：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage56eb5633292b85320c4a309d67f06c94b0eb.jpg" alt="图片"/></p><p>中期这里的Calculated Window Size明显增大了，到了445312字节。再看看后半程：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage55d755cecd4faa33088df661d5058df379d7.jpg" alt="图片"/></p><p>最后阶段已经达到863800字节。综合这三个阶段来看，折中值差不多在400KB左右，我们把它除以RTT 0.029秒，得到的是400KB/0.029s=13790KB/s。显然，这个数值远超过前面I/O Graph里看到的300~400KB/s。这是怎么回事呢？难道我们的核心公式是错的吗？</p><p>不知道你有没有考虑到这个问题：Bytes in flight是指真的一直在网络上两头不着吗？一般来说，数据到了接收端，接收端就发送ACK确认这部分数据，然后TCP Window就往下降了。比如ACK 300字节，那么TCP Window就又空出来300字节，也就是发送端又可以新发送300字节了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageba96ba911b5a75b84f691d7c61821e759b96.jpg" alt=""/></p><p>像图上这种情况：</p><ul><li>B通知A：“我的接收窗口是1000”；</li><li>A向B发送了1000字节，此时B的接收窗口满；</li><li>B向A确认了300字节的数据，自身的接收窗口也扩大为300字节；</li><li>A的在途字节数也从1000字节变成700字节，因为刚刚有300字节被B确认了。</li></ul><p>图中的t1到t4表示时间点。t2到t4就是一次往返的时间，在这个往返时间内，被传输的数据是1000字节吗？不是。因为被确认的只有300字节，所以传输完的也只有这300字节，速度也就不是1000/RTT，而是300/RTT！我们可以把核心公式做一下改进，变成下面这个：</p><blockquote><p><strong>velocity = acked_data/RTT</strong></p></blockquote><p>我们再用改进后的公式来计算这次的速度。我们可以选择传输中间偏后面一点的报文来做分析。比如下图中，我们选择1337号和1357号报文为起始和截止点，计算NextSeq的差值，还有时间的差值，然后两个差值相除。</p><p><img src="/images/httpsstatic001geekbangorgresourceimaged7ecd7174698a1e5c56357f6bd559bbb83ec.jpg" alt="图片"/></p><p>33600/0.094 = <strong>357KB/s</strong>。是不是很接近I/O Graph的值了？看来这样计算才是正确的！</p><p>那为什么在上节课里我们就可以用 <strong>窗口/往返时间</strong> 来计算速度，而且数值也很准呢？而这种方法用到这里就完全不对呢？</p><p>这是因为上节课的案例，在途数据一旦到了接收端，都被及时确认了。而当前这个案例里面并没有这样。也就是说，这次的案例，出现了“滞留”现象。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage4ee04e02af20ef67d67490ba5b2c00bb7de0.jpg" alt="图片"/></p><p>还是1337到1357号报文，我们去掉了过滤器 <code>tcp.srcport eq 38979</code>，这样就展示了双向报文。可以看到，服务端（B端）在这段时间内，只确认了22400字节（1495254 - 1472854），而同样时刻的在途数据，却一直维持在一个比较高的数字，在660KB上下。所以，<strong>真正完成了传输的数据量，是前者22400B，而不是“虚浮”的660KB</strong>。</p><p>那你可能又要问了：既然已经确认了22400字节，为什么客户端的在途字节数还是没有变化呢？</p><p>这是因为，客户端被确认了22400字节的数据，马上又把这个尺寸的数据发送出去了，事实上就<strong>维持了这个在途字节数的尺寸</strong>。</p><p>我可以再做一个比喻帮助你理解这个现象。我们如果去银行的一个窗口（这可不是TCP窗口）排队办业务，现在排队人数为10人，相当于Bytes in flight为10。每分钟都有一个人能完成业务办理，原以为队列会减小为9人，结果每当有一个人出来，保安就喊：“下一个！”于是就立刻又补进来一个人，所以队伍还是维持在10人这么长。</p><p>那么，窗口的业务员的办理速度是多少呢？显然不是10人/分钟，而是1人/分钟了。这样是不是理解起来容易多了？而上节课的情况，相当于这里的“每次就处理一个人”，所以处理速度就是1人/分钟，也就可以用“速度=窗口/往返时间”来计算了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#小结"><span class="icon icon-link"></span></a>小结</h2><p>这节课，我们集中讨论了TCP传输中的窗口相关的知识，特别是围绕TCP Window Full这个Wiresahrk中比较常见的信息，展开了深入的讨论。你需要重点掌握以下这些知识点：</p><ul><li>Wireshark报告TCP Window Full是因为，一端的在途数据跟另一端的接收窗口相等。</li><li>TCP的下个序列号（Next Sequence Number）等于序列号和段长度之和，即<strong>NextSeq = Seq + Len</strong>。</li><li>我们可以自己人工计算出在途字节数，公式是<strong>Bytes_in_flight = latest_nextSeq - latest_ack_from_receiver</strong>。</li><li>人工计算在途字节数的方法是：<ul><li>找到最近一次发送出去的报文的NextSeq，记为X；</li><li>找到在这次发送之前收到的最近的ACK，记录它的ACK，记为Y；</li><li>X－Y，得到在途字节数。</li></ul></li><li>另外我们也知道了，TCP Window Full确实会影响到传输速度。</li></ul><p>除了技术知识点，我也带你学习了下面这些Wireshark工具使用技巧：</p><ul><li>在Statistics下拉菜单下的I/O Graph工具，可以直观地展示传输速度图。</li><li>同是Statistics菜单下的TCP Stream Graphs的Window Scaling工具，可以直观的展示TCP Window Full历史曲线图。</li></ul><p>最后，我们还发现这个案例里的接收端有“数据滞留”的现象，这就导致“速度=窗口/往返时间”的公式遇到了挑战，而我们可以进一步优化为新的公式：<strong>速度=确认数据/往返时间</strong>。这个改进后的公式，可以兼容这种有“数据滞留”现象的传输场景。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>给你留两道思考题：</p><ul><li>TCP的序列号和确认号，最大可以到多少？</li><li>接收端只确认部分数据，导致了“数据滞留”现象，这个现象背后的原因可能是什么呢？</li></ul><p>欢迎你把答案分享到留言区，我们一同交流和进步。</p><h2 id="附录"><a aria-hidden="true" tabindex="-1" href="/blog-base/网络排查案例课/03.实战一tcp真实案例揭秘篇/09#附录"><span class="icon icon-link"></span></a>附录</h2><p>抓包示例文件：<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/steelvictor/network-analysis/tree/master/10">https://gitee.com/steelvictor/network-analysis/tree/master/10<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/网络排查案例课/03.实战一TCP真实案例揭秘篇/09.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:34:58</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
