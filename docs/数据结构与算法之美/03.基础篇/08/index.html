<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>
      12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？ - 大师兄
    </title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/数据结构与算法之美/03.基础篇/08" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a aria-current="page" class="active" href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a aria-current="page" class="active" href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/数据结构与算法之美/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/数据结构与算法之美/01.开篇词/01"><span>开篇词 | 从今天起，跨过“数据结构与算法”这道坎</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/02.入门篇">02.入门篇</a><ul><li><a href="/blog-base/数据结构与算法之美/02.入门篇/01"><span>01 | 为什么要学习数据结构和算法？</span></a></li><li><a href="/blog-base/数据结构与算法之美/02.入门篇/02"><span>02 | 如何抓住重点，系统高效地学习数据结构与算法？</span></a></li><li><a href="/blog-base/数据结构与算法之美/02.入门篇/03"><span>03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</span></a></li><li><a href="/blog-base/数据结构与算法之美/02.入门篇/04"><span>04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/数据结构与算法之美/03.基础篇">03.基础篇</a><ul><li><a href="/blog-base/数据结构与算法之美/03.基础篇/01"><span>05 | 数组：为什么很多编程语言中数组都从0开始编号？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/02"><span>06 | 链表（上）：如何实现LRU缓存淘汰算法?</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/03"><span>07 | 链表（下）：如何轻松写出正确的链表代码？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/04"><span>08 | 栈：如何实现浏览器的前进和后退功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/05"><span>09 | 队列：队列在线程池等有限资源池中的应用</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/06"><span>10 |  递归：如何用三行代码找到“最终推荐人”？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/07"><span>11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/数据结构与算法之美/03.基础篇/08"><span>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/09"><span>13 | 线性排序：如何根据年龄给100万用户数据排序？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/10"><span>14 | 排序优化：如何实现一个通用的、高性能的排序函数？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/11"><span>15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/12"><span>16 | 二分查找（下）：如何快速定位IP对应的省份地址？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/13"><span>17 | 跳表：为什么Redis一定要用跳表来实现有序集合？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/14"><span>18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/15"><span>19 | 散列表（中）：如何打造一个工业级水平的散列表？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/16"><span>20 | 散列表（下）：为什么散列表和链表经常会一起使用？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/17"><span>21 | 哈希算法（上）：如何防止数据库中的用户信息被脱库？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/18"><span>22 | 哈希算法（下）：哈希算法在分布式系统中有哪些应用？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/19"><span>23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/20"><span>24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/21"><span>25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/22"><span>26 | 红黑树（下）：掌握这些技巧，你也可以实现一个红黑树</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/23"><span>27 | 递归树：如何借助树来求解递归算法的时间复杂度？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/24"><span>28 | 堆和堆排序：为什么说堆排序没有快速排序快？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/25"><span>29 | 堆的应用：如何快速获取到Top 10最热门的搜索关键词？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/26"><span>30 | 图的表示：如何存储微博、微信等社交网络中的好友关系？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/27"><span>31 | 深度和广度优先搜索：如何找出社交网络中的三度好友关系？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/28"><span>32 | 字符串匹配基础（上）：如何借助哈希算法实现高效字符串匹配？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/29"><span>33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/30"><span>34 | 字符串匹配基础（下）：如何借助BM算法轻松理解KMP算法？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/31"><span>35 | Trie树：如何实现搜索引擎的搜索关键词提示功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/32"><span>36 | AC自动机：如何用多模式串匹配实现敏感词过滤功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/33"><span>37 | 贪心算法：如何用贪心算法实现Huffman压缩编码？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/34"><span>38 | 分治算法：谈一谈大规模计算框架MapReduce中的分治思想</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/35"><span>39 | 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/36"><span>40 | 初识动态规划：如何巧妙解决“双十一”购物时的凑单问题？</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/37"><span>41 | 动态规划理论：一篇文章带你彻底搞懂最优子结构、无后效性和重复子问题</span></a></li><li><a href="/blog-base/数据结构与算法之美/03.基础篇/38"><span>42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇">04.高级篇</a><ul><li><a href="/blog-base/数据结构与算法之美/04.高级篇/01"><span>43 | 拓扑排序：如何确定代码源文件的编译依赖关系？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/02"><span>44 | 最短路径：地图软件是如何计算出最优出行路径的？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/03"><span>45 | 位图：如何实现网页爬虫中的URL去重功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/04"><span>46 | 概率统计：如何利用朴素贝叶斯算法过滤垃圾短信？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/05"><span>47 | 向量空间：如何实现一个简单的音乐推荐系统？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/06"><span>48 | B+树：MySQL数据库索引是如何实现的？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/07"><span>49 | 搜索：如何用A*搜索算法实现游戏中的寻路功能？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/08"><span>50 | 索引：如何在海量数据中快速查找某个数据？</span></a></li><li><a href="/blog-base/数据结构与算法之美/04.高级篇/09"><span>51 | 并行算法：如何利用并行处理提高算法的执行效率？</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/05.实战篇">05.实战篇</a><ul><li><a href="/blog-base/数据结构与算法之美/05.实战篇/01"><span>52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构</span></a></li><li><a href="/blog-base/数据结构与算法之美/05.实战篇/02"><span>53 | 算法实战（二）：剖析搜索引擎背后的经典数据结构和算法</span></a></li><li><a href="/blog-base/数据结构与算法之美/05.实战篇/03"><span>54 | 算法实战（三）：剖析高性能队列Disruptor背后的数据结构和算法</span></a></li><li><a href="/blog-base/数据结构与算法之美/05.实战篇/04"><span>55 | 算法实战（四）：剖析微服务接口鉴权限流背后的数据结构和算法</span></a></li><li><a href="/blog-base/数据结构与算法之美/05.实战篇/05"><span>56 | 算法实战（五）：如何用学过的数据结构和算法实现一个短网址系统？</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利">06.加餐不定期福利</a><ul><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/01"><span>不定期福利第一期 | 数据结构与算法学习书单</span></a></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/02"><span>不定期福利第二期 | 王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫</span></a></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/03"><span>不定期福利第三期 | 测一测你的算法阶段学习成果</span></a></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/04"><span>不定期福利第四期 | 刘超：我是怎么学习《数据结构与算法之美》的？</span></a></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/05"><span>总结课 | 在实际开发中，如何权衡选择使用哪种数据结构和算法？</span></a></li><li><a href="/blog-base/数据结构与算法之美/06.加餐不定期福利/06"><span>《数据结构与算法之美》学习指导手册</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练">07.加餐春节7天练</a><ul><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/01"><span>春节7天练 | Day 1：数组和链表</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/02"><span>春节7天练 | Day 2：栈、队列和递归</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/03"><span>春节7天练 | Day 3：排序和二分查找</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/04"><span>春节7天练 | Day 4：散列表和字符串</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/05"><span>春节7天练 | Day 5：二叉树和堆</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/06"><span>春节7天练 | Day 6：图</span></a></li><li><a href="/blog-base/数据结构与算法之美/07.加餐春节7天练/07"><span>春节7天练 | Day 7：贪心、分治、回溯和动态规划</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/08.加餐用户学习故事">08.加餐用户学习故事</a><ul><li><a href="/blog-base/数据结构与算法之美/08.加餐用户学习故事/01"><span>用户故事 | Jerry银银：这一年我的脑海里只有算法</span></a></li><li><a href="/blog-base/数据结构与算法之美/08.加餐用户学习故事/02"><span>用户故事 | zixuan：站在思维的高处，才有足够的视野和能力欣赏“美”</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/09.结束语">09.结束语</a><ul><li><a href="/blog-base/数据结构与算法之美/09.结束语/01"><span>结束语 | 送君千里，终须一别</span></a></li><li><a href="/blog-base/数据结构与算法之美/09.结束语/02"><span>第2季回归 | 这一次，我们一起拿下设计模式！</span></a></li><li><a href="/blog-base/数据结构与算法之美/09.结束语/03"><span>结课测试｜这些数据结构与算法，你真的掌握了吗？</span></a></li><li><a href="/blog-base/数据结构与算法之美/09.结束语/04"><span>课程迭代｜全新交付71讲音频</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令">10.打卡召集令</a><ul><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令/01"><span>打卡召集令 | 60 天攻克数据结构与算法</span></a></li><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令/02"><span>打卡召集令 | 第一阶段知识总结</span></a></li><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令/03"><span>打卡召集令 | 第二阶段知识总结</span></a></li><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令/04"><span>打卡召集令 | 第三阶段知识总结</span></a></li><li><a href="/blog-base/数据结构与算法之美/10.打卡召集令/05"><span>打卡召集令 | 第四阶段知识总结</span></a></li></ul></li><li><a href="/blog-base/数据结构与算法之美/summary">数据结构与算法之美</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="归并排序的原理" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#归并排序的原理"><span>归并排序的原理</span></a></li><li title="归并排序的性能分析" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#归并排序的性能分析"><span>归并排序的性能分析</span></a></li><li title="快速排序的原理" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#快速排序的原理"><span>快速排序的原理</span></a></li><li title="快速排序的性能分析" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#快速排序的性能分析"><span>快速排序的性能分析</span></a></li><li title="解答开篇" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#解答开篇"><span>解答开篇</span></a></li><li title="内容小结" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#内容小结"><span>内容小结</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-base/数据结构与算法之美/03.基础篇/08#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12--排序下如何用快排思想在on内查找第k大元素"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#12--排序下如何用快排思想在on内查找第k大元素"><span class="icon icon-link"></span></a>12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？</h1><p>上一节我讲了冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是O(n2)，比较高，适合小规模数据的排序。今天，我讲两种时间复杂度为O(nlogn)的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序，比上一节讲的那三种排序算法要更常用。</p><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong>如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</strong> 这就要用到我们今天要讲的内容。</p><h2 id="归并排序的原理"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#归并排序的原理"><span class="icon icon-link"></span></a>归并排序的原理</h2><p>我们先来看<strong>归并排序</strong>（Merge Sort）。</p><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimagedb2bdb7f892d3355ef74da9cd64aa926dc2b.jpg" alt=""/></p><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。分治算法的思想我后面会有专门的一节来讲，现在不展开讨论，我们今天的重点还是排序算法。</p><p>前面我通过举例让你对归并有了一个感性的认识，又告诉你，归并排序用的是分治思想，可以用递归来实现。我们现在就来看看<strong>如何用递归代码来实现归并排序</strong>。</p><p>我在<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/41440">第10节<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲的递归代码的编写技巧你还记得吗？写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">递推公式：</span></div><div class="token-line"><span class="token plain">    merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    终止条件：</span></div><div class="token-line"><span class="token plain">    p &gt;= r 不用再继续分解</span></div></pre></div><p>我来解释一下这个递推公式。</p><p>merge_sort(p…r)表示，给下标从p到r之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q)和merge_sort(q+1…r)，其中下标q等于p和r的中间位置，也就是(p+r)/2。当下标从p到q和从q+1到r这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从p到r之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 归并排序算法, A是数组，n表示数组大小</span></div><div class="token-line"><span class="token plain">    merge_sort(A, n) {</span></div><div class="token-line"><span class="token plain">      merge_sort_c(A, 0, n-1)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 递归调用函数</span></div><div class="token-line"><span class="token plain">    merge_sort_c(A, p, r) {</span></div><div class="token-line"><span class="token plain">      // 递归终止条件</span></div><div class="token-line"><span class="token plain">      if p &gt;= r  then return</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 取p到r之间的中间位置q</span></div><div class="token-line"><span class="token plain">      q = (p+r) / 2</span></div><div class="token-line"><span class="token plain">      // 分治递归</span></div><div class="token-line"><span class="token plain">      merge_sort_c(A, p, q)</span></div><div class="token-line"><span class="token plain">      merge_sort_c(A, q+1, r)</span></div><div class="token-line"><span class="token plain">      // 将A[p...q]和A[q+1...r]合并为A[p...r]</span></div><div class="token-line"><span class="token plain">      merge(A[p...r], A[p...q], A[q+1...r])</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你可能已经发现了，merge(A[p...r], A[p...q], A[q+1...r])这个函数的作用就是，将已经有序的A[p...q]和A[q+1....r]合并成一个有序的数组，并且放入A[p....r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组tmp，大小与A[p...r]相同。我们用两个游标i和j，分别指向A[p...q]和A[q+1...r]的第一个元素。比较这两个元素A[i]和A[j]，如果A[i]&lt;=A[j]，我们就把A[i]放入到临时数组tmp，并且i后移一位，否则将A[j]放入到数组tmp，j后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组tmp中的数据拷贝到原数组A[p...r]中。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage952f95897ade4f7ad5d10af057b1d144a22f.jpg" alt=""/></p><p>我们把merge()函数写成伪代码，就是下面这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">merge(A[p...r], A[p...q], A[q+1...r]) {</span></div><div class="token-line"><span class="token plain">      var i := p，j := q+1，k := 0 // 初始化变量i, j, k</span></div><div class="token-line"><span class="token plain">      var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组</span></div><div class="token-line"><span class="token plain">      while i&lt;=q AND j&lt;=r do {</span></div><div class="token-line"><span class="token plain">        if A[i] &lt;= A[j] {</span></div><div class="token-line"><span class="token plain">          tmp[k++] = A[i++] // i++等于i:=i+1</span></div><div class="token-line"><span class="token plain">        } else {</span></div><div class="token-line"><span class="token plain">          tmp[k++] = A[j++]</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 判断哪个子数组中有剩余的数据</span></div><div class="token-line"><span class="token plain">      var start := i，end := q</span></div><div class="token-line"><span class="token plain">      if j&lt;=r then start := j, end:=r</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 将剩余的数据拷贝到临时数组tmp</span></div><div class="token-line"><span class="token plain">      while start &lt;= end do {</span></div><div class="token-line"><span class="token plain">        tmp[k++] = A[start++]</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 将tmp中的数组拷贝回A[p...r]</span></div><div class="token-line"><span class="token plain">      for i:=0 to r-p do {</span></div><div class="token-line"><span class="token plain">        A[p+i] = tmp[i]</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你还记得<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/41149">第7讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲过的利用哨兵简化编程的处理技巧吗？merge()合并函数如果借助哨兵，代码就会简洁很多，这个问题留给你思考。</p><h2 id="归并排序的性能分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#归并排序的性能分析"><span class="icon icon-link"></span></a>归并排序的性能分析</h2><p>这样跟着我一步一步分析，归并排序是不是没那么难啦？还记得上节课我们分析排序算法的三个问题吗？接下来，我们来看归并排序的三个问题。</p><p><strong>第一，归并排序是<strong><strong>稳定</strong></strong>的排序算法吗？</strong></p><p>结合我前面画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看merge()函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p><p>在合并的过程中，如果A[p...q]和A[q+1...r]之间有值相同的元素，那我们可以像伪代码中那样，先把A[p...q]中的元素放入tmp数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p><strong>第二，归并排序的<strong><strong>时间复杂度</strong></strong>是多少？</strong></p><p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。</p><p>在递归那一节我们讲过，递归的适用场景是，一个问题a可以分解为多个子问题b、c，那求解问题a就可以分解为求解问题b、c。问题b、c解决之后，我们再把b、c的结果合并成a的结果。</p><p>如果我们定义求解问题a的时间是T(a)，求解问题b、c的时间分别是T(b)和 T( c)，那我们就可以得到这样的递推关系式：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">T(a) = T(b) + T(c) + K</span></div></pre></div><p>其中K等于将两个子问题b、c的结果合并成问题a的结果所消耗的时间。</p><p>从刚刚的分析，我们可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p><p>套用这个公式，我们来分析一下归并排序的时间复杂度。</p><p>我们假设对n个元素进行归并排序需要的时间是T(n)，那分解成两个子数组排序的时间都是T(n/2)。我们知道，merge()函数合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span></div><div class="token-line"><span class="token plain">    T(n) = 2*T(n/2) + n； n&gt;1</span></div></pre></div><p>通过这个公式，如何来求解T(n)呢？还不够直观？那我们再进一步分解一下计算过程。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">T(n) = 2*T(n/2) + n</span></div><div class="token-line"><span class="token plain">         = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span></div><div class="token-line"><span class="token plain">         = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span></div><div class="token-line"><span class="token plain">         = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span></div><div class="token-line"><span class="token plain">         ......</span></div><div class="token-line"><span class="token plain">         = 2^k * T(n/2^k) + k * n</span></div><div class="token-line"><span class="token plain">         ......</span></div></pre></div><p>通过这样一步一步分解推导，我们可以得到T(n) = 2^k_T(n/2^k)+k_n。当T(n/2^k)=T(1)时，也就是n/2^k=1，我们得到k=log2n 。我们将k值代入上面的公式，得到T(n)=C_n+n_log2n 。如果我们用大O标记法来表示的话，T(n)就等于O(nlogn)。所以归并排序的时间复杂度是O(nlogn)。</p><p>从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)。</p><p><strong>第三，归并排序的<strong><strong>空间复杂度</strong></strong>是多少？</strong></p><p>归并排序的时间复杂度任何情况下都是O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是O(n2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是归并排序不是原地排序算法。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是O(n)，还是O(nlogn)，应该如何分析呢？</p><p>如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？</p><p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以空间复杂度是O(n)。</p><h2 id="快速排序的原理"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#快速排序的原理"><span class="icon icon-link"></span></a>快速排序的原理</h2><p>我们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。</p><p>快排的思想是这样的：如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。</p><p>我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三个部分，前面p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage4d814d892c3a2e08a17f16097d07ea088a81.jpg" alt=""/></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><p>如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">递推公式：</span></div><div class="token-line"><span class="token plain">    quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    终止条件：</span></div><div class="token-line"><span class="token plain">    p &gt;= r</span></div></pre></div><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 快速排序，A是数组，n表示数组的大小</span></div><div class="token-line"><span class="token plain">    quick_sort(A, n) {</span></div><div class="token-line"><span class="token plain">      quick_sort_c(A, 0, n-1)</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 快速排序递归函数，p,r为下标</span></div><div class="token-line"><span class="token plain">    quick_sort_c(A, p, r) {</span></div><div class="token-line"><span class="token plain">      if p &gt;= r then return</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      q = partition(A, p, r) // 获取分区点</span></div><div class="token-line"><span class="token plain">      quick_sort_c(A, p, q-1)</span></div><div class="token-line"><span class="token plain">      quick_sort_c(A, q+1, r)</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>归并排序中有一个merge()合并函数，我们这里有一个partition()分区函数。partition()分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为pivot（一般情况下，可以选择p到r区间的最后一个元素），然后对A[p...r]分区，函数返回pivot的下标。</p><p>如果我们不考虑空间消耗的话，partition()分区函数可以写得非常简单。我们申请两个临时数组X和Y，遍历A[p...r]，将小于pivot的元素都拷贝到临时数组X，将大于pivot的元素都拷贝到临时数组Y，最后再将数组X和数组Y中数据顺序拷贝到A[p....r]。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage66dc6643bc3cef766f5b3e4526c332c60adc.jpg" alt=""/></p><p>但是，如果按照这种思路实现的话，partition()函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是O(1)，那partition()分区函数就不能占用太多额外的内存空间，我们就需要在A[p...r]的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">partition(A, p, r) {</span></div><div class="token-line"><span class="token plain">      pivot := A[r]</span></div><div class="token-line"><span class="token plain">      i := p</span></div><div class="token-line"><span class="token plain">      for j := p to r-1 do {</span></div><div class="token-line"><span class="token plain">        if A[j] &lt; pivot {</span></div><div class="token-line"><span class="token plain">          swap A[i] with A[j]</span></div><div class="token-line"><span class="token plain">          i := i+1</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      swap A[i] with A[r]</span></div><div class="token-line"><span class="token plain">      return i</span></div></pre></div><p>这里的处理有点类似选择排序。我们通过游标i把A[p...r-1]分成两部分。A[p...i-1]的元素都是小于pivot的，我们暂且叫它“已处理区间”，A[i...r-1]是“未处理区间”。我们每次都从未处理的区间A[i...r-1]中取一个元素A[j]，与pivot对比，如果小于pivot，则将其加入到已处理区间的尾部，也就是A[i]的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是交换，在O(1)的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将A[i]与A[j]交换，就可以在O(1)时间复杂度内将A[j]放到下标为i的位置。</p><p>文字不如图直观，所以我画了一张图来展示分区的整个过程。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage08e7086002d67995e4769473b3f50dd96de7.jpg" alt=""/></p><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个6的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理你应该也掌握了。现在，我再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimageaa05aa03ae570dace416127c9ccf9db8ac05.jpg" alt=""/></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为O(nlogn)的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h2 id="快速排序的性能分析"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#快速排序的性能分析"><span class="icon icon-link"></span></a>快速排序的性能分析</h2><p>现在，我们来分析一下快速排序的性能。我在讲解快排的实现原理的时候，已经分析了稳定性和空间复杂度。快排是一种原地、不稳定的排序算法。现在，我们集中精力来看快排的时间复杂度。</p><p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是O(nlogn)。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span></div><div class="token-line"><span class="token plain">    T(n) = 2*T(n/2) + n； n&gt;1</span></div></pre></div><p>但是，公式成立的前提是每次分区操作，我们选择的pivot都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>我举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如1，3，5，6，8。如果我们每次选择最后一个元素作为pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素，这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n2)。</p><p>我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>我们假设每次分区操作都将区间分成大小为9:1的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</span></div></pre></div><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树，在树那一节我再讲，这里暂时不说。我这里直接给你结论：T(n)在大部分情况下的时间复杂度都可以做到O(nlogn)，只有在极端情况下，才会退化到O(n2)。而且，我们也有很多方法将这个概率降到很低，如何来做？我们后面章节再讲。</p><h2 id="解答开篇"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#解答开篇"><span class="icon icon-link"></span></a>解答开篇</h2><p>快排核心思想就是<strong>分治</strong>和<strong>分区</strong>，我们可以利用分区的思想，来解答开篇的问题：O(n)时间复杂度内求无序数组中的第K大元素。比如，4， 2， 5， 12， 3这样一组数据，第3大元素就是4。</p><p>我们选择数组区间A[0...n-1]的最后一个元素A[n-1]作为pivot，对数组A[0...n-1]原地分区，这样数组就分成了三部分，A[0...p-1]、A[p]、A[p+1...n-1]。</p><p>如果p+1=K，那A[p]就是要求解的元素；如果K&gt;p+1, 说明第K大元素出现在A[p+1...n-1]区间，我们再按照上面的思路递归地在A[p+1...n-1]这个区间内查找。同理，如果K&lt;p+1，那我们就在A[0...p-1]区间查找。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/03.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage8991898d94fc32e0a795fd65897293b98791.jpg" alt=""/></p><p>我们再来看，为什么上述解决思路的时间复杂度是O(n)？</p><p>第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对大小为n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+...+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述解决思路的时间复杂度就为O(n)。</p><p>你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行K次，找到的数据不就是第K大元素了吗？</p><p>不过，时间复杂度就并不是O(n)了，而是O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n)不就等于O(n)吗？</p><p>这个可不能这么简单地划等号。当K是比较小的常量时，比如1、2，那最好时间复杂度确实是O(n)；但当K等于n/2或者n时，这种最坏情况下的时间复杂度就是O(n2)了。</p><h2 id="内容小结"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#内容小结"><span class="icon icon-link"></span></a>内容小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和merge()合并函数。同理，理解快排的重点也是理解递推公式，还有partition()分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是O(n2)，但是平均情况下时间复杂度都是O(nlogn)。不仅如此，快速排序算法时间复杂度退化到O(n2)的概率非常小，我们可以通过合理地选择pivot来避免这种情况。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-base/数据结构与算法之美/03.基础篇/08#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>现在你有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这10个较小的日志文件，合并为1个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB，你有什么好的解决思路，能“快速”地将这10个日志文件合并吗？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr/><p>我已将本节内容相关的详细代码更新到GitHub，<a target="_blank" rel="noopener noreferrer" href="https://github.com/wangzheng0822/algo">戳此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>即可查看。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/数据结构与算法之美/03.基础篇/08.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:07:49</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
