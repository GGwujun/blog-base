<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog/umi.css" />
    <script>
      window.routerBase = "/blog";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>10｜搜索算法： 一起来写一个简单的爬虫？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/04.基础算法篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog/编译原理之美">编译原理之美</a></li><li><a href="/blog/编译原理实战">编译原理实战</a></li><li><a href="/blog/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog/详解http">详解http</a></li><li><a href="/blog/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog/网络排查案例课">网络排查案例课</a></li><li><a href="/blog/linux操作系统">linux操作系统</a></li><li><a href="/blog/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog/程序员数学基础">程序员数学基础</a></li><li><a href="/blog/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog/操作系统实战">操作系统实战</a></li><li><a href="/blog/软件工程之美">软件工程之美</a></li><li><a href="/blog/sql必知必会">sql必知必会</a></li><li><a href="/blog/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog/网络编程实战">网络编程实战</a></li><li><a href="/blog/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog/常用算法25讲">常用算法25讲</a></li><li><a href="/blog/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog/全栈工程师修炼指南">全栈工程师修炼指南</a></li><li><a href="/blog/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog/代码之丑">代码之丑</a></li><li><a href="/blog/代码精进之路">代码精进之路</a></li><li><a href="/blog/数据分析思维课">数据分析思维课</a></li><li><a href="/blog/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a aria-current="page" class="active" href="/blog/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="BFS和DFS" data-depth="2"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#bfs和dfs"><span>BFS和DFS</span></a></li><li title="BFS实现思路" data-depth="2"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#bfs实现思路"><span>BFS实现思路</span></a></li><li title="实现" data-depth="3"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#实现"><span>实现</span></a></li><li title="DFS实现思路" data-depth="2"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#dfs实现思路"><span>DFS实现思路</span></a></li><li title="实现" data-depth="3"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#实现-1"><span>实现</span></a></li><li title="时空复杂度" data-depth="2"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#时空复杂度"><span>时空复杂度</span></a></li><li title="空间复杂度" data-depth="3"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#空间复杂度"><span>空间复杂度</span></a></li><li title="总结" data-depth="2"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#总结"><span>总结</span></a></li><li title="课后作业" data-depth="3"><a href="/blog/业务开发算法50讲/04.基础算法篇/03#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="10搜索算法-一起来写一个简单的爬虫"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#10搜索算法-一起来写一个简单的爬虫"><span class="icon icon-link"></span></a>10｜搜索算法： 一起来写一个简单的爬虫？</h1><p>你好，我是微扰君。</p><p>你玩过井字棋的游戏吗？在一个九宫格中，双方轮流用X和O占领一个格子，某一方的O或者X三个连成一线时即可获胜。</p><p>这样一个简单井字棋的游戏，如果要让你自己写代码实现一个AI，你会怎么做呢？怎么把博弈过程清晰地表示出来呢？</p><p>实际上，许多博弈类游戏的过程，我们都可以用树来表示。根节点就是棋盘为空的状态，终点就是各个棋下完的状态，这样的树也被称为博弈树。下图是井字棋某个局面3步内的树状展示：<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/04.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/resourceimageaf35afa35cb31b7e23b452e49743d53f4235.jpg" alt=""/></p><p>一般来说，对弈双方在做的事情，其实就是找到这棵树上对于自己最优的一种落子方式，使得之后的每条路径，自己都有必胜或者必不败的策略。<strong>如果你想要找出一个AI策略，最暴力的方式就是直接遍历每一种情况，找到最优的下法，这就是一个典型的搜索问题了</strong>。</p><p>事实上，这类博弈的游戏要么是先手必不败，要么是后手必不败，所以对全空间的搜索一定是可以写出一个无敌AI的，对证明感兴趣的同学可以去搜索“策梅洛定理”了解。</p><p>如果暴力遍历，有多少种情况呢？相信你也发现了，就是这么一个简单的井字棋小游戏，终局的数量非常多，达到了255168种。我们可以这样来简单地估计它，第一步有9种下法，第二步有8种下法，显然通过排列组合的知识，占满棋盘一共有9！=362880种下法，当然还需要去掉一些中间获胜不应该继续进行对弈的情况。</p><p>这本身是一道挺有意思的数学问题，也可以通过写代码更快地计算出来，留给你作为课后作业。当然这个数字还不算天文数字，尚且在计算机的处理范围之内，如果我们稍微把游戏的复杂度提升一下，比如围棋，还能通过暴力搜索的方式得到一个优秀的AI吗？</p><p>我们知道，围棋盘有19*19个落子点，所以刚开始的每一步可能都有接近361个选择，那整体的情况可能接近361！种。这是一个天文数字，在现在的计算机架构下，直接计算和存储这样的问题是不可能的。所以我们<strong>想要写出一个靠谱的围棋AI，就需要采取一些新的策略，只选择部分分支进行遍历，从中找出一个比较好的方案</strong>。</p><p>对于人类而言这个过程就是依靠经验，对于AI来说，就是依托于数据，你从AlphaGO核心算法的名字“蒙特卡洛搜索树”中，就可以看出来，这本质上还是一个搜索的问题，只不过人类棋手和AI都采用了比较高明的搜索策略。</p><p>我们今天就不讲那么进阶的内容了，就讲一讲平时常用的广度优先搜索算法BFS和深度优先搜索算法DFS。</p><p>它们是两种最常见的暴力搜索算法，在面试中也相当常见，前者的实现需要用到我们之前讲解的队列这一数据结构，后者则是递归思想最常用的场景之一。在工程中它们也发挥着巨大的作用。比如，DFS在前端开发中DOM树相关的操作里就非常常见，我们可以用它来实现对DOM树的遍历，从而对比两颗DOM树的差异，这就是React中虚拟DOM树算法的关键点之一。</p><h2 id="bfs和dfs"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#bfs和dfs"><span class="icon icon-link"></span></a>BFS和DFS</h2><p>BFS和DFS，作为两种最暴力、也相当常用的搜索策略，<strong>最大的特点就是无差别地去遍历搜索空间的每一种情况，因此但凡是可以抽象成图上的问题，基本上都可以考虑用BFS、DFS去做</strong>。只不过效率可能不是最优的，所以我们也常常称之为暴力搜索算法，在各大刷题网站题解区中，你应该常常能见到“暴搜”这样的关键词，说的一般就是DFS和BFS这两种算法。</p><p>所以，在爬虫这样本来就需要无差别遍历全部空间的场景下可以说是非常合适的了。至于DFS和BFS具体选择哪一种，我们可以结合一个具体的爬虫场景来分析。</p><p>如果让你手写一个爬虫，从豆瓣上爬取一个用户关注的所有用户，是不是很简单？只要直接遍历某个用户的关注者列表就可以了，除了需要处理一些鉴权和页面解析的问题，没有什么复杂的地方。</p><p>那我们升级一下挑战，爬取这个用户关注的人的所有关注的人，也就是和这个用户有二度关系的所有用户，你要怎么实现呢？如果不是二度，而是让你查找三度关系，也就是找出需要三跳的所有用户，你的代码能否很简单地通过配置就完成这件事呢？</p><p>这其实就是一个非常适合用DFS和BFS解决的问题，因为它天然就是一个需要无差别遍历所有图上节点的问题。<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/04.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/resourceimage2f4b2f60f4ec427e8acb573216626f882c4b.jpg" alt=""/><br/>你可以把豆瓣用户看成节点，用户之间的关注关系就是边，它们一起构成了一个复杂的社交网络。相信你也听过社交网络中的“六度分割理论”，说的就是世界上任何一个人和你之间的距离不会超过6度，描述了社交网络的小世界特性。这种网络关系也是许多人在研究的。</p><h2 id="bfs实现思路"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#bfs实现思路"><span class="icon icon-link"></span></a>BFS实现思路</h2><p>好我们先来使用BFS解决这一问题。我们优先去遍历所有到源用户距离为一度的用户，然后再遍历这些用户的邻居，用层层深入的方式进行搜索。广度优先搜索，其实是一个很直观的定义，我们把对应到图上的搜索顺序画出来，就很清晰了。</p><p>看简化的情况，假设我们搜索的源用户为图的0节点，一度关系包含3个节点，二度关系包含了6个节点，每条连边都是一个关注关系。那我们基于广度优先搜索策略遍历时，就会按照标号顺序进行遍历。</p><p>为了在代码中实现这样的遍历效果，求出所有和0节点构成两度以内关系的用户，我们就需要借助之前学习的“队列”了。</p><p>因为广度优先搜索是由源点向外逐层推进的，每遍历下一层的时候，我们都需要用到上一层的节点，所以我们需要一个容器记录每一层的元素，并依次遍历，先进先出的队列就可以帮助我们很好地解决这个问题。<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/04.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/resourceimageb6cdb6a00c0c8f97bbcf4849939c469d07cd.jpg" alt=""/></p><p>我们首先把遍历的初始节点加入queue中，然后循环读取queue中的元素，每次读出一个元素，就把它的所有相邻节点都放入新队列中，直到目前队列为空，就代表我们遍历完了所有的元素。队列FIFO的特性保证了，下一层的元素一定会比上层的元素更晚出现。</p><p>当然我们经常需要设置自己的搜索退出条件，比如在最短路径问题中，我们并不需要遍历所有的路径，当搜索到终点的时候其实就可以退出了；在我们的例子中，我们的退出条件也不是遍历完整个社交网络，遍历到第二度关系就可以结束了，因此我们还需要在代码中记录当前遍历的层数。</p><p>另外，有时候需要对插入队列中的元素做一些判重，防止重复的搜索。</p><p>在搜索最短路径或者求几度关系所有用户的情况下就很有用，因为重复的节点已经没有必要再搜索了；如果不这样做，甚至可能导致你的搜索永远无法结束，比如在图有环的情况下。</p><h3 id="实现"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#实现"><span class="icon icon-link"></span></a>实现</h3><p>下面我们试着写一下，就用爬虫常用的脚本语言Python来实现这次的代码。</p><p>解释一下几个关键的变量。</p><p>degree就是广度优先搜索中我们用于记录搜索层数的变量。为了每一次出队的时候，把一层的元素全部出队，在遍历中我们采用了两层while循环，这样内层循环结束后，我们就可以保证当前层的元素已经全部被访问，也可以将degree进行自增操作。</p><p>之所以开了一个新的变量next_degree_urls也是同样的道理，当前层的邻居不能干扰到这一层的出队操作，所以我们将邻居们放到一个新的队列中；内层循环结束后，再将已经为空的队列更新为next_degree_urls。</p><p>而类型为set的变量res，除了记录所有的用户主页，也起到了判重的作用；如果已经出现在res集中，说明我们已经遍历过这个用户主页了，不需要再遍历一次了，所以在循环中直接通过<code>continue</code>跳过。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 这里我们需要一个合适的 douban html parser</span></div><div class="token-line"><span class="token plain">        def crawl(self, startUrl: str) -&gt; List[str]:        </span></div><div class="token-line"><span class="token plain">            urls = deque()</span></div><div class="token-line"><span class="token plain">            urls.append(startUrl)</span></div><div class="token-line"><span class="token plain">            res = set()</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            degree = 0</span></div><div class="token-line"><span class="token plain">            N = 2</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            while urls:</span></div><div class="token-line"><span class="token plain">                # 遍历层数超过N层，停止遍历</span></div><div class="token-line"><span class="token plain">                if degree &gt; N: break </span></div><div class="token-line"><span class="token plain">                # 用于记录下一层的节点</span></div><div class="token-line"><span class="token plain">                next_degree_urls = deque()</span></div><div class="token-line"><span class="token plain">                # 遍历当前层 </span></div><div class="token-line"><span class="token plain">                while urls:</span></div><div class="token-line"><span class="token plain">                  u = urls.popleft()</span></div><div class="token-line"><span class="token plain">                  if u in set: continue</span></div><div class="token-line"><span class="token plain">                  for url in doubanHtmlParser.getFollowings(u):</span></div><div class="token-line"><span class="token plain">                      next_degree_urls.append(url)</span></div><div class="token-line"><span class="token plain">                  res.add(u)</span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">                urls = next_degree_urls</span></div><div class="token-line"><span class="token plain">                # 当前层元素全部出队；进入下一层遍历，记录遍历层数的变量加1</span></div><div class="token-line"><span class="token plain">                degree = degree + 1</span></div></pre></div><p>当然，既然是爬虫，我们肯定是需要对网页进行解析的，就用一个getFollowing函数表示这个过程，做的事情就是输入一个用户主页的URL，返回该用户关注的其他好友的个人主页。</p><p>大致实现思路就是，通过网络请求库获取指定URL的HTML文本信息，从中解析出表示用户关注好友列表的部分，一般列表中的每个元素都会指向该好友的个人主页，我们把相关的href标签里的URL解析出来即可。</p><p>好了，这样我们就用基于队列的广度优先搜索策略完成了一个简易的爬虫，感兴趣你可以自己补全HTML解析器的代码，完整实现一下。</p><h2 id="dfs实现思路"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#dfs实现思路"><span class="icon icon-link"></span></a>DFS实现思路</h2><p>再来用DFS解决这个问题。深度优先搜索，就不会再像广度优先搜索那样严格由内而外逐层推进了，它和棋手下棋的思路其实会更像一点，我们就用下棋举个例子。</p><p>假设下棋的时候，当前局面可以有若干个落子点，棋手一般会先顺着其中一个落子点在脑海中模拟若干步，发现某一步不行，我们回溯到分叉点，再看一下其他选择；最终遍历完当前选择的落子点的各种局面之后，再依次进行其他落子点的判断，直到选出一种比较优的策略。</p><p>画成图对比一下，你会更直观地感受到两者的区别，同样用刚刚假想的豆瓣用户关注关系图来举例：<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/04.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/resourceimage997d99dc4e012057249a93141e120960e07d.jpg" alt=""/></p><p>上图的数字，表示深度优先搜索在同样的关系图中的遍历顺序；可以看到相比于BFS的逐层推进，在DFS中，是一条条分支顺次遍历到终点再进行下一种尝试的，这也是深度优先搜索命名的由来。</p><h3 id="实现-1"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#实现-1"><span class="icon icon-link"></span></a>实现</h3><p>这种遍历方式也天然符合回溯法的适用场景，所以常规做法就是通过递归来实现。写成代码如下，关键就是11-13行的for循环，递归地对当前节点的每个子节点进行同样的DFS过程，细节你可以参考代码中的注释来理解，网页解析的逻辑和前面所说的是一样的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 结果集 用于存放所有N度关系以内的用户</span></div><div class="token-line"><span class="token plain">        res = set()</span></div><div class="token-line"><span class="token plain">        N = 2 # 记录找N度关系以内的所有用户；N=2即找2度关系以内的用户</span></div><div class="token-line"><span class="token plain">        def crawl(startUrl, degree):  </span></div><div class="token-line"><span class="token plain">            # 如果已经超过N度关系，我们不用继续遍历      </span></div><div class="token-line"><span class="token plain">            if degree &gt; N : return</span></div><div class="token-line"><span class="token plain">            # 如果已经搜索过，我们也不用继续搜索</span></div><div class="token-line"><span class="token plain">            if startUrl in res : return</span></div><div class="token-line"><span class="token plain">            # 将当前搜索的用户主页加入结果集</span></div><div class="token-line"><span class="token plain">            res.add(startUrl)</span></div><div class="token-line"><span class="token plain">            for url in doubanHtmlParser.getFollowings(startUrl):</span></div><div class="token-line"><span class="token plain">              # 遍历关注的所有用户，注意需要将度数增加1</span></div><div class="token-line"><span class="token plain">              crawl(url, degree+1)</span></div></pre></div><p>DFS的代码看起来明显要简短很多，这就是递归的威力。通过对自身的调用，很多时候，我们可以让代码变得非常简单。</p><h2 id="时空复杂度"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#时空复杂度"><span class="icon icon-link"></span></a>时空复杂度</h2><p>两种方法的时空复杂度都非常容易分析。</p><p>先说时间复杂度。我们做的事情就是遍历一次网络或者图中的每个节点，因为借助结果集判重后，即使在图中多次出现的节点，也只会入队一次或者被递归一次。那么假设图中有V个顶点，E条边。</p><p>在BFS中，图中所有顶点入队一次、出队一次，每条边都会在边起点出队的时候被遍历一次，所以整体的复杂度为O(V+E)。而在实际的复杂网络中，E一般是远大于V的，所以可以近似认为复杂度为O(E)。</p><p>在DFS中，是从起点出发递归遍历图，通过结果集判重，保证重复的节点不会被递归两次，从而每条边只会被遍历一次，整体复杂度为O(E)。</p><p>所以时间复杂度上两者没有太大的差别。但是在一些求最短路径的场景下，比如求从当前位置走出迷宫的最短路径，就会有一定差异。这是因为BFS是从内到外逐层搜索，所以最早搜索到终点的时候，就对应了最短路径；因此找到终点我们就可以提前结束搜索过程。<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/04.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/resourceimaged414d4553905d9da922e22b6192cb316ec14.jpg" alt=""/></p><p>而在DFS中，由于我们优先遍历每条路径的最大深度，即使找到了终点也只能说明找到了一条路径，这并不能保证这条路径是最短的，所以哪怕找到终点也不能结束搜索过程，需要遍历完整个搜索空间，找到所有可能的路径之后再从中选择一条最短的。</p><p>在搜索空间很大，但已知搜索路径不会特别长的情况下，DFS可能会比BFS要慢很多，所以你要根据实际情况选择一种合适的算法。</p><p>当然在今天豆瓣爬虫的场景下，我们需要的就是遍历整个空间找到所有构成N度关系的用户，所以两种算法的时间复杂度其实没什么区别。</p><h3 id="空间复杂度"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#空间复杂度"><span class="icon icon-link"></span></a>空间复杂度</h3><p>再来看空间复杂度。</p><p>在BFS中，主要的空间复杂度就是queue和res所占用的大小。那这里的，res本身并不是所有的BFS场景下都会需要的，因为我们并不一定需要返回所有遍历过的节点，可能只需要记录一个距离之类的值。</p><p>但是，在大部分的BFS下，我们是不希望重复遍历节点的，所以仍然需要一个类似于res的集合去标记所有经过的点。它所需要的最大空间和图中总结点数量V一致。而queue存储的就是图上的节点，其所占用的空间最大也不会超过V。所以BFS的空间复杂度是O(V)。</p><p>在DFS中，所消耗的内存同样主要与res相关。因为虽然相比于BFS，我们少了queue的内存消耗，但是也多了隐含递归中调用栈所消耗的空间。由于调用栈最多就是描述一条经过了所有节点的路径，其最大空间大小也不会超过顶点数量V。因而DFS的空间复杂度同样是O(V)。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>作为两个相当常用的暴力搜索算法，BFS和DFS比较适合用来解决图规模不大，或者本身就需要无差别遍历搜索空间的每一种情况的问题；这两者的时间空间复杂度是相当的。</p><p>而至于DFS和BFS具体选择哪一种，我也总结出一些自己的经验，供你参考。</p><p>BFS因为是由内向外地毯式地搜索，所以首次搜索到目标位置的时候一定是源点到目标位置的最短路径，所以求最短路径类的问题往往可以用BFS解决。当然，这里的“最短路径”是有条件的，只有在图中所有边权重相等时首次搜索到的才是最短路径；另一类边权不等的图上的最短路径求解问题我们之后会单独讲解。</p><p>而DFS实现起来比BFS更简单，且由于递归栈的存在，让我们可以很方便地在递归函数的参数中记录路径，所以需要输出路径的题目用DFS会比较合适。毕竟想用BFS实现相同的路径记录，除了需要在queue中记录节点，还需要关联到此节点的路径才可以，占用的空间比DFS高得多。</p><p>一般情况下我们都可以优先使用DFS实现，但这完全建立在我个人觉得DFS写起来更简单的前提下。而在需要求解路径本身的问题中，强烈建议你采用DFS作为搜索算法的实现。</p><h3 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog/业务开发算法50讲/04.基础算法篇/03#课后作业"><span class="icon icon-link"></span></a>课后作业</h3><p>最后，我再给你留三个小作业。</p><ol><li>既然说是可以用DFS或者BFS写一个爬虫，希望你尝试补全一下爬虫中解析HTML和HTTP请求的逻辑。或者动手写一个你自己想写的爬虫感受一下，体会搜索算法在实战中的应用。</li><li>在搜索N度关系的所有用户时，如果我们希望同时把源用户和这些用户的关注关系记录下来，比如A-&gt;B-&gt;C就表示A关注了B，B关注了C；更广泛地意义上来说就是让你记录搜索过程中的路径。你会怎么实现这个逻辑呢？</li><li>前面提到的井字棋中，尝试用代码计算一共有多少种最终合法的局面呢？</li></ol><p>欢迎你在留言区与我讨论。如果有收获也欢迎你转发给身边的朋友，邀他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/docs/业务开发算法50讲/04.基础算法篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 13:36:35</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog/umi.js"></script>
  </body>
</html>
