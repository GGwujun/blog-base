<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>08｜外部排序：如何为TB级数据排序？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/04.基础算法篇/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="排序" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#排序"><span>排序</span></a></li><li title="举个例子" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#举个例子"><span>举个例子</span></a></li><li title="TB级数据排序" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#tb级数据排序"><span>TB级数据排序</span></a></li><li title="外部排序" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#外部排序"><span>外部排序</span></a></li><li title="运行时间" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#运行时间"><span>运行时间</span></a></li><li title="如何降低归并层数" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#如何降低归并层数"><span>如何降低归并层数</span></a></li><li title="败者树" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#败者树"><span>败者树</span></a></li><li title="时间复杂度" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#时间复杂度"><span>时间复杂度</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#总结"><span>总结</span></a></li><li title="课后作业" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="08外部排序如何为tb级数据排序"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#08外部排序如何为tb级数据排序"><span class="icon icon-link"></span></a>08｜外部排序：如何为TB级数据排序？</h1><p>你好，我是微扰君。</p><p>之前已经学习了常用数据结构的工业级实现（包括动态数组、双向链表、双端队列、栈、哈希表、红黑树、堆），从今天开始，我们来讲讲一些经典的算法思想在工程实践中的应用。</p><p>那讲哪些算法呢？我们都知道算法是一个很大的命题，也有很多分类的方式，比如就有人总结过非常经典的五类常用算法：贪婪算法、动态规划算法、分治算法、回溯算法以及分支限界算法。力扣上的每一道算法题也有相应标签，你感兴趣的话可以到题库看一下。</p><p>不过有些算法可能只会在特定的场景下被特定的中间件所使用，比如布隆过滤器、前缀树等等，我们在后面的章节结合实际的系统或中间件来讲解；有一些算法思想应用更为广泛，我们会在这个部分学习，所以基础算法篇主要包括了贪心、分治、二分的算法思想，也会涵盖排序、搜索、字符串匹配这些更为常见的应用场景。</p><p>今天就让我们从经典的排序问题开始讲起吧。</p><h3 id="排序"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#排序"><span class="icon icon-link"></span></a>排序</h3><p>排序，应该是我们学习算法和数据结构时最早就会学习到的几个算法问题，按时间复杂度这个标准大体可以分为O(n^2)、 O(nlogn) 、O(n) 三大类。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage29b729c48a9fc247438d6c94ffdf3b43a6b7.jpg" alt="图片"/></p><p>O(n^2)的选择排序、冒泡排序、插入排序，这些常用的算法相信你应该非常熟练了；几种O(n)的算法在工程中其实也都有实际应用，你也可以自己在网上搜索资料了解学习，最好再找几道相关算法题做一做加深印象。</p><p>O(nlogn) 的三个常见算法从概念上看也不难理解，但细节实现起来还是有一些复杂度，需要花点时间刻意练习，是面试中相对重要的算法考点。</p><p>其中归并排序和快速排序的常用写法都可以采用递归的方式实现，背后是分治的算法思想，也就是分而治之，把大问题递归拆小然后递归得出结果。</p><p>而堆排序的思路和实现，在上一讲优先队列中我们详细讲过，相信你现在应该很容易用Java的PriorityQueue实现堆排序，主要思路其实就是建立一个堆，借助堆动态调整的能力，只需要将所有待排序元素依次入队，再依次出队直到堆元素全部出队为止；比如在小顶堆中，每次出队的都是当前最小的元素。</p><p>但只是能写出这样的排序代码，往往并不足以让你解决真实世界的工程问题。</p><h3 id="举个例子"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#举个例子"><span class="icon icon-link"></span></a>举个例子</h3><p>比如有这样一个基于真实场景的经典面试题：假设现在有1TB的任意文本，请问如何能将其中出现的单词按照字母序排列，得到一个新的文本？</p><p>这个问题，你可以回答好吗？</p><p>你也许会觉得很简单呀。我们就直接用堆排序，建立一个小顶堆，然后遍历整个文本进行分词，将每个单词都依次push进堆，最后再逐一出队输出到一个文本，最后就可以得到一个按字典序升序排列的文本了。</p><p>这当然是一个正确的思路，<strong>但是，你忽略了一个至关重要的问题，就是我们的内存可能没有这么大</strong>！</p><p>这也是面试官考察这个问题的核心知识点，1TB的数据量级，意味着绝对不可能一次性将所有的数据都放入到内存中。而大部分单纯考察算法的面试题，其实都是在一个比较理想的环境下的，比如和排序相关的问题，绝大部分题目肯定会给你一个数组去存放需要排序的元素，隐含了内存可以一次性将所有数据读入的条件。</p><p>但在实际工作中，我们经常会遇到内存中放不下所有数据的排序场景。</p><p>早期可能因为内存的容量确实很小，而现在更多是因为我们需要存储的数据越来越大了，甚至不只是内存放不下，单机的硬盘可能也不够了，需要考虑分布式环境下的排序问题，比如在一个分布式数据库中进行超大表的<code>order by</code>操作，这往往需要花费几分钟甚至几小时的运算才能完成。</p><p>好言归正传，我们就借助这道经典面试题一起来看看如何解决大量数据的排序问题。</p><h2 id="tb级数据排序"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#tb级数据排序"><span class="icon icon-link"></span></a>TB级数据排序</h2><p>这个经典的算法问题我们一般称之为外部排序，这里的“外”指的其实就是外部存储的意思。</p><p>读写较慢的外存，相比快速但昂贵的内存而言，有着更低廉的成本，通常是硬盘，它可以存放更大的数据。<strong>当我们不能直接在内存中进行排序，而需要借助外存去处理极大量数据的排序时，就需要使用外部排序算法了</strong>。</p><p>如果遇到这样的面试题，首先可以来向面试官确认一下已有的硬件环境，比如面试官可能会告诉你，你现在有1GB的内存可用。那么我们知道整个1TB的文件，至少要读1024次才能遍历一遍，所以直接在内存里排序显然是不现实的。</p><p>但是文件其实是可以一部分一部分读的，如果内存中一次放不下全部的数据，也许我们可以<strong>将文件分成若干段，分别读入内存中，并采用常见的内排序算法（比如堆排序），对这段可以在内存中存储的段落进行排序</strong>；得到若干个有序的文件段后，最后通过一些合并的方式，得到整体有序的文件。</p><p>当然在这个过程里会有大量的中间结果，比如那些有序的文件片段，这些我们都需要借助外存存储，这个思路就是最常见的一种外部排序的方式。</p><p>其实你会发现我们刚刚描述的想法和归并排序如出一辙，归并排序也是常用的外排实现方式，只不过我们在学习它的时候，一般都是针对数组，也就是在内存中排序的场景。</p><h3 id="外部排序"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#外部排序"><span class="icon icon-link"></span></a>外部排序</h3><p>好我们用严谨的语言来重新描述一下基于归并思想的外排过程，整体分为两个阶段：</p><ul><li>部分排序阶段</li></ul><p>我们根据内存大小，将待排序的文件拆成多个部分，使得每个部分都是足以存入内存中的。然后选择合适的内排序算法，将多个文件部分排序，并输出到容量可以更大的外存临时文件中，每个临时文件都是有序排列的，我们将其称之为一个“顺段”。</p><ul><li>归并阶段</li></ul><p>我们对前面的多个“顺段”进行合并，思想和归并排序其实是一样的。以2路归并为例，每次都将两个连续的顺段合并成一个更大的顺段。</p><p>因为内存限制，每次可能只能读入两个顺段的部分内容，所以我们需要<strong>一部分一部分读入，在内存里将可以确定顺序的部分排列，并输出到外存里的文件中</strong>，不断重复这个过程，直至两个顺段被完整遍历。这样经过多层的归并之后，最终会得到一个完整的顺序文件。</p><p>举一个简化的例子，配合示意图理解。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageedceed5c8cfa170455d8a8ff4c3c736a0fce.jpg" alt="图片"/></p><p>假设现在有含有1000个记录的文件，而内存最多只能读取100个记录。那么我们要做的第一步就是先把1000个记录拆成十个文件，每个文件有100个记录，读入后在内存中排序得到10个有序的临时文件，并输出到外存也就是硬盘中。</p><p>然后我们进行多次归并操作，每次都把相邻的文件合并。在这个例子中可以看到只需要进行4轮归并，就得到了一个最终有序的文件。</p><h3 id="运行时间"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#运行时间"><span class="icon icon-link"></span></a>运行时间</h3><p>那整个过程里，运行时间主要和哪些因素有关呢？</p><p>在第一个阶段部分排序中，由于内存可以装下每个顺段的所有元素，所以几种主流的O(nlogn)的算法都是可以的，其中快速排序在大部分场景下是最快的，因此我们可以首选快速排序。</p><p>比较复杂的是归并阶段。因为内存不足以装下所有需要排序的元素，所以O(nlogn)的堆排和快排都已经没办法被应用在外排的场景中了，但基于分治思想的归并排序却依然可以很好地发挥作用。</p><p>而且相比很多其他排序方式比如选择排序、冒泡排序，归并排序O(nlogn)的复杂度已经是理论上相当好的复杂度了。当然在一些特定场景下我们也可以用一些线性排序算法比如桶排序来解决外部排序问题，感兴趣的同学可以自己搜索了解一下。</p><p>但是和内排中的归并排序不同，<strong>外部排序场景下，我们还有个非常大的时间消耗就是IO，也就是输入输出</strong>。</p><p>相比内存中的读写操作，在磁盘中的读写是一个慢得多的过程，两者之间可能有千倍以上的时间开销差距。所以考虑外排效率时，非常重要的一点就是我们要尽量减少从磁盘中读取数据的耗时，而这主要关系要访问多少次外存。</p><p>那我们在外存中需要读取多少次数据呢？从图中其实可以看出来，每一层我们读取外存的数据总量其实是一样的，本质上就是将所有的数据都遍历一遍。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageedceed5c8cfa170455d8a8ff4c3c736a0fce.jpg" alt="图片"/></p><p>而内存大小是一样的，所以每一层中读取外存的次数也就是一样的，那么显然关系我们读取次数的多少主要就取决于所需归并的层数了。因此，<strong>我们要做的事情就是让归并的层数越低越好</strong>。</p><p>怎么样做到这件事呢？答案很简单也很直观，就是增加更多的归并路数或者降低初始的顺段数量。</p><h3 id="如何降低归并层数"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#如何降低归并层数"><span class="icon icon-link"></span></a>如何降低归并层数</h3><p>我们先算出归并层数，以2路归并为例，每次合并两个连续的顺段，如果上一层有n个顺段，到下一层就会有n/2个顺段，每一层的顺段都会减少一半，直至只剩一个顺段，也就是需要的排序结果。因而，假设初始一共有n个顺段，那么我们大致需要log2n层。</p><p>同样的道理，如果进行k路归并，每一层的顺段数量都会变成上一层的1/k，所以就大概只需要logk(n)层即可完成整个归并。比如一个5路归并的例子。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage36423660c083db7a5e190822yy66ff37cb42.jpg" alt="图片"/></p><p>所以，为了增加归并路数，也就是尽量增加k。</p><p>另外为了降低初始n个顺段的数量，我们会做的事情也很简单，就是在第一次进行逐段内排序的时候尽可能多地将数据读入内存中并进行内排。</p><p>但是增加k的大小，其实也会导致每次归并的时候合并的成本变大，<strong>一个显著的问题就是在k路归并中，我们需要从k个元素中选择出最小的元素，代价比2路归并的更高</strong>。如果用最暴力的方式，遍历k个元素，每次选择最小的元素的过程将产生O(k)的时间复杂度，这一定程度上会抵消前面通过增加k减少磁盘IO所带来的时间提升。</p><p>但是我们仔细想想这个问题，选择k个元素中的最小元素，显然有优于暴力遍历O(k)复杂度的算法。比如，上一讲介绍的堆就可以解决这个问题。</p><p>而败者树，则是解决从k个元素中选取最小元素并可以动态更新的另一种方法，也是更广泛运用于多路归并中的算法，我们来学习一下它的思路。</p><h2 id="败者树"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#败者树"><span class="icon icon-link"></span></a>败者树</h2><p>败者树也被称为，淘汰赛树，也就是Tournament Tree，思想来自体育比赛。</p><p>我们知道在淘汰赛中，每一场比赛都有两个参与者，其中胜者可以晋级下一轮。整体可以画成一颗树的形状，如果看过足球比赛，相信你对这个图一点也不陌生。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage97e897c53873407010835d7ee108225085e8.jpg" alt="图片"/></p><p>败者树算法就是基于这一思想实现的，我们用叶子节点存储所有待比较的元素，<strong>对叶子结点两两比赛，在它们共同的父节点中存储失败者；然后对获胜者节点再两两比较，得到更上一层的败者，取出胜者继续往上比较</strong>，这个过程和归并的思路其实也是比较相似的；这样一层一层往上比较，最后就可以得到一颗锦标赛状的树。</p><p>因为除了叶子结点外的每一层的父节点存储的都是其子节点中的失败者，所以我们称其为败者树。根节点我们会稍微做一点特别的处理，除了在根结点存储失败者，同时，我们在根节点之上会悬挂上整棵树的最终获胜者。</p><p>我们可以给刚刚的例子画出对应的败者树，大概就是下面这个图的样子。其中根节点上的方框存储的就是整个树的胜者，也就是1，它一定是所有元素中的最小值，和锦标赛的冠军是一个意思。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageaf20afaf8cd198861999f23a45f65e2bc620.jpg" alt="图片"/></p><p>至于为什么在节点中存储的是失败者，而不是获胜者呢？就留给你做课后思考题啦。事实上，在父节点中存储获胜者的树也是存在的，和你想的一样，我们也称之为胜者树。</p><p>和堆一样，我们也会需要对败者树进行类似于出队的操作；在上面的例子中，就是我们需要将1从败者树中取出，寻找下一个最小的元素。</p><p>这里有两种情况，一种是我们取出1之后，用一个新的元素替代1，另一种就是取出1之后不再添加新的元素，分别对应某一路元素被取出之后仍有元素未取完，和该路元素已经全部取出的情况。在这两种情况中，我们其实都只需要对整个树重新比赛一次即可，只是在第二种情况里，我们会用一个无限大的数字替换1，因为无限大的数字一定不会在这次重赛中胜出。</p><p>我们用一个具体的例子来讲解一下这个过程，假设取出1之后，我们用8来替换1原来的位置。<br/><img src="/images/httpsstatic001geekbangorgresourceimagec62bc686d1ae17e65d09a6d2d0ebd1a6642b.jpg" alt=""/><br/>由于每个父节点存储的都是两个子节点中的失败者，所以我们只要用更新的值和父节点的值比较，也就是和之前两个子节点中的失败者比较。</p><p>因为原来的获胜者已经被取走了，这里的父节点现在存储的其实就是这颗子树中原来的亚军，<strong>如果我们要看这次新来的选手能否能成为新的冠军，只需要和原来的亚军进行一次比较即可</strong>；当然这次比较结束后，两者中的胜者还需要到更上一层继续比较。</p><p>这个过程和运动员从市队、省队一路选拔到国家队参加奥运会的过程也是颇为神似的，希望这个例子能帮助你更好地理解败者树的工作机制。</p><p>整个过程写成伪代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 定义节点的value为具体的值；index为每一路数据的索引</span></div><div class="token-line"><span class="token plain">    // 用index.next可以取到每一路某个元素的后继元素。</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function merge(L1, …, Ln)</span></div><div class="token-line"><span class="token plain">        buildTree(heads of L1, …, Ln)</span></div><div class="token-line"><span class="token plain">        while tree has elements</span></div><div class="token-line"><span class="token plain">            winner := tree.winner</span></div><div class="token-line"><span class="token plain">            output winner.value</span></div><div class="token-line"><span class="token plain">            new := winner.index.next</span></div><div class="token-line"><span class="token plain">            replayGames(winner, new) // Replacement selection</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    function replayGames(node, new)</span></div><div class="token-line"><span class="token plain">        loser, winner := playGame(node, new) // 比较新节点和老节点的大小</span></div><div class="token-line"><span class="token plain">        node.value := loser.value // 当前节点记录为比较中失败的节点</span></div><div class="token-line"><span class="token plain">        node.index := loser.index</span></div><div class="token-line"><span class="token plain">        if node != root</span></div><div class="token-line"><span class="token plain">            replayGames(node.parent, winner) // 胜者跟父节点继续比较</span></div><div class="token-line"><span class="token plain">     </span></div><div class="token-line"><span class="token plain">    function buildTree(elements)</span></div><div class="token-line"><span class="token plain">        nextLayer := new Array()</span></div><div class="token-line"><span class="token plain">        while elements not empty // 自下而上而上建树</span></div><div class="token-line"><span class="token plain">            el1 := elements.take()</span></div><div class="token-line"><span class="token plain">            el2 := elements.take()</span></div><div class="token-line"><span class="token plain">            loser, winner := playGame(el1, el2) // 两两比较</span></div><div class="token-line"><span class="token plain">            parent := new Node(el1, el2, loser) </span></div><div class="token-line"><span class="token plain">            nextLayer.add(parent) // 将获胜者放入上一层 继续</span></div><div class="token-line"><span class="token plain">        if nextLayer.size == 1 // 只有根节点 直接返回即可</span></div><div class="token-line"><span class="token plain">            return nextLayer </span></div><div class="token-line"><span class="token plain">        else</span></div><div class="token-line"><span class="token plain">            return buildTree(nextLayer)</span></div></pre></div><h3 id="时间复杂度"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#时间复杂度"><span class="icon icon-link"></span></a>时间复杂度</h3><p>最后我们来分析一下败者树的整体时间复杂度，我们假设一共有k个节点。首先，初始化的过程需要花费 O(k) 的时间，因为对于k个子节点，一共只需要进行k-1场比赛即可完成淘汰赛。</p><p>然后在归并排序的每一次合并中，只需要进行replay操作，从新元素到根路径上逐一重赛。在每一层中，只需要进行一次比较。由于树是平衡的，从叶子结点到根路径仅包含 O(logk) 元素（这里高度的计算和之前讲解堆的推导是差不多的，你可以复习之前的章节）。所以，总的时间复杂度为 O(klog k) 。</p><p>现在有了败者树的加持，多路归并排序就可以比较高效地解决外部排序的问题了。对于1TB任意文本的排序问题，大致思路就是：</p><ol><li>先用内排序算法，尽可能多的加载源文件，将其变成n个有序顺段。</li><li>在内存有限的前提下每k个文件为一组，<strong>每次流式地从各个文件中读取一个单词，借助败者树选出字典序最低的一个，输出到文件中</strong>，这样就可以将k个顺段合并到一个顺段中了；反复执行这样的操作，直至所有顺段被归并到同一个顺段。</li></ol><p>这里稍微补充一下，看起来我们每次从文件中只读取了一个单词，但操作系统在读文件的时候是会按页为单位读取并缓存下来的，所以某一次磁盘访问之后的若干次访问，其实都会直接命中cache，也就是说，并不是每次从败者树中取出元素时都会真的产生磁盘IO，请不用担心。</p><p>当然在工业级实现中肯定还是有很多优化空间的。比如待合并的文件比较大的时候，我们可以利用二分搜索对文件进行分段，并行地合并，相关研究也比较多，感兴趣你可以自行搜索了解。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#总结"><span class="icon icon-link"></span></a>总结</h2><p>随着互联网的发展，数据量一直在稳步的提升，许多算法问题都不能只简单地考虑内存中可以存储，甚至单机磁盘可以存储的情况了。相信我们今天学习的外排算法思想，一定会给你一些解决此类问题的启发，希望你可以举一反三在实际生产中也能将算法更好地运用在有各种限制的真实环境中。</p><p>借鉴内排中归并排序的想法，我们可以实现一个多路归并的外排算法，解决内存空间不足的问题。但也因为涉及外部存储，需要重点考虑IO的成本。通过尽可能多地利用内存中的排序，得到尽量少的初始顺段，以及选择合适的多路归并参数，我们就可以做到外存访问次数尽量少了。</p><p>多路归并，可以通过堆或者败者树实现，这里我也给你贴一道力扣上的<a target="_blank" rel="noopener noreferrer" href="https://leetcode-cn.com/problems/merge-k-sorted-lists">算法题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>供你练习。</p><h3 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/01#课后作业"><span class="icon icon-link"></span></a>课后作业</h3><p>最后留两个思考题。</p><ol><li>既然，我们已经有了堆，为什么还要用败者树这样的数据结构呢？还有前面提到的胜者树，它不是一个更直观的表示方式吗？所以相比堆和胜者树，败者树在解决求多个元素中最小元素的问题时，又有什么样的优势呢？</li><li>除了基于O(n*logn)的归并排序的思想，有没有可能基于线性排列的几种算法来实现外部排序呢？</li></ol><p>欢迎你留言与我讨论。如果有收获也欢迎你转发给身边的朋友，邀他一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/04.基础算法篇/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:33:51</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
