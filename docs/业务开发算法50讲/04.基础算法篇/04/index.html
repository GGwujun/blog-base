<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>11｜字符串匹配：如何实现最快的grep工具 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/04.基础算法篇/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="字符串匹配问题" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#字符串匹配问题"><span>字符串匹配问题</span></a></li><li title="坏字符规则" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#坏字符规则"><span>坏字符规则</span></a></li><li title="好后缀规则" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#好后缀规则"><span>好后缀规则</span></a></li><li title="具体实现" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#具体实现"><span>具体实现</span></a></li><li title="坏字符最右位置计算" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#坏字符最右位置计算"><span>坏字符最右位置计算</span></a></li><li title="好后缀偏移表计算" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#好后缀偏移表计算"><span>好后缀偏移表计算</span></a></li><li title="匹配过程" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#匹配过程"><span>匹配过程</span></a></li><li title="时间复杂度" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#时间复杂度"><span>时间复杂度</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#总结"><span>总结</span></a></li><li title="课后作业" data-depth="3"><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="11字符串匹配如何实现最快的grep工具"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#11字符串匹配如何实现最快的grep工具"><span class="icon icon-link"></span></a>11｜字符串匹配：如何实现最快的grep工具</h1><p>你好，我是微扰君。</p><p>grep命令，相信使用过Linux的同学都会非常熟悉，我们常常用它在Linux上进行文本搜索操作，具体来说就是从一段文本中查找某个字符串存在的行。下面一个典型的grep的使用例子，比如我可以用它来看看自己在LeetCode上用Java做了多少题：</p><p><img src="/images/httpsstatic001geekbangorgresourceimage9baa9b96f1b08a964ba051681c05dc3f8faa.png" alt="图片"/></p><p>GNU Grep 则是 grep 命令的一个工业级实现，在项目官方 Readme 中作者是这样介绍它的：</p><blockquote><p>This is GNU grep, the “fastest grep in the west” (we hope).</p></blockquote><p>其实就是在说这是世界上最快的grep程序。当然，这款从上世纪就诞生的软件，敢这么说自己也是因为它有着十足的底气。</p><p>GNU Grep 确实是将“文本搜索”这一简单的功能做到了极致。作者 Mike Haertel 自己写了<a target="_blank" rel="noopener noreferrer" href="https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">一封邮件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>解释 GNU Grep 为什么这么快，主要有两点：</p><ol><li>它避免了检查每一个byte</li><li>对于被检查的byte，只需要执行非常少的指令</li></ol><p><strong>第一点的主要优化就在于 GNU Grep 用到了非常知名的字符串匹配算法：Boyer Moore 算法</strong>，也就是我们常说的 BM 算法，它是目前已知的在大多数工业级应用场景中最快的字符串匹配算法，因而被广泛应用在各种需要搜索关键词的软件中，许多文档编辑器快捷键 <code>ctrl+f</code> 对应的搜索功能都是基于这个算法实现的。</p><p>那第二点呢，就是当你发现查询的速度已经优化到足够好时，也需要让IO的速度更快一些，查询所需的指令也更少一些，这里可以优化的地方就更多了。</p><p>比如由于 grep 是按行查找的，许多版本的 grep 实现都会去遍历查找<code>\n</code> 换行符先进行分行，但 GNU Grep 则是将搜索文本直接读入一个缓冲区优先查找目标字符串，只有命中时才会在命中位置的前后进行换行符的查找；又比如，GNU Grep提供了基于mmap映射内存到文件的参数，可以减少一些内存拷贝的时间开销。具体的细节还有很多，比较繁琐，有兴趣的同学可以自行查阅 Mike Haertel 的<a target="_blank" rel="noopener noreferrer" href="https://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">邮件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>这个例子也再次说明了一件事情，<strong>要写出真正高性能的程序，不只要懂算法，也要懂计算机底层原理</strong>；只有这样，才能真正了解程序在运行时可能存在的各种性能瓶颈，找到不同场景下的最优解。</p><p>好我们回到今天的主题，字符串匹配。这也是一个经典问题了，相关算法非常多种，比如最暴力的 Brute-Force 算法、将前缀信息运用到极致理论性能极佳的KMP算法，还有利用哈希思想和滑动窗口思想的Rabin-Karp算法等等。</p><p>那为什么BM算法的性能在工程实战中最好呢？</p><p>别急，老规矩，我们还是先来严谨地定义一下字符串匹配问题，方便展开后面的讨论。</p><h2 id="字符串匹配问题"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#字符串匹配问题"><span class="icon icon-link"></span></a>字符串匹配问题</h2><p>假设给定长度为n的主串 s[0…n-1] 和长度为m的模式串 p[0…m-1]，一般n远大于m，请实现一个函数 match(string s, string p) 用于找出所有的p在s中出现的位置。</p><p>那如何解决这个问题呢？<br/><img src="/images/httpsstatic001geekbangorgresourceimagef25bf244ae179a364325fc79645b57d53a5b.jpg" alt=""/></p><p>容易理解、复杂度也相对差的方法就是，遍历主串的每一个位置，看当前位置是否能和模式串匹配上；能否匹配的判断方式也很简单，从主串的当前位置开始，逐一对比主串对应字符是否和模式串相等。如果可以匹配，说明找到了一个匹配的位点，记录下来；如果不可以匹配，我们就继续尝试下一个位置，直到整个主串遍历完全。这也是<strong>最暴力的Brute-Force算法</strong>的思路。</p><p>写成代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*</span></div><div class="token-line"><span class="token plain">     * s: 主串</span></div><div class="token-line"><span class="token plain">     * p：模式串</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    std::vector&lt;intstring&gt; match(string s, string p) {</span></div><div class="token-line"><span class="token plain">      std::vector&lt;int&gt; ans;</span></div><div class="token-line"><span class="token plain">      int n = s.size();</span></div><div class="token-line"><span class="token plain">      int m = p.size();</span></div><div class="token-line"><span class="token plain">      int i, j;</span></div><div class="token-line"><span class="token plain">      for (i = 0; i &lt; n - m + 1; i++) {</span></div><div class="token-line"><span class="token plain">        for (j = 0; j &lt; m; j++) {</span></div><div class="token-line"><span class="token plain">          if (s[i + j] != p[j]) break;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        if (j == m) ans.push_back(i);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return ans;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码非常清晰易懂，相信你看懂没什么压力。</p><p><strong>通常在字符串不长的时候，不同的匹配算法之间的效率差异不大</strong>。Brute-Force算法的实现和理解都非常简单，不容易出错，完美地符合了KISS（Keep it simple, stupid）原则，也就是让代码尽量简单从而避免出错。所以BF算法在真实开发的环境中出镜率很高，在日常工作中如果有手写字符串匹配的需求，你也可以考虑这种方式。</p><p>但这个算法在最坏的情况下时间复杂度确实不是很理想。</p><p>比如s = AAAAAAAA、p = AAAB时，在每个位置匹配p最终都会失败，但是都需要匹配到p的最后一个字母“B”才能发现匹配失败；这就导致我们总共需要匹配 m_n 次，其时间复杂度就是 O(m_n)。<br/><img src="/images/httpsstatic001geekbangorgresourceimage962f962daeec277d3d043d6e1fe532a84d2f.jpg" alt=""/></p><p>那有没有办法优化它呢？我们再来认真观察一下BF算法，首先会从主串和模式串的头开始遍历匹配，看第一次匹配的情况，BF算法之所以慢，就在于匹配p[3]失败后，我们又从模式串的第一个字符p[0]和主串的下一个位置s[1]开始比较，而s[1]这个位置其实在之前的搜索过程中出现过了。</p><p>所以，<strong>我们有没有办法通过一些预处理的手段，利用p[0…2]和当前正在匹配的主串中s[0…2]相等的已知信息，跳过一些肯定不可能的匹配，从失配处s[3]继续匹配呢</strong>？ KMP和BM算法其实都是这样做的，只不过手段有些差别。</p><p>KMP算法将前缀的信息利用到了极致，用匹配串自身的信息建立了一张部分匹配表，在每次失配的时候可以用来加速模式串，而不是每次都只向后移动一位。其算法逻辑整体比较复杂，感兴趣的同学可以网上搜索一下相关资料自行学习。</p><p>而GNU Grep 中用到的BM（Boyer Moore）算法，不仅理解起来容易很多，实际应用时性能也更好，它同样是基于预处理来避免不必要的重复匹配。但BM算法引入了两条很好懂的规则，“坏字符”和“好后缀”规则，并采用从后往前的匹配顺序进行匹配，构思非常巧妙。</p><p>后面的内容我们就用 moore 教授本人提供的<a target="_blank" rel="noopener noreferrer" href="https://www.cs.utexas.edu/~moore/best-ideas/string-searching/fstrpos-example.html">例子<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来讲解。</p><p><img src="/images/httpsstatic001geekbangorgresourceimageb6c8b6c0716e8d293d29fd1931a7cc7cb0c8.png" alt="图片"/></p><p>其中模式串p是EXAMPLE，主串s是 HERE IS A SIMPLE EXAMPLE。</p><h2 id="坏字符规则"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#坏字符规则"><span class="icon icon-link"></span></a>坏字符规则</h2><p>先来看第一条规则：“坏字符”规则，描述的是主串上的失配字符，目的就是为了跳过一些肯定不可能成立的匹配位置。</p><p>在BM算法中，我们同样将s和p对齐，开始遍历匹配，但匹配的顺序和BF算法不同，<strong>采用从后往前匹配的方式</strong>。这其实是一种非常巧妙的设计，你马上可以看到它配合坏字符规则使用时有着绝佳的效果。<br/><img src="/images/httpsstatic001geekbangorgresourceimage06c706149aa63e9yya45e22f3dedea5301c7.jpg" alt=""/></p><p>所以在例子中，第一次尝试匹配，首先会把p[6]的“E”和s[6]的“S”匹配，发现它们不匹配，所以这里的“S”就是一个坏字符。</p><p>那此时我们有两种选择，一种就是直接将模式串往后移动一位尝试继续匹配，这就和之前BF算法的想法差不多，没有利用到模式串中任何先验的信息。</p><p>而另一种呢，就是BM的做法了。<br/><img src="/images/httpsstatic001geekbangorgresourceimage603b60e54463301257abc4f75fb8db85723b.jpg" alt=""/></p><p>我们先看失配的坏字符“S”在模式串p中是否有出现，如果没有出现，那说明模式串其实不可能和这个位置有重叠，可以直接跳过这段位置，从主串的下一个位置开始匹配。在例子中，“S”显然不属于模式串EXAMPLE，我们就应该跳过“S”继续匹配，这样就大大加速了匹配的过程。</p><p>同样在下一步匹配时，因为主串的“P”和模式串的末尾“E”不匹配，但失配的“P”在模式串中就有出现，我们可以将模式串中最后一次出现的“P”和主串中的“P”对齐，同样从模式串尾开始匹配。<br/><img src="/images/httpsstatic001geekbangorgresourceimage3cb93c1ff31210fb788a18a8b9c1ff468db9.jpg" alt=""/></p><p>至此，坏字符的主要内涵就全部展示出来了，也就是，<strong>每次失配的时候，我们需要将匹配串往后移动 （失配位置下标 - 失配字符最右出现的位置下标） 位</strong>；如果失配字符不存在，则位置为-1。</p><p>这里你可能会有个疑问，为什么是最右的位置呢，不应该是记录上一次出现的位置吗？我的理解是，如果在每个位置都存储相比于当前位置的上一次失配字符出现的位置，存储开销会大得多；而如果只存每个字符最右出现的位置，我们所需要的只是一个字符集大小的哈希表，用一个长度为256的数组即可实现。</p><p>当然，这个公式会导致我们有时候求出的移动值可能是负的，让模式串反而向前移动了。比如在 BBBBBB 和 ABB 匹配时，第一次失配的坏字符B，会让匹配串往后移动（0-2=）-2位，导致前移。<br/><img src="/images/httpsstatic001geekbangorgresourceimage39e7399c7046392324fa8bae68248e06d5e7.jpg" alt=""/></p><p>那往前移显然是没有意义的，因为当前位置之前的匹配可能我们已经全部排除了；所以当移动位数出现负数时，我们也要让模式串至少往后移动一位，这点通过对基于坏字符的移动值和1取max操作即可实现。</p><p>而在这种时候，我们另一条规则“好后缀”也就可以发挥作用了。</p><h2 id="好后缀规则"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#好后缀规则"><span class="icon icon-link"></span></a>好后缀规则</h2><p>我们继续来看刚刚的例子。</p><p>在SIMPLE和EXAMPLE的匹配中，我们发现“MPLE”都匹配得上，但主串中的“I”和模式串中的“A”出现了失配。那这里的“MPLE”，我们就会称之为好后缀；同样“PLE”、“LE”、“E”其实也都是好后缀。</p><p>此时如果应用之前的坏字符规则，我们应该将模式串往后移动（2-(-1)=）3位，因为“I”在模式串中不存在。</p><p>但是，有没有办法利用已经匹配上的好后缀“MPLE”的信息，往后移动更多位呢？</p><p>当然是可以的，我们只要看匹配上的好后缀“MPLE”及它的子串“PLE”、“LE”、“E”是否之前也出现在模式串中即可。这里只有子串“E”之前也出现在了模式串中，所以我们<strong>可以直接把模式串移动至和这里主串的“E”对齐即可，这样我们向后移动了6位，显然比坏字符规则跳过了更多不可能的情况</strong>。<br/><img src="/images/httpsstatic001geekbangorgresourceimage7d817d108b48c017acc6b83b62d6eeb50281.jpg" alt=""/></p><p>总结起来，好后缀规则移动的方式就是，**找到好后缀在模式串中最右的匹配位置，总计向后移动（模式串字符长度 - 1 - 好后缀在模式串上次出现的最右位置）位。**以EXAMPLE为例，好后缀“E”在模式串中上一次出现的下标是0，整个字符串长度为7，所以向后移动（7-1-0）6个位置。</p><p>这里还需要注意一点，好后缀匹配的时候，只有最长的好后缀被允许出现在模式串的中间位置；其余子串只能匹配在模式串的前缀中。比如下面的例子，主串中的“A”和模式串中的“C”失配，“MABC”是最长好后缀，但之前并没有出现在模式串中。</p><ul><li>我们不能直接将模式串直接移到“MABC”之后，因为这样会错过好后缀子串“ABC”的匹配点。</li><li>但同样我们也不用匹配红色虚线框中的“ABC”，因为“MABC”没有匹配上，后面所有的MABC的子后缀匹配肯定只能发生在模式串的前缀中。</li></ul><p><img src="/images/httpsstatic001geekbangorgresourceimage1558158a9ac35bfb30c0cd48e06fc22ff558.jpg" alt=""/></p><p>好后缀和坏字符规则其实都是可以单独使用的；BM算法，为了尽可能多地跳过不可能匹配的字符，会选择两条规则中的较大移动值来往后移动。<strong>而且这两个规则和主串都没有关系，只和模式串自身有关，我们显然可以通过预处理得到两个规则的偏移表，来加速整个模式匹配的过程</strong>。</p><p>好了，现在讲完了BM算法“好后缀”、“坏字符”的两个规则和从后往前匹配的策略，我们一起来把例子匹配完成吧。</p><p>在查表发现好后缀的规则能跳过更多的位置后，我们选择将模式串往后移动了6位。这时“P”和 “E”没有匹配成功，我们采用坏字符规则，拿着坏字符“P”，找到模式串中出现的“P”位于p[4]，向后移动(6-4=) 2位和主串的“P”对齐。从尾部往前遍历匹配，此时，我们发现所有的字符都匹配上了，因而找到了一个完全匹配的位置。<br/><img src="/images/httpsstatic001geekbangorgresourceimagefc60fc1yy27fd7c2d28346b56d6a88cc6260.jpg" alt=""/></p><h2 id="具体实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#具体实现"><span class="icon icon-link"></span></a>具体实现</h2><p>相信你现在已经大体理解整个BM算法的思路了，但正所谓，“细节是魔鬼”，BM算法从概念上理解其实并不是很难，但真要手写实现还是比较困难的，不熟练的时候debug很容易花费很多的时间。为了方便起见，我们就用Python来实现这个算法。</p><p>具体实现我们可以分为三个大块：“坏字符”最右位置计算、“好后缀”偏移表计算、在主串上的搜索实现。</p><h3 id="坏字符最右位置计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#坏字符最右位置计算"><span class="icon icon-link"></span></a>坏字符最右位置计算</h3><p>“坏字符”的部分是最简单的，只需要开一个dict，遍历一次模式串，找到每个字符出现在模式串中的最右侧的那个位置即可。事实上，我们可以用一个[0,256]的数组来替代HashMap以提高性能，大部分工业级实现也都是这样做的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def get_bc(pattern):</span></div><div class="token-line"><span class="token plain">        bc = dict() # 记录每个badchar最右出现的位置</span></div><div class="token-line"><span class="token plain">        for i in range(len(pattern) - 1):</span></div><div class="token-line"><span class="token plain">            char = pattern[i]</span></div><div class="token-line"><span class="token plain">            bc[char] = i + 1</span></div><div class="token-line"><span class="token plain">        return bc</span></div></pre></div><p>由于遍历的时候我们会不断地覆写dict，所以最后遍历完成，就能得到每个badchar在模式串中最右侧的位置。</p><h3 id="好后缀偏移表计算"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#好后缀偏移表计算"><span class="icon icon-link"></span></a>好后缀偏移表计算</h3><p>“好后缀”的部分相对来说比较复杂，尤其是工业级的实现对性能要求很高，代码有很多trick，非常不易于理解，这里我们做一些简化的处理；而且在大部分时候，由于模式串比主串要短的多，即使预处理时间复杂度稍微高一些，问题也不是很大。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def get_gs(pattern):</span></div><div class="token-line"><span class="token plain">        gs = dict()</span></div><div class="token-line"><span class="token plain">        gs[&#x27;&#x27;] = len(pattern)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        # suf_len 用于标记后缀长度</span></div><div class="token-line"><span class="token plain">        for suf_len in range(len(pattern)):</span></div><div class="token-line"><span class="token plain">            suffix = pattern[len(pattern) - suf_len - 1:]</span></div><div class="token-line"><span class="token plain">            # j 用于标记可用于匹配的位置</span></div><div class="token-line"><span class="token plain">            for j in range(len(pattern) - suf_len - 1):</span></div><div class="token-line"><span class="token plain">                substr = pattern[j:j + suf_len + 1]</span></div><div class="token-line"><span class="token plain">                if suffix == substr:</span></div><div class="token-line"><span class="token plain">                    gs[suffix] = len(pattern) - j - suf_len - 1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        for suf_len in range(len(pattern)):</span></div><div class="token-line"><span class="token plain">            suffix = pattern[len(pattern) - suf_len - 1:]</span></div><div class="token-line"><span class="token plain">            if suffix in gs: continue</span></div><div class="token-line"><span class="token plain">            gs[suffix] = gs[suffix[1:]]</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        gs[&#x27;&#x27;] = 0</span></div><div class="token-line"><span class="token plain">        return gs</span></div></pre></div><p>我们同样开一个dict，用于标记失配时每个字符串应该往后移动多少，也就是对应的好后缀应该和之前哪个子串或者前缀匹配。怎么做呢？</p><p>一种比较暴力的做法就是遍历所有可能的后缀，然后从前往后看这个后缀是否在模式串中的其他位置也出现了，后面遍历的会覆盖之前的记录，所以记录下来的就是最右的匹配位置。</p><p>记得前面说过如果一个后缀在模式串中不存在，<strong>我们不能直接跳过整个字符串，因为该后缀的子串还可能和模式串中的前缀重合</strong>。比如例子中的“MPLE”后缀虽然不再存在于“EXAMPLE”中，但是其子串“E”与“EXAMPLE”的前缀“E”是重叠的。</p><p>所以在后缀不存在的时候，还需要检查一下其子后缀是否在dict有对应的匹配，如果有的话，也应该采用；这个通过一次循环赋值即可实现，对应到代码里就是第14到17行。</p><p>我这里实现的时间复杂度为O(m^3)，你可以自己推导一下，也欢迎去留言区讨论。</p><h3 id="匹配过程"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#匹配过程"><span class="icon icon-link"></span></a>匹配过程</h3><p>有了好后缀的偏移表和坏字符的最右位置，我们就可以来实现整个匹配的过程了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">def bm(string, pattern, bc, gs):</span></div><div class="token-line"><span class="token plain">        # i 用于标记当前模式串和主串哪个位置左对齐。</span></div><div class="token-line"><span class="token plain">        i = 0 </span></div><div class="token-line"><span class="token plain">        # j 用于标记当前模式串匹配到哪个位置；从右往左遍历匹配。</span></div><div class="token-line"><span class="token plain">        j = len(pattern)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        while i &lt; len(string) - len(pattern) and (j &gt; 0):</span></div><div class="token-line"><span class="token plain">                # 从右往左匹配每个位置</span></div><div class="token-line"><span class="token plain">                a = string[i + j - 1]</span></div><div class="token-line"><span class="token plain">                b = pattern[j - 1]</span></div><div class="token-line"><span class="token plain">                if a == b: # 匹配的上，继续匹配前一位</span></div><div class="token-line"><span class="token plain">                    j = j - 1</span></div><div class="token-line"><span class="token plain">                else: # 匹配不上，根据两个规则的预处理结果进行快速移动</span></div><div class="token-line"><span class="token plain">                    i = i + max(gs.setdefault(pattern[j:], len(pattern)), j - bc.setdefault(a, 0))</span></div><div class="token-line"><span class="token plain">                    j = len(pattern)</span></div><div class="token-line"><span class="token plain">                # 匹配成功返回匹配位置</span></div><div class="token-line"><span class="token plain">                if j == 0:</span></div><div class="token-line"><span class="token plain">                    return i</span></div><div class="token-line"><span class="token plain">        # 匹配失败返回 None</span></div><div class="token-line"><span class="token plain">        return -1</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">    if __name__ == &#x27;__main__&#x27;:</span></div><div class="token-line"><span class="token plain">        string = &#x27;here is a simple example &#x27; </span></div><div class="token-line"><span class="token plain">        pattern = &#x27;example&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        bc = get_bc(pattern)  # 坏字符表</span></div><div class="token-line"><span class="token plain">        gs = get_gs(pattern)  # 好后缀表</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        print(gs)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        x = bm(string, pattern, bc, gs)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        print(x)</span></div></pre></div><p>参照详细的注释，整个过程和前面讲解的原理是一一对应的，你可以配合代码一起理解。 完整的代码我放到了<a target="_blank" rel="noopener noreferrer" href="https://github.com/wfnuser/Algorithms/blob/main/Boyer-Moore/bm.py">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>上。</p><h3 id="时间复杂度"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#时间复杂度"><span class="icon icon-link"></span></a>时间复杂度</h3><p>Boyer-Moore 算法，在最好情况下复杂度可以达到 O(n/m)，在字符集比较大的时候，坏字符和好后缀规则可以帮助我们快速跳过大部分不必要的查询，达到接近最好的时间复杂度的概率是比较大。</p><p>但BM算法的最坏时间复杂度估计就是一个很难的数学问题了，许多学者都尝试做过相关的证明，目前我知道相对精细的比较上限次数的估计是Guibas和Odlyzko给出的3n，你感兴趣的话可以阅读<a target="_blank" rel="noopener noreferrer" href="https://ieeexplore.ieee.org/document/4567942">原始论文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了解。</p><p>因而和KMP一样，BM算法的理论时间复杂度也在O(m+n)之内，但由于字符集比较大的时候，BM常常能达到更好的时间复杂度，所以在实际应用中得到了更广泛的使用。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>我们来总结一下BM算法的特性。</p><p>BM算法，最大的特点就是利用了对目标串的预处理，用空间换时间，避免了许多不必要的比较，预处理的方式主要来自于对“坏字符”和“好后缀”两条规则的观察，因为这两个规则和主串都没有关系，只和模式串自身有关，显然可以通过预处理得到两个规则的偏移表，来加速整个模式匹配的过程。</p><p>总的来说，BM算法不难理解但实现起来有一定复杂度，感兴趣的同学可以自行练习。不过这一个特定的字符串匹配算法的学习其实还是次要的，空间换时间和预处理的思想你可以好好感受。</p><h3 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/04.基础算法篇/04#课后作业"><span class="icon icon-link"></span></a>课后作业</h3><p>相信通过今天的学习，你已经知道了如何基于Boyer-Moore算法实现一个高效的grep命令了吧。这里我也把<a target="_blank" rel="noopener noreferrer" href="https://github.com/zevweiss/grep/blob/7b894c48b2fba94c0f8f21f9d464fab864df038a/src/kwset.c">grep源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中BM算法出现的地方分享给你，代码中运用了许多不同的技巧，可读性其实并不是很好，作为今天的课后作业，留给你课后研究。</p><p>如果你在阅读代码的时候有什么问题欢迎留言和我一起讨论。如果你觉得有收获，也欢迎分享给身边的朋友一起学习，我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/04.基础算法篇/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:45:08</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
