<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>32｜时间轮：Kafka是如何实现定时任务的？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/08.工程实战篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="常见业务场景" data-depth="3"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#常见业务场景"><span>常见业务场景</span></a></li><li title="JDK中的DelayedQueue" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#jdk中的delayedqueue"><span>JDK中的DelayedQueue</span></a></li><li title="Redis中的ZSET" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#redis中的zset"><span>Redis中的ZSET</span></a></li><li title="时间轮" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#时间轮"><span>时间轮</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#总结"><span>总结</span></a></li><li title="课后作业" data-depth="3"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="32时间轮kafka是如何实现定时任务的"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#32时间轮kafka是如何实现定时任务的"><span class="icon icon-link"></span></a>32｜时间轮：Kafka是如何实现定时任务的？</h1><p>你好，我是微扰君。</p><p>今天我们来聊一聊日常开发中非常常见的技术需求：延时队列。</p><p>之前在学Kafka二分搜索的时候，我们已经学过了消息队列，它是一个用于传递消息的组件，大部分场景下，我们都希望消息尽快送达，并且消息之间要严格遵循先进先出的约束。但在有一些时候，我们也会希望消息不要立刻送达，而是在一段时间之后才会被接收方收到，也就是延后消息被处理的时间，像这样的场景就是“延时队列”。</p><h3 id="常见业务场景"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#常见业务场景"><span class="icon icon-link"></span></a>常见业务场景</h3><p>延时队列的应用非常多。我们回想一下有哪些业务场景，比如一个网上售卖电影票的平台，用户在买票的时候肯定要先选好位置，也就是说用户下单一张电影票有两个动作：选位置、付费。</p><p>我们不希望用户在付费的时候发现，自己选好的位置被别人买了，所以往往会在用户选定座位之后，就把这个位置锁定；但这个时候用户还没有付费，我们肯定不能让锁定一直持续下去，所以也会想要有一种定时机制，在用户超过一定时间没有付费时，在系统中自动取消这个订单，将对应的座位释放。</p><p>类似的场景还有许多，对应需要的定时周期跨度也很大。比如在云平台上如果用户资源过期，一般不会立刻清理所有数据，而会在超过一段时间之后再进行资源回收；再比如外卖平台上订单，如果快超过送餐时限了，就需要提醒外卖小哥加紧配送等等。</p><p>在这些业务场景下，一个好用的延时队列应该具备什么样的功能呢：<strong>我们只需要把任务和期望的执行时间存储到队列中，等到指定的时候，任务消息就会通过队列被发送给需要执行任务的主体，比如某个订单服务，让主体执行</strong>。</p><p>当然，我们也可以把队列直接实现在业务里，但是延时特性和具体业务无关，其实是一个完全通用的技术方案，所以一般会用通用的中间件来处理这样的问题。</p><p>Kafka就是一个非常好用的选择，作为一款高性能的消息队列，Kafka天然支持了延时消息的能力，可以帮助我们处理所有的延时场景下的问题。其实上一讲我们介绍的Redis中的ZSET，也是一种实现延时队列的常见手段。</p><p>不过在学习基于ZSET的实现之前，我们先从更简单的实现学起，边学边思考这些常见实现的场景和原理差异是什么。</p><h2 id="jdk中的delayedqueue"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#jdk中的delayedqueue"><span class="icon icon-link"></span></a>JDK中的DelayedQueue</h2><p>除了上面说的业务场景，在一些纯技术的领域，定时任务的需求也非常普遍，比如Linux下就支持了定时任务调度的功能。如果你熟悉Java，估计会想到JDK也默认支持了DelayedQueue的数据结构。</p><p>DelayedQueue，作为JDK原生支持的数据结构，能非常方便地帮助我们支持单机、数据规模不大的延时队列的场景。它的实现思路也是一种非常典型的延时队列实现思路，事实上也经常是面试官常考的八股文之一，值得我们好好掌握。</p><p><strong>DelayedQueue实现延时队列的本质，是在内存中维护一个有序的数据结构，按任务应该被执行的时间来排序</strong>。对外提供了offer和take两个主要的接口，分别用于从队列中插入元素和请求元素。</p><ul><li>在插入元素时，既然是所谓的延时队列，我们会插入一个带执行时间的任务，底层会对这些任务进行排序，保证队列最前的任务是最快到期的；</li><li>调用take接口后，会有一个线程检查头部元素，如果队列头的任务没有到期，我们就阻塞这个线程，直到任务到期，再唤醒这个线程；如果检查头部的时候任务已经到期，我们就会让这个消费进程真的从队列取出该元素，并执行。</li></ul><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/08.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage6ab46a766e3178c1b3c9a47066d8aacea0b4.jpg" alt="图片"/></p><p>为了提高效率，DelayedQueue底层还采用了一种leader-follower的线程模型，也非常常用，你可以理解成任务的执行会有多个线程进行，参考示意图，这样任务的具体执行和到期时间的检查就不会产生冲突，可以并行地进行。</p><p>分析清楚了设计思路，那DelayedQueue底层是如何对任务做有序排列的，用的是什么数据结构呢？你可以先猜想一下。</p><p>链表？数组？事实上，这里的有序排列并不会像你想的那样从头到尾维护一个线性的序列。我们之前也讲过，如果维护一个线性的序列，不管是链表还是数组，排序的时候都需要O(n*logn)的时间复杂度；而在这里<strong>我们所需要的其实只是判断整个队列中，最接近到期的那个任务的执行时间，是否已经被当前系统时间所超过。也就是说并不需要整个队列有序，只需要最值</strong>。</p><p>这不正是堆这个数据结构的长处嘛？所以DelayedQueue底层的存储结构正是堆。</p><p>由于整个数据结构都维护在内存上，也没有线性扩展性，空间上会受一定的制约，但从时间效率上来说，DelayedQueue还是一个非常不错的延时队列实现，特别适合在业务层面上直接解决一些规模不大、比较简单的延时队列场景。具体的代码可以直接在JDK中找到，感兴趣你可以自己研究。</p><p>学完DelayedQueue， 我们再来看Redis中的ZSET是如何实现延时队列的，对比理解。</p><h2 id="redis中的zset"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#redis中的zset"><span class="icon icon-link"></span></a>Redis中的ZSET</h2><p>底层基于跳表（<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/491979">上节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>讲过），Redis的有序集合性能非常不错，而且Redis本身是一个稳定、性能良好且能支持大量数据的KV存储引擎，用来实现延时队列自然比基于DelayedQueue的本地实现适用场景更大。</p><p>借助ZSET来实现延时队列，本质思想和DelayedQueue是类似的，主要就是我们会用ZSET来维护按任务执行时间排列的数据结构。</p><p>在使用ZSET做延时队列的时候，一般会用任务ID作为key，任务详情作为value，任务执行时间作为score，这样所有的待执行任务，在ZSET中，就会按任务执行时间score有序排列。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/08.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/resourceimagec88ec879d96c657a503fa540756b396ff58e.jpg" alt="图片"/></p><p>在需要被调度的延时任务执行主体上，我们可以开启一个线程定时轮询 <code>ZRANGEBYSCORE KEY \-inf +inf limit 0 1 WITHSCORES</code> 查询ZSET中最近可执行的任务：</p><ul><li>如果发现任务时间戳仍然大于当前时间戳，说明没有任务过期，什么都不执行；</li><li>如果发现任务时间戳已经小于当前时间戳，说明任务已经可以执行，我们按照约定的协议执行就可以了。</li></ul><p>当然，这里Redis里存储的任务详情其实就是个值，我们需要按照自己的场景序列化和反序列化。写成Java代码大概如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void poll() {</span></div><div class="token-line"><span class="token plain">            while (true) {</span></div><div class="token-line"><span class="token plain">                Set&lt;Tuple&gt; set = jedis.zrangeWithScores(DELAY_QUEUE, 0, 0);</span></div><div class="token-line"><span class="token plain">                String value = ((Tuple) set.toArray()[0]).getElement();</span></div><div class="token-line"><span class="token plain">                int score = (int) ((Tuple) set.toArray()[0]).getScore();</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">                Calendar cal = Calendar.getInstance();</span></div><div class="token-line"><span class="token plain">                int nowSecond = (int) (cal.getTimeInMillis() / 1000);</span></div><div class="token-line"><span class="token plain">                // 任务已经过期；可以执行</span></div><div class="token-line"><span class="token plain">                if (nowSecond &gt;= score) {</span></div><div class="token-line"><span class="token plain">                    jedis.zrem(DELAY_QUEUE, value);</span></div><div class="token-line"><span class="token plain">                    // TODO：执行任务</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                // 队列为空</span></div><div class="token-line"><span class="token plain">                if (jedis.zcard(DELAY_QUEUE) &lt;= 0) {</span></div><div class="token-line"><span class="token plain">                    return;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                Thread.sleep(1000);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>不过在这种方案中我们需要主动轮询，这会带来一定的开销，也有一定的精度问题，毕竟最小的粒度就是轮训的时间间隔。</p><p>既然引入了精度的问题，那我们有没有什么更好的方式呢，尤其是在有大量超时任务的场景下，有什么办法可以进一步优化超时任务的调度呢？</p><h2 id="时间轮"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#时间轮"><span class="icon icon-link"></span></a>时间轮</h2><p>这就是时间轮算法的用武之地了。在Kafka、Netty、ZooKeeper等知名组件中都有用到时间轮算法，可以说是久经考验。</p><p>思路其实很简单，如果用排序来类比的话，刚才JDK中基于堆的实现当然就是堆排序，永远可以拿到最快要过期的任务；那为了维护有序性，我们是不是也可以用类似桶排序的思想呢？</p><p>这正是时间轮的本质。</p><ul><li>把任务按时间分成不同的槽（bucket），每个槽位里放着任务的列表，通常采用一个双链表来实现；</li><li>把槽位加在一起，构成一个循环队列，底层用数组实现；</li><li>一个槽代表一个时间跨度，每个槽内队列中存储的任务就都是在这个跨度内应该被执行的任务。</li></ul><p>这样整个时间轮看起来就像一个时钟。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/08.%E5%B7%A5%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/resourceimage091509d1ebef599d5297bfbff31c51aa9215.jpg" alt="图片"/></p><p>我们还会有一个类似于秒针的指针，以槽位时间跨度为周期固定地转动，就像秒针一样，永远指向当前时间所应该对应的槽位，当然在这里精度不是秒，而是槽位的时间跨度。比如我们期待任务调度的精度是一分钟，在图中就可以让每个槽位代表的时间为60s，<strong>这样我们就可以很确定的在时间轮里表示600s也就是10分钟内的任务，每隔1分钟，就将当前的槽位指针+1，指向下一个槽位，并判断槽位中是否有任务需要执行</strong>。</p><p>槽位编号更小的任务，自然就会得到更先的执行，从而就实现了在某个精度下定时任务或者延时任务的需求。</p><p>这里的精度也可以调整，时间轮的整个时间周期除以刻度数量，就是我们最小的任务调度的精度，在不同的场景下，可以设计不同的时间轮刻度。比如以24小时、以秒，甚至毫秒为刻度都是可以的，当然精度越高，我们所需要的成本也就更高。</p><p>对比思考之前的实现，<strong>时间轮方案很大的提升就在于，我们大大减少了任务插入和取出时的锁竞争</strong>。相比于只维护一个堆，让所有的线程并发修改，在时间轮中，我们可以将锁的粒度减少到以刻度为单位，大大减少了锁冲突的可能性，取出任务时也只要从槽位中直接遍历，避免了从堆或者其他有序结构中取出元素和调整的开销。</p><p>当然这里还有个问题需要处理。比如在600s的时间轮中，我们不难发现601s的任务和9s的任务在同一个时间轮的槽位里，因为601s已经超过600s了，由于循环队列的特性，它会又一次被加入到第一个槽中。</p><p>不过这个问题也很好处理，只需要多判断一次当前时间和槽位中时间的关系就行，如果发现是601s或者更后期的任务，直接跳过即可。我们可以类比Hashmap冲突的情况，相信你很容易想明白其中的思想，无非就是遍历链表进行判断。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天我们一起学习了延时队列的底层实现方式和应用场景。</p><p>JDK中的DelayedQueue，以及借助Redis中ZSET的实现方式，两者总体思路比较相似，都是通过某种数据结构，来维护按任务执行时间排列的任务集合，然后定时或者轮询地去判断最接近过期的任务是否已经过期，选择执行或者继续等待。</p><p>当然单机的JDK可以更好地利用系统内置的定时机制，避免轮询的成本，不过也因为单机本身的限制，不能很好的扩展来支持海量的数据场景。</p><p>第三种实现方式，时间轮，是一个巧妙又高效的设计。牺牲了一定精度，但通过在内存中以循环队列的方式维护任务，降低了任务并行插入的锁竞争，也减少了取出任务的时间复杂度，特别适用于大量定时任务存在的场景，也因此成为Kafka实现延时队列的一种常用方式。</p><p>总体来说，这几种方式各有利弊，你可以好好体会一下其中的差异，结合自己的业务场景做一些选型的思考。</p><h3 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/07#课后作业"><span class="icon icon-link"></span></a>课后作业</h3><p>今天的课后作业是时间轮的实现，整体思路不难，不考虑并发的场景下100行左右的代码就可以完成了，这也是面试官常考的题目之一，值得好好练习。</p><p>欢迎你在评论区留下你的代码作业，一起讨论。如果觉得这篇文章对你有帮助的话，也欢迎转发给你的朋友一起学习，我们下节课见~</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/08.工程实战篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:09:02</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
