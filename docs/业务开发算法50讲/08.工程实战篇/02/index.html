<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>27｜LSM Tree：LevelDB的索引是如何建立的？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/08.工程实战篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="通过批量读写提高性能" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#通过批量读写提高性能"><span>通过批量读写提高性能</span></a></li><li title="早期LSM Tree" data-depth="3"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#早期lsm-tree"><span>早期LSM Tree</span></a></li><li title="现代LSM Tree" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#现代lsm-tree"><span>现代LSM Tree</span></a></li><li title="压缩数据" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#压缩数据"><span>压缩数据</span></a></li><li title="删除数据" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#删除数据"><span>删除数据</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#总结"><span>总结</span></a></li><li title="课后讨论" data-depth="3"><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02#课后讨论"><span>课后讨论</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="27lsm-treeleveldb的索引是如何建立的"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#27lsm-treeleveldb的索引是如何建立的"><span class="icon icon-link"></span></a>27｜LSM Tree：LevelDB的索引是如何建立的？</h1><p>你好，我是微扰君。</p><p>上一节我们学习了数据库中非常常用的索引数据结构——B+树，在过去很多年里它都是数据库索引的首选实现方式，但是这种数据结构也并不是很完美。</p><p>因为，每次修改数据都很有可能破坏B+树的约束，我们需要对整棵树进行递归的合并、分裂等调整操作，而不同节点在磁盘上的位置很可能并不是连续的，这就导致我们需要不断地做随机写入的操作。</p><p>众所周知，随机写入的性能是比较差的。这个问题在写多读少的场景下会更加明显，而且现在很多非关系型数据库就是为了适用写多读少的场景而设计的，比如时序数据库常常面对的IOT也就是物联网场景，数据会大量的产生。所以，如果用B+树作为索引的实现方式，就会产生大量的随机读写，这会成为系统吞吐量的瓶颈。</p><p>但是考虑到非关系型数据库的检索，往往都是针对近期的数据进行的。不知道你会不会又一次想到Kafka的线性索引呢？不过很可惜，非关系型数据库的workload也不是完全append only的，我们仍然需要面对索引结构变动的需求。</p><p>那在写多读少的场景下，如何降低IO的开销呢？</p><p>LSM Tree（Log Structure Merge Tree）就是这样比B+树更适合写多读少场景的索引结构，也广泛应用在各大NoSQL中。比如基于LSM树实现底层索引结构的RocksDB，就是Facebook用Golang对LevelDB的实现，RocksDB本身是一个KV存储引擎，现在被很多分布式数据库拿来做单机存储引擎，其中LSM树对性能的贡献功不可没。</p><h2 id="通过批量读写提高性能"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#通过批量读写提高性能"><span class="icon icon-link"></span></a>通过批量读写提高性能</h2><p>那LSM Tree的秘密到底是什么呢？</p><p>其实说起来也不复杂，还记得我们当时讲UUID的时候提到过的“批量生成”策略吗，很多时候，如果批量地去做一些事情，就能获得更好的效率。</p><p>在读写磁盘的场景中也是一样，既然B+树的多次随机写入性能不佳，<strong>我们有没有办法把多次写入合并成一次写入，从而减少磁盘寻道的开销呢？LSM Tree正是这样做的。</strong></p><h3 id="早期lsm-tree"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#早期lsm-tree"><span class="icon icon-link"></span></a>早期LSM Tree</h3><p>早期，LSM Tree中包含了多个树状结构，C0-tree存储在内存，而C1-tree存储在磁盘中，<strong>实质就是利用内存，延迟写入磁盘的时机。</strong></p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagef998f9a5a1ca2fc0e5a71647023b75ae2998.e7f764d4.jpg" alt="图片"/></p><p>C0-tree 由于常驻内存，检索起来不会产生IO，所以理论上，我们可以使用各种可用于高效索引的数据结构来存储数据，比如红黑树、跳表等等。但是因为内存成本高昂，能存储的数据必然有限，更大量的数据仍然需要存储在磁盘里。而磁盘中的C1-tree一般被实现为特殊的B+树。</p><p>数据的存储也会分为两个阶段，我们会一直先在内存中存储元素，直到内存中的数据到达一个阈值，我们会开始和C1-tree中的节点进行合并和覆写，过程和多路归并有点相似。因为我们可以决定写入磁盘的时机，所以完全可以保证B+树的所有节点是满的，也就避免了许多单次的随机写操作。</p><p>实现细节我们不用掌握，只需要明白设计实质就可以了，感兴趣的话你可以翻阅最早的LSM tree的<a target="_blank" rel="noopener noreferrer" href="http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf">论文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了解。</p><p>现代的LSM-tree已经抛弃了这样繁琐的结构，<strong>但核心仍然是一致的，都是通过内存维护有序的结构，延迟写入磁盘的时机，通过合并多次随机写操作，降低磁盘臂移动的开销</strong>，在多写少读的场景下能获得比B+树好许多的性能。</p><h2 id="现代lsm-tree"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#现代lsm-tree"><span class="icon icon-link"></span></a>现代LSM Tree</h2><p>整个LSM树包含了三个部分，memtable、immutable memtable、SSTable，前两个在内存中，最后一个在磁盘中。同样，我们会先临时地把数据写在memtable中，然后在合适的时机刷入磁盘上的SSTable中。</p><p>看到这里，不知道你会不会有一个疑问，这个过程听起来好像很不靠谱呀？众所周知，内存是非持久化的存储介质，如果写入内容写到一半的时候断电了，考虑到延迟刷盘的机制，岂不是之前的数据都丢失了，而且很多可能是我们已经认为提交了的修改记录？</p><p>如果你还记得我们之前在操作系统篇学习的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/478396">WAL机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，就能想到这个问题的解决方式了吧？没错，在LSM-Tree中我们正是通过预写日志的方式，来保证数据的安全性。</p><p><strong>每次提交记录的时候，都会先把操作同步到磁盘上的WAL中做备份</strong>，如果断电，我们也可以从WAL中恢复所有的修改记录。而且WAL是典型的Append Only的日志存储格式，并不是随机读写，虽然引入了额外成本，但是能明显避免许多随机写的操作，还是能带来巨大的性能提升。</p><p>好解决这个困惑，我们来看LSM tree的三大组成部分，搞清楚它们是如何工作的。</p><ol><li>Memtable</li></ol><p>Memtable显然是内存中的数据结构，存储的是近期更新的记录值，类似原始的LSM tree，可以用各种有序高效的数据结构来实现，比如HBase中采用的跳跃表，我们之后讲Redis的时候也会着重介绍这一数据结构，当然用之前介绍的红黑树也是可以的。</p><p>所谓近期的更新的记录值呢，在KV存储的场景下，就是你最近提交的对某个key的插入或者更新的记录，你可以简单的理解成一个Map中的key，value对就可以了。</p><ol start="2"><li>Immutable Table</li></ol><p>在Memtable存储的元素到达一个数量级之后，我们就会把它固化成immutable table，从字面上理解，就是不可变表。</p><p>很明显这就是memtable的拷贝操作，那我们为什么要引入这样一个memtable的不可变副本呢？虽然现在还没学习具体的落盘过程，但是我们可以先猜测一下，拷贝过程是需要时间的，但同时我们的系统很可能仍然在对外工作，所以创建副本，可以很好的地帮助我们避免读写冲突竞争，从而避免阻塞，提高系统性能。</p><ol start="3"><li>SSTable</li></ol><p>现在，我们拥有的是内存中的有序结构，存储了近期的记录变更，如何把这样的数据存储在磁盘上，既利用磁盘顺序读写的优势，也能保证所写的格式便于改动也便于查询呢？</p><p>SSTable就是一种很巧妙的设计，它是整个LSM Tree的核心，毕竟我们的大部分数据都是存储在磁盘上的，SSTable就是在磁盘上做持久化的部分。本质其实很简单，就是一段段按照key有序排列的键值对（最早出自Google的bigtable论文，后来在工程实践中加了很多优化）：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage122912860501292e4eed66119bb77f556829.92f62891.jpg" alt="图片"/></p><p>原始的SSTable，key和value可以是任意大小的，所以直接在磁盘上查询不是特别靠谱，但是SSTable本身的有序性，让我们可以采用类似Kafka的线性索引来加速查询过程，所以SSTable一般也会带上一个索引文件，值存储的是key所对应的offset，加载到内存后，我们利用二分搜索可以很快查找出要访问的key的值。</p><p>好，我们知道内存中的数据一定是有序的，而持久化数据到磁盘最高效的方式就是顺序写一遍，每次内存中的数据，我们都一次性dump成磁盘上的一段自然是比较快的，这样一段段的数据，我们就称为一个个segment。所以最简单的持久化方式就是我们在磁盘上把内存中有序的键值对直接dump成一个个段，也就是segment。</p><p>当然，后面存储的段和前面存储的段，key可能是重复的，因为后面的段新一些，所以在有重复的时候，最靠后的段中的记录值，就是某个key最新的状态。</p><p>整个持久化的过程就像这样，<strong>我们把内存中有序的数据结构比如红黑树中的记录，dump到一段磁盘上的空间，然后按segment一段一段往后叠加</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageyyc1yy96792b7948a3034bc9af49cc6471c1.c10af27e.jpg" alt="图片"/></p><p>那在这样的存储下，检索数据的时候需要怎么做呢？很简单，就是从后面的段开始，往前遍历，看看是否有查找到目标key，有的话就返回。由于从后往前遍历，我们第一次查询到key的时候，一定就是这个key对应的最新状态。</p><p>但很显然，这样的存储会有很多问题。</p><ul><li>首先数据冗余很大，随着时间推移，磁盘上就会有大量重复的键；</li><li>其次我们需要遍历每个有序的segment，查看数据是否存在。随着数据量增大，最坏情况下，要遍历的segment会非常多，整个系统的查询效率显然是惨不忍睹的。当然这个问题，我们可以通过布隆过滤器进行一定的缓解，之后介绍Redis的时候再介绍。</li></ul><p>总而言之，虽然说在写多读少的情况下，我们可以稍微降低一些读的速度，来换取更快的写的速度，但是这样无止尽的读性能劣化显然是不可接受的。怎么解决呢？</p><h2 id="压缩数据"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#压缩数据"><span class="icon icon-link"></span></a>压缩数据</h2><p>我们需要合并segment。</p><p>每个segment都是有序的，那我们显然可以比较高效地对多段数据进行合并操作，之前讲外排的时候也有提到，就是“多路归并”的思路，一般，多路归并的程序我们会在后台不断运行，我们会不断地把多个老的segment合并成一个更长的、同样有序的segment。</p><p>合并前老的segment长度都是一样的，在SSTable的主流实现里，<strong>我们会把不同的阶段被合并的segment放到不同的层中，并限制每一层数量，当某层segment超过一定数量，我们就会把它们删除，合并出一个更大的segment放入下一层</strong>。</p><p>低层中的segment显然是更新的记录值，更高层的则是更老的记录值。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage6c376c8cf69f285940fbaecac7aefb1ac137.295bb76f.jpg" alt="图片"/></p><p>在图的例子中可以看出来，我们合并segment1、2、3之后，在得到的segment4里，dog的记录就只剩更新的segment2中的记录84了。这样我们的整个存储空间就不会无尽地膨胀，最高的一层，最多也就是占用历史以来所有出现过的key和对应的记录值这样数量级的空间，而存储这些是数据库本应做到的。</p><p>检索的时候，我们只需要按照“内存-&gt;level0-&gt;level1”这样的顺序，去遍历每层中不同段是否包含目标key。每个段内都是有序存储的，所以整体读的时间复杂度也是可以接受的，</p><p>确实可能会比B+树的查询效率低一些，不过辅以布隆过滤器等手段，劣化也不会非常明显，在许多读写比不到1:10的场景下，顺序写带来的写性能提升是非常令人满意的。</p><h2 id="删除数据"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#删除数据"><span class="icon icon-link"></span></a>删除数据</h2><p>我们了解了如何存储数据、如何检索数据，那如何删除数据呢？</p><p>和B+树直接在本地进行删除的策略不同，LevelDB其实不会真的把某个数据移除，因为一旦移除，就可能需要去不同的层进行数据的清理，代价比较高昂。</p><p>一个聪明的做法就是我们用和写入一样的手段，将数据标记成一种特殊的状态。这种通过标记而不是真实移除数据的方法，在业务开发中其实也很常见，有时候我们称为soft delete。在有些ORM库中会直接通过deleteAt字段，标记删除时间，来表示这个数据被删除了，想恢复这个数据的时候也很简单，直接将deleteAt置空即可。</p><p>在LSM tree中也是一样，我们把这个特殊的状态称为tombstone，墓碑，看图就非常清楚了。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimaged2a4d2e0abb10f18e6d00d8be8773e8230a4.3441c2b8.jpg" alt="图片"/></p><p>查询的时候，如果我们先查到了tombstone，就可以认为数据已经不复存在了。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>今天我们学习了一个相对简化的modern LSM tree的实现，分为内存和磁盘上的数据结构两部分：</p><ul><li>内存上的部分，memtable、immutable memtable，比较简单，用通用的有序集合存储即可，跳表、红黑树都是非常不错的选择；</li><li>磁盘上的数据结构，SSTable，也不复杂，就是一段段连续按key有序存储的段，唯一需要做的就是后台启动一个程序不断地进行多路归并，得到分层的有序存储结构。</li></ul><p>为了提高查询效率，我们引入了稀疏索引和布隆过滤器。其中稀疏线性索引，在Kafka的章节我们已经学习了，布隆过滤器很快也会介绍，核心就是可以帮助我们快速过滤掉一些肯定在数据库中不存在的字段。</p><p>整个LSM Tree的实现还是比较复杂的，重点体会批量写对性能的提高，在你的工作中有一天也许会做出类似的优化。</p><p>另外相信你也能感受到，从本篇开始常常提到之前学过的一些思想和算法，这也是这些大型系统之所以难以掌握的原因之一，涉及很多基础算法知识。不过当你能把它们串联起来灵活运用，也就不会觉得特别难啦；相信这些思想对你工作中的系统设计也会有很大的帮助。</p><h3 id="课后讨论"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/08.工程实战篇/02#课后讨论"><span class="icon icon-link"></span></a>课后讨论</h3><p>前面说segment都是一段段的，如果让你来实现一个基于LSM索引结构的数据库，最小的segment应该设置成多大呢？</p><p>欢迎你在留言区留下你的思考，觉得这篇文章对你有帮助的话，也欢迎你转发给你的朋友一起学习。我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/08.工程实战篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
