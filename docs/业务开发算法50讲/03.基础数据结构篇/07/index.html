<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07｜堆：如何实现一个高效的优先队列？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/03.基础数据结构篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="优先队列" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#优先队列"><span>优先队列</span></a></li><li title="如何实现" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#如何实现"><span>如何实现</span></a></li><li title="二叉堆" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#二叉堆"><span>二叉堆</span></a></li><li title="为什么这么设计" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#为什么这么设计"><span>为什么这么设计</span></a></li><li title="PriorityQueue的实现" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#priorityqueue的实现"><span>PriorityQueue的实现</span></a></li><li title="堆的操作" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#堆的操作"><span>堆的操作</span></a></li><li title="grow函数" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#grow函数"><span>grow函数</span></a></li><li title="siftUp函数" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#siftup函数"><span>siftUp函数</span></a></li><li title="删除的poll操作" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#删除的poll操作"><span>删除的poll操作</span></a></li><li title="siftDown函数" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#siftdown函数"><span>siftDown函数</span></a></li><li title="扩容机制" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#扩容机制"><span>扩容机制</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#总结"><span>总结</span></a></li><li title="课后作业" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07堆如何实现一个高效的优先队列"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#07堆如何实现一个高效的优先队列"><span class="icon icon-link"></span></a>07｜堆：如何实现一个高效的优先队列？</h1><p>你好，我是微扰君。</p><p>上一讲学习了基于红黑树的ordered_map的实现，今天我们来介绍另外一种有趣的树，heap，也就是堆。堆的应用非常广泛，我们常说的堆排序的堆就是指这种树状数据结构，除此之外还可以用来解决诸如TopK，或者合并多个有序小文件之类的问题。</p><p>堆也是我们最后一个基础数据结构容器-优先队列的常见底层实现方式。</p><h3 id="优先队列"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#优先队列"><span class="icon icon-link"></span></a>优先队列</h3><p>你一定还记得之前讲过的线性数据结构queue吧，也就是队列，一种先进先出的数据结构，生活中这种先进先出的场景也很常见，我们当时举了一个在餐厅排队取号的例子，先来的人一定会先取到号，也先被叫到号，这完美地符合队列的语义。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage0375031f3908df1315910fab5543a50e9575.a630563f.jpg" alt="图片"/></p><p>那如果我们现在希望允许一部分人插队呢？比如在医院中，大部分病人都有序的挂号排队，但这时候如果来了一个重症病患，我们就很可能需要破坏先进先出的规则，让医生优先诊断治疗这位病患。这种场景中的队列，我们就可以定义为“优先队列”。</p><p>优先队列中的每个元素，我们会赋予它一个优先级，优先级相同的元素我们还是遵循先进先出的原则，<strong>但一定会保证队列中优先级更高的元素先出队，即使它进队时间更晚</strong>。比如例子中的重症病患来的并不早，但依旧得到了医生的优先治疗。</p><p>对于这种优先队列，我们应该如何高效地实现呢？</p><h3 id="如何实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#如何实现"><span class="icon icon-link"></span></a>如何实现</h3><p>其实也很容易想到不止一种方案。</p><p>比如，一种比较暴力的思路可以是：我们依旧用线性容器存储元素。在入队的时候，我们不关心优先级的影响直接按顺序存入容器中，<strong>出队的时候，则遍历容器找到最高优先级的元素出队</strong>。</p><p>由于入队的时候没有对优先级做任何处理，所以出队的元素显然可能在线性容器中任意一个位置，基于之前所学的知识，遇到节点删除的场景，用链表显然比用动态数组有更好的时间复杂度。但即使如此，每次出队时我们也需要遍历链表，所以时间复杂度为O(N)。</p><p>那与之相对的，另一种同样基于链表的思路也可以是，<strong>我们每次在入队的时候进行一些额外的调整，使得整个队列一直满足优先级更高的元素在更前面的约束</strong>，这样出队的时候就比较简单。当然这样会导致入队的时候都需要进行一次类似于插入排序的操作，最差情况下也会要遍历完整个链表，时间复杂度同样为O(N)。</p><p>假设出队和入队操作数量相等，均摊下来，每一次操作的时间复杂度就是O(N)。</p><p>看示意图辅助你理解，队列里的数字代表权重，a、b、c、d、e 代表着入队的值，我们假设入队顺序和值的字典序是一致的。上面的队列画的就是入队的时候就按照优先级排好序的情况，所以直接从队尾出队即可；下面的队列是入队的时候直接放到队尾，出队的时候要按照优先级取出元素。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage80c9804e072a611c89dc87f762f1119c08c9.ce6df5fb.jpg" alt="图片"/></p><p>那有没有一种入队和出队都相对来说比较高效的方式呢？答案是肯定的，<strong>只是我们需要抛弃线性的存储结构</strong>。</p><p>不知道你是不是也想到了上一章讲的红黑树。其实你的想法是对的，红黑树当然是可以用来实现优先级队列的一种方式，我们建红黑树的时候以优先级为key作为排序依据即可。入队的时候可以直接push入队，出队pop的时候先从树中找到优先级高的，也就是树的最右节点，然后移除即可。</p><p>这些操作的复杂度都是O(logN)，所以出队和入队的复杂度自然也就是O(logN)。所以，基于红黑树的优先队列复杂度均摊下来，相比于之前基于线性表的O(N)复杂度，显然更胜一筹。</p><p>但是由于我们不会进行类似“找出优先级第3高的元素出队”这样的操作，<strong>其实并不需要一直维护完全的顺序信息，只是需要能在每次出队时，找到优先级最高的元素即可。那有没有更合适的选择呢</strong>？</p><p>相比复杂的红黑树，简明的“二叉堆”就是这样一种特别适合用来动态维护一组元素中最大或者最小值的数据结构，它也是各大语言实现优先级队列的首选。</p><h2 id="二叉堆"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#二叉堆"><span class="icon icon-link"></span></a>二叉堆</h2><p>二叉堆，这个数据结构是1964年斯坦福大学教授Robert W．Floyd和J．Williams在发明堆排序的时候提出，之所以想介绍一下它的历史，主要是因为Robert W．Floyd是一个文科出生，后来自学计算机科学，逆袭成为斯坦福终身教授的大佬。我想这多多少少能证明热爱的力量，也能给可能是非科班出身的你我一些信心吧。</p><p>好啦回归正题，“二叉堆”，也就是binary heap，顾名思义，这个数据结构也是建立在一种特别的二叉树上的。</p><p>它主要有两个约束：</p><ol><li>二叉堆是一颗满二叉树。也就是说，除了最后一层外的每一层都没有空节点，且最后一层所有节点靠左排列，不存在从左到右中间有某些节点为空。</li><li>二叉堆中的<strong>每个节点和其子节点都有一样的偏序关系，要么大于要么小于</strong>，这两种情况分别对应大顶堆和小顶堆。所以大顶堆就要求堆中所有节点的值，一定大于其左右子树中的任何一个节点的值，也就是说顶部的节点一定是最大的，故称为大顶堆。小顶堆就正好相反。</li></ol><p>有了这样的约束，可以保证根节点要么是最大的要么是最小的，也让我们在出队入队的操作里调整的成本很小，整个过程有点像冒泡排序的感觉，我们马上讲解具体的细节。</p><p>比如下图中左边就是一个二叉堆，但中间因为不满足满二叉树的约束，就不是一个二叉堆；右边因为不满足完全的有序关系也不是一个二叉堆。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage9e829e58f9e5d39a0ef5748ea511ae481e82.803a5019.jpg" alt="图片"/></p><h3 id="为什么这么设计"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#为什么这么设计"><span class="icon icon-link"></span></a>为什么这么设计</h3><p>那现在我们来看看，这样的数据结构设计对于维护优先队列有什么帮助呢？和红黑树一样，二叉堆这样的树状结构同样暗含了关键的顺序信息，而我们核心就是利用这样的信息，在插入时进行更少的操作，而避免像线性表那样做从头到尾的顺序遍历。</p><p>为了实现优先级队列，我们会用优先级，priority，来作为二叉堆节点间大小比较的依据。假设我们始终希望出队的是优先级更高的元素，那可以<strong>采用大顶堆作为优先队列的底层实现，这样每次只需要从顶部取出元素即可获得优先级最高的元素。</strong></p><p>当然很重要的一点是，取出元素后显然会在树的顶部产生一个空位，我们需要进行一定的操作使得大顶堆的性质得以保全。</p><p>同样，为了享受直接从顶部取出优先级最高元素的便利，我们在插入元素时也要让二叉堆的性质得以保持。</p><p>幸运的是，正是因为二叉树是一个满二叉树，其高度约等于LogN，其中N为优先队列中元素的个数。而第二条约束父子节点之间的有序关系，让我们每次做pop和push操作，只需要经过最多二叉树高度次的交换调整即可保持堆的所有特性。</p><p>这样，我们就得到了一个入队和出队操作复杂度都为O(LogN)的数据结构，虽然均摊的时间复杂度和红黑树是一样的，但实现的难度却要小很多，所以今天我们就结合源码来讲解。</p><h3 id="priorityqueue的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#priorityqueue的实现"><span class="icon icon-link"></span></a>PriorityQueue的实现</h3><p>以JDK14中的PriorityQueue为例（后面简称PQ），我们来分析一个生产环境中的优先队列要怎么基于堆实现。</p><p>先来看看JDK中优先队列数据结构的基本定义，我们会讲一些重要的成员变量和方法。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span></div><div class="token-line"><span class="token plain">        implements java.io.Serializable {</span></div><div class="token-line"><span class="token plain">          /**</span></div><div class="token-line"><span class="token plain">           * Priority queue represented as a balanced binary heap: the two</span></div><div class="token-line"><span class="token plain">           * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span></div><div class="token-line"><span class="token plain">           * priority queue is ordered by comparator, or by the elements&#x27;</span></div><div class="token-line"><span class="token plain">           * natural ordering, if comparator is null: For each node n in the</span></div><div class="token-line"><span class="token plain">           * heap and each descendant d of n, n &lt;= d.  The element with the</span></div><div class="token-line"><span class="token plain">           * lowest value is in queue[0], assuming the queue is nonempty.</span></div><div class="token-line"><span class="token plain">           */</span></div><div class="token-line"><span class="token plain">          transient Object[] queue; // non-private to simplify nested class access</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">          /**</span></div><div class="token-line"><span class="token plain">           * The number of elements in the priority queue.</span></div><div class="token-line"><span class="token plain">           */</span></div><div class="token-line"><span class="token plain">          int size;</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">          /**</span></div><div class="token-line"><span class="token plain">           * Inserts the specified element into this priority queue.</span></div><div class="token-line"><span class="token plain">           *</span></div><div class="token-line"><span class="token plain">           * @return {@code true} (as specified by {@link Queue#offer})</span></div><div class="token-line"><span class="token plain">           * @throws ClassCastException if the specified element cannot be</span></div><div class="token-line"><span class="token plain">           *         compared with elements currently in this priority queue</span></div><div class="token-line"><span class="token plain">           *         according to the priority queue&#x27;s ordering</span></div><div class="token-line"><span class="token plain">           * @throws NullPointerException if the specified element is null</span></div><div class="token-line"><span class="token plain">           */</span></div><div class="token-line"><span class="token plain">          public boolean offer(E e) { ... }</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">          /**</span></div><div class="token-line"><span class="token plain">           * Increases the capacity of the array.</span></div><div class="token-line"><span class="token plain">           *</span></div><div class="token-line"><span class="token plain">           * @param minCapacity the desired minimum capacity</span></div><div class="token-line"><span class="token plain">           */</span></div><div class="token-line"><span class="token plain">          private void grow(int minCapacity) { ... }</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">          public E peek() {</span></div><div class="token-line"><span class="token plain">              return (E) queue[0];</span></div><div class="token-line"><span class="token plain">          }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">          /**</span></div><div class="token-line"><span class="token plain">           * Inserts item x at position k, maintaining heap invariant by</span></div><div class="token-line"><span class="token plain">           * promoting x up the tree until it is greater than or equal to</span></div><div class="token-line"><span class="token plain">           * its parent, or is the root.</span></div><div class="token-line"><span class="token plain">           *</span></div><div class="token-line"><span class="token plain">           * To simplify and speed up coercions and comparisons, the</span></div><div class="token-line"><span class="token plain">           * Comparable and Comparator versions are separated into different</span></div><div class="token-line"><span class="token plain">           * methods that are otherwise identical. (Similarly for siftDown.)</span></div><div class="token-line"><span class="token plain">           *</span></div><div class="token-line"><span class="token plain">           * @param k the position to fill</span></div><div class="token-line"><span class="token plain">           * @param x the item to insert</span></div><div class="token-line"><span class="token plain">           */</span></div><div class="token-line"><span class="token plain">          private void siftUp(int k, E x) { ... }</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">          public E poll() { ... }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>首先要看堆元素在内存中到底是怎么存储的。可以看到：</p><ul><li>成员变量size，它显然用于表示优先队列中元素的大小。</li><li>成员变量中有一个叫queue的数组，这就是堆中元素存放的地方。</li></ul><p>你这个时候可能就会有些疑惑了？诶？那我们堆的树状结构到哪里去了，为什么还是一个线性的存储结构呢？</p><p>其实，<strong>在JDK中的PQ实现里，并没有和我们想象中一般的树那样采用节点+指针来实现树状数据结构，而是用了内存上连续的数组来模拟</strong>。代码中的queue数组就是用来表示堆这一树状结构的成员变量。</p><p>这么讲可能你不是很理解，我们看下面的图。图中画的就是一个大顶堆的示例，上下分别代表堆的树状结构本身和存储到queue数组中的样子。你可以通过元素的值来判断两种表示间的对应关系。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage9f099f8fc9d9e5ca9d60da352219c4c62209.d7f386e5.jpg" alt=""/></p><p>相信你也发现了，图中的数组就是<strong>按照对树做层序遍历的方式依次排列的</strong>，所以数组中下标为0的元素就是堆顶的元素，我们也用箭头将数组元素中的父子关系都标记出来了。由于二叉树每一层元素个数都是上一层两倍的特性，你会发现，queue[k]节点，它的左子节点为queue[2_k+1]，右子节点为queue[2_k+2]。</p><p>事实上，不止二叉堆，其实一般的二叉树也是可以用数组表示的，如果你做过LeetCode上相关试题的话，也会经常碰到类似的表示方式。大部分时候，用数组表示树写起来比较简单，不需要引入类似指针的概念，也不用定义树节点的类或者结构体。</p><p>但如果二叉树不是满的，数组中会有大量的空值，非常浪费空间。<strong>而堆本身满二叉树的特性，则让我们可以选择用数组作为底层二叉树实现而不至于浪费大量的内存</strong>，这就是JDK中为什么可以使用数组作为底层存储的原因。</p><h2 id="堆的操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#堆的操作"><span class="icon icon-link"></span></a>堆的操作</h2><p>有了底层的数据表示，下面我们来了解一下堆的两个重要操作，插入和删除。</p><p>首先看堆的插入操作，也就是 <code>offer</code> 方法，对应的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * Inserts the specified element into this priority queue.</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @return {@code true} (as specified by {@link Queue#offer})</span></div><div class="token-line"><span class="token plain">     * @throws ClassCastException if the specified element cannot be</span></div><div class="token-line"><span class="token plain">     *         compared with elements currently in this priority queue</span></div><div class="token-line"><span class="token plain">     *         according to the priority queue&#x27;s ordering</span></div><div class="token-line"><span class="token plain">     * @throws NullPointerException if the specified element is null</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public boolean offer(E e) {</span></div><div class="token-line"><span class="token plain">        if (e == null)</span></div><div class="token-line"><span class="token plain">            throw new NullPointerException();</span></div><div class="token-line"><span class="token plain">        modCount++;</span></div><div class="token-line"><span class="token plain">        int i = size;</span></div><div class="token-line"><span class="token plain">        if (i &gt;= queue.length)</span></div><div class="token-line"><span class="token plain">            grow(i + 1);</span></div><div class="token-line"><span class="token plain">        siftUp(i, e);</span></div><div class="token-line"><span class="token plain">        size = i + 1;</span></div><div class="token-line"><span class="token plain">        return true;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>该方法接收一个待插入的元素e，在18行中将堆的大小增加1，这个非常直观。有两个函数详细解释一下，grow和siftUp。</p><h3 id="grow函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#grow函数"><span class="icon icon-link"></span></a>grow函数</h3><p>grow函数用于扩展数组的大小。</p><p>我们用数组模拟堆，就必然要给出一个数组的大小，这也就限制了二叉堆的最大大小。但这在使用过程中并不方便，我们没有办法在各种场景下都准确预估堆所需使用的最大元素个数。所以和STL的vector一样，JDK中的PriorityQueue，通过内置的grow函数和扩容机制解决了堆动态大小的问题。grow函数具体做的事情我们最后再讲。</p><p>所以在offer方法里，如果发现当前插入的元素已经超过了内置queue数组的容量，我们需要进行扩容操作，这就是第15-16行代码所做的事情。</p><h3 id="siftup函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#siftup函数"><span class="icon icon-link"></span></a>siftUp函数</h3><p>现在我们来看siftUp的过程，具体的插入操作其实就隐藏在了siftUp这个函数中。</p><p>之所以叫siftUp，就是因为这个插入的过程是自下而上的。我们结合具体例子，来讲解siftUp的过程，先搞清楚思路，再来看对应的代码就很好理解了。</p><p>假设有这样的一个二叉堆，我们想要插入一个新的元素。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagefy23fyy22c38b93f0fda3a33682eea0db823.746dfb8e.jpg" alt="图片"/></p><p>可以先将该元素插入到数组的尾部，也就是堆中的最后一个位置，这是一个O(1)的操作，因为不涉及任何元素的移位。然后要做的，就是将这个元素一路往上交换使得二叉堆可以保持自身的2条特性。</p><p>由于我们是将新的元素放到堆的尾部，没有空开任何一个子节点，所以<strong>只是进行元素的交换，并不会破坏堆是满二叉树的特性，因而我们只需要关注父节点比所有子节点大这一特性</strong>。</p><p>所以将该节点不断和其父节点比较，如果比父节点大，将该节点和父节点交换，并继续和该节点新的父节点进行比较。由于原来的父亲节点一定比其左右子节点（其中一个是这次调整的节点，另一个是他的兄弟节点）都大，所以将其和父亲节点交换位置，一定也能保证该节点比其兄弟节点大。</p><p>而只要发现该节点已经比父节点小了，我们就可以结束这次的比较、交换之旅，堆已经重新满足了特性。</p><p>结合示意图理解，比如在堆的最后一个位置插入92。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageac42ac8d9a6bc4fa5cdac42a286ccf250042.458dc875.jpg" alt="图片"/></p><p>我们要先把92和47比较，发现92比47大的时候，互换位置；然后继续比较，会交换92和76的位置，关注父子节点的大小要求特性，因为76本身比52大，所以交换后一定也能保证92比52。这就是堆siftUp的过程。</p><p>这里再稍微补充两句，堆和红黑树不一样，我们在整个过程中只关心父子节点之间的大小关系，而不用在意兄弟节点之间的大小关系，比如原本4（47）节点是比5（52）节点小的，现在4节点（76）比5节点（52）大了，这并不会破坏堆的性质。这也是堆之所以调整比红黑树简单很多的地方。</p><p>了解这个过程，对应的代码就非常好懂了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private void siftUp(int k, E x) {</span></div><div class="token-line"><span class="token plain">        if (comparator != null)</span></div><div class="token-line"><span class="token plain">            siftUpUsingComparator(k, x, queue, comparator);</span></div><div class="token-line"><span class="token plain">        else</span></div><div class="token-line"><span class="token plain">            siftUpComparable(k, x, queue);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] es) {</span></div><div class="token-line"><span class="token plain">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;</span></div><div class="token-line"><span class="token plain">        while (k &gt; 0) {</span></div><div class="token-line"><span class="token plain">            // 计算父节点的下标</span></div><div class="token-line"><span class="token plain">            int parent = (k - 1) &gt;&gt;&gt; 1;</span></div><div class="token-line"><span class="token plain">            Object e = es[parent];</span></div><div class="token-line"><span class="token plain">            // 比较当前节点和父节点的关系 如果当前节点优先级更高，我们可以直接结束比较</span></div><div class="token-line"><span class="token plain">            if (key.compareTo((T) e) &gt;= 0)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">            // 交换节点</span></div><div class="token-line"><span class="token plain">            es[k] = e;</span></div><div class="token-line"><span class="token plain">            k = parent;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        es[k] = key;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因为PriorityQueue里存放的可以是任何元素，用户也可以自定义比较关系，所以Java的PQ实现里引入了比较符和泛型的概念。&lt;T&gt;就是Java中泛型相关的语法，<code>siftUpUsingComparator</code> 则给了用户自定义比较符的自由；不熟悉的同学可以自行搜索相关资料了解。</p><p>我们直接看siftUpComparable方法，也就是元素类型自带比较方法的情况。</p><p>我们要比较这个新节点和父节点的值，那怎么定位父节点呢？回忆一下前面讲queue底层存储的时候讲过的父子节点关系，<strong>对queue[k]来说，它的父节点一定是queue[(k-1)/2]。当然k需要大于0，否则k就已经是根节点了</strong>。</p><p>所以11-18行的循环就是在做siftUp中和父节点比较并交换的操作，第14行就是对应key比e大，也就是子节点比父节点大的情况，此时我们就可以退出循环了。这也说明PQ默认情况下实现的是小顶堆。</p><h3 id="删除的poll操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#删除的poll操作"><span class="icon icon-link"></span></a>删除的poll操作</h3><p>好，下面看PQ中第二个主要操作，<code>poll</code>操作，这是我们返回并删除堆顶元素的操作，也就是从优先队列中取出最高优先级元素的操作。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public E poll() {</span></div><div class="token-line"><span class="token plain">        final Object[] es;</span></div><div class="token-line"><span class="token plain">        final E result;</span></div><div class="token-line"><span class="token plain">        // 取出堆顶元素</span></div><div class="token-line"><span class="token plain">        if ((result = (E) ((es = queue)[0])) != null) {</span></div><div class="token-line"><span class="token plain">            modCount++;</span></div><div class="token-line"><span class="token plain">            final int n;</span></div><div class="token-line"><span class="token plain">            // 其实就是要将最后一个元素放到顶部</span></div><div class="token-line"><span class="token plain">            final E x = (E) es[(n = --size)];</span></div><div class="token-line"><span class="token plain">            // 将最后一个元素置空</span></div><div class="token-line"><span class="token plain">            es[n] = null;</span></div><div class="token-line"><span class="token plain">            // 进行siftdown操作</span></div><div class="token-line"><span class="token plain">            if (n &gt; 0) {</span></div><div class="token-line"><span class="token plain">                final Comparator&lt;? super E&gt; cmp;</span></div><div class="token-line"><span class="token plain">                if ((cmp = comparator) == null)</span></div><div class="token-line"><span class="token plain">                    siftDownComparable(0, x, es, n);</span></div><div class="token-line"><span class="token plain">                else</span></div><div class="token-line"><span class="token plain">                    siftDownUsingComparator(0, x, es, n, cmp);</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return result;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>重点理解第7行和关键的siftDown函数。</p><p>要取出堆顶元素，数组第一个元素就会有所空缺。基于siftUp的想法（还是用刚才的大顶堆），我们第一反应很容易想到，直接从空缺的根节点开始，找其左右子节点中大的一个提拔到当前空缺的位置，然后依次找新的空位左右子节点哪个位置可以提拔上来，直到没有子节点为止。</p><p>这个思路确实很自然，但有一个比较大的问题就是，如果我们在第一次比较的时候选择了左节点提升上来，当右节点并不为空时，最后得到的树一定不是一个满二叉树了，这就破坏了堆的基本性质。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagea821a8ea7c6bd1d46c96aaca2c4c0da1ca21.740cd950.jpg" alt="图片"/></p><p>那怎么做呢？一个比较巧妙的想法就是和代码里第7行一样，将根节点删除后，我们把二叉堆中最后的元素提到根节点的位置，这样又可以保证新的二叉树是一颗满二叉树了，然后要做的就和前面所说的一样，比较+交换。</p><p>看大顶堆的例子，现在要删掉最大的元素92，怎么做呢？首先把堆中最后一个节点也就是47提到堆顶的空位，然后依次比较左右节点；47比90、79都小，但90更大，所以我们用47和90进行交换。同理47和76也需要交换。这样我们就完成了优先队列优先级最高元素出队的操作。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageabdbabfff0c466175ab7427127784a14b5db.cd348418.jpg" alt="图片"/></p><h3 id="siftdown函数"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#siftdown函数"><span class="icon icon-link"></span></a>siftDown函数</h3><p>回到代码，这里说的比较+交换的过程就是由siftDown这个函数完成的：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] es, int n) {</span></div><div class="token-line"><span class="token plain">        // assert n &gt; 0;</span></div><div class="token-line"><span class="token plain">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;</span></div><div class="token-line"><span class="token plain">        int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf</span></div><div class="token-line"><span class="token plain">        while (k &lt; half) {</span></div><div class="token-line"><span class="token plain">            int child = (k &lt;&lt; 1) + 1; // assume left child is least</span></div><div class="token-line"><span class="token plain">            Object c = es[child];</span></div><div class="token-line"><span class="token plain">            int right = child + 1;</span></div><div class="token-line"><span class="token plain">            if (right &lt; n &amp;&amp;</span></div><div class="token-line"><span class="token plain">                ((Comparable&lt;? super T&gt;) c).compareTo((T) es[right]) &gt; 0)</span></div><div class="token-line"><span class="token plain">                c = es[child = right];</span></div><div class="token-line"><span class="token plain">            if (key.compareTo((T) c) &lt;= 0)</span></div><div class="token-line"><span class="token plain">                break;</span></div><div class="token-line"><span class="token plain">            es[k] = c;</span></div><div class="token-line"><span class="token plain">            k = child;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        es[k] = key;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>5-14行就是之前所说的父亲节点和左右子节点循环比较并交换的过程。k的左子节点下标为(k&lt;&lt;1)+1，右子节点下标为左子节点+1，这就是6行和8行代码的意义。在发现左右子节点都比根节点小之后，同样可以退出循环，否则和左右节点中小的一个交换即可。</p><p>嗯，如果只是要查看优先级最高的节点而不用出队，当然是非常简单了，我们直接取堆顶元素即可。也就是之前PQ定义的这几行代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public E peek() {</span></div><div class="token-line"><span class="token plain">        return (E) queue[0];</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="扩容机制"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#扩容机制"><span class="icon icon-link"></span></a>扩容机制</h3><p>那，最后我们来讲讲PQ的扩容机制，这是PQ虽然用数组作为底层存储，却不用限制优先队列大小的核心。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * Increases the capacity of the array.</span></div><div class="token-line"><span class="token plain">     *</span></div><div class="token-line"><span class="token plain">     * @param minCapacity the desired minimum capacity</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    private void grow(int minCapacity) {</span></div><div class="token-line"><span class="token plain">        int oldCapacity = queue.length;</span></div><div class="token-line"><span class="token plain">        // Double size if small; else grow by 50%</span></div><div class="token-line"><span class="token plain">        int newCapacity = ArraysSupport.newLength(oldCapacity,</span></div><div class="token-line"><span class="token plain">                minCapacity - oldCapacity, /* minimum growth */</span></div><div class="token-line"><span class="token plain">                oldCapacity &lt; 64 ? oldCapacity + 2 : oldCapacity &gt;&gt; 1</span></div><div class="token-line"><span class="token plain">                                           /* preferred growth */);</span></div><div class="token-line"><span class="token plain">        queue = Arrays.copyOf(queue, newCapacity);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>本质和之前讲的STL中的vector扩容思想如出一辙，就是将当前的数组搬到一段更大的连续数组中，新的数组容量为newCapacity，旧的数组容量为oldCapacity。</p><p>它俩的关系在第11行中可以看出来：如果原来的数组已经比较大了，那新数组的大小是旧数组大小的1.5倍，否则是2倍再+2。至于为什么要成倍增长，你可以回看vector的章节，都是为了保证良好的均摊时间复杂度。</p><p>用于计算容量的newLength的方法还有个参数用于保证最小的扩容大小，如果你感兴趣可以自己研究一下。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#总结"><span class="icon icon-link"></span></a>总结</h2><p>学完了JDK中PriorityQueue的主要实现机制和源码，现在你有没有掌握用数组模拟树的技巧呢？如果让你手写一个堆应该也不难了吧，这也是面试中算法的常考题目。</p><p>核心就是数组中父子节点的下标关系。下标为k的节点queue[k]，它的左子节点为queue[2_k+1]，右子节点为queue[2_k+2]。理解了这一点，去实现siftDown和siftUp操作，相信对你来说不在话下。</p><p>当然JDK为了提供一个更通用的优先队列，也引入了泛型，也提供了动态扩容的能力，这些内容和动态数组的实现非常相似的，你可以回去复习并尝试手写实现一下。</p><h3 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07#课后作业"><span class="icon icon-link"></span></a>课后作业</h3><p>有了堆，实现优先队列的语义其实并不难。但有个问题想问问你，你觉得Java的优先队列是否真正保证了优先队列语义呢？比如优先队列中相同优先级的元素，是否应该要保证先进先出的特性？如果，JDK中的没有这个保证，但我们却有这样的需求，你觉得应该如何改造呢？</p><p>这是一个开放问题，欢迎你在留言区参与讨论。如果你觉得这篇文章对你有帮助，也欢迎你转发给身边的朋友一起学习。我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/03.基础数据结构篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
