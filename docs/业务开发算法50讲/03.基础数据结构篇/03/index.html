<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>03｜双端队列：并行计算中的工作窃取算法如何实现？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/03.基础数据结构篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="队列" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#队列"><span>队列</span></a></li><li title="双端队列" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#双端队列"><span>双端队列</span></a></li><li title="Deque实现" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque实现"><span>Deque实现</span></a></li><li title="Deque的内存布局" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的内存布局"><span>Deque的内存布局</span></a></li><li title="Deque的迭代器" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的迭代器"><span>Deque的迭代器</span></a></li><li title="Deque的基础操作" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的基础操作"><span>Deque的基础操作</span></a></li><li title="push操作" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#push操作"><span>push操作</span></a></li><li title="pop操作" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#pop操作"><span>pop操作</span></a></li><li title="C++的选择" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#c的选择"><span>C++的选择</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="03双端队列并行计算中的工作窃取算法如何实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#03双端队列并行计算中的工作窃取算法如何实现"><span class="icon icon-link"></span></a>03｜双端队列：并行计算中的工作窃取算法如何实现？</h1><p>你好，我是微扰君。</p><p>目前我们已经学习了 vector 动态数组和 list 双向链表两种STL中的序列式容器了，今天我们继续学习另一种常见的序列式数据结构，双端队列。</p><p>在并行计算中，我们常常会用多进程处理一些复杂的计算任务。为了能够通过多进程加速计算，我们除了需要对任务进行合理的切分，也需要将任务合理公平地分配到每一个进程。简单来说就是，我们希望每个进程都不至于闲着。那怎么样能做到这件事呢？</p><p>其实有一种非常常用的算法，工作窃取算法，就可以用来达成这个目标，它就需要用到我们今天的主角——双端队列。</p><h2 id="队列"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#队列"><span class="icon icon-link"></span></a>队列</h2><p>要介绍双端队列，我们先来聊一聊队列，queue。什么是队列呢？</p><p>从概念上来说其实非常好理解，因为它的特性和“队列”这个词在现实生活中的意思是一致的，那就是FIFO先进先出。简单来说就是排队。</p><p>比如说现在到很多餐厅就餐，服务员都会给你发一个号码让你排队，等有空位的时候，服务员叫号是按照取号的顺序来的，肯定是先来取号的人结束排队去入座；这样的约束就是先进先出。</p><p>显然这种<strong>先进先出的队列也是一种典型的序列式数据结构</strong>；和数组最大的区别就在于，它是一个有约束的序列式数据结构，因为先进先出的特性要求我们，所有的插入操作必须在队列的尾部进行，而所有的删除操作则必须在队列的头部进行。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage0375031f3908df1315910fab5543a50e9575.a630563f.jpg" alt="图片"/></p><p>上图就是一个对队列入队、出队操作的示例。我们注意到先入队的元素一定会比后入队的元素更早出队。这一特性和思想在许多业务系统或者基础软件、操作系统、计算机网络中都有应用，比如在操作系统中的CPU调度中，进程资源使用CPU的顺序就用队列来排序。</p><h2 id="双端队列"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#双端队列"><span class="icon icon-link"></span></a>双端队列</h2><p>队列和链表一样也会延展出更多种类的队列，比如带权重的优先队列、或者只能一边进一边出的单端队列。</p><p>我们今天要实现的double ended queue，双端队列是其中一种，相比于普通队列而言，双端队列是两端开口的，在队列的头尾两端都可以进行进队和出队操作，让我们在使用队列时有了更大的灵活性。</p><p>你肯定想问，数组也可以在两边插入数据呀，那双端队列和数组有什么区别呢？</p><p>首先，数组头部的插入操作复杂度很高，如果我们并不需要快速随机访问，这种操作的复杂度是完全可以避免的，这是双端队列和数组的一个很大区别。更本质的地方在于，<strong>双端队列仅仅是一个两端都支持FIFO插入删除操作的队列，语义上来说并不支持数组基于下标在指定位置的修改、插入和删除的操作</strong>。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage7a767a241d6d4783165e7b7d359087b61976.2a11e109.jpg" alt="图片"/></p><p>当然，我们是可以用数组或者链表来模拟实现双端循环队列的，只要暴露出经过剪裁的且满足FIFO的语义方法就可以了。</p><p>比如可以开一个大小为N的数组array，用两个数字 rear 和 front 代表队列的前端和尾端。在前端插入 target，只需要 <code>array[(--front+N)%N] = target</code>，这样既扩展了前端的边界，也达到了插入target的效果。%N也就是要对N取模，主要也就是为了处理越界的问题，这样当数组的前端read到达小于0的位置时，就会马上变成N-1，也就实现了一个循环队列。</p><h2 id="deque实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque实现"><span class="icon icon-link"></span></a>Deque实现</h2><p>虽然说，可以用数组或者链表来实现队列，但<strong>C++并没有选择依赖已有的序列式容器vector或者list来实现</strong>，原因是什么呢？你可以先想一想。</p><p>带着这个问题，我们一起来学习后面的内容，看看STL中的deque是如何实现一个高效好用的双端队列的。</p><p>我个人认为，在 STL 序列化容器的空间分配中，deque 可能是最复杂的，这也可能会对你阅读源码造成一定的障碍，但是不要害怕，如果只是为了搞清deque设计的大致思想，我们完全可以将内存分配的部分当成黑盒来看，这对搞清楚deque的原理并没有什么影响。</p><h3 id="deque的内存布局"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的内存布局"><span class="icon icon-link"></span></a>Deque的内存布局</h3><p>deque的内存布局，可以说同时具备了list和vector的特点。</p><p>deque的内存布局**是由一段段连续的空间、用另一个类似数组的东西将这些空间的地址信息拼接在一起组成的，真实存放数据的就是那一段段连续的空间。**在首尾两端插入和删除的时间复杂度是O(1)。以插入为例，每次一段连续的空间元素被用完的时候，会直接申请一段新的空间并链接到deque的分段空间末尾。</p><p>所以deque既不像 vector 那样每次扩容都需要付出复制和拷贝的高昂代价，也不会像链表那样每次插入一个新的节点都需要申请一次内存。</p><p>当然这也导致了非常复杂的控制流程，deque的代码量也远远多于vector和list。</p><p>为了维护一段段连续的内存空间，deque需要维护一个被称为map的成员变量；这个map数据结构起到了管理真正用于存储队列元素的一段段连续线性空间的作用。那一段段连续的线性空间，我们称为缓冲区。</p><p>map的示意图如下：</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagec87ac8ac7fb00e8eae4637ab764aea0dc47a.e1410e04.jpg" alt="图片"/></p><p>可以认为map是一个数组，每个元素指向了一段缓冲区的地址。而缓冲区对应了一段指定大小的连续内存空间，默认大小为 512 bytes。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;class _Tp, class _Alloc&gt;</span></div><div class="token-line"><span class="token plain">    class _Deque_base {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    protected:</span></div><div class="token-line"><span class="token plain">      _Tp** _M_map;</span></div><div class="token-line"><span class="token plain">      size_t _M_map_size;  </span></div><div class="token-line"><span class="token plain">      iterator _M_start;</span></div><div class="token-line"><span class="token plain">      iterator _M_finish;</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因此 _M_map 在数据结构中的表现就是一个二级指针。_M_map_size指的就是 deque 中 map 的空间大小，即在map中最多能存储多少个指针。如果map的空间已经被用满了，我们也会对map进行一次重新分配迁移的操作，核心思想和vector的重分配其实是一样的，我们马上具体讲。</p><h3 id="deque的迭代器"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的迭代器"><span class="icon icon-link"></span></a>Deque的迭代器</h3><p>介绍完内存布局和基本数据结构，下一个重点就是STL的通用访问模式，迭代器的实现了。</p><p>正是因为 <strong>deque 底层实质是分段连续空间</strong>，operator++ 和 operator<code>--</code> 的实现也变得更困难一些，迭代器既要能找到与当前缓冲区相邻的缓冲区在哪；也需要知道目前访问的地方是否已经到当前缓冲区的边缘，只有这样到边缘时，才能正确跳转。</p><p>为了方便达到这一目标，我们需要在迭代器的数据结构中记录一下迭代器在当前缓冲区的位置，同时记录当前缓冲区的开始位置和结束位置，以及缓冲区的map指针：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;class _Tp, class _Ref, class _Ptr&gt;</span></div><div class="token-line"><span class="token plain">    struct _Deque_iterator {</span></div><div class="token-line"><span class="token plain">      typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span></div><div class="token-line"><span class="token plain">      typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;</span></div><div class="token-line"><span class="token plain">      static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      typedef _Tp** _Map_pointer; // 缓冲区指针</span></div><div class="token-line"><span class="token plain">      ... </span></div><div class="token-line"><span class="token plain">      _Tp* _M_cur; // 当前缓冲区的位置</span></div><div class="token-line"><span class="token plain">      _Tp* _M_first; // 缓冲区的左边界线</span></div><div class="token-line"><span class="token plain">      _Tp* _M_last; // 缓冲区的右边界</span></div><div class="token-line"><span class="token plain">      _Map_pointer _M_node;</span></div><div class="token-line"><span class="token plain">      _Deque_iterator(_Tp* __x, _Map_pointer __y) </span></div><div class="token-line"><span class="token plain">        : _M_cur(__x), _M_first(*__y),</span></div><div class="token-line"><span class="token plain">          _M_last(*__y + _S_buffer_size()), _M_node(__y) {}</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了位置的记录，operator++ 可以这样实现：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">_Self&amp; operator++() {</span></div><div class="token-line"><span class="token plain">        ++_M_cur;</span></div><div class="token-line"><span class="token plain">        if (_M_cur == _M_last) {</span></div><div class="token-line"><span class="token plain">          _M_set_node(_M_node + 1);</span></div><div class="token-line"><span class="token plain">          _M_cur = _M_first;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return *this; </span></div><div class="token-line"><span class="token plain">      }  </span></div><div class="token-line"><span class="token plain">      void _M_set_node(_Map_pointer __new_node) {</span></div><div class="token-line"><span class="token plain">        _M_node = __new_node;</span></div><div class="token-line"><span class="token plain">        _M_first = *__new_node;</span></div><div class="token-line"><span class="token plain">        _M_last = _M_first + difference_type(_S_buffer_size());</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>核心的就是_M_set_node方法，如果我们发现M_cur已经达到了当前缓冲区的尾部，就将它移动到下一段缓冲区的头部，更新迭代器中当前map的位置。另外，也需要将_M_first和_M_last更新为新的缓冲区的左确界和右虚界。</p><p><code>--</code> 的操作类似：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">_Self&amp; operator--() {</span></div><div class="token-line"><span class="token plain">        if (_M_cur == _M_first) {</span></div><div class="token-line"><span class="token plain">          _M_set_node(_M_node - 1);</span></div><div class="token-line"><span class="token plain">          _M_cur = _M_last;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        --_M_cur;</span></div><div class="token-line"><span class="token plain">        return *this;</span></div><div class="token-line"><span class="token plain">      }</span></div></pre></div><p>我们发现M_cur达到缓冲区头部的时候，就要将它移动到当前缓冲区的前一段缓冲区了，调用set_node方法即可。</p><p>到这里就完成了迭代器的主要接口，这让我们将内存实质不连续的真相隐藏了起来，取而代之地提供了一个非常简洁好用的遍历deque的接口。</p><p>好啦，学完deque 的内存布局和迭代器如何实现，你知道它的基础操作该怎么写了吗？</p><h2 id="deque的基础操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#deque的基础操作"><span class="icon icon-link"></span></a>Deque的基础操作</h2><p>相比于vector和list来说，deque支持的操作要少得多，只有基本的push和pop实现，因为队列语义保证了我们不会在队列中间进行插入删除操作，也就不用支持insert和erase这样的操作了。</p><p>不过正因为内存布局复杂，deque的内存管理扩缩容的逻辑也比较复杂，我们了解大概思想就可以了。如果你感兴趣可以自行查阅deque源码。</p><h3 id="push操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#push操作"><span class="icon icon-link"></span></a>push操作</h3><p>Deque的第一个操作当然是push_front和push_back，因为我们实现的是双端队列，所以头部尾部都有可能插入数据。</p><p>遇到内存不足的时候，deque会按照下图的逻辑进行扩容，有几个检查点，首先判断是不是能在当前缓冲区插入元素，如果可以，直接插入就行；如果不能，就要检查缓冲区map两端是否有足够的空间；如果有的话，也很简单，直接创建一个新的缓冲区并存入map。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagedf10dfb62956a3766be073e91e56a6348b10.e24d637c.jpg" alt=""/></p><p>关键是在map空间不足的时候，也就是插入的数据已经达到map头部或者尾部缓冲区的边界时，我们可以分两种情况讨论：</p><ol><li><strong>如果 map使用率已经超过一半</strong>，我们就可以重新申请更大的空间，把老的map上的数据拷贝到新的区域。这里注意，map中指向的那些缓冲区里的数据并不用变化，只是需要一个更大的map去放那些缓冲区的指针，和动态数组扩容的方式如出一辙。</li><li><strong>map使用率没有超过一半</strong>，这时候我们认为申请新的空间可能是浪费的，所以只是将数据重新调整到map中间的位置，当然也要进行一次拷贝。这可能会帮我们节约大量的空间。</li></ol><p>翻译成代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void push_back(const value_type&amp; __t) {</span></div><div class="token-line"><span class="token plain">        if (_M_finish._M_cur != _M_finish._M_last - 1) {</span></div><div class="token-line"><span class="token plain">          construct(_M_finish._M_cur, __t);</span></div><div class="token-line"><span class="token plain">          ++_M_finish._M_cur;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else</span></div><div class="token-line"><span class="token plain">          _M_push_back_aux(__t);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    template &lt;class _Tp, class _Alloc&gt;</span></div><div class="token-line"><span class="token plain">    void deque&lt;_Tp,_Alloc&gt;::_M_push_back_aux()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      _M_reserve_map_at_back();</span></div><div class="token-line"><span class="token plain">      *(_M_finish._M_node + 1) = _M_allocate_node();</span></div><div class="token-line"><span class="token plain">      __STL_TRY {</span></div><div class="token-line"><span class="token plain">        construct(_M_finish._M_cur);</span></div><div class="token-line"><span class="token plain">        _M_finish._M_set_node(_M_finish._M_node + 1);</span></div><div class="token-line"><span class="token plain">        _M_finish._M_cur = _M_finish._M_first;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="pop操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#pop操作"><span class="icon icon-link"></span></a>pop操作</h3><p>pop操作不再需要处理插入导致的扩容拷贝问题, 相对来说就显得简单很多。以pop_back为例，我们只需要关注是否已经pop到某一段缓冲区的边界。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void pop_back() {</span></div><div class="token-line"><span class="token plain">        if (_M_finish._M_cur != _M_finish._M_first) {</span></div><div class="token-line"><span class="token plain">          --_M_finish._M_cur;</span></div><div class="token-line"><span class="token plain">          destroy(_M_finish._M_cur);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        else</span></div><div class="token-line"><span class="token plain">          _M_pop_back_aux();</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    // Called only if _M_finish._M_cur == _M_finish._M_first.</span></div><div class="token-line"><span class="token plain">    template &lt;class _Tp, class _Alloc&gt;</span></div><div class="token-line"><span class="token plain">    void deque&lt;_Tp,_Alloc&gt;::_M_pop_back_aux()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      _M_deallocate_node(_M_finish._M_first);</span></div><div class="token-line"><span class="token plain">      _M_finish._M_set_node(_M_finish._M_node - 1);</span></div><div class="token-line"><span class="token plain">      _M_finish._M_cur = _M_finish._M_last - 1;</span></div><div class="token-line"><span class="token plain">      destroy(_M_finish._M_cur);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>如果发现当前迭代器已经和缓冲区的首位置相同，除了释放掉当前的内存，还需要释放掉整段缓冲区的内存，并且将迭代器的缓冲区指针，指向当前缓冲区前一段的位置，这可以通过_M_set_node方法达成。当然，由于我们还需要pop一个节点，所以会将_M_cur指向_M_finish._M_last-1的位置。</p><h3 id="c的选择"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#c的选择"><span class="icon icon-link"></span></a>C++的选择</h3><p>现在掌握了deque的实现和基本操作，我们来回答一下为什么C++不选择依赖已有的序列式容器来实现deque？</p><p>其实我们已有的容器就两个，一个是vector，另外一种就是list。</p><p>显然，基于vector实现，不能真的在头部插入元素，会产生O(N)的时间开销，我们只能用一个固定大小的vector来模拟循环队列，具体实现方式前面说过。但这样就导致我们<strong>必须事先确定数组的最大容量，让它的大小是实现分配好的，这就和数组一样，也会产生内存浪费和无法动态扩容的问题</strong>。</p><p>不过在最大容量能确定的场景下，用vector也是一种非常常见的循环队列实现方式。</p><p>而基于list，看起来首尾都可以O(1)的时间插入，但对数据的随机读取性能会很差；且每次插入元素都需要申请内存，相比于deque一次申请一段内存的方式也会带来额外的性能开销。而<strong>list的最大优势，任意位置的快速插入/删除能力，我们却用不上</strong>。</p><p>所以基于deque的使用场景，C++设计了基于map分段存储的双端队列的数据结构，能同时具备list和vector的特点。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#总结"><span class="icon icon-link"></span></a>总结</h2><p>队列的基本特性是FIFO，也就是先进先出，它能衍生出几种不同的形式，包括循环队列、双端队列，既可以通过数组实现，也可以通过链表实现。</p><p>STL的deque是一种双端队列的实现，内存布局是由一段段连续内存串联起来的，在队列两端都可以pop和push数据。因为复杂的内存分配，代码实现的难度要高很多。但更多的复杂性还是体现在内存管理中，只要我们通过迭代器等模式，将底层的逻辑封装起来，相信你也看到了，pop和push操作的思路其实是非常清晰好懂的。</p><p>现在你知道为什么说工作窃取算法需要用到双端队列了吗？</p><p>我们一起看看。为了更公平也更高效地分配每个进程负责的任务，我们可能会多开很多个队列去存储任务，每个进程就去消费一个队列中的任务，这样就可以有效避免进程间的竞争。因为任务先进先出，用一个普通的单向队列就可以完成了。</p><p>但是你可能很难保证任务划分得非常均匀，使得每个进程完成所有任务的时间都差不多。这不是一个很好解决的问题。但是如果我们<strong>换一个思路，不再费心让任务分配得均匀，只是简单地允许先完成任务的进程，去其他进程的队列盗取任务，是不是就不会有进程闲置了呢</strong>？</p><p>不过怎么盗取，可以让我们仍然尽量规避进程间的竞争问题呢？ 相信你已经想到答案了，没错，就是双端队列。我们让盗取任务的进程，从队列的另一端盗取就行了，这样只有队列长度为1的时候才会出现竞争。当然还有很多实现细节，你感兴趣的话可以去看一下Java中ForkJoinPool的实现。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>最后，同样给你留一个课后作业。我们讲解了如何用数组实现队列，也提到队列同样可以通过链表来实现？你可以试着实现一下吗？</p><p>欢迎你留言与我讨论交流～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/03.基础数据结构篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
