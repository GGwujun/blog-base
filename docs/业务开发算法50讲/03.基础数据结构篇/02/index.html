<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>02｜双向链表：list如何实现高效地插入与删除？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/业务开发算法50讲/03.基础数据结构篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/业务开发算法50讲/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/业务开发算法50讲/01.开篇词/01"><span>开篇词｜真实世界的算法，和你想的不一样</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/02.先导篇">02.先导篇</a><ul><li><a href="/blog-base/业务开发算法50讲/02.先导篇/01"><span>先导篇｜诶，这个 git diff 好像不是很直观？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇">03.基础数据结构篇</a><ul><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/01"><span>01｜动态数组：按需分配的vector为什么要二倍扩容？</span></a></li><li><a aria-current="page" class="active" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02"><span>02｜双向链表：list如何实现高效地插入与删除？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/03"><span>03｜双端队列：并行计算中的工作窃取算法如何实现？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/04"><span>04｜栈：函数调用的秘密究竟是什么？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/05"><span>05｜HashMap：一个优秀的散列表是怎么来的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/06"><span>06｜TreeMap：红黑树真的有那么难吗？</span></a></li><li><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/07"><span>07｜堆：如何实现一个高效的优先队列？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇">04.基础算法篇</a><ul><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/01"><span>08｜外部排序：如何为TB级数据排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/02"><span>09｜二分：如何高效查询Kafka中的消息？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/03"><span>10｜搜索算法： 一起来写一个简单的爬虫？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/04"><span>11｜字符串匹配：如何实现最快的grep工具</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/05"><span>12｜拓扑排序：Webpack是如何确定构建顺序的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/04.基础算法篇/06"><span>13｜哈夫曼树：HTTP2.0是如何更快传输协议头的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇">05.操作系统篇</a><ul><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/01"><span>14｜调度算法：操作系统中的进程是如何调度的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/02"><span>15｜LRU：在虚拟内存中页面是如何置换的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/05.操作系统篇/03"><span>16｜日志型文件系统：写入文件的时候断电了会发生什么？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇">06.计算机网络篇</a><ul><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/01"><span>17｜选路算法：Dijkstra是如何解决最短路问题的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/02"><span>18｜选路算法：链路状态算法是如何分发全局信息的</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/03"><span>19｜选路算法：距离矢量算法为什么会产生无穷计算问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/06.计算机网络篇/04"><span>20｜滑动窗口：TCP是如何进行流量控制和拥塞控制的？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇">07.分布式篇</a><ul><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/01"><span>21｜分而治之：MapReduce如何解决大规模分布式计算问题</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/02"><span>22｜PageRank：谷歌是如何计算网页排名的</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/03"><span>23｜Raft：分布式系统间如何达成共识？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/04"><span>24｜UUID：如何高效生成全局的唯一ID？</span></a></li><li><a href="/blog-base/业务开发算法50讲/07.分布式篇/05"><span>25｜一致性哈希：如何在集群上合理分配流量？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇">08.工程实战篇</a><ul><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/01"><span>26｜B+ Tree：PostgreSQL 的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/02"><span>27｜LSM Tree：LevelDB的索引是如何建立的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/03"><span>28｜MVCC：如何突破数据库并发读写性能瓶颈？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/04"><span>29｜位图：如何用更少空间对大量数据进行去重和排序？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/05"><span>30｜布隆过滤器：如何解决Redis缓存穿透问题？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/06"><span>31｜跳表：Redis是如何存储有序集合的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/07"><span>32｜时间轮：Kafka是如何实现定时任务的？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/08"><span>33｜限流算法：如何防止系统过载？</span></a></li><li><a href="/blog-base/业务开发算法50讲/08.工程实战篇/09"><span>34｜前缀树：Web框架中如何实现路由匹配？</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/09.结束语">09.结束语</a><ul><li><a href="/blog-base/业务开发算法50讲/09.结束语/01"><span>结束语｜在技术的世界里享受思维的乐趣</span></a></li><li><a href="/blog-base/业务开发算法50讲/09.结束语/02"><span>期末测试｜来赴一场满分之约！</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划">10.特别策划</a><ul><li><a href="/blog-base/业务开发算法50讲/10.特别策划/01"><span>特别策划｜面试：BAT面试三关准备方法大揭秘</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/02"><span>即学即练｜基础数据结构篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/03"><span>即学即练｜基础算法思想篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/04"><span>即学即练｜操作系统篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/05"><span>即学即练｜计算机网络篇：复习卡 &amp; 算法题特训</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/06"><span>即学即练｜分布式篇：复习卡一键直达</span></a></li><li><a href="/blog-base/业务开发算法50讲/10.特别策划/07"><span>即学即练｜工程实战篇：复习卡一键直达</span></a></li></ul></li><li><a href="/blog-base/业务开发算法50讲/summary">业务开发算法50讲</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="链表" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表"><span>链表</span></a></li><li title="单链表vs双链表vs循环链表" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#单链表vs双链表vs循环链表"><span>单链表vs双链表vs循环链表</span></a></li><li title="STL中List的实现" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#stl中list的实现"><span>STL中List的实现</span></a></li><li title="链表节点的实现" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表节点的实现"><span>链表节点的实现</span></a></li><li title="链表迭代器的实现" data-depth="3"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表迭代器的实现"><span>链表迭代器的实现</span></a></li><li title="链表数据结构的实现" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表数据结构的实现"><span>链表数据结构的实现</span></a></li><li title="链表基本操作的实现" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表基本操作的实现"><span>链表基本操作的实现</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#总结"><span>总结</span></a></li><li title="课后作业" data-depth="2"><a href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#课后作业"><span>课后作业</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="02双向链表list如何实现高效地插入与删除"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#02双向链表list如何实现高效地插入与删除"><span class="icon icon-link"></span></a>02｜双向链表：list如何实现高效地插入与删除？</h1><p>你好，我是微扰君。</p><p>在上一讲实现的一个简易银行账户管理系统中，每个账号都对应了一个余额，系统支持用户的开通、存/取款和查询余额。我们使用动态数组容器满足了频繁随机访问查询的需求。</p><p>但是如果要在系统里支持删除的功能，就会有一个问题：我们为了不进行整体的数组移动操作，通常就只能保留这个用户在数组里占用的内存，用将元素标记为特殊值的方式来模拟“删除”；而因为数组是连续存储的，不能单独释放掉数组中间某些区域的内存，所以这段内存空间我们实际上就是浪费的。</p><p>如果还有个需求，比如现在某个不讲道理的领导来到这个银行，要求自己在数组中排在最前面；那么我们不得不将所有人的账户信息往后挪动一位来满足他奇怪的自尊心，这也会带来高昂的时间复杂度。</p><p>那么有没有办法让我们不再需要连续的存储空间去存储一个序列，同时又可以在序列中快速进行插入/删除操作而不用波及之后的所有元素呢？</p><p>这就需要另一种常见的序列式数据结构——链表登场了，这同样是几乎所有高级语言都会原生支持的数据结构。</p><h2 id="链表"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表"><span class="icon icon-link"></span></a>链表</h2><p>链表这个数据结构的发明也是很久之前的事了，最早在1955年，它就是IPL这一古老语言的内置数据结构，用于开发当时的人工智能程序。</p><p>类似数组，链表同样是一种序列式的数据结构，但存储元素时并不需要使用连续的内存空间，而是采用一系列通过指针相连的节点来存储，<strong>因为有了指针来关联节点的地址，就不需要连续存储了</strong>。</p><p>在每个节点内，我们都会同时存储元素的数据信息和一个指针，存储元素信息的部分是数据域，也就是 data field，存储指针的地方称为引用域，也就是 reference field；其中指针指向该节点的后继节点，也就是记录着链表中存储下一个元素节点的地址。</p><p>下图就是一个典型长度为3的链表的示例，我们可以通过指针很容易地从第一个节点遍历完整个链表。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimage575f57a4afd78ed47c5f4dedd450c87b8c5f.jpg" alt="图片"/></p><p>从内存布局能看出来，链表比连续存储的数组，有更灵活的内存使用方式和更高的内存使用率。</p><p>因为数组要求事先分配内存，而链表是每次插入新节点的时候，才申请该节点所需的内存空间，灵活得多，也就不会有分配空间没有被使用的浪费问题，自然内存使用率高。</p><p>链表存储元素采用的是通过指针的串联方式，而非数组的连续排列方式。我们在任何位置插入或者删除节点，不再需要为了保持元素的连续存储而进行O(n)的整体移动操作，只需要进行O(1)的指针改写，加申请或者释放内存就行。这显然比数组的插入删除要高效得多。</p><p>但是毕竟鱼和熊掌不能兼得。<strong>也正是因为这样非连续的存储方式，我们需要访问链表中第n个元素的时候就不得不从头节点遍历</strong>，导致访问第i个元素的均摊时间复杂度为O(N)，而不能像数组那样直接基于下标和元素大小，计算出指定元素的偏移量。</p><p>所以，我们并不能简单地说链表和数组哪个更好，而是要根据使用的场景做出合适的选择。毕竟如果两个相似的数据结构其中一个各个方面都好于另一个的话，另一个数据结构可能也不会存在至今了。</p><p>基于上面的特性对比，我们可以得出一个大致的结论：链表更适用于删除、插入、遍历操作频繁的场景，而不适用于随机访问索引频繁的场景。比如在内存池、操作系统进程管理、最常用的缓存替换算法LRU中都有应用，之后讲解到相关专题的时候也会提到。</p><h2 id="单链表vs双链表vs循环链表"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#单链表vs双链表vs循环链表"><span class="icon icon-link"></span></a>单链表vs双链表vs循环链表</h2><p>在实际使用过程中，根据不同的需求，大致有3种常见的链表形式，单链表、双链表和循环链表，它们都需要支持几种最基本的链表操作，包括插入节点、删除节点、修改节点信息，以及访问遍历节点信息。</p><p>可以看图直观感受三者的区别。三种链表节点都包含引用域和数据域。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimagefba5fb50a216ba0f4d38461427d13cd0d9a5.jpg" alt="图片"/></p><p>其中，单链表和双链表最大的区别就在于，单链表的引用域，只存了一个后继指针。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimagea402a42ab74b0ceaf7675eb07b830e986c02.jpg" alt="图片"/></p><p>而双链表有两个引用域，不只存有后继节点的地址，也存储了前驱节点的信息，这使得我们<strong>可以双向遍历链表，拥有了在遍历中回退的能力</strong>。在链表首尾的前驱和后继指针，可以设为NULL或者指向一个特殊的虚拟节点，来标记链表的终结。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimageb0e6b02c37b3d8ba0a9a213e3ff1d1461ee6.jpg" alt="图片"/></p><p>而循环链表则是一个没有边界的环，既可以用双链表来实现也可以用单链表实现。相比于前两者的主要区别在于，在链表的边界，比如尾部，不再设为NULL或者一个虚拟节点，而是直接将尾部指向链表的头部。这在许多需要循环遍历的场景下非常有用，比如可以用于模拟约瑟夫环。</p><h2 id="stl中list的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#stl中list的实现"><span class="icon icon-link"></span></a>STL中List的实现</h2><p>好了，讲解完链表的基础概念和分类，进入今天的重头戏，我们看看如何实现一个链表。</p><p>为了契合专栏真实世界的语义，我们继续以STL这一久经考验的C++标准库中的实现来讲解。<strong>List就是STL中的链表容器，它实现的是前面提到的双向、循环链表</strong>。如果你想要使用更节约空间的单链表，STL中也提供了相应的实现<a target="_blank" rel="noopener noreferrer" href="https://en.cppreference.com/w/cpp/container/forward_list">forward_list<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有兴趣的话，你可以自己去了解背后的实现。</p><p>和上节课一样，因为STL的实现背后涉及了许多繁琐的C++高级语法，我们会对代码做一定的简化方便理解，你对C++不感兴趣的话也不用深究。</p><h3 id="链表节点的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表节点的实现"><span class="icon icon-link"></span></a>链表节点的实现</h3><p>首先来看一下 list 的主要组成部分node ，也就是链表节点，它是整个链表的关键，存储着元素信息本身和连接链表的前后指针。</p><p>Node节点的实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template &lt;class T&gt;</span></div><div class="token-line"><span class="token plain">    struct __list_node {</span></div><div class="token-line"><span class="token plain">      __list_node&lt;T&gt;* next;  // 前驱节点指针</span></div><div class="token-line"><span class="token plain">      __list_node&lt;T&gt;* prev; // 后继节点指针</span></div><div class="token-line"><span class="token plain">      T data; //存储数据</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>可以看到，链表节点的定义，除了为了支持各种元素类型而用到的泛型语法。其他的内容和前面说的双链表的节点完全一致，<strong>指针域同时包含了前驱和后继节点的地址</strong>，成员变量data用于存储元素信息本身。</p><h3 id="链表迭代器的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表迭代器的实现"><span class="icon icon-link"></span></a>链表迭代器的实现</h3><p>所有的STL容器都需要实现迭代器，这也是后面所有操作的基础。</p><p>迭代器提供用于遍历的最重要的接口，它本身也是一种重要的设计模式，支持的操作就是自增<code>++</code>和自减<code>--</code>。上一讲的vector，因为内存是连续存储的，可以直接通过地址的++和–操作；但在内存不连续存储的List中，我们需要基于节点引用域中的前驱后继节点信息，来实现自己的迭代方法。</p><p>代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template&lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">    struct __list_iterator{</span></div><div class="token-line"><span class="token plain">        typedef __list_iterator&lt;T&gt;   self;</span></div><div class="token-line"><span class="token plain">        typedef __list_node&lt;T&gt;*      link_type;</span></div><div class="token-line"><span class="token plain">        link_type ptr; //成员</span></div><div class="token-line"><span class="token plain">        __list_iterator(link_type p = nullptr):ptr(p){}</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    T&amp; operator *(){return ptr-&gt;data;}</span></div><div class="token-line"><span class="token plain">    T* operator -&gt;(){return &amp;(operator*());}</span></div><div class="token-line"><span class="token plain">    // 类似 ++x 返回next节点</span></div><div class="token-line"><span class="token plain">    self&amp; operator++(){</span></div><div class="token-line"><span class="token plain">        ptr = ptr-&gt;next;</span></div><div class="token-line"><span class="token plain">        return *this;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 类似 x++ 返回当前节点</span></div><div class="token-line"><span class="token plain">    self operator++(int){</span></div><div class="token-line"><span class="token plain">        self tmp = *this;</span></div><div class="token-line"><span class="token plain">        ++*this;</span></div><div class="token-line"><span class="token plain">        return tmp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 类似 --x 返回prev节点</span></div><div class="token-line"><span class="token plain">    self&amp; operator--(){</span></div><div class="token-line"><span class="token plain">        ptr = ptr-&gt;prev;</span></div><div class="token-line"><span class="token plain">        return *this;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    // 类似 x-- 返回当前节点</span></div><div class="token-line"><span class="token plain">    self operator--(int){</span></div><div class="token-line"><span class="token plain">        self tmp = *this;</span></div><div class="token-line"><span class="token plain">        --*this;</span></div><div class="token-line"><span class="token plain">        return tmp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    bool operator==(const __list_iterator&amp; rhs){</span></div><div class="token-line"><span class="token plain">        return ptr == rhs.ptr;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    bool operator!=(const __list_iterator&amp; rhs){</span></div><div class="token-line"><span class="token plain">        return !(*this==rhs);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实就是将迭代器的方法都实现一遍。我们重点需要关注的操作是++和–，对应实现也非常直观。</p><p>在迭代器中，ptr是我们的主要成员变量，它指向的就是迭代器当前遍历的节点地址。所以++就是返回一个指向 <code>ptr-&gt;next</code> 的指针；而–对应的，就是返回一个指向<code>prt-&gt;prev</code> 的指针；同时我们需要把内置的ptr 也指向prt-&gt;next 或者 ptr-&gt;prev。这样我们就可以自如地用迭代器在链表上进行遍历了。</p><h2 id="链表数据结构的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表数据结构的实现"><span class="icon icon-link"></span></a>链表数据结构的实现</h2><p>有了迭代器和节点，我们要做的就是将STL中双向循环链表的结构，用C++语言描述出来，并将一些链表相关的基本操作实现出来。</p><p>所谓链表，就是要将节点链接起来。由于链表节点本身已经存了前置后继节点的地址，所以<strong>链表数据结构主要的内涵，其实只需要使用一个节点即可表示出来</strong>，用这一个节点，我们就可以找到所有其他的节点。</p><p>所以数据结构定义如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">template&lt;typename T&gt;</span></div><div class="token-line"><span class="token plain">        class list{</span></div><div class="token-line"><span class="token plain">            protected:</span></div><div class="token-line"><span class="token plain">                typedef __list_node&lt;T&gt; list_node; // 显示定义list_node类型</span></div><div class="token-line"><span class="token plain">                typedef allocator&lt;list_node&gt; nodeAllocator; // 定义allocator类型</span></div><div class="token-line"><span class="token plain">            public:</span></div><div class="token-line"><span class="token plain">                typedef T                  value_type;</span></div><div class="token-line"><span class="token plain">                typedef T&amp;                 reference;</span></div><div class="token-line"><span class="token plain">                typedef value_type*        pointer;</span></div><div class="token-line"><span class="token plain">                typedef list_node*         link_type;</span></div><div class="token-line"><span class="token plain">                typedef const value_type*  const_pointer;</span></div><div class="token-line"><span class="token plain">                typedef size_t             size_type;</span></div><div class="token-line"><span class="token plain">            public:</span></div><div class="token-line"><span class="token plain">                typedef __list_iterator&lt;value_type&gt; iterator; // 迭代器类型重写</span></div><div class="token-line"><span class="token plain">            private:</span></div><div class="token-line"><span class="token plain">                link_type node; // 只要一个指针，便可表示整个环状双向链表</span></div><div class="token-line"><span class="token plain">                // ......</span></div><div class="token-line"><span class="token plain">        }</span></div></pre></div><p>这段代码看起来比较长，其实大部分是一些类型定义，比如简写了带泛型的节点类型，更多是为了保证语义清晰和可读。我们真正要关注的只有private的成员变量 node，事实上，这一个节点就可以表示整个环状双向链表。</p><p>在内存中的排布方式如下图所示：<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimaged062d090e6a6c8ff2e4f6da3b6d5a2c48b62.jpg" alt="图片"/></p><p>每个链表数据结构，都会有一个<strong>虚拟节点的成员变量node，用于标记这整个循环链表的首尾连接处</strong>，它既是整个链表的开始，也是整个链表的结尾；也就是说，这个虚拟节点的pre 指向链表的最后一个节点，它的next指向链表的第一个节点。</p><p>所以链表初始化容量为零的时候，显然只有一个前后指针都指向自己的虚拟节点。</p><p>这里还有一个非常巧妙的设计，我们会让end()迭代器指向这个虚拟节点，begin()则会指向虚拟节点的下一个节点，这完美符合迭代器前闭后开的语义。</p><p>因为end()节点指向的是一个并不真实存储数据的元素，是永远取不到值的；而对应的begin()，在链表不空的时候，指向正是链表中的第一个节点。因此要遍历链表所有的元素的时候，就会写出这样的代码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">for (std::list&lt;int&gt;::iterator it=mylist.begin(); it != mylist.end(); ++it)</span></div><div class="token-line"><span class="token plain">        std::cout &lt;&lt; &#x27; &#x27; &lt;&lt; *it;</span></div></pre></div><p>我们在判断是否遍历到终点的代码，就和vector一样，写的是 it != mylist.end() 。</p><h2 id="链表基本操作的实现"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#链表基本操作的实现"><span class="icon icon-link"></span></a>链表基本操作的实现</h2><p>好了，终于来到最激动人心的部分：链表的基本操作。</p><p>有了刚才的数据结构和迭代器，很容易访问到链表的节点了，我们开始实现链表的另外几个主要操作：初始化链表、插入节点、删除节点。</p><p>先来看一切的开始，链表是如何初始化的。</p><p>相比数组其实要简单一些，因为前面说了，一个空的链表，就只包含了一个虚拟节点，STL内置的空间配置器很容易处理这个节点的内存申请。初始化代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void empty_initialize() {</span></div><div class="token-line"><span class="token plain">      node = get_node(0);</span></div><div class="token-line"><span class="token plain">      node-&gt;next = node; // next 指针指向自身</span></div><div class="token-line"><span class="token plain">      node-&gt;prev = node; // prev 指针指向自身</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    link_type get_node() { return list_node_allocator:allocate(); }</span></div></pre></div><p>当链表为空时，虚拟节点前、后指针都指向自身，代码就是如此简洁直观。</p><p>那怎么往链表里插入数据呢，我们主要看 <code>insert</code> 方法是如何实现的，它用来在链表中的任何一个节点后面插入数据。有了insert，我们当然也能很容易实现 push_back 等常用方法。</p><p>那 insert 需要传入哪些参数呢？</p><p>前面也说了，相比数组，链表的最大优势之一就是它的插入和删除效率会高效得多。这正是因为内存空间不是线性排列的，所以想要插入数据，我们只需要修改指定位置的前、后指针的指向，把新的节点在逻辑上插入某个位置就可以了。</p><p>所以 insert需要<strong>两个入参，一个是插入位置，类型是一个迭代器；另一个是插入的值</strong>。其实现方法如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">iterator insert(iterator position, const T&amp; x) {</span></div><div class="token-line"><span class="token plain">      lik_type tmp = create_node(x); // 创建一个临时节点</span></div><div class="token-line"><span class="token plain">      tmp-&gt;next = position.node; // 将该节点的后继指针指向当前位置的节点</span></div><div class="token-line"><span class="token plain">      tmp-&gt;prev = position.node-&gt;prev; // 将该节点的前驱指针指向当前位置的前驱节点</span></div><div class="token-line"><span class="token plain">      (link_type(position.node-&gt;prev))-&gt;next = tmp; // 将前驱节点本来指向当前节点的后继指针改为指向该临时节点</span></div><div class="token-line"><span class="token plain">      position.node-&gt;prev = tmp; // 同样，当前位置的前驱指针也要修改为指向该临时节点</span></div><div class="token-line"><span class="token plain">      return tmp;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>代码其实并不复杂，但许多新手还是需要花一些时间理解一下的，整个过程有点像“穿针引线”。<br/><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimagefa13fa87760aeb6af98ab9e9a272410dde13.jpg" alt="图片"/></p><p>先创建一个节点tmp，将该节点的前驱后继分别指向当前position的前驱和position本身；再将当前position的后继和position-&gt;prev的前驱指向这个新创建的节点。这样我们就完成了链表节点的插入。</p><p><img src="/images/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%AE%97%E6%B3%9550%E8%AE%B2/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/resourceimage7ec37e4ae3e8b7a12eac2c4ca469a40261c3.jpg" alt="图片"/></p><p>这些操作的顺序是非常重要的。你可以理解成要<strong>先把新的节点全接上去，才能把旧指针一一改过来</strong>。</p><p>如果调换了操作的顺序，比如先将当前position的后继指向临时节点，那么我们就访问不到插入节点的后继节点了。建议你用纸笔多模拟几遍整个插入的过程，多练习几遍自然就能掌握了。</p><p>而链表的删除操作是类似的，基本上就是进行一组和插入相反的操作。找到某个需要删除的节点位置，将该节点的后继和前驱直接关联在一起，最后释放掉待删除节点的空间即可。代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">iterator erase(iterator position) {</span></div><div class="token-line"><span class="token plain">      link_type next_node = link_type(position.node-&gt;next);</span></div><div class="token-line"><span class="token plain">      link_type prev_node = link_type(position.node-&gt;prev);</span></div><div class="token-line"><span class="token plain">      prev_node-&gt;next = next_node;</span></div><div class="token-line"><span class="token plain">      next_node-&gt;prev = prev_node;</span></div><div class="token-line"><span class="token plain">      destroy_node(position.node);</span></div><div class="token-line"><span class="token plain">      return iterator(next_node);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>有了 insert 和 erase操作，其他一些基础操作当然也很容易衍生出来。比如pop_front/pop_back/push_back，我们只需要在指定的位置调用 erase 和 insert 即可，首尾的位置都可以通过begin、end等迭代器接口快速取到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void pop_front() { erase(begin()) };</span></div><div class="token-line"><span class="token plain">    void pop_back() {</span></div><div class="token-line"><span class="token plain">      iterator tmp = end(); </span></div><div class="token-line"><span class="token plain">      erase(--tmp);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    push_back(const T&amp; x) { insert(end(), x); }</span></div></pre></div><p>这三个操作都是在O(1)时间复杂度内可以完成的，比vector对应的操作O(n)的时间复杂度要高效很多。</p><p>list其实还支持sort等操作，借助内部实现的transfer方法和归并排序的思想，同样可以做到O(n*logn)的复杂度。但实现比较复杂，如果你有兴趣，可以去看自己搜索一下相关的资料，力扣上有一道关于链表排序的<a target="_blank" rel="noopener noreferrer" href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd">题目<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>也可以练习。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#总结"><span class="icon icon-link"></span></a>总结</h2><p>链表，相比于数组，有更好的灵活性和更低的插入、删除的复杂度，更加适用于查询索引较少、遍历、插入、删除操作较多的场景，所以要频繁在容器中间某个位置插入元素的时候，就经常用到，比如在LRU和操作系统进程调度的场景下就都会用到。</p><p>链表操作在实现的过程中主要需要注意指针之间的变换顺序，你可以在脑海里多模拟几遍这样的过程，并尝试在不借助参考资料的前提下自己实现几次，这也是面试官在算法面试中经常会考察的点。</p><h2 id="课后作业"><a aria-hidden="true" tabindex="-1" href="/blog-base/业务开发算法50讲/03.基础数据结构篇/02#课后作业"><span class="icon icon-link"></span></a>课后作业</h2><p>今天没有讲链表中find方法的实现，这也是STL在各种容器中都会提供的一个通用方法。该方法用于寻找容器中某个值的迭代器，比如链表 1-&gt;5-&gt;3-&gt;4 中，调用find(3)，你应该返回的就是链表中的第三个节点的迭代器。你可以来实现一下find方法吗？时间复杂度又是多少呢？</p><p>欢迎留言与我讨论。如果你觉得文章有帮助的话呢，也欢迎你点赞转发，我们下节课见～</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/业务开发算法50讲/03.基础数据结构篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:07:33</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
