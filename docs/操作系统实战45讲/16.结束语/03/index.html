<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>参考答案 | 对答案，是再次学习的一个机会 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/16.结束语/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="第1节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第1节课"><span>第1节课</span></a></li><li title="第2节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第2节课"><span>第2节课</span></a></li><li title="第3节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第3节课"><span>第3节课</span></a></li><li title="第4节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第4节课"><span>第4节课</span></a></li><li title="第5节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第5节课"><span>第5节课</span></a></li><li title="第6节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第6节课"><span>第6节课</span></a></li><li title="第7节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第7节课"><span>第7节课</span></a></li><li title="第8节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第8节课"><span>第8节课</span></a></li><li title="第9节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第9节课"><span>第9节课</span></a></li><li title="第10节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第10节课"><span>第10节课</span></a></li><li title="第11节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第11节课"><span>第11节课</span></a></li><li title="第12节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第12节课"><span>第12节课</span></a></li><li title="第13节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第13节课"><span>第13节课</span></a></li><li title="第14节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第14节课"><span>第14节课</span></a></li><li title="第15节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第15节课"><span>第15节课</span></a></li><li title="第16节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第16节课"><span>第16节课</span></a></li><li title="第17节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第17节课"><span>第17节课</span></a></li><li title="第18节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第18节课"><span>第18节课</span></a></li><li title="第19节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第19节课"><span>第19节课</span></a></li><li title="第20节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第20节课"><span>第20节课</span></a></li><li title="第21节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第21节课"><span>第21节课</span></a></li><li title="第22节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第22节课"><span>第22节课</span></a></li><li title="第23节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第23节课"><span>第23节课</span></a></li><li title="第24节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第24节课"><span>第24节课</span></a></li><li title="第25节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第25节课"><span>第25节课</span></a></li><li title="第26节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第26节课"><span>第26节课</span></a></li><li title="第27节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第27节课"><span>第27节课</span></a></li><li title="第28节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第28节课"><span>第28节课</span></a></li><li title="第29节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第29节课"><span>第29节课</span></a></li><li title="第30节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第30节课"><span>第30节课</span></a></li><li title="第31节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第31节课"><span>第31节课</span></a></li><li title="第32节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第32节课"><span>第32节课</span></a></li><li title="第33节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第33节课"><span>第33节课</span></a></li><li title="第34节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第34节课"><span>第34节课</span></a></li><li title="第35节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第35节课"><span>第35节课</span></a></li><li title="第36节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第36节课"><span>第36节课</span></a></li><li title="第37节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第37节课"><span>第37节课</span></a></li><li title="第38节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第38节课"><span>第38节课</span></a></li><li title="第39节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第39节课"><span>第39节课</span></a></li><li title="第40节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第40节课"><span>第40节课</span></a></li><li title="第41节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第41节课"><span>第41节课</span></a></li><li title="第42节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第42节课"><span>第42节课</span></a></li><li title="第43节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第43节课"><span>第43节课</span></a></li><li title="第44节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第44节课"><span>第44节课</span></a></li><li title="第45节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第45节课"><span>第45节课</span></a></li><li title="第45节课" data-depth="3"><a href="/blog-base/操作系统实战45讲/16.结束语/03#第45节课-1"><span>第45节课</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="参考答案--对答案是再次学习的一个机会"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#参考答案--对答案是再次学习的一个机会"><span class="icon icon-link"></span></a>参考答案 | 对答案，是再次学习的一个机会</h1><p>你好，我是编辑宇新。</p><p>春节将至，先给你拜个早年：愿你2022年工期变长，需求变少，技术水平更加硬核。</p><p>距离我们专栏更新结束已经过去了不少时间，给坚持学习的你点个赞。学习操作系统是一个长期投资，需要持之以恒，才能见效。无论你是二刷、三刷的朋友，还是刚买课的新同学，都建议你充分利用留言区，给自己的学习加个增益buff。这种学习讨论的氛围，也会激励你持续学习。</p><p>今天这期加餐，我们整理了课程里的思考题答案，一次性发布出来，供你对照参考，查漏补缺。</p><p>建议你一定要先自己学习理解，动脑思考、动手训练，有余力还可以看看其他小伙伴的解题思路，之后再来对答案。</p><h3 id="第1节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第1节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/369457">第1节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：为了实现C语言中函数的调用和返回功能，CPU实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call和ret指令在逻辑上执行的操作是怎样的呢？</p><p>A：一般函数调用的情况下call和ret指令在逻辑上执行的操作如下：</p><p>1.将call指令的下一条指令的地址压入栈中；<br/>2.将call指令数据中的地址送入IP寄存器中（指令指针寄存器），该地址就是被调用函数的地址；<br/>3.由于IP寄存器地址设置成为被调用函数的地址，CPU自然跳转到被调用函数处开始执行指令；<br/>4.在被调用函数的最后都有一条ret指令，当CPU执行到ret指令时，就从栈中弹出一个数据到IP寄存器，而这个数据通常是先前执行call指令的下一条指令的地址，即实现了函数返回功能。</p><h3 id="第2节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第2节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/369502">第2节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：以上printf函数定义，其中有个形式参数很奇怪，请你思考下：为什么是“…”形式参数，这个形式参数有什么作用？</p><p>A：在C语言中经常使用printf(“%s :%d”,“number is :”,20);printf(“%x :%d”,0x10,20);printf(“%x,%x :%d”,0xba,0xff,20);可以看出，这些printf函数参数个数都不同，因为C语言的特性支持变参函数。而“…”表示支持0个和多个参数，C语言是通过调用者传递参数的，刚好支持这种变参函数。</p><h3 id="第3节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第3节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/372609">第3节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：其实我们的内核架构不是我们首创的，它是属于微内核、宏内核之外的第三种架构，请问这是什么架构？</p><p>A：我们的内核架构是混合内核架构，是介于微、宏架构之间的一种架构，这种架构保证了宏架构的高性能又兼顾了微架构的可移植、可扩展性。</p><h3 id="第4节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第4节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/374474">第4节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：Windows NT内核属于哪种架构类型？</p><p>A：Windows NT内核架构其实既不属于传统的宏内核架构，也不是新的微内核架构，说NT是微内核架构是错误的，NT这种内核架构其实是宏内核的变种——混合内核。</p><h3 id="第5节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第5节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/375278">第5节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问实模式下能寻址多大的内存空间？</p><p>A：由于实模式下访问内存的地址是这样产生的：16位段寄存器左移4位，加一个16位通用寄存器，最后形成了20位地址，所以只能访问1MB大的内存空间。</p><h3 id="第6节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第6节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/376064">第6节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：分页模式下，操作系统是如何对应用程序的地址空间进行隔离的？</p><p>A：操作系统会给每个应用程序都配置独立的一套页表数据。应用程序运行时，就让CR3寄存器指向该应用程序的页表数据。运行下一个应用程序时，则会执行同样的操作。</p><h3 id="第7节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第7节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/376711">第7节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你思考一下，如何写出让CPU跑得更快的代码？由于Cache比内存快几个数量级，所以这个问题也可以转换成：如何写出提高Cache命中率的代码？</p><p>A：第一，定义变量时，尽量让其地址与Cache行大小对齐。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int a __attribute__((aligned (64))); </span></div><div class="token-line"><span class="token plain">    int b __attribute__((aligned (64)));</span></div></pre></div><p>第二，操作数据时的顺序，尽量和数据在内存中布局顺序保持一致。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int arr[M][M];</span></div><div class="token-line"><span class="token plain">    for(int i = 0; i &lt; M; i++) {</span></div><div class="token-line"><span class="token plain">        for(int k = 0; k &lt; M; k++) {</span></div><div class="token-line"><span class="token plain">            arr[i][k] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //而非这样</span></div><div class="token-line"><span class="token plain">    for(int i = 0; i &lt; M; i++) {</span></div><div class="token-line"><span class="token plain">        for(int k = 0; k &lt; M; k++) {</span></div><div class="token-line"><span class="token plain">            arr[k][i] = 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>第三，尽量少用全局变量。</p><h3 id="第8节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第8节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/377913">第8节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p><p>A：最常规的形式是在设计共享数据结构时，在其中包含自旋锁或者信号量。</p><p>如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_DATA</span></div><div class="token-line"><span class="token plain">    {   </span></div><div class="token-line"><span class="token plain">        spinlock_t d_lock;</span></div><div class="token-line"><span class="token plain">        sem_t d_sem;</span></div><div class="token-line"><span class="token plain">        int a;</span></div><div class="token-line"><span class="token plain">        int b;</span></div><div class="token-line"><span class="token plain">        long state;</span></div><div class="token-line"><span class="token plain">    }data_t;</span></div><div class="token-line"><span class="token plain">    data_t da;</span></div><div class="token-line"><span class="token plain">    do_da_write(data_t* d)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        x86_spin_lock(&amp;d-&gt;d_lock);</span></div><div class="token-line"><span class="token plain">        d-&gt;a = 0;</span></div><div class="token-line"><span class="token plain">        d-&gt;b = 1;</span></div><div class="token-line"><span class="token plain">        d-&gt;state = 2;</span></div><div class="token-line"><span class="token plain">        x86_spin_unlock(&amp;d-&gt;d_lock);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    do_da_sem_write(data_t* d)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krlsem_down(&amp;d-&gt;d_sem);</span></div><div class="token-line"><span class="token plain">        d-&gt;a = 20;</span></div><div class="token-line"><span class="token plain">        d-&gt;b = 10;</span></div><div class="token-line"><span class="token plain">        d-&gt;state = 4;</span></div><div class="token-line"><span class="token plain">        krlsem_up(&amp;d-&gt;d_sem);</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    do_da_write(&amp;da);</span></div><div class="token-line"><span class="token plain">    do_da_sem_write(&amp;da);</span></div></pre></div><h3 id="第9节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第9节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/378870">第9节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请试着回答：上述Linux的读写锁，支持多少个进程并发读取共享数据？这样的读写锁有什么不足？</p><p>A：第一个问题，根据上述描述，读写锁本质上就是一个计数器。锁变量的初始值为0x01000000，即表示最多可以有0x01000000个进程同时获取读锁。</p><p>第二个问题，读写锁的不足是，如果一直有很多读取数据的进程占有读锁，因而可能导致修改数据的进程饥饿的情况。操作系统会加以控制，让修改数据的进程优先得锁。</p><h3 id="第10节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第10节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/379291">第10节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问，我们为什么要把虚拟硬盘格式化成ext4文件系统格式呢？</p><p>A：有两点原因。第一，GRUB在加载系统映像文件时，能够识别ext4文件系统格式；二，我们在Linux下生成系统映像文件时，要复制到虚拟硬盘中去，所以这个文件系统格式必须被Linux所识别，那么选ext4就最合适。</p><h3 id="第11节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第11节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/380507">第11节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问GRUB头中为什么需要_entry标号和_start标号的地址？</p><p>A：这是GRUB规定的。GRUB正是通过_entry标号和_start标号的地址，控制内核文件被加载到什么内存地址，又应该从什么内存地址开始运行。</p><h3 id="第12节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第12节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/381157">第12节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你想一下，init_bstartparm()函数中的init_mem820()函数，这个函数到底干了什么？</p><p>A：init_mem820()函数是把e820map_t结构数组复制到内核文件之后的内存空间，并且重新填写了机器信息结构。</p><p>它的代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_meme820(machbstart_t *mbsp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //源e820map_t结构数组地址</span></div><div class="token-line"><span class="token plain">        e820map_t *semp = (e820map_t *)((u32_t)(mbsp-&gt;mb_e820padr));</span></div><div class="token-line"><span class="token plain">        //e820map_t结构数组元素个数</span></div><div class="token-line"><span class="token plain">        u64_t senr = mbsp-&gt;mb_e820nr;</span></div><div class="token-line"><span class="token plain">         //获取下一段空闲内存空间的首地址，即e820map_t结构数组的新地址 </span></div><div class="token-line"><span class="token plain">        e820map_t *demp = (e820map_t *)((u32_t)(mbsp-&gt;mb_nextwtpadr));</span></div><div class="token-line"><span class="token plain">        //检查地址空间冲突</span></div><div class="token-line"><span class="token plain">        if (1 &gt; move_krlimg(mbsp, (u64_t)((u32_t)demp), (senr * (sizeof(e820map_t)))))</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            kerror(&quot;move_krlimg err&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //复制</span></div><div class="token-line"><span class="token plain">        m2mcopy(semp, demp, (sint_t)(senr * (sizeof(e820map_t))));</span></div><div class="token-line"><span class="token plain">        //并重新填写了对应的机器信息结构字段</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_e820padr = (u64_t)((u32_t)(demp));</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_e820sz = senr * (sizeof(e820map_t));</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((u32_t)(demp) + (u32_t)(senr * (sizeof(e820map_t))));</span></div><div class="token-line"><span class="token plain">        mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_e820padr + mbsp-&gt;mb_e820sz;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="第13节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第13节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/381810">第13节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你画出Cosmos硬件抽象层的函数调用关系图。</p><p>A：Cosmos硬件抽象层的函数调用关系图如下。</p><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9845%E8%AE%B2/16.%E7%BB%93%E6%9D%9F%E8%AF%AD/resourceimage90d79045b4fc2ece20b18e99b03b29be15d7.jpg" alt=""/></p><h3 id="第14节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第14节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/382733">第14节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：为什么要用C代码mkpiggy程序生成piggy.S文件，并包含vmlinux.bin.gz文件呢？</p><p>A：因为mkpiggy程序在读取vmlinux.bin.gz文件，知道了其长度等信息，它就会把这些信息保存在piggy.S文件相关的字段中。在解压vmlinux.bin.gz文件时，解压的代码需要用到这些信息。</p><h3 id="第15节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第15节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/383611">第15节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：你能指出上文中Linux初始化流程里，主要函数都被链接到哪些对应的二进制文件中了？</p><p>A：它们的链接结构如下。</p><p>1._start、main函数链接在setup.elf文件中，而setup.elf文件生成了setup.bin。</p><p>2.startup_32、startup_64、extract_kernel链接在linux/arch/x86/boot/compressed目录下的vmlinux文件中，而这个文件生成了vmlinux.bin。</p><p>3.Linux内核的startup_64、x86_64_start_kernel、start_kernel、arch_call_rest_init、rest_init、kernel_init、try_to_run_init_process、run_init_process函数链接在顶层linux目录下的vmlinux中。这是一个elf格式的文件，由objcoopy去除符号信息后用压缩工具压缩，包含到piggy.S中，从而形成了piggy.o，最终和其它文件一起生成了vmlinux.bin。</p><h3 id="第16节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第16节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/384366?">第16节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：我们为什么要以 2 的（0～52）次方为页面数来组织页面呢？</p><p>A：以2的（0～52）次方为页面数来组织页面，是为了每组连续的页面能对半分割。对半分割是为了保证连续的页面空间最大化，同时保证在下一次释放时，能最大可能地合并一个整体，这么做的目的只有一个：在满足最小、最大页面请求时，保证内存碎片的最小化。</p><h3 id="第17节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第17节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/384772">第17节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问在 4GB 的物理内存的情况下，msadsc_t 结构实例变量本身占用多大的内存空间？</p><p>A：4GB有1M个页面，那就对应1M个msadsc_t结构，每个msadsc_t结构为40个字节，所以占用40MB的内存空间。</p><h3 id="第18节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第18节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/385628">第18节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：在内存页面分配过程中，是怎样尽可能保证内存页面连续的呢？</p><p>A：因为分配内存页面一开始就是连续的，然后在分配时始终以2的幂次分隔，所以能保证内存页面的最大连续性。</p><h3 id="第19节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第19节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/386400">第19节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：为什么我们在分配内存对象大小时，要按照Cache行大小的倍数分配呢？</p><p>A：因为这使得我们分配的内存对象的地址空间是和Cache行对齐的，那么这个内存对象中的数据就极有可能被Cache命中，从而大大提升程序的性能。</p><h3 id="第20节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第20节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/387258">第20节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问内核虚拟地址空间为什么有一个 0xFFFF800000000000～0xFFFF800400000000 的线性映射区呢？</p><p>A：内核的线性映射区0xFFFF800000000000～0xFFFF800400000000，会映射到物理地址空间的0~～0x400000000。因为内核本身运行在虚拟地址空间，本身使用虚拟地址，但是它又必须访问物理内存，所以有了这个线性映射区，就可以把这个区域的物理地址转换成虚拟地址，也可以直接把虚拟地址转换成物理地址。</p><p>另外，因为它们之间就是一个常数：0xFFFF800000000000。所以，内核就可以很方便地操作自身数据结构和设备寄存器。这个设备寄存器是物理地址，内核很方便就能转换为虚拟地址，然后通过这个虚拟地址访问设备寄存器。</p><h3 id="第21节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第21节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/388167">第21节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问，x86 CPU 的缺页异常，是第几号异常？缺页的地址保存在哪个寄存器中？</p><p>A：x86 CPU的缺页异常，是14号异常。缺页的地址保存在x86 CPU的CR2寄存器中。</p><h3 id="第22节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第22节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/389123">第22节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：在默认配置下，Linux伙伴系统能分配多大的连续物理内存？</p><p>A：Linux伙伴系统能分配多大的连续物理内存，取决于MAX_ORDER。MAX_ORDER的值默认为11，因为是free_area数组的下标，所以要MAX_ORDER-1 = 10, 结果就是2 &lt;&lt; 10 = 1024，而1024个连续的页面（一个页面4KB）是4MB，即Linux伙伴系统能分配多大的连续物理内存是4MB。</p><h3 id="第23节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第23节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/389880">第23节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：Linux的SLAB，使用kmalloc函数能分配多大的内存对象呢？</p><p>A：kmalloc函数能分配32MB的内存对象。</p><h3 id="第24节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第24节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/390674">第24节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：各个进程是如何共享同一份内核代码和数据的？</p><p>A：只需要将每个进程的上半部分虚拟地址空间（0xFFFF800000000000~0xFFFFFFFFFFFFFFFF）的MMU页表设为相同的映射关系就行了，这样每个进程都可以共享内核的代码的数据，但是又不能读取和修改这部分地址空间中的数据，因为权限不够。</p><h3 id="第25节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第25节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/391222">第25节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问当调度器函数调度到一个新建进程时，为何要进入 retnfrom_first_sched 函数呢？</p><p>A：因为新建的进程内核中只有CPU默认的寄存器状态，没有从内核其它任何位置调用进入krlschedul函数。因此没有调用krlschedul函数的调用路径，所以无从返回，只能通过retnfrom_first_sched函数，强制初始化CPU寄存器状态，从而让进程开始运行。</p><h3 id="第26节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第26节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/392198">第26节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：我们让进程进入等待状态后，进程会立马停止运行吗？</p><p>A：进程不会立马停止运行，因为在调用krlsched_wait函数后，进程的上下文并没有切换。需要在krlsched_wait函数的外层，通过调用krlschedul函数进行进程调度，才能让该进程停止运行，进入等待状态。</p><h3 id="第27节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第27节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/393350">第27节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：想一想，Linux 进程的优先级和 Linux 调度类的优先级是一回事儿吗？</p><p>A：不是一回事儿。一个调度类管理着同一类的多个进程，而进程的优先级是该调度类下的各个进程间的优先级。</p><h3 id="第28节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第28节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/394084">第28节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你写出一个用来访问设备的接口函数，或者想一下访问一个设备需要什么参数。</p><p>A：比如打开一个设备的接口函数，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int open(devid_t *devid, uint_t flgs);</span></div></pre></div><p>必须至少要有设备的devid参数。里面要包含设备的类型和设备号，这样才能找到一个具体的设备。</p><h3 id="第29节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第29节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/394875">第29节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你写出帮驱动程序开发者自动分配设备ID接口函数。</p><p>A：很明显，这需要驱动程序提供一个设备类型，然后到设备表中搜索该设备类型还没有占用的设备ID，最后返回这个设备ID。代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t krlnew_devid(devid_t *devid)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        device_t *findevp;</span></div><div class="token-line"><span class="token plain">        drvstus_t rets = DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cpufg;</span></div><div class="token-line"><span class="token plain">        list_h_t *lstp;</span></div><div class="token-line"><span class="token plain">        devtable_t *dtbp = &amp;osdevtable;//获取设备表</span></div><div class="token-line"><span class="token plain">        uint_t devmty = devid-&gt;dev_mtype;</span></div><div class="token-line"><span class="token plain">        uint_t devidnr = 0;</span></div><div class="token-line"><span class="token plain">        if (devmty &gt;= DEVICE_MAX)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        krlspinlock_cli(&amp;dtbp-&gt;devt_lock, &amp;cpufg);</span></div><div class="token-line"><span class="token plain">        if (devmty != dtbp-&gt;devt_devclsl[devmty].dtl_type)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = DFCERRSTUS;</span></div><div class="token-line"><span class="token plain">            goto return_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //检查这个设备类型链表是不是为空</span></div><div class="token-line"><span class="token plain">        if (list_is_empty(&amp;dtbp-&gt;devt_devclsl[devmty].dtl_list) == TRUE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets = DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">            devid-&gt;dev_nr = 0;</span></div><div class="token-line"><span class="token plain">            goto return_step;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //扫描该设备类型链表下的所有设备</span></div><div class="token-line"><span class="token plain">        list_for_each(lstp, &amp;dtbp-&gt;devt_devclsl[devmty].dtl_list)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            findevp = list_entry(lstp, device_t, dev_intbllst);</span></div><div class="token-line"><span class="token plain">            if (findevp-&gt;dev_id.dev_nr &gt; devidnr)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                //获取最大的设备号</span></div><div class="token-line"><span class="token plain">                devidnr = findevp-&gt;dev_id.dev_nr;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //新的设备号等于最大设备号加一</span></div><div class="token-line"><span class="token plain">        devid-&gt;dev_nr = devidnr++;</span></div><div class="token-line"><span class="token plain">        rets = DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    return_step:</span></div><div class="token-line"><span class="token plain">        krlspinunlock_sti(&amp;dtbp-&gt;devt_lock, &amp;cpufg);</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="第30节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第30节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/395772">第30节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你想一想，为什么没有 systick 设备这样周期性的产生中断，进程就有可能霸占 CPU 呢？</p><p>A：如果一个应用程序，它不调用任何系统接口，也不退出系统，就在主函数中执行一个死循环，这样这个进程一旦运行，内核将再也没有办法从应用手中夺回CPU，其代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void main()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        for(;;);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><h3 id="第31节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第31节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/396896">第31节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：为什么无论是我们加载miscdrv.ko内核模块，还是运行App测试，都要在前面加上sudo呢？</p><p>A：Linux系统的安全是基于用户类型的，并且是多用户的系统，所以有些影响系统的操作，必须要root用户才能完成。比如你加载一个内核模块，这个内核模块是不是友好的？会不会干坏事？这需要管理员root用户评估；应用程序访问设备，同样是系统特权操作，也需要root用户，而sudo命令就是暂时让应用以root用户运行。</p><h3 id="第32节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第32节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/397594">第32节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问，我们文件系统的储存单位为什么要自定义一个逻辑储存块？</p><p>A：有两点考量：一是储存设备都按块为单位储存；二是为了文件系统代码的可移植性和可扩展性。因为储存设备的储存块大小各不相同，有512B、1KB、2KB、4KB，我们自己定义一个逻辑储存块，就能很好地适应不同的储存设备。</p><h3 id="第33节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第33节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/39869">第33节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问，建立文件系统的超级块、位图、根目录的三大函数的调用顺序可以随意调换吗，原因是什么？</p><p>A：不能随意调换，因为建立位图要依赖于超级块，而建立根目录时需要依赖于位图，所以必须是先调用建立超级块的函数，然后调用建立位图的函数，最后调用建立根目录的函数。</p><h3 id="第34节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第34节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/399700">第34节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请你想一想，我们这个简单的、小的，却五脏俱全的文件系统有哪些限制？</p><p>A：我们这个文件系统有如下限制：</p><ol><li>不能创建目录，所有文件都在根目录“/”下，即文件路径名都是这样的形式：“/file”、“/file1”、“/file2”等；</li><li>每个文件最多只能分配一个储存块（4KB大小）；</li><li>暂不支持文件随机读写，一旦发生读写操作，我们的文件系统会把一个文件的全部数据都返回给请求者，或者更新该文件的全部数据。</li></ol><h3 id="第35节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第35节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/400424">第35节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请说一说 super_block，dentry，inode 这三个数据结构 ，一定要在储存设备上对应存在吗？</p><p>A：不一定要在储存设备上对应存在，具体的文件系统可以有自己的实现，但是在运行时刻必须要能转换成内存中对应的super_block，dentry，inode这三大数据结构。转换方法由具体文件系统实现。</p><h3 id="第36节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第36节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/401467">第36节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：我们这节课从宏观的角度分析了网络数据的运转，但是在内核中网络数据包怎么运转的呢？请你简单描述这个过程。</p><p>A：内核网络数据包处理流程如下：</p><ol><li>网卡驱动初始化</li><li>中断注册</li><li>重要结构体初始化</li><li>网络收发包</li></ol><h3 id="第37节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第37节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/402840">第37节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：我们已经了解到了操作系统内核和网络协议栈的关系，可是网络协议栈真的一定只能放在内核态实现么？</p><p>A：我们发现传统的收发方式有一些弊端，比如：内核态用户态切换会引入Cache Miss、流水线失效、硬中断、锁、额外的拷贝等等额外开销。这些开销在C10K的并发规模可能无法体现出来，可是一旦到了C10M的规模，这些开销就不容小视了，于是DPDK这种用户态网络栈就应运而生了。</p><h3 id="第38节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第38节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/404013">第38节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请思考一下，我们目前的互联网架构属于中心化架构还是去中心化架构呢？你觉得未来的发展趋势又是如何？</p><p>A：早期的传统互联网架构下，我们如果要配置交换机，一般都是直接用配置线连接交换机，然后命令行配置的，但出现什么问题可能就要跑到机房了。而且那个年代，中小型运营商也比较多，且分布式技术不够成熟。所以，诞生了如OSPF、BGP、ISIS之类的分布式、自组织的动态路由协议。</p><p>而随着分布式技术成熟，以及电信、互联网巨头逐渐聚集，我们现在逐渐演进到了以Google B4为代表的中心化架构的SDN上了，这也就是为什么万维网之父Tim Berners-Lee爵士会表示对今天的中心化Web 非常不满，却还是搞出了开源的去中心化平台 Solid项目的原因。</p><p>至于未来，个人认为随着以大数据、区块链为代表的去中心化架构逐渐成熟，也许互联网的基础架构会回归去中心化。当然为了实现这个目标，就需要我们大家一起努力了。</p><h3 id="第39节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第39节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/404724">第39节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：套接字也是一种进程间通信机制，它和其他通信机制有什么不同？</p><p>A：它可用于不同机器间的进程通信。</p><h3 id="第40节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第40节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/405781">第40节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：我们了解的 TCP 三次握手，发生在 socket 的哪几个函数中呢？</p><p>A：第一次握手：客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；</p><p>第二次握手：服务器监听到连接请求，即收到SYN J包，就会调用accept函数接收请求，向客户端发送SYN K ，接着ACK J+1，这时accept进入阻塞状态；</p><p>第三次握手：客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回。至此三次握手完毕，连接建立。</p><h3 id="第41节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第41节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/406633">第41节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问 int 指令后面的常数能不能大于255，为什么？</p><p>A：int 指令后面的常数不能大于255，因为int指令会经过中断门，后面的常数就是中断门的索引，而我们中断门最多256（0～255）个，所以不能大于255。</p><h3 id="第42节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第42节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/407343">第42节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请说说syscall指令和int指令的区别是什么？</p><p>A：syscall指令不需要经过中断门，执行syscall指令后的进入内核的入口地址，是内核在初始化时写入到特殊寄存器。这个寄存器应用程序不能访问，处理器在硬件层还对syscall指令执行逻辑做了一定的优化，而int要经过中断门进入到内核，做权限检查又还要读取内存，这会导致性能下降。</p><h3 id="第43节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第43节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/408124">第43节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：有了KVM作为虚拟化的基石之后，如果让你从零开始，设计一款像各大云厂商IAAS平台一样的虚拟化平台，还需要考虑哪些问题呢？</p><p>A：如果只是在一台物理机上开启多个虚拟机，KVM确实已经做的很棒了，但是如果我们扩展到多个机架、多个机房，问题就变得更加复杂了。</p><p>我们除了要考虑之前讲过的网络问题，还需要考虑分布式环境下的计算、存储、消息传输、状态同步、动态迁移、扩缩容、镜像、身份认证、编排与调度、UI管理面板等很多问题。</p><p>当然，业界也有一些开源解决方案，比如大名鼎鼎的OpenStack，不过笔者觉得OpenStack由于设计实现得比较早，所以存在集群规模有限，部署、维护、二次开发复杂度高，历史包袱重等问题。和多位架构师沟通交流之后，我们正在尝试重新设计并实现一套更现代化的、轻量级的、IAAS云平台，感兴趣的同学可以加入课程群多多交流。课程交流群点<a target="_blank" rel="noopener noreferrer" href="https://jinshuju.net/f/I4XbfK">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，按加群提示操作后加入。</p><h3 id="第44节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第44节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/408927">第44节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：在我们启动容器后，一旦容器退出，容器可写层的所有内容都会被删除。那么，如果用户需要持久化容器里的部分数据该怎么办呢？</p><p>A：可以通过实现volume（数据卷），在容器文件系统里创建挂载点，把宿主机文件目录挂载到容器挂载点，启动过程中读取数据卷。</p><h3 id="第45节课"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第45节课"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/409790">第45节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：除了 ARM 指令集，如果想开发一款 CPU，我们还有更好的 RISC 指令集可选么？</p><p>A：RISC-V是2010年加州大学柏克莱分校创建的开源指令集架构。由于这个指令集是完全开放，允许任何人用于任何目的而设计，还不需要付高昂的专利费，所以开源之后IBM、高通、恩智浦、甲骨文、华为、阿里等知名公司也纷纷加入基金会，并且投入大量资源来进行研发与优化。由此可见，RISC-V是一个非常有潜力的项目，我们也会在后续课程结束后，发起Cosmos配套的开源芯片研发项目，感兴趣的同学可以加入课程群一起多多交流。</p><h3 id="第45节课-1"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/16.结束语/03#第45节课-1"><span class="icon icon-link"></span></a><a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/410396">第45节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3><p>Q：请问，ARMv8有多少特权级？每个特权级有什么作用？</p><p>A：ARMv8，有4个特权级，E0～E3, E0运行APP，E1运行OS， E2运行虚拟机监控软件，E3运行安全监视软件。</p><p>到这里，思考题答案公布完毕，同学们学习加油呀！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/16.结束语/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:10:29</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
