<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>33 | 仓库划分：文件系统的格式化操作 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/10.银行仓库文件系统/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="文件系统设备" data-depth="2"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#文件系统设备"><span>文件系统设备</span></a></li><li title="文件系统系统格式化" data-depth="2"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#文件系统系统格式化"><span>文件系统系统格式化</span></a></li><li title="建立超级块" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立超级块"><span>建立超级块</span></a></li><li title="建立位图" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立位图"><span>建立位图</span></a></li><li title="建立根目录" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立根目录"><span>建立根目录</span></a></li><li title="串联" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#串联"><span>串联</span></a></li><li title="测试文件系统" data-depth="2"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统"><span>测试文件系统</span></a></li><li title="测试文件系统超级块" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统超级块"><span>测试文件系统超级块</span></a></li><li title="测试文件系统位图" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统位图"><span>测试文件系统位图</span></a></li><li title="测试文件系统根目录" data-depth="3"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统根目录"><span>测试文件系统根目录</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="33--仓库划分文件系统的格式化操作"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#33--仓库划分文件系统的格式化操作"><span class="icon icon-link"></span></a>33 | 仓库划分：文件系统的格式化操作</h1><p>你好，我是LMOS。</p><p>上一节课中，我们已经设计好了文件系统数据结构，相当于建好了仓库的基本结构。</p><p>今天，我将和你一起探索仓库的划分，即什么地方存放仓库的管理信息，什么地方存放进程的“劳动成果”（也就是文件），对应于文件系统就是文件系统的格式化操作。</p><p>具体我是这样安排的，我们先来实现文件系统设备驱动，接着建立文件系统超级块，然后建立根目录，最后建立文件系统的位图。下面，我们先从建立文件系统设备开始。</p><p>这节课的配套代码，你可以从<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson33/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>获取。</p><h2 id="文件系统设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#文件系统设备"><span class="icon icon-link"></span></a>文件系统设备</h2><p>根据我们前面的设计，文件系统并不是Cosmos的一部分，它只是Cosmos下的一个设备。</p><p>既然是设备，那就要编写相应的设备驱动程序。我们首先得编写文件系统设备的驱动程序。由于前面已经写过驱动程序了，你应该对驱动程序框架已经很熟悉了。</p><p>我们先在cosmos/drivers/目录下建立一个drvrfs.c文件，在里面写下文件系统驱动程序框架代码，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">drvstus_t rfs_entry(driver_t* drvp,uint_t val,void* p){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_exit(driver_t* drvp,uint_t val,void* p){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_open(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_close(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_read(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_write(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_lseek(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_ioctrl(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_dev_start(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_dev_stop(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_set_powerstus(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_enum_dev(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_flush(device_t* devp,void* iopack){……}</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_shutdown(device_t* devp,void* iopack){……}</span></div></pre></div><p>这个框架代码我们已经写好了，是不是感觉特别熟悉？这就是我们开发驱动程序的规范操作。下面，我们来建立文件系统设备。</p><p>按照之前的设计（如果不熟悉可以回顾<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/397594">第32课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），我们将使用4MB内存空间来模拟真实的储存设备，在建立文件系统设备的时候分配一块4MB大小的内存空间，这个内存空间我们用一个数据结构来描述，这个数据结构的分配内存空间的代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_RFSDEVEXT</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t rde_lock;//自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t rde_list;//链表</span></div><div class="token-line"><span class="token plain">        uint_t rde_flg;//标志    </span></div><div class="token-line"><span class="token plain">        uint_t rde_stus;//状态</span></div><div class="token-line"><span class="token plain">        void* rde_mstart;//用于模拟储存介质的内存块的开始地址</span></div><div class="token-line"><span class="token plain">        size_t rde_msize;//内存块的大小</span></div><div class="token-line"><span class="token plain">        void* rde_ext;//扩展所用</span></div><div class="token-line"><span class="token plain">    }rfsdevext_t;</span></div><div class="token-line"><span class="token plain">    drvstus_t new_rfsdevext_mmblk(device_t* devp,size_t blksz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //分配模拟储存介质的内存空间，大小为4MB</span></div><div class="token-line"><span class="token plain">        adr_t blkp= krlnew(blksz);</span></div><div class="token-line"><span class="token plain">        //分配rfsdevext_t结构实例的内存空间</span></div><div class="token-line"><span class="token plain">        rfsdevext_t* rfsexp=(rfsdevext_t*)krlnew(sizeof(rfsdevext_t));</span></div><div class="token-line"><span class="token plain">        //初始化rfsdevext_t结构</span></div><div class="token-line"><span class="token plain">        rfsdevext_t_init(rfsexp);</span></div><div class="token-line"><span class="token plain">        rfsexp-&gt;rde_mstart=(void*)blkp;</span></div><div class="token-line"><span class="token plain">        rfsexp-&gt;rde_msize=blksz;</span></div><div class="token-line"><span class="token plain">        //把rfsdevext_t结构的地址放入device_t 结构的dev_extdata字段中，这里dev_extdata字段就起作用了</span></div><div class="token-line"><span class="token plain">        devp-&gt;dev_extdata=(void*)rfsexp;.</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，new_rfsdevext_mmblk函数分配了一个内存空间和一个rfsdevext_t结构实例变量，rfsdevext_t结构中保存了内存空间的地址和大小。而rfsdevext_t结构的地址放在了device_t结构的dev_extdata字段中。</p><p>剩下的就是建立文件系统设备了，我们在文件系统驱动程序的rfs_entry函数中，通过后面这段代码完成这个功能。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void rfs_set_device(device_t* devp,driver_t* drvp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //设备类型为文件系统类型</span></div><div class="token-line"><span class="token plain">        devp-&gt;dev_id.dev_mtype = FILESYS_DEVICE; </span></div><div class="token-line"><span class="token plain">        devp-&gt;dev_id.dev_stype = 0;</span></div><div class="token-line"><span class="token plain">        devp-&gt;dev_id.dev_nr = 0;</span></div><div class="token-line"><span class="token plain">        //设备名称为rfs</span></div><div class="token-line"><span class="token plain">        devp-&gt;dev_name = &quot;rfs&quot;;</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_entry(driver_t* drvp,uint_t val,void* p)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //分配device_t结构并对其进行初级初始化</span></div><div class="token-line"><span class="token plain">        device_t* devp = new_device_dsc();</span></div><div class="token-line"><span class="token plain">        rfs_set_driver(drvp);</span></div><div class="token-line"><span class="token plain">        rfs_set_device(devp,drvp);</span></div><div class="token-line"><span class="token plain">        //分配模拟储存设备的内存空间</span></div><div class="token-line"><span class="token plain">        if(new_rfsdevext_mmblk(devp,FSMM_BLK) == DFCERRSTUS){……}</span></div><div class="token-line"><span class="token plain">        //把设备加入到驱动程序之中</span></div><div class="token-line"><span class="token plain">        if(krldev_add_driver(devp,drvp) == DFCERRSTUS){……}</span></div><div class="token-line"><span class="token plain">        //向内核注册设备</span></div><div class="token-line"><span class="token plain">        if(krlnew_device(devp)==DFCERRSTUS){……}</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>其实这和我们之前的写systick驱动程序的套路差不多，只不过这里需要分配一个模拟储存设备的空间，并把它放在device_t结构相关的字段中。<strong>还有很重要的一点是，这个设备类型我们要在rfs_set_device函数把它设置好，设置成文件系统类型。</strong></p><p>需要注意的是要把rfs_entry函数放在驱动表中，文件系统程序才可以运行，下面我们就把这个rfs_entry函数，放入驱动表中，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//cosmos/kernel/krlglobal.c</span></div><div class="token-line"><span class="token plain">    KRL_DEFGLOB_VARIABLE(drventyexit_t,osdrvetytabl)[]={systick_entry,rfs_entry,NULL};</span></div></pre></div><p>有了上述代码，Cosmos在启动的时候，在init_krldriver函数中就会运行rfs_entry函数。从名字就能看出rfs_entry函数的功能，这是rfs文件系统设备驱动程序的入口函数，它一旦执行，就会建立文件系统设备。</p><h2 id="文件系统系统格式化"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#文件系统系统格式化"><span class="icon icon-link"></span></a>文件系统系统格式化</h2><p>我们经常听说格式化硬盘、格式化U盘，可以把设备上的数据全部清空，事实是格式化操作并不是把设备上所有的空间都清零，而是在这个设备上重建了文件系统用于管理文件的那一整套数据结构。这也解释了为什么格式化后的设备，还能通过一些反删除软件找回一些文件。</p><p>在储存设备上创建文件系统，其实就是执行这个格式化操作，即重建文件系统的数据结构。</p><p>那么接下来，我们就从建立文件系统的超级块开始，然后建立用于管理储存设备空间的位图，最后建立根目录，这样才能最终实现在储存设备上创建文件系统。</p><h3 id="建立超级块"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立超级块"><span class="icon icon-link"></span></a>建立超级块</h3><p>我们首先来建立文件系统的超级块。建立超级块其实非常简单，就是初始化超级块的数据结构，然后把它写入到储存设备中的第一块逻辑储存块。</p><p>下面我们一起写代码来实现，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void *new_buf(size_t bufsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return (void *)krlnew(bufsz);//分配缓冲区</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void del_buf(void *buf, size_t bufsz)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krldelete((adr_t)buf, bufsz)//释放缓冲区</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void rfssublk_t_init(rfssublk_t* initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krlspinlock_init(&amp;initp-&gt;rsb_lock);</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_mgic = 0x142422;//标志就是一个数字而已，无其它意义</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_vec = 1;//文件系统版本为1</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_flg = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_stus = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_sz = sizeof(rfssublk_t);//超级块本身的大小</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_sblksz = 1;//超级块占用多少个逻辑储存块</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_dblksz = FSYS_ALCBLKSZ;//逻辑储存块的大小为4KB</span></div><div class="token-line"><span class="token plain">        //位图块从第1个逻辑储存块开始，超级块占用第0个逻辑储存块</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_bmpbks = 1;</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_bmpbknr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;rsb_fsysallblk = 0;</span></div><div class="token-line"><span class="token plain">        rfsdir_t_init(&amp;initp-&gt;rsb_rootdir);//初始化根目录</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    bool_t create_superblk(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void *buf = new_buf(FSYS_ALCBLKSZ);//分配4KB大小的缓冲区，清零</span></div><div class="token-line"><span class="token plain">        hal_memset(buf, 0, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        //使rfssublk_t结构的指针指向缓冲区并进行初始化</span></div><div class="token-line"><span class="token plain">        rfssublk_t *sbp = (rfssublk_t *)buf;</span></div><div class="token-line"><span class="token plain">        rfssublk_t_init(sbp);</span></div><div class="token-line"><span class="token plain">        //获取储存设备的逻辑储存块数并保存到超级块中</span></div><div class="token-line"><span class="token plain">        sbp-&gt;rsb_fsysallblk = ret_rfsdevmaxblknr(devp);</span></div><div class="token-line"><span class="token plain">        //把缓冲区中超级块的数据写入到储存设备的第0个逻辑储存块中</span></div><div class="token-line"><span class="token plain">        if (write_rfsdevblk(devp, buf, 0) == DFCERRSTUS)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return FALSE;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);//释放缓冲区</span></div><div class="token-line"><span class="token plain">        return TRUE;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码的意思是，我们先在内存缓冲区中建立文件系统的超级块，最后会调用write_rfsdevblk函数，把内存缓冲区的数据写入到储存设备中。</p><p>下面我们来实现这个write_rfsdevblk函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//返回设备扩展数据结构</span></div><div class="token-line"><span class="token plain">    rfsdevext_t* ret_rfsdevext(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        return (rfsdevext_t*)devp-&gt;dev_extdata;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //根据块号返回储存设备的块地址</span></div><div class="token-line"><span class="token plain">    void* ret_rfsdevblk(device_t* devp,uint_t blknr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        rfsdevext_t* rfsexp = ret_rfsdevext(devp);</span></div><div class="token-line"><span class="token plain">        //块号乘于块大小的结果再加上开始地址（用于模拟储存设备的内存空间的开始地址）</span></div><div class="token-line"><span class="token plain">        void* blkp = rfsexp-&gt;rde_mstart + (blknr*FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        //如果该地址没有落在储存入设备的空间中，就返回NULL表示出错</span></div><div class="token-line"><span class="token plain">        if(blkp &gt;= (void*)((size_t)rfsexp-&gt;rde_mstart+rfsexp-&gt;rde_msize))</span></div><div class="token-line"><span class="token plain">            return NULL;</span></div><div class="token-line"><span class="token plain">        //返回块地址</span></div><div class="token-line"><span class="token plain">        return blkp;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //把4KB大小的缓冲区中的内容，写入到储存设备的某个逻辑储存块中</span></div><div class="token-line"><span class="token plain">    drvstus_t write_rfsdevblk(device_t* devp,void* weadr,uint_t blknr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //返回储存设备中第blknr块的逻辑存储块的地址</span></div><div class="token-line"><span class="token plain">        void* p = ret_rfsdevblk(devp,blknr); </span></div><div class="token-line"><span class="token plain">        //复制数据到逻辑储存块中</span></div><div class="token-line"><span class="token plain">        hal_memcpy(weadr,p,FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>前面我们一下子写了三个函数，由于我们用内存模拟储存设备，我们要写一个ret_rfsdevext函数返回设备扩展数据结构，这个函数和ret_rfsdevblk函数将会一起根据块号，计算出内存地址。然后，我们把缓冲区的内容复制到这个地址开始的内存空间就行了。</p><h3 id="建立位图"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立位图"><span class="icon icon-link"></span></a>建立位图</h3><p>接下来，我们要建立文件系统的位图了。</p><p>延续我们文件系统的设计思路，储存设备被分成了许多同等大小的逻辑储存块，位图就是为了能准确地知道储存设备中，哪些逻辑储存块空闲、哪些是被占用的。</p><p>我们使用一个逻辑储存块空间中的所有字节，来管理逻辑储存块的状态。建立位图无非就是把储存设备中的位图块清零，因为开始文件系统刚创建时，所有的逻辑储存块都是空闲的。下面我们来写好代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//把逻辑储存块中的数据，读取到4KB大小的缓冲区中</span></div><div class="token-line"><span class="token plain">    drvstus_t read_rfsdevblk(device_t* devp,void* rdadr,uint_t blknr)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //获取逻辑储存块地址</span></div><div class="token-line"><span class="token plain">        void* p=ret_rfsdevblk(devp,blknr);</span></div><div class="token-line"><span class="token plain">        //把逻辑储存块中的数据复制到缓冲区中</span></div><div class="token-line"><span class="token plain">        hal_memcpy(p,rdadr,FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //获取超级块</span></div><div class="token-line"><span class="token plain">    rfssublk_t* get_superblk(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //分配4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        void* buf=new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        //清零缓冲区</span></div><div class="token-line"><span class="token plain">        hal_memset(buf,FSYS_ALCBLKSZ,0);</span></div><div class="token-line"><span class="token plain">        //读取第0个逻辑储存块中的数据到缓冲区中，如果读取失败则释放缓冲区</span></div><div class="token-line"><span class="token plain">        read_rfsdevblk(devp,buf,0);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //返回超级块数据结构的地址，即缓冲区的首地址</span></div><div class="token-line"><span class="token plain">        return (rfssublk_t*)buf;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //释放超级块</span></div><div class="token-line"><span class="token plain">    void del_superblk(device_t* devp,rfssublk_t* sbp) </span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //回写超级块，因为超级块中的数据可能已经发生了改变，如果出错则死机</span></div><div class="token-line"><span class="token plain">        write_rfsdevblk(devp,(void*)sbp,0);//释放先前分配的4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        del_buf((void*)sbp,FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //建立位图</span></div><div class="token-line"><span class="token plain">    bool_t create_bitmap(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        bool_t rets=FALSE;</span></div><div class="token-line"><span class="token plain">        //获取超级块，失败则返回FALSE</span></div><div class="token-line"><span class="token plain">        rfssublk_t* sbp = get_superblk(devp);</span></div><div class="token-line"><span class="token plain">        //分配4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        void* buf = new_buf(FSYS_ALCBLKSZ); </span></div><div class="token-line"><span class="token plain">          //获取超级块中位图块的开始块号</span></div><div class="token-line"><span class="token plain">        uint_t bitmapblk=sbp-&gt;rsb_bmpbks;</span></div><div class="token-line"><span class="token plain">        //获取超级块中储存介质的逻辑储存块总数</span></div><div class="token-line"><span class="token plain">        uint_t devmaxblk=sbp-&gt;rsb_fsysallblk;</span></div><div class="token-line"><span class="token plain">        //如果逻辑储存块总数大于4096，就认为出错了</span></div><div class="token-line"><span class="token plain">        if(devmaxblk&gt;FSYS_ALCBLKSZ)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            rets=FALSE;</span></div><div class="token-line"><span class="token plain">            goto errlable;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //把缓冲区中每个字节都置成1</span></div><div class="token-line"><span class="token plain">        hal_memset(buf,FSYS_ALCBLKSZ,1);</span></div><div class="token-line"><span class="token plain">        u8_t* bitmap=(u8_t*)buf;</span></div><div class="token-line"><span class="token plain">        //把缓冲区中的第3个字节到第devmaxblk个字节都置成0</span></div><div class="token-line"><span class="token plain">        for(uint_t bi=2;bi&lt;devmaxblk;bi++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            bitmap[bi]=0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //把缓冲区中的数据写入到储存介质中的第bitmapblk个逻辑储存块中，即位图块中</span></div><div class="token-line"><span class="token plain">        if(write_rfsdevblk(devp,buf,bitmapblk)==DFCERRSTUS){</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto errlable;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //设置返回状态</span></div><div class="token-line"><span class="token plain">        rets=TRUE;</span></div><div class="token-line"><span class="token plain">    errlable:</span></div><div class="token-line"><span class="token plain">    //释放超级块</span></div><div class="token-line"><span class="token plain">        del_superblk(devp,sbp);</span></div><div class="token-line"><span class="token plain">    //释放缓冲区</span></div><div class="token-line"><span class="token plain">        del_buf(buf,FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这里为什么又多了几个辅助函数呢？这是因为，位图块的块号和储存介质的逻辑储存块总数，都保存在超级块中，所以要实现获取、释放超级块的函数，还需要一个读取逻辑储存块的函数，写入逻辑储存块的函数前面已经写过了。</p><p>因为第0块是超级块，第1块是位图块本身，所以代码从缓冲区中的第3个字节开始清零，一直到devmaxblk个字节，devmaxblk就是储存介质的逻辑储存块总数。缓冲区中有4096个字节，但devmaxblk肯定是小于4096的，所以devmaxblk后面的字节全部为1，这样就不会影响到后面分配逻辑储存块代码的正确性了。</p><p>最后，我们把这个缓冲区中的数据写入到储存介质中的第bitmapblk个逻辑储存块中，就完成了位图的建立。</p><p>建立好了管理逻辑储存块状态的位图，下面就去接着建立根目录吧！</p><h3 id="建立根目录"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#建立根目录"><span class="icon icon-link"></span></a>建立根目录</h3><p>一切目录和文件都是存放在根目录下的，查询目录和文件也是从这里开始的，所以文件系统创建的最后一步就是创建根目录。</p><p>根目录也是一种文件，所以要为其分配相应的逻辑储存块，因为根目录下的文件和目录对应的rfsdir_t结构，就是保存在这个逻辑储存块中的。</p><p>因为根目录是文件，所以要在这个逻辑储存块的首个512字节空间中建立fimgrhd_t结构，即文件管理头数据结构。最后，我们要把这个逻辑储存块的块号，储存在超级块中的rfsdir_t结构中，同时修改该rfsdir_t结构中的文件名称为“/”。</p><p>要达到上述功能要求，就需要操作文件系统的超级块和位图，所以我们要先写好这些辅助功能函数，实现获取/释放位图块的代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//获取位图块</span></div><div class="token-line"><span class="token plain">    u8_t* get_bitmapblk(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //获取超级块</span></div><div class="token-line"><span class="token plain">        rfssublk_t* sbp = get_superblk(devp);</span></div><div class="token-line"><span class="token plain">        //分配4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        void* buf = new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        //缓冲区清零</span></div><div class="token-line"><span class="token plain">        hal_memset(buf, FSYS_ALCBLKSZ, 0);</span></div><div class="token-line"><span class="token plain">        //读取sbp-&gt;rsb_bmpbks块（位图块），到缓冲区中</span></div><div class="token-line"><span class="token plain">        read_rfsdevblk(devp, buf, sbp-&gt;rsb_bmpbks)</span></div><div class="token-line"><span class="token plain">        //释放超级块</span></div><div class="token-line"><span class="token plain">        del_superblk(devp, sbp);</span></div><div class="token-line"><span class="token plain">        //返回缓冲区的首地址</span></div><div class="token-line"><span class="token plain">        return (u8_t*)buf;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //释放位图块</span></div><div class="token-line"><span class="token plain">    void del_bitmapblk(device_t* devp,u8_t* bitmap)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //获取超级块</span></div><div class="token-line"><span class="token plain">        rfssublk_t* sbp = get_superblk(devp);</span></div><div class="token-line"><span class="token plain">        //回写位图块，因为位图块中的数据可能已经发生改变</span></div><div class="token-line"><span class="token plain">        write_rfsdevblk(devp, (void*)bitmap, sbp-&gt;rsb_bmpbks)</span></div><div class="token-line"><span class="token plain">        //释放超级块和存放位图块的缓冲区</span></div><div class="token-line"><span class="token plain">        del_superblk(devp, sbp);</span></div><div class="token-line"><span class="token plain">        del_buf((void*)bitmap, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>获取/释放位图块非常简单，就是根据超级块中的位图块号，把储存设备中的位图数据块读取到缓冲区中，而释放位图块则需要把缓冲区的数据写入到储存设备对应的逻辑块中。获取/释放超级块的函数，我们建立位图时已经写好了。</p><p>建立根目录需要分配新的逻辑储存块，分配新的逻辑储存块其实就是扫描位图数据，从中找出一个空闲的逻辑储存块，下面我们来写代码实现这个函数，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//分配新的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">    uint_t rfs_new_blk(device_t* devp) </span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t retblk=0;</span></div><div class="token-line"><span class="token plain">        //获取位图块</span></div><div class="token-line"><span class="token plain">        u8_t* bitmap = get_bitmapblk(devp);        </span></div><div class="token-line"><span class="token plain">        if(bitmap == NULL)</span></div><div class="token-line"><span class="token plain">        {    </span></div><div class="token-line"><span class="token plain">            return 0;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        for(uint_t blknr = 2; blknr &lt; FSYS_ALCBLKSZ; blknr++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //找到一个为0的字节就置为1，并返回该字节对应的空闲块号</span></div><div class="token-line"><span class="token plain">            if(bitmap[blknr] == 0)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                bitmap[blknr] = 1;</span></div><div class="token-line"><span class="token plain">                retblk = blknr;</span></div><div class="token-line"><span class="token plain">                goto retl;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //如果到这里就说明没有空闲块了，所以返回0</span></div><div class="token-line"><span class="token plain">        retblk=0;</span></div><div class="token-line"><span class="token plain">    retl:</span></div><div class="token-line"><span class="token plain">        //释放位图块</span></div><div class="token-line"><span class="token plain">        del_bitmapblk(devp,bitmap);</span></div><div class="token-line"><span class="token plain">        return retblk;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>rfs_new_blk函数会返回新分配的逻辑储存块号，如果没有空闲的逻辑储存块了，就会返回0。下面我们就可以建立根目录了，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//建立根目录</span></div><div class="token-line"><span class="token plain">    bool_t create_rootdir(device_t* devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        bool_t rets = FALSE;</span></div><div class="token-line"><span class="token plain">        //获取超级块</span></div><div class="token-line"><span class="token plain">        rfssublk_t* sbp = get_superblk(devp);</span></div><div class="token-line"><span class="token plain">        //分配4KB大小的缓冲区</span></div><div class="token-line"><span class="token plain">        void* buf = new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        //缓冲区清零</span></div><div class="token-line"><span class="token plain">        hal_memset(buf,FSYS_ALCBLKSZ,0);</span></div><div class="token-line"><span class="token plain">        //分配一个空闲的逻辑储存块</span></div><div class="token-line"><span class="token plain">        uint_t blk = rfs_new_blk(devp);</span></div><div class="token-line"><span class="token plain">        if(blk == 0) {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto errlable;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //设置超级块中的rfsdir_t结构中的名称为“/”</span></div><div class="token-line"><span class="token plain">        sbp-&gt;rsb_rootdir.rdr_name[0] = &#x27;/&#x27;;</span></div><div class="token-line"><span class="token plain">        //设置超级块中的rfsdir_t结构中的类型为目录类型</span></div><div class="token-line"><span class="token plain">        sbp-&gt;rsb_rootdir.rdr_type = RDR_DIR_TYPE;</span></div><div class="token-line"><span class="token plain">        //设置超级块中的rfsdir_t结构中的块号为新分配的空闲逻辑储存块的块号</span></div><div class="token-line"><span class="token plain">        sbp-&gt;rsb_rootdir.rdr_blknr = blk;</span></div><div class="token-line"><span class="token plain">        fimgrhd_t* fmp = (fimgrhd_t*)buf;</span></div><div class="token-line"><span class="token plain">        //初始化fimgrhd_t结构</span></div><div class="token-line"><span class="token plain">        fimgrhd_t_init(fmp);</span></div><div class="token-line"><span class="token plain">        //因为这是目录文件所以fimgrhd_t结构的类型设置为目录类型</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_type = FMD_DIR_TYPE;</span></div><div class="token-line"><span class="token plain">        //fimgrhd_t结构自身所在的块设置为新分配的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_sfblk = blk;</span></div><div class="token-line"><span class="token plain">        //fimgrhd_t结构中正在写入的块设置为新分配的空闲逻辑储存块</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_curfwritebk = blk;</span></div><div class="token-line"><span class="token plain">        //fimgrhd_t结构中正在写入的块的偏移设置为512字节</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_curfinwbkoff = 0x200;</span></div><div class="token-line"><span class="token plain">        //设置文件数据占有块数组的第0个元素</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_fleblk[0].fb_blkstart = blk;</span></div><div class="token-line"><span class="token plain">        fmp-&gt;fmd_fleblk[0].fb_blknr = 1;</span></div><div class="token-line"><span class="token plain">        //把缓冲区中的数据写入到新分配的空闲逻辑储存块中，其中包含已经设置好的      fimgrhd_t结构</span></div><div class="token-line"><span class="token plain">        if(write_rfsdevblk(devp, buf, blk) == DFCERRSTUS) {</span></div><div class="token-line"><span class="token plain">            rets = FALSE;</span></div><div class="token-line"><span class="token plain">            goto errlable;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        rets = TRUE;</span></div><div class="token-line"><span class="token plain">    errlable:</span></div><div class="token-line"><span class="token plain">        //释放缓冲区</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">    errlable1:</span></div><div class="token-line"><span class="token plain">        //释放超级块</span></div><div class="token-line"><span class="token plain">        del_superblk(devp, sbp); </span></div><div class="token-line"><span class="token plain">        return rets;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码的注释已经很清楚了，虽然代码有点长，但总体流程还是挺清晰的。首先，分配一块新的逻辑储存块。接着，设置超级块中的rfsdir_t结构中的名称以及类型和块号。然后设置文件管理头，由于根目录是目录文件，所以文件管理头的类型为FMD_DIR_TYPE，表示文件数据存放的是目录结构。最后，回写对应的逻辑储存块即可。</p><h3 id="串联"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#串联"><span class="icon icon-link"></span></a>串联</h3><p>建立超级块、建立位图、建立根目录的代码已经写好了。</p><p>现在我们来写一个rfs_fmat函数，把刚才这三个操作包装起来，调用它们完成文件系统格式化这一流程。顺便，我们还可以把init_rfs函数也实现了，让它调用rfs_fmat函数，随后init_rfs函数本身会在rfs_entry函数的最后被调用，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//rfs初始化</span></div><div class="token-line"><span class="token plain">    void init_rfs(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //格式化rfs</span></div><div class="token-line"><span class="token plain">        rfs_fmat(devp);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //rfs格式化</span></div><div class="token-line"><span class="token plain">    void rfs_fmat(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //建立超级块</span></div><div class="token-line"><span class="token plain">        if (create_superblk(devp) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;create superblk err&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //建立位图</span></div><div class="token-line"><span class="token plain">        if (create_bitmap(devp) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;create bitmap err&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //建立根目录</span></div><div class="token-line"><span class="token plain">        if (create_rootdir(devp) == FALSE)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;create rootdir err&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //rfs驱动程序入口</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_entry(driver_t *drvp, uint_t val, void *p)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //……</span></div><div class="token-line"><span class="token plain">        init_rfs(devp);//初始化rfs</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码中，init_rfs函数会在rfs驱动程序入口函数的最后被调用，到这里我们rfs文件系统的格式化操作就完成了，这是实现文件系统的重要一步。</p><h2 id="测试文件系统"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统"><span class="icon icon-link"></span></a>测试文件系统</h2><p>尽管我们的文件系统还有很多其它操作，如打开、关闭，读写文件，这些文件相关的操作我们放在下一节课中来实现。这里我们先对文件系统格式化的功能进行测试，确认一下我们的格式化代码没有问题，再进行下一步的开发。</p><h3 id="测试文件系统超级块"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统超级块"><span class="icon icon-link"></span></a>测试文件系统超级块</h3><p>之前我们文件系统格式化操作的第一步，就是建立文件系统的超级块。</p><p>所以我们首先来测试一下建立文件系统超级块的代码，测试方法非常简单，我们只要把超级块读取到一个缓冲区中，然后把其中一些重要的数据，打印出来看一看就知道了，我们写个函数完成这个功能，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//测试文件系统超级块</span></div><div class="token-line"><span class="token plain">    void test_rfs_superblk(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kprint(&quot;开始文件系统超级块测试\n&quot;);</span></div><div class="token-line"><span class="token plain">        rfssublk_t *sbp = get_superblk(devp);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统标识:%d,版本:%d\n&quot;, sbp-&gt;rsb_mgic, sbp-&gt;rsb_vec);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统超级块占用的块数:%d,逻辑储存块大小:%d\n&quot;, sbp-&gt;rsb_sblksz, sbp-&gt;rsb_dblksz);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统位图块号:%d,文件系统整个逻辑储存块数:%d\n&quot;, sbp-&gt;rsb_bmpbks, sbp-&gt;rsb_fsysallblk);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统根目录块号:%d 类型:%d\n&quot;, sbp-&gt;rsb_rootdir.rdr_blknr, sbp-&gt;rsb_rootdir.rdr_type);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统根目录名称:%s\n&quot;, sbp-&gt;rsb_rootdir.rdr_name);</span></div><div class="token-line"><span class="token plain">        del_superblk(devp, sbp);</span></div><div class="token-line"><span class="token plain">        hal_sysdie(&quot;结束文件系统超级块测试&quot;);//死机用于观察测试结果</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //rfs驱动程序入口</span></div><div class="token-line"><span class="token plain">    drvstus_t rfs_entry(driver_t *drvp, uint_t val, void *p)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_rfs(devp);//初始化rfs</span></div><div class="token-line"><span class="token plain">        test_rfs_superblk(devp);//测试文件系统超级块</span></div><div class="token-line"><span class="token plain">        return DFCOKSTUS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>测试代码我们已经写好了，下面我们打开终端，切换到Cosmos目录下执行make vboxtest，Cosmos加载rfs驱动程序运行后的结果，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea3a4a3cb6f6d31d2f5faaf77d2fbb3010fa4.jpg" alt="" title="文件系统超级块测试."/></p><p>上图中我们可以看到，文件系统的标识、版本和最初定义的是相同的，逻辑储存块的大小为4KB。位图占用的是第1个逻辑储存块，因为第0个逻辑储存块被超级块占用了。</p><p>同时，我们还可以看到储存设备上共有1024个逻辑储存块，根目录文件的逻辑储存块为第2块，名称为“/”，这些正确的数据证明了建立超级块的代码是没有问题的。</p><h3 id="测试文件系统位图"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统位图"><span class="icon icon-link"></span></a>测试文件系统位图</h3><p>测试完了文件系统超级块，我们接着来测试文件系统位图。测试方法很简单，先读取位图块到一个缓冲区中，然后循环扫描这个缓冲区，看看里面有多少个为0的字节，即表明储存介质上有多少个空闲的逻辑储存块。</p><p>我们一起来写好这个测试函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void test_rfs_bitmap(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kprint(&quot;开始文件系统位图测试\n&quot;);</span></div><div class="token-line"><span class="token plain">        void *buf = new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        hal_memset(buf, 0, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        read_rfsdevblk(devp, buf, 1)//读取位图块</span></div><div class="token-line"><span class="token plain">        u8_t *bmp = (u8_t *)buf;</span></div><div class="token-line"><span class="token plain">        uint_t b = 0;</span></div><div class="token-line"><span class="token plain">        //扫描位图块</span></div><div class="token-line"><span class="token plain">        for (uint_t i = 0; i &lt; FSYS_ALCBLKSZ; i++)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            if (bmp[i] == 0)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                b++;//记录空闲块</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件系统空闲块数:%d\n&quot;, b);</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        hal_sysdie(&quot;结束文件系统位图测试\n&quot;);//死机用于观察测试结果</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>test_rfs_bitmap函数我们已经写好了，别忘了<strong>在rfs_entry函数的末尾调用它</strong>，随后我们在终端下执行make vboxtest，就可以看到Cosmos加载rfs驱动程序运行后的结果，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage71f6718af93fc57342571df213c5c3989bf6.jpg" alt="" title="文件系统位图测试"/></p><p>上图中的空闲块数为1021，表示储存介质上已经分配了3块逻辑储存块了。这就证明了我们建立文件系统位图的代码是没有问题的。</p><h3 id="测试文件系统根目录"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#测试文件系统根目录"><span class="icon icon-link"></span></a>测试文件系统根目录</h3><p>最后我们来测试文件系统的根目录文件建立的对不对，测试方法就是先得到根目录文件的rfsdir_t结构，然后读取其中指向的逻辑储存块到缓冲区中，最后把它们的数据打印出来。</p><p>这个函数很简单，我们来写好它，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void test_rfs_rootdir(device_t *devp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        kprint(&quot;开始文件系统根目录测试\n&quot;);</span></div><div class="token-line"><span class="token plain">        rfsdir_t *dr = get_rootdir(devp);</span></div><div class="token-line"><span class="token plain">        void *buf = new_buf(FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        hal_memset(buf, 0, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        read_rfsdevblk(devp, buf, dr-&gt;rdr_blknr)</span></div><div class="token-line"><span class="token plain">        fimgrhd_t *fmp = (fimgrhd_t *)buf;</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件管理头类型:%d 文件数据大小:%d 文件在开始块中偏移:%d 文件在结束块中的偏移:%d\n&quot;,</span></div><div class="token-line"><span class="token plain">                fmp-&gt;fmd_type, fmp-&gt;fmd_filesz, fmp-&gt;fmd_fileifstbkoff, fmp-&gt;fmd_fileiendbkoff);</span></div><div class="token-line"><span class="token plain">        kprint(&quot;文件第一组开始块号:%d 块数:%d\n&quot;, fmp-&gt;fmd_fleblk[0].fb_blkstart, fmp-&gt;fmd_fleblk[0].fb_blknr);</span></div><div class="token-line"><span class="token plain">        del_buf(buf, FSYS_ALCBLKSZ);</span></div><div class="token-line"><span class="token plain">        del_rootdir(devp, dr);</span></div><div class="token-line"><span class="token plain">        hal_sysdie(&quot;结束文件系统根目录测试\n&quot;);//死机用于观察测试结果</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>test_rfs_rootdir函数同样要在rfs_entry函数的末尾调用，然后我们在终端下执行make vboxtest，就可以看到cosmos加载rfs驱动程序运行后的结果了。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagef91af98f2035948514bdf5ffcc3a50b9061a.jpg" alt="" title="文件系统根目录测试"/></p><p>从上图我们可以看到，根目录文件的类型为目录文件类型。因为根目录文件才刚建立，所以文件大小为0，文件数据的存放位置从文件占用的第1块逻辑储存块的512字节处开始。因为第0、1块逻辑储存块被超级块和位图块占用了，所以根目录文件占用的逻辑储存块，就是第2块逻辑储存块，只占用了1块。</p><p>好了，上面一系列的测试结果，表明我们的文件系统格式化的代码正确无误，文件系统格式化操作的内容我们就告一段落了</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>今天的课程就到这里了，今天我们继续推进了文件系统的进度，实现了文件系统的格式化操作，我来为你把今天的课程重点梳理一下。</p><p>首先实现了文件系统设备驱动程序框架，这是因为我们之前的架构设计，把文件系统作为Cosmos系统下的一个设备，这有利于<strong>扩展不同的文件系统。</strong></p><p>然后我们实现了文件系统格式化操作，包括建立文件系统超级块、位图、根目录操作，并且将它们串联在一起完成文件系统格式化。</p><p>最后是对文件系统测试，我们通过打印出文件系统超级块、位图还有根目录的相关数据来验证，最终确认了我们文件系统格式化操作的代码是正确的。</p><p>虽然我们实现了文件系统的格式化，也对其进行了测试，但是我们的文件系统还是不能存放文件，因为我们还没有实现操作文件相关的功能，下一节课我们继续探索。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/10.银行仓库文件系统/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请问，建立文件系统的超级块、位图、根目录的三大函数的调用顺序可以随意调换吗，原因是什么？</p><p>欢迎你在留言区记录你的疑问或者收获，积极输出有利于你深入理解这节课的内容。同时，也欢迎你把这节课转给身边的同事、朋友。</p><p>好，我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/10.银行仓库文件系统/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:34:47</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
