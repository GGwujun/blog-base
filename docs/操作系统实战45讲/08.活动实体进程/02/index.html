<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>25 | 多个活动要安排（上）：多进程如何调度？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/08.活动实体进程/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="为什么需要多进程调度" data-depth="2"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#为什么需要多进程调度"><span>为什么需要多进程调度</span></a></li><li title="管理进程" data-depth="2"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#管理进程"><span>管理进程</span></a></li><li title="进程的生命周期" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程的生命周期"><span>进程的生命周期</span></a></li><li title="如何组织进程" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#如何组织进程"><span>如何组织进程</span></a></li><li title="管理进程的初始化" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#管理进程的初始化"><span>管理进程的初始化</span></a></li><li title="设计实现进程调度器" data-depth="2"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#设计实现进程调度器"><span>设计实现进程调度器</span></a></li><li title="进程调度器入口" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程调度器入口"><span>进程调度器入口</span></a></li><li title="如何获取当前运行的进程" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#如何获取当前运行的进程"><span>如何获取当前运行的进程</span></a></li><li title="选择下一个进程" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#选择下一个进程"><span>选择下一个进程</span></a></li><li title="获取空转进程" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#获取空转进程"><span>获取空转进程</span></a></li><li title="进程切换" data-depth="3"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程切换"><span>进程切换</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战45讲/08.活动实体进程/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="25--多个活动要安排上多进程如何调度"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#25--多个活动要安排上多进程如何调度"><span class="icon icon-link"></span></a>25 | 多个活动要安排（上）：多进程如何调度？</h1><p>你好，我是LMOS。</p><p>上节课，我们了解了什么是进程，还一起写好了建立进程的代码。不知道你想过没有，如果在系统中只有一个进程，那我们提出进程相关的概念和实现与进程有关的功能，是不是就失去了意义呢？</p><p>显然，提出进程的目的之一，就是为了实现多个进程，使系统能运行多个应用程序。今天我们就在单进程的基础上扩展多进程，并在进程与进程之间进行调度。</p><p>“你存在，我深深的脑海里，我的梦里，我的心里，我的代码里”，我经常一边哼着歌，一边写着代码，这就是我们大脑中最典型“多进程”场景。</p><p>再来举一个例子：你在Windows上，边听音乐，边浏览网页，还能回复微信消息。Windows之所以能同时运行多个应用程序，就是因为Windows内核支持多进程机制，这就是最典型的多进程场景了。</p><p>这节课配套代码，你可以点击<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson25~26/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载。</p><h2 id="为什么需要多进程调度"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#为什么需要多进程调度"><span class="icon icon-link"></span></a>为什么需要多进程调度</h2><p>我们先来搞清楚多进程调度的原因是什么，我来归纳一下。</p><p>第一，CPU同一时刻只能运行一个进程，而CPU个数总是比进程个数少，这就需要让多进程共用一个CPU，每个进程在这个CPU上运行一段时间。</p><p>第二点原因，当一个进程不能获取某种资源，导致它不能继续运行时，就应该让出CPU。当然你也可以把第一点中的CPU时间，也归纳为一种资源，这样就合并为一点：**进程拿不到资源就要让出CPU。**我来为你画幅图就明白了，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage8b528b94e8daaf985262d6a83d38dbb07152.jpg" alt="" title="多进程调度示意图"/></p><p>上图中，有五个进程，其中浏览器进程和微信进程依赖于网络和键盘的数据资源，如果不能满足它们，就应该通过进程调度让出CPU。</p><p>而两个科学计算进程，则更多的依赖于CPU，但是如果它们中的一个用完了自己的CPU时间，也得借助进程调度让出CPU，不然它就会长期霸占CPU，导致其它进程无法运行。需要注意的是，每个进程都会依赖一种资源，那就是CPU时间，你可以把CPU时间理解为它就是CPU，一个进程必须要有CPU才能运行。</p><p>这里我们只需要明白，多个进程为什么要进行调度，就可以了。</p><h2 id="管理进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#管理进程"><span class="icon icon-link"></span></a>管理进程</h2><p>下面我们一起来看看怎么管理进程，我们的Cosmos操作系统也支持多个进程，有了多个进程就要把它们管理起来。说白了，就是弄清楚这些进程有哪些状态，是如何组织起来的，又要从哪找到它们。</p><h3 id="进程的生命周期"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程的生命周期"><span class="icon icon-link"></span></a>进程的生命周期</h3><p>人有生老病死，对于一个进程来说也是一样。一个进程从建立开始，接着运行，然后因为资源问题不得不暂停运行，最后退出系统。这一过程，我们称为进程的生命周期。在系统实现中，通常用进程的状态表示进程的生命周期。进程的状态我们用几个宏来定义，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define TDSTUS_RUN 0        //进程运行状态</span></div><div class="token-line"><span class="token plain">    #define TDSTUS_SLEEP 3      //进程睡眠状态</span></div><div class="token-line"><span class="token plain">    #define TDSTUS_WAIT 4       //进程等待状态</span></div><div class="token-line"><span class="token plain">    #define TDSTUS_NEW 5        //进程新建状态</span></div><div class="token-line"><span class="token plain">    #define TDSTUS_ZOMB 6       //进程僵死状态</span></div></pre></div><p>可以发现，我们的进程有5个状态。其中进程僵死状态，表示进程将要退出系统不再进行调度。那么进程状态之间是如何转换的，别急，我来给画一幅图解释，如下所示。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagea37aa3ec5e2e1c0dc6acdb50095b20e2977a.jpg" alt="" title="进程状态切换示意图"/></p><p>上图中已经为你展示了，从建立进程到进程退出系统各状态之间的转换关系和需要满足的条件。</p><h3 id="如何组织进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#如何组织进程"><span class="icon icon-link"></span></a>如何组织进程</h3><p>首先我们来研究如何组织进程。由于系统中会有许多个进程，在上节课中我们用thread_t结构表示一个进程，因此会有多个thread_t结构。而根据刚才我们对进程生命周期的解读，我们又知道了进程是随时可能建立或者退出的，所以系统中会随时分配或者删除thread_t结构。</p><p>要应对这样的情况，最简单的办法就是<strong>使用链表数据结构</strong>，而且我们的进程有优先级，所以我们可以设计成<strong>每个优先级对应一个链表头</strong>。</p><p>下面我们来把设计落地成数据结构，由于这是调度器模块，所以我们要建立几个文件krlsched.h、krlsched.c，在其中写上代码，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_THRDLST</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t    tdl_lsth;                //挂载进程的链表头</span></div><div class="token-line"><span class="token plain">        thread_t*   tdl_curruntd;            //该链表上正在运行的进程</span></div><div class="token-line"><span class="token plain">        uint_t      tdl_nr;                  //该链表上进程个数</span></div><div class="token-line"><span class="token plain">    }thrdlst_t;</span></div><div class="token-line"><span class="token plain">    typedef struct s_SCHDATA</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t  sda_lock;                //自旋锁</span></div><div class="token-line"><span class="token plain">        uint_t      sda_cpuid;               //当前CPU id</span></div><div class="token-line"><span class="token plain">        uint_t      sda_schdflgs;            //标志</span></div><div class="token-line"><span class="token plain">        uint_t      sda_premptidx;           //进程抢占计数</span></div><div class="token-line"><span class="token plain">        uint_t      sda_threadnr;            //进程数</span></div><div class="token-line"><span class="token plain">        uint_t      sda_prityidx;            //当前优先级</span></div><div class="token-line"><span class="token plain">        thread_t*   sda_cpuidle;             //当前CPU的空转进程</span></div><div class="token-line"><span class="token plain">        thread_t*   sda_currtd;              //当前正在运行的进程</span></div><div class="token-line"><span class="token plain">        thrdlst_t   sda_thdlst[PRITY_MAX];   //进程链表数组</span></div><div class="token-line"><span class="token plain">    }schdata_t;</span></div><div class="token-line"><span class="token plain">    typedef struct s_SCHEDCALSS</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t  scls_lock;                //自旋锁</span></div><div class="token-line"><span class="token plain">        uint_t      scls_cpunr;               //CPU个数</span></div><div class="token-line"><span class="token plain">        uint_t      scls_threadnr;            //系统中所有的进程数</span></div><div class="token-line"><span class="token plain">        uint_t      scls_threadid_inc;        //分配进程id所用</span></div><div class="token-line"><span class="token plain">        schdata_t   scls_schda[CPUCORE_MAX];  //每个CPU调度数据结构</span></div><div class="token-line"><span class="token plain">    }schedclass_t;</span></div></pre></div><p>从上述代码中，我们发现schedclass_t是个全局数据结构，这个结构里包含一个schdata_t结构数组，数组大小根据CPU的数量决定。在每个schdata_t结构中，又包含一个进程优先级大小的thrdlst_t结构数组。我画幅图，你就明白了。这幅图能让你彻底理清以上数据结构之间的关系。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage51495181c38bfcb42c688076daaeb3452d49.jpg" alt="" title="组织进程示意图"/></p><p>好，下面我们就去定义这个schedclass_t数据结构并初始化。</p><h3 id="管理进程的初始化"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#管理进程的初始化"><span class="icon icon-link"></span></a>管理进程的初始化</h3><p>管理进程的初始化非常简单，就是对schedclass_t结构的变量的初始化。</p><p>通过前面的学习，你也许已经发现了，schedclass_t结构的变量应该是个全局变量，所以先得在cosmos/kernel/krlglobal.c文件中定义一个schedclass_t结构的全局变量，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">KRL_DEFGLOB_VARIABLE(schedclass_t,osschedcls);</span></div></pre></div><p>有了schedclass_t结构的全局变量osschedcls，接着我们在cosmos/kernel/krlsched.c文件中写好初始化osschedcls变量的代码，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void thrdlst_t_init(thrdlst_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;tdl_lsth); //初始化挂载进程的链表</span></div><div class="token-line"><span class="token plain">        initp-&gt;tdl_curruntd = NULL; //开始没有运行进程 </span></div><div class="token-line"><span class="token plain">        initp-&gt;tdl_nr = 0;  //开始没有进程</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void schdata_t_init(schdata_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krlspinlock_init(&amp;initp-&gt;sda_lock);</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_cpuid = hal_retn_cpuid(); //获取CPU id</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_schdflgs = NOTS_SCHED_FLGS;</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_premptidx = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_threadnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_prityidx = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_cpuidle = NULL; //开始没有空转进程和运行的进程</span></div><div class="token-line"><span class="token plain">        initp-&gt;sda_currtd = NULL;</span></div><div class="token-line"><span class="token plain">        for (uint_t ti = 0; ti &lt; PRITY_MAX; ti++)</span></div><div class="token-line"><span class="token plain">        {//初始化schdata_t结构中的每个thrdlst_t结构</span></div><div class="token-line"><span class="token plain">            thrdlst_t_init(&amp;initp-&gt;sda_thdlst[ti]);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void schedclass_t_init(schedclass_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        krlspinlock_init(&amp;initp-&gt;scls_lock);</span></div><div class="token-line"><span class="token plain">        initp-&gt;scls_cpunr = CPUCORE_MAX;  //CPU最大个数</span></div><div class="token-line"><span class="token plain">        initp-&gt;scls_threadnr = 0;   //开始没有进程</span></div><div class="token-line"><span class="token plain">        initp-&gt;scls_threadid_inc = 0;</span></div><div class="token-line"><span class="token plain">        for (uint_t si = 0; si &lt; CPUCORE_MAX; si++)</span></div><div class="token-line"><span class="token plain">        {//初始化osschedcls变量中的每个schdata_t</span></div><div class="token-line"><span class="token plain">            schdata_t_init(&amp;initp-&gt;scls_schda[si]);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void init_krlsched()</span></div><div class="token-line"><span class="token plain">    {   //初始化osschedcls变量</span></div><div class="token-line"><span class="token plain">        schedclass_t_init(&amp;osschedcls);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码非常简单，由init_krlsched函数调用schedclass_t_init函数，对osschedcls变量进行初始化工作，但是init_krlsched函数由谁调用呢？</p><p>还记得之前学的内核功能层的入口函数吗（可回看<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/381810">第13节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）？它就是cosmos/kernel/krlinit.c文件中的<strong>init_krl函数</strong>，我们在这个函数中来调用init_krlsched函数，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void init_krl()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_krlsched();</span></div><div class="token-line"><span class="token plain">        die(0);//控制不让init_krl函数返回</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>至此，管理进程的初始化就完成了，其实这也是我们进程调度器的初始化，就是这么简单吗？当然不是，还有重要的进程调度等我们搞定。</p><h2 id="设计实现进程调度器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#设计实现进程调度器"><span class="icon icon-link"></span></a>设计实现进程调度器</h2><p>管理进程的数据结构已经初始化好了，现在我们开始设计实现进程调度器。</p><p>进程调度器是为了在合适的时间点，合适的代码执行路径上进行进程调度。说白了，就是从当前运行进程切换到另一个进程上运行，让当前进程停止运行，由CPU开始执行另一个进程的代码。这个事情说来简单，但做起来并不容易，下面我将带领你一步步实现进程调度器。</p><h3 id="进程调度器入口"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程调度器入口"><span class="icon icon-link"></span></a>进程调度器入口</h3><p>首先请你想象一下，进程调度器是什么样子的。其实，进程调度器不过是个函数，和其它函数并没有本质区别，你在其它很多代码执行路径上都可以调用它。只是它会从一个进程运行到下一个进程。</p><p>那这个函数的功能就能定下来了：**无非是确定当前正在运行的进程，然后选择下一个将要运行的进程，最后从当前运行的进程，切换到下一个将要运行的进程。**下面我们先来写好进程调度器的入口函数，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void krlschedul()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        thread_t *prev = krlsched_retn_currthread(),//返回当前运行进程</span></div><div class="token-line"><span class="token plain">                 *next = krlsched_select_thread();//选择下一个运行的进程</span></div><div class="token-line"><span class="token plain">        save_to_new_context(next, prev);//从当前进程切换到下一个进程</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们只要在任何需要调度进程的地方，调用上述代码中的函数就可以了。下面我们开始实现krlschedul函数中的其它功能逻辑。</p><h3 id="如何获取当前运行的进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#如何获取当前运行的进程"><span class="icon icon-link"></span></a>如何获取当前运行的进程</h3><p>获取当前正在运行的进程，目的是为了保存当前进程的运行上下文，确保在下一次调度到当前运行的进程时能够恢复运行。后面你就会看到，每次切换到下一个进程运行时，我们就会将下一个运行的进程设置为当前运行的进程。</p><p>这个获取当前运行进程的函数，它的代码是这样的。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlsched_retn_currthread()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t cpuid = hal_retn_cpuid();</span></div><div class="token-line"><span class="token plain">        //通过cpuid获取当前cpu的调度数据结构</span></div><div class="token-line"><span class="token plain">        schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];</span></div><div class="token-line"><span class="token plain">        if (schdap-&gt;sda_currtd == NULL)</span></div><div class="token-line"><span class="token plain">        {//若调度数据结构中当前运行进程的指针为空，就出错死机</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;schdap-&gt;sda_currtd NULL&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return schdap-&gt;sda_currtd;//返回当前运行的进程</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码非常简单，如果你认真了解过前面组织进程的数据结构，就会发现，schdata_t结构中的<strong>sda_currtd字段</strong>正是保存当前正在运行进程的地址。返回这个字段的值，就能取得当前正在运行的进程。</p><h3 id="选择下一个进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#选择下一个进程"><span class="icon icon-link"></span></a>选择下一个进程</h3><p>根据调度器入口函数的设计，取得了当前正在运行的进程之后，下一步就是选择下个将要投入运行的进程。</p><p>在商业系统中，这个过程极为复杂。因为这个过程是<strong>进程调度算法的核心</strong>，它关乎到进程的吞吐量，能否及时响应请求，CPU的利用率，各个进程之间运行获取资源的公平性，这些问题综合起来就会影响整个操作系统的性能、可靠性。</p><p>作为初学者，我们不必搞得如此复杂，可以使用一个简单的优先级调度算法，就是始终选择优先级最高的进程，作为下一个运行的进程。</p><p>完成这个功能的代码，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlsched_select_thread()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        thread_t *retthd, *tdtmp;</span></div><div class="token-line"><span class="token plain">        cpuflg_t cufg;</span></div><div class="token-line"><span class="token plain">        uint_t cpuid = hal_retn_cpuid();</span></div><div class="token-line"><span class="token plain">        schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];</span></div><div class="token-line"><span class="token plain">        krlspinlock_cli(&amp;schdap-&gt;sda_lock, &amp;cufg);</span></div><div class="token-line"><span class="token plain">        for (uint_t pity = 0; pity &lt; PRITY_MAX; pity++)</span></div><div class="token-line"><span class="token plain">        {//从最高优先级开始扫描</span></div><div class="token-line"><span class="token plain">            if (schdap-&gt;sda_thdlst[pity].tdl_nr &gt; 0)</span></div><div class="token-line"><span class="token plain">            {//若当前优先级的进程链表不为空</span></div><div class="token-line"><span class="token plain">                if (list_is_empty_careful(&amp;(schdap-&gt;sda_thdlst[pity].tdl_lsth)) == FALSE)</span></div><div class="token-line"><span class="token plain">                {//取出当前优先级进程链表下的第一个进程</span></div><div class="token-line"><span class="token plain">                    tdtmp = list_entry(schdap-&gt;sda_thdlst[pity].tdl_lsth.next, thread_t, td_list);</span></div><div class="token-line"><span class="token plain">                    list_del(&amp;tdtmp-&gt;td_list);//脱链</span></div><div class="token-line"><span class="token plain">                    if (schdap-&gt;sda_thdlst[pity].tdl_curruntd != NULL)</span></div><div class="token-line"><span class="token plain">                    {//将这sda_thdlst[pity].tdl_curruntd的进程挂入链表尾</span></div><div class="token-line"><span class="token plain">                        list_add_tail(&amp;(schdap-&gt;sda_thdlst[pity].tdl_curruntd-&gt;td_list), &amp;schdap-&gt;sda_thdlst[pity].tdl_lsth);</span></div><div class="token-line"><span class="token plain">                    }</span></div><div class="token-line"><span class="token plain">                    schdap-&gt;sda_thdlst[pity].tdl_curruntd = tdtmp;</span></div><div class="token-line"><span class="token plain">                    retthd = tdtmp;//将选择的进程放入sda_thdlst[pity].tdl_curruntd中，并返回</span></div><div class="token-line"><span class="token plain">                    goto return_step;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">                if (schdap-&gt;sda_thdlst[pity].tdl_curruntd != NULL)</span></div><div class="token-line"><span class="token plain">                {//若sda_thdlst[pity].tdl_curruntd不为空就直接返回它</span></div><div class="token-line"><span class="token plain">                    retthd = schdap-&gt;sda_thdlst[pity].tdl_curruntd;</span></div><div class="token-line"><span class="token plain">                    goto return_step;</span></div><div class="token-line"><span class="token plain">                }</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        //如果最后也没有找到进程就返回默认的空转进程</span></div><div class="token-line"><span class="token plain">        schdap-&gt;sda_prityidx = PRITY_MIN;</span></div><div class="token-line"><span class="token plain">        retthd = krlsched_retn_idlethread();</span></div><div class="token-line"><span class="token plain">    return_step:</span></div><div class="token-line"><span class="token plain">        //解锁并返回进程</span></div><div class="token-line"><span class="token plain">        krlspinunlock_sti(&amp;schdap-&gt;sda_lock, &amp;cufg);</span></div><div class="token-line"><span class="token plain">        return retthd;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码的逻辑非常简单，我来给你梳理一下。</p><p>首先，从高到低扫描优先级进程链表，然后若当前优先级进程链表不为空，就取出该链表上的第一个进程，放入thrdlst_t结构中的tdl_curruntd字段中，并把之前thrdlst_t结构的tdl_curruntd字段中的进程挂入该链表的尾部，并返回。最后，当扫描到最低优先级时也没有找到进程，就返回默认的空转进程。</p><p>这个算法极其简单，但是对我们学习原理却足够了，也欢迎你举一反三，动手实现更高级的调度算法。</p><h3 id="获取空转进程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#获取空转进程"><span class="icon icon-link"></span></a>获取空转进程</h3><p>在选择下一个进程的函数中，如果没有找到合适的进程，就返回默认的空转进程。</p><p>你可以想一下，为什么要有一个空转进程，直接返回NULL不行吗？</p><p>还真不行，因为调度器的功能必须完成从一个进程到下一个进程的切换，如果没有下一个进程，而上一个进程又不能运行了，调度器将无处可去，整个系统也将停止运行，这当然不是我们要的结果，所以我们要给系统留下最后一条路。</p><p>下面我们先来实现获取空转进程的函数，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">thread_t *krlsched_retn_idlethread()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t cpuid = hal_retn_cpuid();</span></div><div class="token-line"><span class="token plain">        //通过cpuid获取当前cpu的调度数据结构</span></div><div class="token-line"><span class="token plain">        schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];</span></div><div class="token-line"><span class="token plain">        if (schdap-&gt;sda_cpuidle == NULL)</span></div><div class="token-line"><span class="token plain">        {//若调度数据结构中空转进程的指针为空，就出错死机</span></div><div class="token-line"><span class="token plain">            hal_sysdie(&quot;schdap-&gt;sda_cpuidle NULL&quot;);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return schdap-&gt;sda_cpuidle;//返回空转进程</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上述代码非常简单，和我们之前实现的获取当前运行进程的函数如出一辙，只是使用schdata_t结构中的字段发生了改变。好，接下来我们要处理更重要的问题，那就是进程之间的切换。</p><h3 id="进程切换"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#进程切换"><span class="icon icon-link"></span></a>进程切换</h3><p>经过前面的流程，我们已经找到了当前运行的进程P1，和下一个将要运行的进程P2，现在就进入最重要的进程切换流程。</p><p>在进程切换前，我们还要了解另一个重要的问题：<strong>进程在内核中函数调用路径，那什么是函数调用路径。</strong></p><p>举个例子，比如进程P1调用了函数A，接着在函数A中调用函数B，然后在函数B中调用了函数C，最后在函数C中调用了调度器函数S，这个函数A到函数S就是进程P1的函数调用路径。</p><p>再比如，进程P2开始调用了函数D，接着在函数D中调用函数E，然后在函数E中又调用了函数F，最后在函数F中调用了调度器函数S，函数D、E、F到函数S就是进程P2的函数调用路径。</p><p>函数调用路径是通过栈来保存的，对于运行在内核空间中的进程，就是保存在对应的内核栈中。我为你准备了一幅图帮助理解。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage28d0283efe1570a388902ae842acyyb299d0.jpg" alt="" title="内核栈状态"/></p><p>以上就是进程P1，P2的函数调用路径，也是它们调用函数时各自内核栈空间状态的变化结果。说个题外话，你有没有发现。C语言栈才是最高效内存管理，而且变量的生命周期也是妥妥的，比很多高级语言的内存垃圾回收器都牛。</p><p>有了前面的基础，现在我们来动手实现进程切换的函数。在这个函数中，我们要干这几件事。</p><p>首先，我们把当前进程的通用寄存器保存到当前进程的内核栈中；然后，保存CPU的RSP寄存器到当前进程的机器上下文结构中，并且读取保存在下一个进程机器上下文结构中的RSP的值，把它存到CPU的RSP寄存器中；接着，调用一个函数切换MMU页表；最后，从下一个进程的内核栈中恢复下一个进程的通用寄存器。</p><p>这样下一个进程就开始运行了，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void save_to_new_context(thread_t *next, thread_t *prev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        __asm__ __volatile__(</span></div><div class="token-line"><span class="token plain">            &quot;pushfq \n\t&quot;//保存当前进程的标志寄存器</span></div><div class="token-line"><span class="token plain">            &quot;cli \n\t&quot;  //关中断</span></div><div class="token-line"><span class="token plain">            //保存当前进程的通用寄存器</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rax\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rbx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rcx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rdx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rbp\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rsi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%rdi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r8\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r9\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r10\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r11\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r12\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r13\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;pushq %%r15\n\t&quot;</span></div><div class="token-line"><span class="token plain">            //保存CPU的RSP寄存器到当前进程的机器上下文结构中</span></div><div class="token-line"><span class="token plain">            &quot;movq %%rsp,%[PREV_RSP] \n\t&quot;</span></div><div class="token-line"><span class="token plain">            //把下一个进程的机器上下文结构中的RSP的值，写入CPU的RSP寄存器中</span></div><div class="token-line"><span class="token plain">            &quot;movq %[NEXT_RSP],%%rsp \n\t&quot;//事实上这里已经切换到下一个进程了，因为切换进程的内核栈    </span></div><div class="token-line"><span class="token plain">            //调用__to_new_context函数切换MMU页表</span></div><div class="token-line"><span class="token plain">            &quot;callq __to_new_context\n\t&quot;</span></div><div class="token-line"><span class="token plain">            //恢复下一个进程的通用寄存器</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r15\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r13\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r12\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r11\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r10\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r9\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r8\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rdi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rsi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rbp\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rdx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rcx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rbx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rax\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popfq \n\t&quot;      //恢复下一个进程的标志寄存器</span></div><div class="token-line"><span class="token plain">            //输出当前进程的内核栈地址</span></div><div class="token-line"><span class="token plain">            : [ PREV_RSP ] &quot;=m&quot;(prev-&gt;td_context.ctx_nextrsp)</span></div><div class="token-line"><span class="token plain">            //读取下一个进程的内核栈地址</span></div><div class="token-line"><span class="token plain">            : [ NEXT_RSP ] &quot;m&quot;(next-&gt;td_context.ctx_nextrsp), &quot;D&quot;(next), &quot;S&quot;(prev)//为调用__to_new_context函数传递参数</span></div><div class="token-line"><span class="token plain">            : &quot;memory&quot;);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>你看，代码中的save_to_new_context函数，是不是有点偷天换日的感觉？</p><p>通过切换进程的内核栈，导致切换进程，因为进程的函数调用路径就保存在对应的内核栈中，只要调用krlschedul函数，最后的函数调用路径一定会停在save_to_new_context函数中，当save_to_new_context函数一返回，就会导致回到调用save_to_new_context函数的下一行代码开始运行，在这里就是返回到krlschedul函数中，最后层层返回。</p><p>我知道你很难理解这一过程，所以准备了一幅图辅助说明。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage24c42414600d584323034cbd383c756yybc4.jpg" alt="" title="进程切换示意图"/></p><p>结合上图，你就能理解这个进程切换的原理了。同时你也会发现一个问题，就是这个切换机制能够正常运行，必须保证下一个进程已经被调度过，也就是<strong>它调用执行过krlschedul函数。</strong></p><p>那么已知新建进程绝对没有调用过krlschedul函数，所以它得进行特殊处理。我们在__to_new_context函数中完成这个特殊处理，代码如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void __to_new_context(thread_t *next, thread_t *prev)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t cpuid = hal_retn_cpuid();</span></div><div class="token-line"><span class="token plain">        schdata_t *schdap = &amp;osschedcls.scls_schda[cpuid];</span></div><div class="token-line"><span class="token plain">        //设置当前运行进程为下一个运行的进程</span></div><div class="token-line"><span class="token plain">        schdap-&gt;sda_currtd = next;</span></div><div class="token-line"><span class="token plain">        //设置下一个运行进程的tss为当前CPU的tss</span></div><div class="token-line"><span class="token plain">        next-&gt;td_context.ctx_nexttss = &amp;x64tss[cpuid];</span></div><div class="token-line"><span class="token plain">        //设置当前CPU的tss中的R0栈为下一个运行进程的内核栈</span></div><div class="token-line"><span class="token plain">        next-&gt;td_context.ctx_nexttss-&gt;rsp0 = next-&gt;td_krlstktop;</span></div><div class="token-line"><span class="token plain">        //装载下一个运行进程的MMU页表</span></div><div class="token-line"><span class="token plain">        hal_mmu_load(&amp;next-&gt;td_mmdsc-&gt;msd_mmu);</span></div><div class="token-line"><span class="token plain">        if (next-&gt;td_stus == TDSTUS_NEW)</span></div><div class="token-line"><span class="token plain">        {   //如果是新建进程第一次运行就要进行处理</span></div><div class="token-line"><span class="token plain">            next-&gt;td_stus = TDSTUS_RUN;</span></div><div class="token-line"><span class="token plain">            retnfrom_first_sched(next);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面代码的注释已经很清楚了，__to_new_context负责设置当前运行的进程，处理CPU发生中断时需要切换栈的问题，又切换了一个进程的MMU页表（即使用新进程的地址空间），最后如果是新建进程第一次运行，就调用retnfrom_first_sched函数进行处理。下面我们来写好这个函数。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void retnfrom_first_sched(thread_t *thrdp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        __asm__ __volatile__(</span></div><div class="token-line"><span class="token plain">            &quot;movq %[NEXT_RSP],%%rsp\n\t&quot;  //设置CPU的RSP寄存器为该进程机器上下文结构中的RSP</span></div><div class="token-line"><span class="token plain">            //恢复进程保存在内核栈中的段寄存器</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;movw %%r14w,%%gs\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;movw %%r14w,%%fs\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;movw %%r14w,%%es\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;movw %%r14w,%%ds\n\t&quot;</span></div><div class="token-line"><span class="token plain">            //恢复进程保存在内核栈中的通用寄存器</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r15\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r14\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r13\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r12\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r11\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r10\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r9\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%r8\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rdi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rsi\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rbp\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rdx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rcx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rbx\n\t&quot;</span></div><div class="token-line"><span class="token plain">            &quot;popq %%rax\n\t&quot;</span></div><div class="token-line"><span class="token plain">            //恢复进程保存在内核栈中的RIP、CS、RFLAGS，（有可能需要恢复进程应用程序的RSP、SS）寄存器</span></div><div class="token-line"><span class="token plain">            &quot;iretq\n\t&quot;</span></div><div class="token-line"><span class="token plain">            :</span></div><div class="token-line"><span class="token plain">            : [ NEXT_RSP ] &quot;m&quot;(thrdp-&gt;td_context.ctx_nextrsp)</span></div><div class="token-line"><span class="token plain">            : &quot;memory&quot;);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>retnfrom_first_sched函数不会返回到调用它的__to_new_context函数中，而是直接运行新建进程的相关代码（如果你不理解这段代码的原理，可以回顾<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/390674">上一课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，看看建立进程时，对进程内核栈进行的初始化工作）。</p><p>好，进行到这里，我们已经设计出了我们的Cosmos的进程调度器，但我们都知道，这样的调度器还不够，我们还没有解决进程的等待和唤醒问题，这些内容下节课我再跟你详细分享。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>这节课我们从了解为什么需要多进程调度开始，随后实现子调度管理多个进程，最终实现了进程调度器，这里面有很多重要的知识点，我来为你梳理一下。</p><p>1.**为什么需要多进程调度？**我们分析了系统中总有些资源不能满足每个进程的需求，所以一些进程必须要走走停停，这就需要不同的进程来回切换到CPU上运行，为了实现这个机制就需要多进程调度。</p><p>2.**组织多个进程。**为了实现进程管理，必须要组织多个进程。我们设计了调度器数据结构，在该结构中，我们使用优先级链表数组来组织多个进程，并且对这些数据结构的变量进行了初始化。</p><p>3.**进程调度。**有了多个进程就需要进程调度，我们的进程调度器是一个函数，在这个函数中选择了当前运行进程和下一个将要运行的进程，如果实在没有可运行的进程就选择空转进程，最后关键是进程间切换，我们是通过切换进程的内核栈来切换进程的函数调用路径，当调度器函数返回的时候已经是另一个进程了。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/08.活动实体进程/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请问当调度器函数调度到一个新建进程时，为何要进入retnfrom_first_sched函数呢？</p><p>欢迎你在留言区积极分享，相信通过主动输出，你将更好地理解这节课的内容。也欢迎把这节课分享给你的朋友，和他交流探讨，</p><p>好，我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/08.活动实体进程/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 18:45:29</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
