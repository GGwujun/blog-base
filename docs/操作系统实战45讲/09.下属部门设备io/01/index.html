<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>28 | 部门分类：如何表示设备类型与设备驱动？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/09.下属部门设备io/01" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="计算机的结构" data-depth="2"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#计算机的结构"><span>计算机的结构</span></a></li><li title="如何管理设备" data-depth="2"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#如何管理设备"><span>如何管理设备</span></a></li><li title="分权而治" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#分权而治"><span>分权而治</span></a></li><li title="设备分类" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备分类"><span>设备分类</span></a></li><li title="设备驱动" data-depth="2"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备驱动"><span>设备驱动</span></a></li><li title="设备" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备"><span>设备</span></a></li><li title="驱动" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#驱动"><span>驱动</span></a></li><li title="设备驱动的组织" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备驱动的组织"><span>设备驱动的组织</span></a></li><li title="驱动程序功能" data-depth="3"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#驱动程序功能"><span>驱动程序功能</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="28--部门分类如何表示设备类型与设备驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#28--部门分类如何表示设备类型与设备驱动"><span class="icon icon-link"></span></a>28 | 部门分类：如何表示设备类型与设备驱动？</h1><p>你好，我是LMOS。</p><p>小到公司，大到国家，都有各种下属部门，比如我们国家现在有教育部、科学技术部、外交部，财政部等，这些部门各自负责完成不同的职能工作，如教育部负责教育事业和语言文字工作，科学技术部负责推动解决经济社会发展的重大科技问题。</p><p>既然大道相通，那我们的Cosmos中是否也是类似这样的结构呢？</p><p>答案是肯定的，在前面的课中，我们搞定了内存管理和进程管理，它们是内核不可分隔的，但是计算机中还有各种类型的设备需要管理。</p><p>我们的Cosmos也会“成立各类部门”，用于管理众多设备，一个部门负责一类设备。具体要怎么管理设备呢？你不妨带着这个问题，正式开始今天的学习！</p><p>这节课的代码，你可以从<a target="_blank" rel="noopener noreferrer" href="https://gitee.com/lmos/cosmos/tree/master/lesson28~29/Cosmos">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>下载。</p><h2 id="计算机的结构"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#计算机的结构"><span class="icon icon-link"></span></a>计算机的结构</h2><p>不知道你是否和我一样，经常把计算机的机箱打开，看看 CPU，看看内存条，看看显卡，看看主板上的各种芯片。</p><p>其实，这些芯片并非独立存在，而是以总线为基础连接在一起的，各自完成自己的工作，又能互相打配合，共同实现用户要求的功能。</p><p>为了帮你理清它们的连接关系，我为你画了一幅图，如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2f4c2f7697d94bee25d4c036eb4bca16ee4c.e73c0738.jpg" alt="" title="计算机结构示意图"/></p><p>上图是一个典型的桌面系统，你先不用管是物理上怎么样连接的，逻辑上就是这样的。实际可能比图中有更多或者更少的总线。但是总线有层级关系，各种设备通过总线相连。这里我们只需要记住，计算机中有很多种类的设备，脑中有刚才这幅图就行了。</p><h2 id="如何管理设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#如何管理设备"><span class="icon icon-link"></span></a>如何管理设备</h2><p>在前面的课程中，我们实现了管理内存和进程，其实进程从正面看它是管理应用程序的，反过来看它也是管理CPU的，它能使CPU的使用率达到最高。</p><p>管理内存和管理CPU是操作系统最核心的部分，但是这还不够，因为计算机不止有CPU，还有各种设备。</p><p>如果把计算机内部所有的设备和数据都描述成资源，操作系统内核无疑是这些资源的管理者。既然设备也是一种资源，如何高效管理它们，以便提供给应用进程使用和操作，就是操作系统内核的重要任务。</p><h3 id="分权而治"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#分权而治"><span class="icon icon-link"></span></a>分权而治</h3><p>一个国家之所以有那么多部门，就是要把管理工作分开，专权专职专责，对于操作系统也是一样。</p><p>现代计算机早已不限于只处理计算任务，它还可以呈现图像、音频，和远程计算机通信，储存大量数据，以及和用户交互。所以，计算机内部需要处理图像、音频、网络、储存、交互的设备。这从上面的图中也可以看得出来。</p><p>操作系统内核要控制这些设备，就要包含每个设备的控制代码。如果操作系统内核被设计为通用可移植的内核，那是相当可怕的。试想一下，这个世界上有如此多的设备，操作系统内核代码得多庞大，越庞大就越危险，因为其中一行代码有问题，整个操作系统就崩溃了。</p><p>可是仅仅只有这些问题吗？当然不是，我们还要考虑到后面这几点。</p><p>1.操作系统内核开发人员，不可能罗列世界上所有的设备，并为其写一套控制代码。</p><p>2.为了商业目的，有很多设备厂商并不愿意公开设备的编程细节。就算内核开发人员想为其写控制代码，实际也不可行。</p><p>3.如果设备更新换代，就要重写设备的控制代码，然后重新编译操作系统内核，这样的话操作很麻烦，操作系统内核开发人员和用户都可能受不了。</p><p>以上三点，足于证明这种方案根本不可取。</p><p>既然操作系统内核无法包含所有的设备控制代码，那就索性不包含，或者只包含最基本、最通用的设备控制代码。这样操作系统内核就可以非常通用，非常精巧。</p><p>但是要控制设备就必须要有设备的相关控制代码才行，所以我们要把设备控制代码独立出来，与操作系统内核分开、独立开发，设备控制代码可由设备厂商人员开发。</p><p>每个设备对应一个设备控制代码模块，操作系统内核要控制哪个设备，就加载相应的设备代码模块，以后不使用这个设备了，就可以删除对应的设备控制代码模块。</p><p>这种方式，给操作系统内核带来了<strong>巨大的灵活性</strong>。设备厂商在发布新设备时，只要随之发布一个与此相关的设备控制代码模块就行了。</p><h3 id="设备分类"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备分类"><span class="icon icon-link"></span></a>设备分类</h3><p>要想管理设备，先要对其分门别类，在开始分类之前，你不妨先思考一个问题：操作系统内核所感知的设备，一定要与物理设备一一对应吗？</p><p>举个例子，储存设备，其实不管它是机械硬盘，还是TF卡，或者是一个设备控制代码模块，它向操作系统内核表明它是储存设备，但它完全有可能分配一块内存空间来储存数据，不必访问真正的储存设备。<strong>所以，操作系统内核所感知的设备，并不需要和物理设备对应，这取决于设备控制代码自身的行为。</strong></p><p>操作系统内核所定义的设备，可称为内核设备或者逻辑设备，其实这只是对物理计算平台中几种类型设备的一种抽象。下面，我们在cosmos/include/knlinc/krldevice_t.h文件中对设备进行分类定义，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define NOT_DEVICE 0               //不表示任何设备</span></div><div class="token-line"><span class="token plain">    #define BRIDGE_DEVICE 4            //总线桥接器设备</span></div><div class="token-line"><span class="token plain">    #define CPUCORE_DEVICE 5           //CPU设备，CPU也是设备</span></div><div class="token-line"><span class="token plain">    #define RAMCONTER_DEVICE 6        //内存控制器设备</span></div><div class="token-line"><span class="token plain">    #define RAM_DEVICE 7              //内存设备</span></div><div class="token-line"><span class="token plain">    #define USBHOSTCONTER_DEVICE 8    //USB主控制设备</span></div><div class="token-line"><span class="token plain">    #define INTUPTCONTER_DEVICE 9     //中断控制器设备</span></div><div class="token-line"><span class="token plain">    #define DMA_DEVICE 10             //DMA设备</span></div><div class="token-line"><span class="token plain">    #define CLOCKPOWER_DEVICE 11      //时钟电源设备</span></div><div class="token-line"><span class="token plain">    #define LCDCONTER_DEVICE 12        //LCD控制器设备</span></div><div class="token-line"><span class="token plain">    #define NANDFLASH_DEVICE 13       //nandflash设备</span></div><div class="token-line"><span class="token plain">    #define CAMERA_DEVICE 14          //摄像头设备</span></div><div class="token-line"><span class="token plain">    #define UART_DEVICE 15             //串口设备</span></div><div class="token-line"><span class="token plain">    #define TIMER_DEVICE 16            //定时器设备</span></div><div class="token-line"><span class="token plain">    #define USB_DEVICE 17              //USB设备</span></div><div class="token-line"><span class="token plain">    #define WATCHDOG_DEVICE 18        //看门狗设备</span></div><div class="token-line"><span class="token plain">    #define RTC_DEVICE 22              //实时时钟设备</span></div><div class="token-line"><span class="token plain">    #define SD_DEVICE 25               //SD卡设备</span></div><div class="token-line"><span class="token plain">    #define AUDIO_DEVICE 26            //音频设备</span></div><div class="token-line"><span class="token plain">    #define TOUCH_DEVICE 27           //触控设备</span></div><div class="token-line"><span class="token plain">    #define NETWORK_DEVICE 28         //网络设备</span></div><div class="token-line"><span class="token plain">    #define VIR_DEVICE 29               //虚拟设备</span></div><div class="token-line"><span class="token plain">    #define FILESYS_DEVICE 30            //文件系统设备</span></div><div class="token-line"><span class="token plain">    #define SYSTICK_DEVICE 31           //系统TICK设备</span></div><div class="token-line"><span class="token plain">    #define UNKNOWN_DEVICE 32        //未知设备，也是设备</span></div><div class="token-line"><span class="token plain">    #define HD_DEVICE 33        //硬盘设备</span></div></pre></div><p>上面定义的这些类型的设备，都是Cosmos内核抽象出来的逻辑设备，例如NETWORK_DEVICE网络设备，不管它是有线网卡还是无线网卡，或者是设备控制代码虚拟出来的虚拟网卡。Cosmos内核都将认为它是一个网络设备，这就是设备的抽象，这样有利于我们灵活、简便管理设备。</p><h2 id="设备驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备驱动"><span class="icon icon-link"></span></a>设备驱动</h2><p>刚才我们解决了设备分类，下面我来研究如何实现分权而治，就是把操作每个设备的相关代码独立出来，这种方式在业界有一个更专业的名字——<strong>设备驱动程序</strong>。同时在下面的内容中，我们将不区分设备驱动程序和驱动程序。</p><p>这种“分权而治”的方式，给操作系统内核带了灵活性、可扩展性……可是也带来了新的问题，有哪些问题呢？</p><p>首先是操作系统内核如何表示多个设备与驱动的存在？然后，还有如何组织多个设备和多个驱动程序的问题，最后我们还得考虑应该让驱动程序提供一些什么支持。下面我们分别解决这些问题。</p><h3 id="设备"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备"><span class="icon icon-link"></span></a>设备</h3><p>你能说说一个设备包含哪些信息吗？无非是设备类型，设备名称，设备状态，设备id，设备的驱动程序等。</p><p>我们把这些信息归纳成一个数据结构，在操作系统内核建立这个数据结构的实例变量，这个设备数据结构的实例变量，一旦建立，就表示操作系统内核中存在一个逻辑设备了。</p><p>我们接下来就一起整理一下设备的信息，然后把它们变成一个数据结构，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_DEVID</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t  dev_mtype;//设备类型号</span></div><div class="token-line"><span class="token plain">        uint_t  dev_stype; //设备子类型号</span></div><div class="token-line"><span class="token plain">        uint_t  dev_nr; //设备序号</span></div><div class="token-line"><span class="token plain">    }devid_t;</span></div><div class="token-line"><span class="token plain">    typedef struct s_DEVICE</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t    dev_list;//设备链表</span></div><div class="token-line"><span class="token plain">        list_h_t    dev_indrvlst; //设备在驱动程序数据结构中对应的挂载链表</span></div><div class="token-line"><span class="token plain">        list_h_t    dev_intbllst; //设备在设备表数据结构中对应的挂载链表</span></div><div class="token-line"><span class="token plain">        spinlock_t  dev_lock; //设备自旋锁</span></div><div class="token-line"><span class="token plain">        uint_t      dev_count; //设备计数</span></div><div class="token-line"><span class="token plain">        sem_t       dev_sem; //设备信号量</span></div><div class="token-line"><span class="token plain">        uint_t      dev_stus; //设备状态</span></div><div class="token-line"><span class="token plain">        uint_t      dev_flgs; //设备标志</span></div><div class="token-line"><span class="token plain">        devid_t      dev_id; //设备ID</span></div><div class="token-line"><span class="token plain">        uint_t      dev_intlnenr; //设备中断服务例程的个数</span></div><div class="token-line"><span class="token plain">        list_h_t    dev_intserlst; //设备中断服务例程的链表</span></div><div class="token-line"><span class="token plain">        list_h_t    dev_rqlist; //对设备的请求服务链表</span></div><div class="token-line"><span class="token plain">        uint_t      dev_rqlnr; //对设备的请求服务个数</span></div><div class="token-line"><span class="token plain">        sem_t       dev_waitints; //用于等待设备的信号量</span></div><div class="token-line"><span class="token plain">        struct s_DRIVER* dev_drv; //设备对应的驱动程序数据结构的指针</span></div><div class="token-line"><span class="token plain">        void* dev_attrb; //设备属性指针</span></div><div class="token-line"><span class="token plain">        void* dev_privdata; //设备私有数据指针</span></div><div class="token-line"><span class="token plain">        void* dev_userdata;//将来扩展所用</span></div><div class="token-line"><span class="token plain">        void* dev_extdata;//将来扩展所用</span></div><div class="token-line"><span class="token plain">        char_t* dev_name; //设备名</span></div><div class="token-line"><span class="token plain">    }device_t;</span></div></pre></div><p>设备的信息比较多，大多是用于组织设备的。这里的<strong>设备ID结构十分重要</strong>，它表示设备的类型、设备号，子设备号是为了解决多个相同设备的，还有一个指向设备驱动程序的指针，这是用于访问设备时调用设备驱动程序的，只要有人建立了一个设备结构的实例变量，内核就能感知到一个设备存在了。</p><p>至于是谁建立了设备结构的实例变量，这个问题我们接着探索。</p><h3 id="驱动"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#驱动"><span class="icon icon-link"></span></a>驱动</h3><p>操作系统内核和应用程序都不会主动建立设备，那么谁来建立设备呢？当然是控制设备的代码，也就是我们常说的<strong>驱动程序</strong>。</p><p>那么驱动程序如何表示呢，换句话说，操作系统内核是如何感知到一个驱动程序的存在呢？</p><p>根据前面的经验，我们还是要定义一个数据结构来表示一个驱动程序，数据结构中应该包含驱动程序名，驱动程序ID，驱动程序所管理的设备，最重要的是<strong>完成功能设备相关功能的函数</strong>，下面我们来定义它，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">typedef struct s_DRIVER</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        spinlock_t drv_lock; //保护驱动程序数据结构的自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t drv_list;//挂载驱动程序数据结构的链表</span></div><div class="token-line"><span class="token plain">        uint_t drv_stuts; //驱动程序的相关状态</span></div><div class="token-line"><span class="token plain">        uint_t drv_flg; //驱动程序的相关标志</span></div><div class="token-line"><span class="token plain">        uint_t drv_id; //驱动程序ID</span></div><div class="token-line"><span class="token plain">        uint_t drv_count; //驱动程序的计数器</span></div><div class="token-line"><span class="token plain">        sem_t drv_sem; //驱动程序的信号量</span></div><div class="token-line"><span class="token plain">        void* drv_safedsc; //驱动程序的安全体</span></div><div class="token-line"><span class="token plain">        void* drv_attrb; //LMOSEM内核要求的驱动程序属性体</span></div><div class="token-line"><span class="token plain">        void* drv_privdata; //驱动程序私有数据的指针</span></div><div class="token-line"><span class="token plain">        drivcallfun_t drv_dipfun[IOIF_CODE_MAX]; //驱动程序功能派发函数指针数组</span></div><div class="token-line"><span class="token plain">        list_h_t drv_alldevlist; //挂载驱动程序所管理的所有设备的链表</span></div><div class="token-line"><span class="token plain">        drventyexit_t drv_entry; //驱动程序的入口函数指针</span></div><div class="token-line"><span class="token plain">        drventyexit_t drv_exit; //驱动程序的退出函数指针</span></div><div class="token-line"><span class="token plain">        void* drv_userdata;//用于将来扩展</span></div><div class="token-line"><span class="token plain">        void* drv_extdata; //用于将来扩展</span></div><div class="token-line"><span class="token plain">        char_t* drv_name; //驱动程序的名字</span></div><div class="token-line"><span class="token plain">    }driver_t;</span></div></pre></div><p>上述代码，你应该很容易看懂。Cosmos内核每加载一个驱动程序模块，就会自动分配一个驱动程序数据结构并且将其实例化。</p><p>而Cosmos内核在首次启动驱动程序时，就会调用这个驱动程序的入口点函数，在这个函数中驱动程序会分配一个设备数据结构，并用相关的信息将其实例化，比如填写正确的设备类型、设备ID号、设备名称等。</p><p>Cosmos内核负责建立驱动数据结构，而驱动程序又建立了设备数据结构，这一来二去，就形成了一个驱动程序与Cosmos内核**“握手”**的动作。</p><h3 id="设备驱动的组织"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#设备驱动的组织"><span class="icon icon-link"></span></a>设备驱动的组织</h3><p>有了设备、驱动，我们下面探索一下怎么合理的组织好它们。</p><p>组织它们要解决的问题，就是在哪里安放驱动。然后我们还要想好怎么找到它们，下面我们用一个叫做<strong>设备表</strong>的数据结构，来组织这些驱动程序数据结构和设备数据结构。</p><p>这个结构我已经帮你定义好了，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define DEVICE_MAX 34</span></div><div class="token-line"><span class="token plain">    typedef struct s_DEVTLST</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint_t dtl_type;//设备类型</span></div><div class="token-line"><span class="token plain">        uint_t dtl_nr;//设备计数</span></div><div class="token-line"><span class="token plain">        list_h_t dtl_list;//挂载设备device_t结构的链表</span></div><div class="token-line"><span class="token plain">    }devtlst_t;</span></div><div class="token-line"><span class="token plain">    typedef struct s_DEVTABLE</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_h_t devt_list; //设备表自身的链表</span></div><div class="token-line"><span class="token plain">        spinlock_t devt_lock; //设备表自旋锁</span></div><div class="token-line"><span class="token plain">        list_h_t devt_devlist; //全局设备链表</span></div><div class="token-line"><span class="token plain">        list_h_t devt_drvlist; //全局驱动程序链表，驱动程序不需要分类，一个链表就行</span></div><div class="token-line"><span class="token plain">        uint_t   devt_devnr; //全局设备计数</span></div><div class="token-line"><span class="token plain">        uint_t   devt_drvnr; //全局驱动程序计数</span></div><div class="token-line"><span class="token plain">        devtlst_t devt_devclsl[DEVICE_MAX]; //分类存放设备数据结构的devtlst_t结构数组</span></div><div class="token-line"><span class="token plain">    }devtable_t;</span></div></pre></div><p>在这段代码的devtable_t结构中，devtlst_t是每个设备类型一个，表示一类设备，但每一类可能有多个设备，所以在devtlst_t结构中，有一个设备计数和设备链表。而你可能想到Cosmos中肯定要定义一个devtable_t结构的全局变量，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//在 cosmos/kernel/krlglobal.c文件中</span></div><div class="token-line"><span class="token plain">    KRL_DEFGLOB_VARIABLE(devtable_t,osdevtable);</span></div><div class="token-line"><span class="token plain">    //在 cosmos/kernel/krldevice.c文件中</span></div><div class="token-line"><span class="token plain">    void devtlst_t_init(devtlst_t *initp, uint_t dtype)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        initp-&gt;dtl_type = dtype;//设置设备类型    initp-&gt;dtl_nr = 0;</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;dtl_list);</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void devtable_t_init(devtable_t *initp)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;devt_list);</span></div><div class="token-line"><span class="token plain">        krlspinlock_init(&amp;initp-&gt;devt_lock);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;devt_devlist);</span></div><div class="token-line"><span class="token plain">        list_init(&amp;initp-&gt;devt_drvlist);</span></div><div class="token-line"><span class="token plain">        initp-&gt;devt_devnr = 0;</span></div><div class="token-line"><span class="token plain">        initp-&gt;devt_drvnr = 0;</span></div><div class="token-line"><span class="token plain">        for (uint_t t = 0; t &lt; DEVICE_MAX; t++)</span></div><div class="token-line"><span class="token plain">        {//初始化设备链表</span></div><div class="token-line"><span class="token plain">            devtlst_t_init(&amp;initp-&gt;devt_devclsl[t], t);</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    void init_krldevice()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        devtable_t_init(&amp;osdevtable);//初始化系统全局设备表</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    //在 cosmos/kernel/krlinit.c文件中</span></div><div class="token-line"><span class="token plain">    void init_krl()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        init_krlmm();</span></div><div class="token-line"><span class="token plain">        init_krldevice();</span></div><div class="token-line"><span class="token plain">        //记住一定要在初始化调度器之前，初始化设备表</span></div><div class="token-line"><span class="token plain">        init_krlsched();</span></div><div class="token-line"><span class="token plain">        init_krlcpuidle();</span></div><div class="token-line"><span class="token plain">        return;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的设备表的初始化代码已经写好了，如果你大脑中没有设备驱动组织图，可能脑子里还是有点乱，所以我来帮你画一幅图，如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage179f17d232bd17b0c328yyed37bab98baa9f.19388172.jpg" alt="" title="设备表结构示意图"/></p><p>上图看似复杂，实则简单，我帮你理一下重点：首先devtable_t结构中能找到所有的设备和驱动，然后从设备能找到对应的驱动，从驱动也能找到其管理的所有设备 ，最后就能实现一个驱动管理多个设备。</p><h3 id="驱动程序功能"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#驱动程序功能"><span class="icon icon-link"></span></a>驱动程序功能</h3><p>我们还有一个问题需要解决，那就是驱动程序，究竟要为操作系统内核提供哪些最基本的功能支持？</p><p>我们已经知道了，写驱动程序就是为了操控相应的设备，所以这得看大多数设备能完成什么功能了。现代计算机的设备无非就是可以输入数据、处理数据、输出数据，然后完成一些特殊的功能。</p><p>当然，现代计算机的设备很多，能耗是个严重的问题，所以操作系统内核应该能控制设备能耗。下面我来帮你归纳一下用来驱动程序的几种主要函数，如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">//驱动程序入口和退出函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_entry(driver_t* drvp,uint_t val,void* p);</span></div><div class="token-line"><span class="token plain">    drvstus_t device_exit(driver_t* drvp,uint_t val,void* p);</span></div><div class="token-line"><span class="token plain">    //设备中断处理函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_handle(uint_t ift_nr,void* devp,void* sframe);</span></div><div class="token-line"><span class="token plain">    //打开、关闭设备函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_open(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    drvstus_t device_close(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //读、写设备数据函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_read(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    drvstus_t device_write(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //调整读写设备数据位置函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_lseek(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //控制设备函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_ioctrl(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //开启、停止设备函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_dev_start(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    drvstus_t device_dev_stop(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //设置设备电源函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_set_powerstus(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //枚举设备函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_enum_dev(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //刷新设备缓存函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_flush(device_t* devp,void* iopack);</span></div><div class="token-line"><span class="token plain">    //设备关机函数</span></div><div class="token-line"><span class="token plain">    drvstus_t device_shutdown(device_t* devp,void* iopack);</span></div></pre></div><p>如上所述，我们可以把每一个操作定义成一个函数，让驱动程序实现这些函数。函数名你可以随便写，但是函数的形式却不能改变，这是操作系统内核与驱动程序沟通的桥梁。当然有很多设备本身并不支持这么多操作，例如时钟设备，驱动程序就不必实现相应的操作。</p><p>那么这些函数如何和操作系统内核关联起来呢？还记得driver_t结构中那个函数指针数组吗，如下所示。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define IOIF_CODE_OPEN 0 //对应于open操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_CLOSE 1 //对应于close操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_READ 2 //对应于read操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_WRITE 3 //对应于write操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_LSEEK 4 //对应于lseek操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_IOCTRL 5 //对应于ioctrl操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_DEV_START 6 //对应于start操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_DEV_STOP 7 //对应于stop操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_SET_POWERSTUS 8 //对应于powerstus操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_ENUM_DEV 9 //对应于enum操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_FLUSH 10 //对应于flush操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_SHUTDOWN 11 //对应于shutdown操作</span></div><div class="token-line"><span class="token plain">    #define IOIF_CODE_MAX 12 //最大功能码</span></div><div class="token-line"><span class="token plain">    //驱动程序分派函数指针类型</span></div><div class="token-line"><span class="token plain">    typedef drvstus_t (*drivcallfun_t)(device_t*,void*);</span></div><div class="token-line"><span class="token plain">    //驱动程序入口、退出函数指针类型</span></div><div class="token-line"><span class="token plain">    typedef drvstus_t (*drventyexit_t)(struct s_DRIVER*,uint_t,void*);</span></div><div class="token-line"><span class="token plain">    typedef struct s_DRIVER</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //……</span></div><div class="token-line"><span class="token plain">        drivcallfun_t drv_dipfun[IOIF_CODE_MAX];//驱动程序分派函数指针数组。</span></div><div class="token-line"><span class="token plain">        list_h_t drv_alldevlist;//驱动所管理的所有设备。</span></div><div class="token-line"><span class="token plain">        drventyexit_t drv_entry;</span></div><div class="token-line"><span class="token plain">        drventyexit_t drv_exit;</span></div><div class="token-line"><span class="token plain">        //……</span></div><div class="token-line"><span class="token plain">    }driver_t;</span></div></pre></div><p>看到这里，你是不是明白了？driver_t结构中的drv_dipfun函数指针数组，正是存放上述那12个驱动程序函数的指针。这样操作系统内核就能通过driver_t结构，调用到对应的驱动程序函数操作对应的设备了。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>现在，我们搞明白了一个典型计算机的结构，里面有很多设备，需要操作系统合理地管理，而操作系统通过加载驱动程序来管理和使用设备，并为此提供了一系列的机制，这也是我们这节课的重点。</p><p>1.计算机结构，我们通过了解一个典型的计算机系统结构，明白了设备的多样性。然后我们对设备做了抽象分类，采用分权而治的方式，让操作系统通过驱动程序来管理设备，同时又能保证操作系统和驱动程序分离，达到操作系统和设备解耦的目的。</p><p>2.归纳整理设备和设备驱动的信息，抽象两个对应的数据结构，这两个数据结构在内存中的实例变量就代表一个设备和对应的驱动。然后，我们通过设备表结构组织了驱动和设备的数据结构。</p><p>3.驱动程序最主要的工作是要操控设备，但这些个操作设备的动作是操作系统调用的，所以对驱动定义了必须要支持的12种标准方法，并对应到函数，这些函数的地址保存在驱动程序的数据结构中。</p><p>你可能在想，我们驱动程序是怎么加载的，设备又是怎么建立的呢？这是正是我们后面课程要解决的。不过你可以先开动脑筋，思考一下，提出你自己的见解，考虑一下这个问题的解决方案。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/09.下属部门设备io/01#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请你写出一个用来访问设备的接口函数，或者想一下访问一个设备需要什么参数。</p><p>欢迎你在留言区跟我交流互动，积极输出有助于更高效地理解这节课的内容。也欢迎你把这节课分享给同事、朋友。</p><p>好，我是LMOS。我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/09.下属部门设备IO/01.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 19:21:50</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
