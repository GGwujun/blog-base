<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      window.publicPath = window.resourceBaseUrl || "/blog-base/";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>46 | AArch64体系：ARM最新编程架构模型剖析 - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/13.番外篇虚化的世界/04" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="什么是AArch64体系" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#什么是aarch64体系"><span>什么是AArch64体系</span></a></li><li title="AArch64体系的寄存器" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系的寄存器"><span>AArch64体系的寄存器</span></a></li><li title="通用寄存器R0-R30" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#通用寄存器r0-r30"><span>通用寄存器R0-R30</span></a></li><li title="特殊寄存器" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#特殊寄存器"><span>特殊寄存器</span></a></li><li title="系统寄存器" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#系统寄存器"><span>系统寄存器</span></a></li><li title="ARM-A Arch64体系下CPU的工作模式" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#arm-a-arch64体系下cpu的工作模式"><span>ARM-A Arch64体系下CPU的工作模式</span></a></li><li title="工作模式分类" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#工作模式分类"><span>工作模式分类</span></a></li><li title="处理器如何切换工作模式" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#处理器如何切换工作模式"><span>处理器如何切换工作模式</span></a></li><li title="AArch64体系如何处理中断" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系如何处理中断"><span>AArch64体系如何处理中断</span></a></li><li title="异常和中断" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#异常和中断"><span>异常和中断</span></a></li><li title="中断处理" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#中断处理"><span>中断处理</span></a></li><li title="中断向量表" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#中断向量表"><span>中断向量表</span></a></li><li title="AArch64体系如何访问内存" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系如何访问内存"><span>AArch64体系如何访问内存</span></a></li><li title="AArch64体系下的地址空间" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系下的地址空间"><span>AArch64体系下的地址空间</span></a></li><li title="AArch64体系下地址映射和转换" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系下地址映射和转换"><span>AArch64体系下地址映射和转换</span></a></li><li title="总结" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#总结"><span>总结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="46--aarch64体系arm最新编程架构模型剖析"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#46--aarch64体系arm最新编程架构模型剖析"><span class="icon icon-link"></span></a>46 | AArch64体系：ARM最新编程架构模型剖析</h1><p>你好，我是LMOS。</p><p>在今天，Andriod+ARM已经成了移动领域的霸主，这与当年的Windows+Intel何其相似。之前我们已经在Intel的x86 CPU上实现了Cosmos，今天我会给你讲讲ARM的AArch64体系结构，带你扩展一下视野。</p><p>首先，我们来看看什么是AArch64体系，然后分析一下AArch64体系有什么特点，最后了解一下AArch64体系下运行程序的基础，包括AArch64体系下的寄存器、运行模式、异常与中断处理，以及AArch64体系的地址空间与内存模型。</p><p>话不多说，下面我们进入正题。</p><h2 id="什么是aarch64体系"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#什么是aarch64体系"><span class="icon icon-link"></span></a>什么是AArch64体系</h2><p>ARM架构在不断发展，现在它在各个领域都得到了非常广泛地应用。</p><p>自从Acorn公司于1983年开始发布第一个版本，到目前为止，有九个主要版本，版本号由1到9表示。2011年，Acorn公司发布了ARMv8版本。</p><p>ARMv8是首款支持64位指令集的ARM处理器架构，它兼容了ARMv7与之前处理器的技术基础，同样它也兼容现有的A32（ARM 32bit）指令集，还扩充了基于64bit的AArch64架构。</p><p>下面我们一起来看看ARMv8一共定义了哪几种架构，一共有三种。</p><p>1.<strong>ARMv8-A（Application）架构</strong>，支持基于内存管理的虚拟内存系统体系结构（VMSA），支持A64、A32和T32指令集，主打高性能，在我们的移动智能设备中广泛应用。</p><p>2.<strong>ARMv8-R（Real-time）架构</strong>，支持基于内存保护的受保护内存系统架构（PMSA），支持A32和T32指令集，一般用于实时计算系统。</p><p>3.<strong>ARMv8-M（Microcontroller架构）</strong>，是一个压缩成本的嵌入式架构，而且需要极低延迟中断处理。它支持T32指令集的变体，主打低功耗，一般用于物联网设备。</p><p>今天我们要讨论的AArch64，它只是ARMv8-A架构下的一种执行状态，“64”表示内存或者数据都保存在64位的寄存器中，并且它的基本指令集可以用64位寄存器进行数据运算处理。</p><h2 id="aarch64体系的寄存器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系的寄存器"><span class="icon icon-link"></span></a>AArch64体系的寄存器</h2><p>一款处理器要运行程序和处理数据，必须要有一定数量的寄存器。特别是基于RISC（精简指令集）架构的ARM处理器，寄存器数量非常之多，因为大量的指令操作的就是寄存器。</p><p>ARMv8-AArch64体系下的寄存器简单可以分为以下几类。</p><p>1.通用寄存器<br/>2.特殊寄存器<br/>3.系统寄存器</p><p>下面我们分别来看看这三类寄存器。</p><h3 id="通用寄存器r0-r30"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#通用寄存器r0-r30"><span class="icon icon-link"></span></a>通用寄存器R0-R30</h3><p>首先来看通用寄存器（general-purpose registers），通用寄存器一共为31个，从R0到R30，这个31个寄存器可以作为全64位使用，也可以只使用其中的低32位。</p><p>全64位的寄存器以x0到x30名称进行引用，用于32位或者64位的整数运算或者64位的寻址；低32位寄存器以W0到W30名称进行引用，只能用于32位的整数运算或者32位的寻址。为了帮你理解，我还在后面画了示意图。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage1cd21c8535a89b4e32a8c717fd0c89a350d2.82faae56.jpg" alt="" title="register_common"/></p><p>通用寄存器中还有32个向量寄存器（SIMD），编号从V0到V31。因为向量计算依然是数据运算类的，所以要把它们归纳到通用寄存器中。每个向量寄存器都是128位的，但是它们可以单独使用其中的8位、16位、32位、64位，它们的访问方式和索引名称如下所示。</p><ul><li>Q0到Q31为一个128-bit的向量寄存器 ；</li><li>D0到D31为一个64-bit的向量寄存器；</li><li>S0到S31为一个32-bit的向量寄存器；</li><li>H0到H31为一个16-bit的向量寄存器；</li><li>B0到B31为一个8-bit的向量寄存器；</li></ul><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage2bc42b3d38cdac2e9cfd5ba9b86db00493c4.bfd4d4dc.jpg" alt="" title="register_simd"/></p><h3 id="特殊寄存器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#特殊寄存器"><span class="icon icon-link"></span></a>特殊寄存器</h3><p><strong>特殊寄存器</strong>（spseical registers）比通用寄存器稍微复杂一些，它还可以细分，包括程序计数寄存器（PC），栈指针寄存器（SP），异常链接寄存器（ELR_ELx），程序状态寄存器（PSTATE、SPSR_ELx）等。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageb70ab7c24e632afd125f566b2b20dc59ef0a.0c650076.jpg" alt="" title="special_registers"/></p><p><strong>PC寄存器</strong></p><p>PC寄存器，保存当前指令地址的64位程序计数器，指向即将要执行的下一条指令，CPU正是在这个寄存器的指引下，一条一条地运行代码指令。在ARMv7上，PC寄存器就是通用寄存器R15，而在ARMv8上，PC寄存器不再是通用寄存器，不能直接被修改，只可以通过隐式的指令来改变，例如PC-relative load。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage9d489dc67becc01e9f35d803f2575e74b648.98800490.jpg" alt="" title="PC寄存器"/></p><p><strong>SP寄存器</strong></p><p>SP是64位的栈指针寄存器，可以通过<strong>WSP</strong>寄存器访问低32位，在指令中使用SP作为操作数，表示使用当前栈指针。C语言调用函数和分配局部变量都需要用栈，栈是一种后进先出的内存空间，而SP寄存器中保存的就是栈顶的内存地址。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage50a7507e60c2882be5fdaa4d59536f022fa7.f0c7148a.jpg" alt="" title="SP寄存器"/></p><p><strong>ELR_ELx异常链接寄存器</strong></p><p>每个异常状态下都有一个ELR_EL寄存器，ELR_ELx 寄存器是异常综合寄存器或者异常状态寄存器 ，负责保存异常进入Elx的地址和发生异常的原因等信息。</p><p>该寄存器只有ELR_EL1、ELR_EL2、ELR_EL3这几种，没用ELR_EL0寄存器，因为异常不会routing(target)到EL0。例如：16bit指令的异常、32bit指令的异常、simd浮点运算的异常、MSR/MRS的异常。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimageed3fed1f8f2yy4f3bb89abb911b82f120d3f.05b01828.jpg" alt="" title="ELR_ELx寄存器"/></p><p><strong>PSTATE</strong></p><p>PSTATE不是单独的一个寄存器，而是保存当前PE（Processing Element）状态的一组寄存器统称，其中可访问寄存器有：NZCV、DAIF、CurrentEL（）、SPSel。这些属于ARMv8新增内容，在64bit下可以代替CPSR（32位系统下的PE信息）。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">type ProcState is (</span></div><div class="token-line"><span class="token plain">    // PSTATE.{N, Z, C, V}： 条件标志位，这些位的含义跟之前AArch32位一样，分别表示补码标志，运算结果为0标志，进位标志，带符号位溢出标志</span></div><div class="token-line"><span class="token plain">    bits (1) N, // Negative condition flag</span></div><div class="token-line"><span class="token plain">    bits (1) Z, // Zero condition flag</span></div><div class="token-line"><span class="token plain">    bits (1) C, // Carry condition flag</span></div><div class="token-line"><span class="token plain">    bits (1) V, // oVerflow condition flag</span></div><div class="token-line"><span class="token plain">    // D表示debug异常产生，比如软件断点指令/断点/观察点/向量捕获/软件单步 等；</span></div><div class="token-line"><span class="token plain">    // A, I, F表示异步异常标志，异步异常会有两种类型：一种是物理中断产生的，包括SError（系统错误类型，包括外部数据终止），IRQ或者FIQ；</span></div><div class="token-line"><span class="token plain">    // 另一种是虚拟中断产生的，这种中断发生在运行在EL2管理者enable的情况下：vSError，vIRQ，vFIQ；</span></div><div class="token-line"><span class="token plain">    bits (1) D, // Debug mask bit [AArch64 only]</span></div><div class="token-line"><span class="token plain">    bits (1) A, // Asynchronous abort mask bit</span></div><div class="token-line"><span class="token plain">    bits (1) I, // IRQ mask bit</span></div><div class="token-line"><span class="token plain">    bits (1) F, // FIQ mask bit</span></div><div class="token-line"><span class="token plain">    // 异常发生的时候，通过设置MDSCR_EL1.SS 为 1启动单步调试机制；</span></div><div class="token-line"><span class="token plain">    bits (1) SS, // Software step bit</span></div><div class="token-line"><span class="token plain">    // 异常执行状态标志，非法异常产生的时候，会设置这个标志位，</span></div><div class="token-line"><span class="token plain">    bits (1) IL, // Illegal execution state bit</span></div><div class="token-line"><span class="token plain">    bits (2) EL, // Exception Level (see above)</span></div><div class="token-line"><span class="token plain">    // 表示当前ELx 所运行的状态，分为AArch64和AArch32:</span></div><div class="token-line"><span class="token plain">    bits (1) nRW, // not Register Width: 0=64, 1=32</span></div><div class="token-line"><span class="token plain">    // 某个ELx 下的堆栈指针，EL0下就表示sp_el0；</span></div><div class="token-line"><span class="token plain">    bits (1) SP, // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]</span></div><div class="token-line"><span class="token plain">    )</span></div></pre></div><p><strong>SPSR_ELx 程序状态寄存器</strong></p><p>程序在运行中，处理大量数据，无非是进行各种数学运算，而数学运算的结果往往有各种状态，如进位、结果为0、结果是负数等，还有程序的运行状态，是否允许中断，CPU的工作模式，这些信息都保存在程序状态寄存器中，即PSTATE中。</p><p>但是当CPU处理异常时，进程相应的ELx状态不同，就要把PSTATE状态信息保存在ELx状态下对应的SPSR_ELx寄存器中。SPSR_ELx寄存器的格式如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagecdyycd75b6cb85b6d20e85698e62602dd0yy.ab317573.jpg" alt="" title="register_SPSR_ELx"/></p><h3 id="系统寄存器"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#系统寄存器"><span class="icon icon-link"></span></a>系统寄存器</h3><p>最后，ARM的CPU上还有一些系统寄存器，用于访问系统配置。</p><p>在EL0状态下，大多数系统寄存器是不可访问的，但是部分系统寄存器可以在EL0状态下进行访问，比如Cache ID 寄存器（用于EL0状态下缓存管理）、调试寄存器（用于代码调试，如MDCCSR_EL0、DBGDTR_EL0等）、性能监控寄存器和时钟寄存器等。</p><h2 id="arm-a-arch64体系下cpu的工作模式"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#arm-a-arch64体系下cpu的工作模式"><span class="icon icon-link"></span></a>ARM-A Arch64体系下CPU的工作模式</h2><p>其实，AArch64、AArch32体系都是简称，从严格意义上说，它们应该是处理器的两种执行方式或者状态。AArch64体系执行A64指令集，这个指令集是全64位的；AArch32体系则可以执行A32指令集和T32指令集（这节课我们不关注这个体系，所以这些指令集暂不深究）。</p><p>不管是AArch64体系还是AArch32体系，ARM CPU的工作模式并没有差异。为了让你把握重点，我们后面只是以AArch64体系为例，探讨ARM处理器的工作模式。</p><h3 id="工作模式分类"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#工作模式分类"><span class="icon icon-link"></span></a>工作模式分类</h3><p>前面我们介绍了x86 CPU的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/375278">工作模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但是x86 CPU的工作模式和ARM的CPU的工作差别很大，x86 CPU的工作模式，包括特权级、处理器位宽、内存的访问与保护。</p><p>ARM CPU工作模式则有些不同，究竟有哪些不同呢？</p><p>ARM的CPU一共有7种不同工作模式，根据权限和状态，以及进入工作模式的方法等方面的不同，我为你用表格的方式做了梳理。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage6f236f7eea3b6c03d81c12f6ab81974ca123.835f1889.jpg" alt="" title="工作模式梳理"/></p><p>虽然看起来比较多，但是还是比较好归纳的，在7种模式中，除了用户模式之外的模式，被统称为<strong>Privileged Modes</strong>(特权模式)。</p><p>首先，我们大多数的应用程序是运行在用户模式下的，在用户模式下，是不能够访问受保护的系统资源的。此外，应用程序也无法进行处理器模式的切换的。这样就做到了应用程序和内核程序的权力分隔，确保应用程序不能破坏操作系统。</p><p>一旦代码的执行流，切换到特权模式下，其代码就可以访问全部的系统资源了，代码也可以随时进行处理器模式的切换。而且只有在特权模式下，CPU的部分内部寄存器才可以被读写。这里的代码就是指内核代码。</p><p>其次，系统模式也是特权模式，代码也是可以访问全部系统资源，也可以随时进行处理器模式的切换，主要供操作系统任务使用。系统模式和用户模式可以访问到的寄存器是同一套的，区别就是它是特权模式，不受用户模式的限制，一般系统模式用于调用操作系统的系统任务。</p><p>最后，特权模式下，除系统模式之外的其他五种模式就是异常模式。异常模式一般是在用户的应用程序发生中断异常时，随着特定的异常而进入的，比如之前我们讲过的硬件中断和软件中断，每种异常模式都有对应的一组寄存器，用来保证用户模式下的状态不被异常破坏。这样可以大大减小处理异常的时间，因为不用保存大量用户态寄存器。</p><h3 id="处理器如何切换工作模式"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#处理器如何切换工作模式"><span class="icon icon-link"></span></a>处理器如何切换工作模式</h3><p>前面我们已经了解了ARM架构下CPU的几种工作模式，那么CPU的工作模式是如何切换的呢？</p><p>工作模式切换大概分两种情况，一是软件控制，通过修改相应的寄存器或者执行相应的指令；二是当外部中断或是异常发生时，也会导致CPU工作模式的切换。</p><p>那么当CPU发生中断或者异常时，CPU进入相应的异常模式时，以下工作由CPU自动完成。</p><p>1.在异常模式的R14中，保存前一个工作模式里，下一条即将执行的指令地址；<br/>2.将CPSR的值复制到异常模式的SPSR中；<br/>3.将CPSR的工作模式设为该异常模式对应的工作模式；<br/>4.令PC值等于这个异常模式在异常向量表中的地址，即跳转去执行异常向量表中的相应指令。</p><p>处理完中断或者异常，就需要从中断或者异常中返回到发生中断或者异常的位置，继续执行程序。这个从异常工作模式退回到之前的工作模式时，需要由软件来完成后面这两项工作。</p><p>1.将异常模式的R14减去一个适当的值（4或8）后，赋给PC寄存器；<br/>2.将异常模式SPSR的值赋给CPSR；</p><p>好了，以上就是CPU切换工作的细节，有了这个基础，接下来我们一起看看AArch64体系下CPU是如何处理中断或者异常的。</p><h2 id="aarch64体系如何处理中断"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系如何处理中断"><span class="icon icon-link"></span></a>AArch64体系如何处理中断</h2><p>现在我们来看看AArch64体系是如何处理中断的，首先我们要搞清楚中断和异常的区别，然后了解它们的处理过程，最后再研究一下中断向量表。</p><h3 id="异常和中断"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#异常和中断"><span class="icon icon-link"></span></a>异常和中断</h3><p>有时候，我们习惯于把异常（Exception）和中断（Interrupt）理解成一回事儿。但是对ARM来说，官方文档用了Exception这个术语来描述广义上的中断，包括异常（Exception）和中断（Interrupt），Exception和Interrupt的执行机制都是一样的，只是触发方式有区别。</p><p>这里的异常，切入的视角是处理器<strong>被动接收</strong>到了异常。异常通常表现为错误，比如CPU执行了未知指令，但CPU明显不能执行这个指令，所以就会产生错误。再比如说，CPU访问了不能访问的内存，这也是错误的。你会发现，共同点是异常都是同步的，不修改程序下次同样会发生。</p><p>而中断对应的视角是处理器<strong>主动申请</strong>，你可以当作是异步的异常，因外部事件产生。中断分为三种，它们分别是IRQ、FIQ和SError。IRQ、FIQ通常是连接到外部中断信号，当外部设备发出中断信号时，CPU就能对此作出响应并处理外部设备需要完成的操作。</p><h3 id="中断处理"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#中断处理"><span class="icon icon-link"></span></a>中断处理</h3><p>我们在了解中断处理之前，首先要搞明白异常级别。</p><p>在全局ARMV8-A体系结构中，定义了四个异常级别（Exception Level）从EL0到El3，每个异常级别的权限不同，你不妨想像一下x86 CPU的R3～R0特权级。</p><p>只不过ARMV8-A体系结构下EL0为最低权限模式，也就是对应用户态，处理的是应用程序；EL1处理的是OS内核层，对应的是内核态；EL2是Supervisor模式，处理的则是可以跑多个虚拟OS内核的管理软件，对应的是虚拟机管理态，它是可选的，如Hypervisor用于和virtualization扩展；EL3运行的是安全管理（Secure Monitor），处理的是监控态，用于security扩展。</p><p>开发通用的操作系统内核只需要使用到EL1，EL2两个异常级别，我为你画了一幅EL模型图，如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage5ff75fa247a1cbfcd7e8832db9215a92d3f7.010fc270.jpg" alt="" title="EL模型图"/></p><p>现在我们来看看中断或者异常发生时，EL级别的切换，这里分为两种情况。</p><p>第一种是高级别向低级别切换，这种方式通过修改PSTATE寄存器中的值来实现，EL异常级别就保存在这个寄存器中；第二种是低级别向高级别切换，通过触发中断或者异常的方式进行切换的。</p><p>在这两种切换过程中，如果高级的状态是AArch64，低级的可以是AArch64或者AArch32，也就是可以向下兼容；如果高级的是AArch32，那么低级的也一定要是AArch32。</p><p>当一个中断或者异常触发后，CPU的操作流程如下所示。</p><p>1.更新SPSR_ELx寄存器，即当前的PSTATE寄存器的信息存储在SPSR_ELx寄存，以便中断结束时恢复到 PSTATE 寄存器。<br/>2.更新PSTATE寄存器以反映新的处理器状态，这个过程中，中断级别可能会发生变化。<br/>3.发生中断时的下一条指令地址存储在 ELR_ELx寄存器中，以便中断返回后，能继续运行。<br/>4.当中断处理完成后，由高级别返回低级别时，需要使用ERET指令返回。</p><p>下图能帮你更加清楚地理解这一行为。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage679f672238298e113e758de6c3a35ab5fc9f.ecacfff6.jpg" alt="" title="Interrupt流程"/></p><p>上图已经清楚地展示了，中断或者异常发生时，其中几个关键寄存器是如何保存和恢复的。</p><h3 id="中断向量表"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#中断向量表"><span class="icon icon-link"></span></a>中断向量表</h3><p>当中断或者异常发生后，CPU进行相应的操作后，必须要跳转到相应的地址开始运行相应的代码，进行中断或者异常的处理，这个地址就是<strong>中断向量</strong>。由于有多个中断或者异常，于是就形成了<strong>中断向量表</strong>。</p><p>在AArch64中，每个中断或者异常触发时会产生EL级别切换。通常在EL0级别调用svc指令，触发一个同步异常，CPU则会切换到EL1级别；如果在EL0级别来了一个IRQ或FIQ，就会触发一个异步中断，CPU会根据SCR寄存器中的中断配置来决定切换EL1或EL2或EL3级别，同时也会区分EL级别使用的是AArch64，还是AArch32的指令集。</p><p>16个向量的分类和偏移地址在向量表中的关系如下所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage0c570cd64d27966ef5d7ce16c0e04555cf57.c542c57a.jpg" alt=""/></p><p>上表中分了四个小表，小表中的每一个entry由不同的中断的类型（IRQ，FIQ，SError，Synchronous）决定。具体使用哪一个小表由以下几个条件决定。</p><ol><li>如果中断发生在同一中断级别，并且使用的栈指针是SP_EL0，则使用SP_EL0这张表。</li><li>如果中断发生在同一中断级别，并且使用的栈指针是SP_EL1/2/3，则使用SP_EL这张表。</li><li>如果中断发生在较低的中断级别，使用的小表则为下一个较低级别（AArch64或AArch32）的执行状态。</li></ol><p>有了这些硬件机制的支持，就可以完美支持现代意义中的操作系统了。</p><h2 id="aarch64体系如何访问内存"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系如何访问内存"><span class="icon icon-link"></span></a>AArch64体系如何访问内存</h2><p>无论是操作系统内核代码还是应用程序代码，它们都是放在内存中的，CPU要执行相应的代码指令，就要访问内存。访问内存有两大关键，<strong>一是寻址，这表现为内存的地址空间；第二个关键点是内存空间的保护，即内存地址的映射和转换</strong>。下面我分别解读一下这两个关键点。</p><h3 id="aarch64体系下的地址空间"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系下的地址空间"><span class="icon icon-link"></span></a>AArch64体系下的地址空间</h3><p>对于工作在AArch64体系下的CPU来说，没有启动MMU的情况下，ARM的CPU发出的地址，就是物理地址直接通过这个寻址内存空间。</p><p>但是你别以为AArch64体系下有64位的寄存器，能发出64位的地址，就一定能寻址64位地址空间的内存。其实实际只能使用52位或者48位的地址，这里我们只讨论使用48位地址的情况。如果启用了MMU，那么CPU会通过虚拟地址寻址，MMU负责将虚拟地址转换为物理地址，进而访问实际的物理地址空间。这个过程如下图所示。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimagedc76dc1ebb7c6f7a5f955b310215c470ce76.49120278.jpg" alt="" title="AArch64虚拟地址空间"/></p><p>上图中可以发现，如果CPU发出的虚拟地址在0x0～0x0000ffffffffffff范围内，MMU就会使用TTBR0_ELx寄存器指向的地址转换表进行物理地址的转换；如果CPU发出的虚拟地址在0xffff000000000000～0xffffffffffffffff，MMU使用TTBR1_ELx寄存器指向的地址转换表进行物理地址的转换。</p><p>究竟虚拟地址是如何转换成物理地址的呢？我们接着往下看。</p><h3 id="aarch64体系下地址映射和转换"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#aarch64体系下地址映射和转换"><span class="icon icon-link"></span></a>AArch64体系下地址映射和转换</h3><p>按照我们以往的经验来看，这里肯定是有一张把虚拟地址转化为物理地址的表，给出一个虚拟地址，通过查表就可以查到物理地址。但是实际过程却不是这么简单，在这里通常要有一个多级的查表过程。</p><p>MMU将虚拟地址映射到物理地址是以页（Page）为单位的，ARMv8架构的AArch64体系可以支持48位虚拟地址，并配置成4级页表（4K页），或者3级页表（64K页）。</p><p>例如，虚拟地址0xb7001000~0xb7001fff是一个页，可能被MMU映射到物理地址0x2000~0x2fff，物理内存中的一个物理页面也称为一个页框（Page Frame）。</p><p>那么MMU执行地址转换的过程是怎样呢？我们看一看4K页表的情况下，虚拟地址转换物理地址的逻辑图。</p><p><img src="/blog-base/static/httpsstatic001geekbangorgresourceimage13091342ba009a4b273165d64db8d602e309.8738947c.jpg" alt="" title="虚拟地址转化"/></p><p>结合上图我们看到，首先要将64位的虚拟内存分成多个位段，这些位段就是用来索引不同级别页表中的entry的。那么MMU是如何具体操作的呢，一共分五步。</p><p>第一步从虚拟地址位段[47:39]开始，用来索引0级页表，0级页表的物理基地址存放在TTBR_ELx寄存器中，以虚拟地址位段[47:39]为索引，找到0级页表中的某个entry，该entry会返回1级页表的基地址。</p><p>第二步，接着之前找到的1级页表的基地址，现在可以用虚拟地址位段[38:30]索引到1级页表的某个entry，该entry在4KB页表情况下，返回的是2级页表的基地址。</p><p>然后到了第三步，有了2级页表基地址，就可以用虚拟地址位段[29:21]作为索引找到2级页表中的某个entry，该entry返回3级页表的基地址。</p><p>再然后是第四步，有了3级页表基地址，则用虚拟地址位段[20:12]作为索引找到3级页表中的某个entry，该entry返回的是物理内存页面的基地址。</p><p>最后一步，我们得到物理内存页面基地址，用虚拟地址剩余的位段[11:0]作为索引，就能访问到4KB大小的物理内存页面内的某个字节了。</p><p>这个过程从TTBR_ELx寄存器开始到0级页表，接着到1级页表，然后到2级页表，再然后到3级页表，最终到物理页面，CPU一次寻址，其实是五次访问物理内存。这个过程完全是由硬件处理的，每次寻址时MMU就自动完成前面这五步，不需要我们编写指令来控制MMU，但是我们要保证内核维护正确的页表项。</p><p>有了MMU硬件转换机制，操作系统只需要控制页表就能控制内存的映射和隔离了。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#总结"><span class="icon icon-link"></span></a>总结</h2><p>这节课我们一起了解了ARM的AArch64体系，它是ARMV8-A下的一种执行状态。作为首款支持64位的处理器架构，AArch64体系不只是32 位ARM 构架的兼容扩展，还引入了新的A64指令集。</p><p>处理器想要运行程序、处理数据，离不开各种寄存器。我们学习了AARch64下的三类寄存器，包括通用寄存器、特殊寄存器和系统寄存器。</p><p>相比x86系统，AArch64的CPU工作模式更加多样，一共有七种工作模式。之后，我们分别研究了工作模式切换还有基于EL0-3的异常中断处理，以及AArch64下的内存架构和访问方式。访问内存，你重点要掌握的是访问内存的两大关键点，<strong>一是寻址，二是内存空间的保护</strong>。</p><p>自从2011年ARM发布首款支持64位的ARMv8版本后，到现在已经过去了十年。在今年ARM也宣布了下一代芯片架构ARMv9的部分技术细节，并称其为十年来最大的创新，也将是未来十年内千亿级别芯片的基础，其在CPU性能、安全性、AI支持上有了显著提升。</p><p>但是ARMv9不会像ARMv7到ARMv8的根本性的执行模式和指令集的变化，ARMv9继续使用AArch64作为基准指令集，但是在其功能上增加了一些非常重要的扩展，ARMv9开发的处理器预计将在2022年正式面世，让我们拭目以待！</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/04#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>请问，ARMv8，有多少特权级？每个特权级有什么作用？</p><p>欢迎你在留言区记录你的思考，也欢迎把这节课分享给有需要的朋友。</p><p>我是LMOS，我们下节课见。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/13.番外篇虚化的世界/04.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 20:27:01</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
