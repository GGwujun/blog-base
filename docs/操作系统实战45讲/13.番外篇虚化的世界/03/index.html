<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-base/umi.css" />
    <script>
      window.routerBase = "/blog-base";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>45 | ARM新宠：苹果的M1芯片因何而快？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/操作系统实战45讲/13.番外篇虚化的世界/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></span><span>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></span><span>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试</span><span>产品与用户体验</span><span>面试</span><span>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-base/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础<ul><li><a href="/blog-base/编译原理之美">编译原理之美</a></li><li><a href="/blog-base/编译原理实战">编译原理实战</a></li><li><a href="/blog-base/深入浅出计算机组成原理">深入浅出计算机组成原理</a></li><li><a href="/blog-base/详解http">详解http</a></li><li><a href="/blog-base/计算机网络通关29讲">计算机网络通关29讲</a></li><li><a href="/blog-base/网络排查案例课">网络排查案例课</a></li><li><a href="/blog-base/linux操作系统">linux操作系统</a></li><li><a href="/blog-base/linux内核技术实战课">linux内核技术实战课</a></li><li><a href="/blog-base/linux性能优化实战">linux性能优化实战</a></li><li><a href="/blog-base/程序员数学基础">程序员数学基础</a></li><li><a href="/blog-base/趣谈网络协议">趣谈网络协议</a></li><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/软件工程之美">软件工程之美</a></li><li><a href="/blog-base/sql必知必会">sql必知必会</a></li><li><a aria-current="page" class="active" href="/blog-base/操作系统实战45讲">操作系统实战45讲</a></li><li><a href="/blog-base/网络编程实战">网络编程实战</a></li><li><a href="/blog-base/趣谈linux操作系统">趣谈linux操作系统</a></li></ul></li><li>算法<ul><li><a href="/blog-base/常用算法25讲">常用算法25讲</a></li><li><a href="/blog-base/数据结构与算法之美">数据结构与算法之美</a></li><li><a href="/blog-base/业务开发算法50讲">业务开发算法50讲</a></li><li><a href="/blog-base/动态规划面试宝典">动态规划面试宝典</a></li></ul></li><li>前端开发<ul><li><a href="/blog-base/正则表达式入门">正则表达式入门</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试</li><li>产品与用户体验</li><li>面试</li><li>杂谈<ul><li><a href="/blog-base/代码之丑">代码之丑</a></li><li><a href="/blog-base/代码精进之路">代码精进之路</a></li><li><a href="/blog-base/数据分析思维课">数据分析思维课</a></li><li><a href="/blog-base/朱涛kotlin编程第一课">朱涛kotlin编程第一课</a></li><li><a href="/blog-base/重学线性代数">重学线性代数</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-base/操作系统实战">操作系统实战</a></li><li><a href="/blog-base/操作系统实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-base/操作系统实战/01.开篇词/01"><span>开篇词 | 为什么要学写一个操作系统？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello">02.尝尝鲜从一个Hello到另一个Hello</a><ul><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/01"><span>01 | 程序的运行过程：从代码到机器运行</span></a></li><li><a href="/blog-base/操作系统实战/02.尝尝鲜从一个hello到另一个hello/02"><span>02 | 几行汇编几行C：实现一个最简单的内核</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计">03.心有蓝图设计</a><ul><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/01"><span>03 | 黑盒之中有什么：内核结构与设计</span></a></li><li><a href="/blog-base/操作系统实战/03.心有蓝图设计/02"><span>04 | 震撼的Linux全景图：业界成熟的内核架构长什么样？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件">04.程序的基石硬件</a><ul><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/01"><span>05 | CPU工作模式：执行程序的三种模式</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/02"><span>06 | 虚幻与真实：程序中的地址如何转换？</span></a></li><li><a href="/blog-base/操作系统实战/04.程序的基石硬件/03"><span>07 | Cache与内存：程序放在哪儿？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语">05.基本法同步原语</a><ul><li><a href="/blog-base/操作系统实战/05.基本法同步原语/01"><span>08 | 锁：并发操作中，解决数据同步的四种方法</span></a></li><li><a href="/blog-base/操作系统实战/05.基本法同步原语/02"><span>09 | 瞧一瞧Linux：Linux的自旋锁和信号量如何实现？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化">06.夺权启动初始化</a><ul><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/01"><span>10 | 设置工作模式与环境（上）：建立计算机</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/02"><span>11 | 设置工作模式与环境（中）：建造二级引导器</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/03"><span>12 | 设置工作模式与环境（下）：探查和收集信息</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/04"><span>13 | 第一个C函数：如何实现板级初始化？</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/05"><span>14 | Linux初始化（上）：GRUB与vmlinuz的结构</span></a></li><li><a href="/blog-base/操作系统实战/06.夺权启动初始化/06"><span>15 | Linux初始化（下）：从_start到第一个进程</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/07.土地革命内存">07.土地革命内存</a><ul><li><a href="/blog-base/操作系统实战/07.土地革命内存/01"><span>16 | 划分土地（上）：如何划分与组织内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/02"><span>17 | 划分土地（中）：如何实现内存页面初始化？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/03"><span>18 | 划分土地（下）：如何实现内存页的分配与释放？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/04"><span>19 | 土地不能浪费：如何管理内存对象？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/05"><span>20 | 土地需求扩大与保障：如何表示虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/06"><span>21 | 土地需求扩大与保障：如何分配和释放虚拟内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/07"><span>22 | 瞧一瞧Linux：伙伴系统如何分配内存？</span></a></li><li><a href="/blog-base/操作系统实战/07.土地革命内存/08"><span>23 | 瞧一瞧Linux：SLAB如何分配内存？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/08.活动实体进程">08.活动实体进程</a><ul><li><a href="/blog-base/操作系统实战/08.活动实体进程/01"><span>24 | 活动的描述：到底什么是进程？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/02"><span>25 | 多个活动要安排（上）：多进程如何调度？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/03"><span>26 | 多个活动要安排（下）：如何实现进程的等待与唤醒机制？</span></a></li><li><a href="/blog-base/操作系统实战/08.活动实体进程/04"><span>27 | 瞧一瞧Linux：Linux如何实现进程与进程调度?</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io">09.下属部门设备IO</a><ul><li><a href="/blog-base/操作系统实战/09.下属部门设备io/01"><span>28 | 部门分类：如何表示设备类型与设备驱动？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/02"><span>29 | 部门建立：如何在内核中注册设备？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/03"><span>30 | 部门响应：设备如何处理内核I/O包？</span></a></li><li><a href="/blog-base/操作系统实战/09.下属部门设备io/04"><span>31 | 瞧一瞧Linux：如何获取所有设备信息？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统">10.银行仓库文件系统</a><ul><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/01"><span>32 | 仓库结构：如何组织文件?</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/02"><span>33 | 仓库划分：文件系统的格式化操作</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/03"><span>34 | 仓库管理：如何实现文件的六大基本操作？</span></a></li><li><a href="/blog-base/操作系统实战/10.银行仓库文件系统/04"><span>35 | 瞧一瞧Linux：虚拟文件系统如何管理文件？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/11.通信部网络">11.通信部网络</a><ul><li><a href="/blog-base/操作系统实战/11.通信部网络/01"><span>36 | 从URL到网卡：如何全局观察网络数据流动？</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/02"><span>37 | 从内核到应用：网络数据在内核中如何流转</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/03"><span>38 | 从单排到团战：详解操作系统的宏观网络架构</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/04"><span>39 | 瞧一瞧Linux：详解socket实现与网络编程接口</span></a></li><li><a href="/blog-base/操作系统实战/11.通信部网络/05"><span>40 | 瞧一瞧Linux：详解socket的接口实现</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/12.服务交接接口">12.服务交接接口</a><ul><li><a href="/blog-base/操作系统实战/12.服务交接接口/01"><span>41 | 服务接口：如何搭建沟通桥梁？</span></a></li><li><a href="/blog-base/操作系统实战/12.服务交接接口/02"><span>42 | 瞧一瞧Linux：如何实现系统API？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界">13.番外篇虚化的世界</a><ul><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/01"><span>43 | 虚拟机内核：KVM是什么？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/02"><span>44 | 容器：如何理解容器的实现机制？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/03"><span>45 | ARM新宠：苹果的M1芯片因何而快？</span></a></li><li><a href="/blog-base/操作系统实战/13.番外篇虚化的世界/04"><span>46 | AArch64体系：ARM最新编程架构模型剖析</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/14.特别放送">14.特别放送</a><ul><li><a href="/blog-base/操作系统实战/14.特别放送/01"><span>用户故事 | 成为面向“知识库”的工程师</span></a></li><li><a href="/blog-base/操作系统实战/14.特别放送/02"><span>用户故事 | 操作系统发烧友：看不懂？因为你没动手</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/15.结束语">15.结束语</a><ul><li><a href="/blog-base/操作系统实战/15.结束语/01"><span>结束语 | 生活可以一地鸡毛，但操作系统却是心中的光</span></a></li><li><a href="/blog-base/操作系统实战/15.结束语/02"><span>结课测试 ｜这些操作系统的问题，你都掌握了么？</span></a></li></ul></li><li><a href="/blog-base/操作系统实战/summary">操作系统实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="CPU的原理初探" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#cpu的原理初探"><span>CPU的原理初探</span></a></li><li title="ALU的需求梳理与方案设计" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#alu的需求梳理与方案设计"><span>ALU的需求梳理与方案设计</span></a></li><li title="自己动手用Verilog实现一个ALU" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#自己动手用verilog实现一个alu"><span>自己动手用Verilog实现一个ALU</span></a></li><li title="验证测试ALU" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#验证测试alu"><span>验证测试ALU</span></a></li><li title="现代CPU加速的套路" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#现代cpu加速的套路"><span>现代CPU加速的套路</span></a></li><li title="更多的硬件指令" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#更多的硬件指令"><span>更多的硬件指令</span></a></li><li title="通过缓存来提高数据装载效率" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#通过缓存来提高数据装载效率"><span>通过缓存来提高数据装载效率</span></a></li><li title="流水线乱序执行与分支预测" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#流水线乱序执行与分支预测"><span>流水线乱序执行与分支预测</span></a></li><li title="多核心CPU" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#多核心cpu"><span>多核心CPU</span></a></li><li title="超线程" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#超线程"><span>超线程</span></a></li><li title="谈谈指令集" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#谈谈指令集"><span>谈谈指令集</span></a></li><li title="CISC" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#cisc"><span>CISC</span></a></li><li title="RISC" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#risc"><span>RISC</span></a></li><li title="ARM与M1芯片" data-depth="3"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#arm与m1芯片"><span>ARM与M1芯片</span></a></li><li title="重点回顾" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#重点回顾"><span>重点回顾</span></a></li><li title="思考题" data-depth="2"><a href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="45--arm新宠苹果的m1芯片因何而快"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#45--arm新宠苹果的m1芯片因何而快"><span class="icon icon-link"></span></a>45 | ARM新宠：苹果的M1芯片因何而快？</h1><p>你好，我是 LMOS。</p><p>前面两节课，我们一起学习了虚拟机和容器的原理，这些知识属于向上延展。而这节课我们要向下深挖，看看操作系统下面的硬件层面，重点研究一下CPU的原理和它的加速套路。</p><p>有了这些知识的加持，我还会给你说说，为什么去年底发布的苹果M1芯片可以实现高性能、低功耗。你会发现，掌握了硬件的知识，很多“黑科技”就不再那么神秘了。</p><p>好，让我们正式开始今天的学习！</p><h2 id="cpu的原理初探"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#cpu的原理初探"><span class="icon icon-link"></span></a>CPU的原理初探</h2><p>经过前面的学习，我们已经对操作系统原理建立了一定认知。从操作系统的位置来看，它除了能够向上封装，为软件调用提供API（也就是系统调用），向下又对硬件资源进行了调度和抽象。我们通常更为关注系统调用，但为了更好地设计实现一个OS，我们当然也要对硬件足够了解。</p><p>接下来，我们一起看一看硬件中最重要的一个硬件——CPU是怎么工作的。让我们拆开CPU这个黑盒子，看一看一个最小的CPU应该包含哪些部分。不同架构的CPU，具体设计还是有很大差异的。为了方便你理解，我这里保留了CPU里的共性部分，给你抽象出了CPU的最小组成架构。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagec2d1c2d0b75dffcfbdb5e72011013a6cd2d1.jpg" alt="" title="CPU架构图"/><br/>对照上图描绘的基本模块，我们可以把CPU运行过程抽象成这样6步。</p><p>1.众所周知，CPU的指令是以二进制形式存储在存储器中的（这里把寄存器、RAM统一抽象成了存储器），所以当CPU执行指令的时候，第一步就要先从存储器中取出（fetch）指令。</p><p>2.CPU将取出的指令通过硬件的指令解码器进行解码。</p><p>3.CPU根据指令解码出的功能，决定是否还要从存储器中取出需要处理的数据。</p><p>4.控制单元（CU）根据解码出的指令决定要进行哪些相应的计算，这部分工作由算术逻辑单元（ALU）完成。</p><p>5.控制单元（CU）根据前边解码出的指令决定是否将计算结果存入存储器。</p><p>6.修改程序计数器（PC）的指针，为下一次取指令做准备，以上整体执行过程由控制单元（CU）在时钟信号的驱动之下，周而复始地有序运行。</p><p>看了CPU核心组件执行的这6个步骤，不知道你有没有联想到<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/369457">第一节课<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的图灵机的执行原理？没错，现代CPU架构与实现虽然千差万别，但核心思想都是一致的。</p><h3 id="alu的需求梳理与方案设计"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#alu的需求梳理与方案设计"><span class="icon icon-link"></span></a>ALU的需求梳理与方案设计</h3><p>通过研究CPU核心组件的运行过程，我们发现，原来CPU也可以想象成我们熟悉的软件，一样能抽象成几大模块，然后再进行模块化开发。</p><p>因为从零开始实现一款CPU的工程量还是不小的，所以在这里我带你使用Verilog语言实现一个可以运行简单计算的ALU，从而对CPU具体模块的设计与实现加深一下认知。</p><p>首先，我们来思考一下，对于一个最简单的ALU这个模块，我们的<strong>核心需求</strong>是什么？</p><p>没错，聪明的你可能已经脱口而出了，我需要能<strong>对两个N位的二进制数进行加减、比较运算</strong>。等等，为啥这里没有乘除？还记得学生时代初学乘除法的时候，老师也同样先简化为加减法，方便我们理解。</p><p>这里也一样，因为乘除也可以转换为循环的加减运算，比如2*3可以转换成2+2+2，6/2可以转换成6-2-2-2。所以，只需要实现了加减运算之后，我们就可以通过软件操作CPU，让它实现更复杂的运算了，这也正是软件扩展硬件能力的魅力。</p><p>好了，搞清楚需求之后，先不用着急编码，我们先来根据需求梳理一下ALU模块功能简图。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage1c031c53d14ef766154fb8a4627490f1ba03.jpg" alt="" title="ALU模块功能简图"/></p><p>首先，我们在模块左侧（也就是输入侧）抽象出了5根引脚，这五根引脚的作用分别是：</p><ul><li>ena：表示使能信号，它的取值是0或1可以分别控制ALU关闭或开启。</li><li>clk：表示时钟信号，时钟信号也是01交替运行的方波，时钟信号会像人的心跳一样驱动ALU的电路稳定可靠地运行。</li><li>opcode：表示操作码，取值范围是00、01、10这三种值，用来区分这一次计算到底是加法、减法还是比较运算。</li><li>data1、data2：表示参与运算的两个N位数据总线。</li></ul><p>现在我们再来看图片右侧，也就是输出侧的y，它表示输出结果，如果是加减运算，则直接输出运算后的数值，而比较运算，则要输出0、1、2，分别表示等于、大于、小于。</p><p>好了，有了方案，接下来就让我们想办法把方案变成可落地的实践吧。</p><h3 id="自己动手用verilog实现一个alu"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#自己动手用verilog实现一个alu"><span class="icon icon-link"></span></a>自己动手用Verilog实现一个ALU</h3><p>Verilog是一种优秀的硬件描述语言，它可以用类似C语言的高级语言设计芯片，从而免去了徒手画门电路的烦恼。</p><p>目前Intel等很多著名芯片公司都在使用Verilog进行芯片设计。我们为了和业界保持一致，也采用了这种Verilog来设计我们的ALU。</p><p>在开发之前，你需要先进行一些准备工作，安装VSCode的Verilog语言支持插件、iverilog、gtkwave，这些工具安装比较简单，你可以自行Google搜索。</p><p>接下来，我们就来实现一下ALU的代码，也就是alu.v，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*----------------------------------------------------------------</span></div><div class="token-line"><span class="token plain">    Filename: alu.v</span></div><div class="token-line"><span class="token plain">    Function: 设计一个N位的ALU(实现两个N位有符号整数加 减 比较运算)</span></div><div class="token-line"><span class="token plain">    -----------------------------------------------------------------*/</span></div><div class="token-line"><span class="token plain">    module alu(ena, clk, opcode, data1, data2, y);</span></div><div class="token-line"><span class="token plain">        //定义alu位宽</span></div><div class="token-line"><span class="token plain">        parameter N = 32; //输入范围[-128, 127]</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //定义输入输出端口</span></div><div class="token-line"><span class="token plain">        input ena, clk;</span></div><div class="token-line"><span class="token plain">        input [1 : 0] opcode;</span></div><div class="token-line"><span class="token plain">        input signed [N - 1 : 0] data1, data2; //输入有符号整数范围为[-128, 127] </span></div><div class="token-line"><span class="token plain">        output signed [N : 0] y; //输出范围有符号整数范围为[-255, 255]</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //内部寄存器定义</span></div><div class="token-line"><span class="token plain">        reg signed [N : 0] y;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //状态编码</span></div><div class="token-line"><span class="token plain">        parameter ADD = 2&#x27;b00, SUB = 2&#x27;b01, COMPARE = 2&#x27;b10;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //逻辑实现</span></div><div class="token-line"><span class="token plain">        always@(posedge clk)</span></div><div class="token-line"><span class="token plain">        begin</span></div><div class="token-line"><span class="token plain">            if(ena)</span></div><div class="token-line"><span class="token plain">            begin</span></div><div class="token-line"><span class="token plain">                casex(opcode)</span></div><div class="token-line"><span class="token plain">                    ADD: y &lt;= data1 + data2; //实现有符号整数加运算</span></div><div class="token-line"><span class="token plain">                    SUB: y &lt;= data1 - data2; //实现有符号数减运算</span></div><div class="token-line"><span class="token plain">                    COMPARE: y &lt;= (data1 &gt; data2) ? 1 : ((data1 == data2) ? 0 : 2); //data1 = data2 输出0; data1 &gt; data2 输出1; data1 &lt; data2 输出2;</span></div><div class="token-line"><span class="token plain">                    default: y &lt;= 0;</span></div><div class="token-line"><span class="token plain">                endcase</span></div><div class="token-line"><span class="token plain">            end</span></div><div class="token-line"><span class="token plain">        end</span></div><div class="token-line"><span class="token plain">    endmodule</span></div></pre></div><p>对照上面的代码块，我帮你挨个解释一下。首先我们定义了ALU简图左侧的5个引脚，对应到代码上就是抽象成了module的5个参数（是不是看起来很像一个C语言的函数）。</p><p>其次，为了能够临时保存运算结果，我们定义了寄存器y。</p><p>再然后，为了区别加、减、比较运算，我们定义了三种状态编码。代码中的always@其实是Verilog中的一个语法特性，表示输入信号的电平发生变化的时候，下边的代码块将会被执行。所以，这里实现的就是当时钟信号发生变化的时候，ALU就会继续执行。</p><p>再之后就是功能的实现啦，功能就是根据opcode将对应运算结果保存至寄存器y。你看，总共才30多行代码，我们就实现了一个可以计算任意N位二进制数的ALU，是不是很神奇？</p><h3 id="验证测试alu"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#验证测试alu"><span class="icon icon-link"></span></a>验证测试ALU</h3><p>作为一个严谨的工程师，我们除了编码之外，肯定还是要编写对应的测试用例，提升我们的代码的健壮性和可靠性。我们这就来一起编写一下对应的测试代码alu_t.v，代码如下。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/*------------------------------------</span></div><div class="token-line"><span class="token plain">    Filename: alu_t.v</span></div><div class="token-line"><span class="token plain">    Function: 测试alu模块的逻辑功能的测试用例</span></div><div class="token-line"><span class="token plain">    ------------------------------------*/</span></div><div class="token-line"><span class="token plain">    `timescale 1ns/1ns</span></div><div class="token-line"><span class="token plain">    `define half_period 5</span></div><div class="token-line"><span class="token plain">    module alu_t(y);</span></div><div class="token-line"><span class="token plain">        //alu位宽定义</span></div><div class="token-line"><span class="token plain">        parameter N = 32;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //输出端口定义</span></div><div class="token-line"><span class="token plain">        output signed [N : 0] y;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //寄存器及连线定义</span></div><div class="token-line"><span class="token plain">        reg ena, clk;</span></div><div class="token-line"><span class="token plain">        reg [1 : 0] opcode;</span></div><div class="token-line"><span class="token plain">        reg signed [N - 1 : 0] data1, data2;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //产生测试信号</span></div><div class="token-line"><span class="token plain">        initial</span></div><div class="token-line"><span class="token plain">        begin</span></div><div class="token-line"><span class="token plain">            $dumpfile(&quot;aly_t.vcd&quot;);</span></div><div class="token-line"><span class="token plain">            $dumpvars(0,alu_t);</span></div><div class="token-line"><span class="token plain">            $display(&quot;my alu test&quot;);</span></div><div class="token-line"><span class="token plain">            //设置电路初始状态</span></div><div class="token-line"><span class="token plain">            #10 clk = 0; ena = 0; opcode = 2&#x27;b00;</span></div><div class="token-line"><span class="token plain">                data1 = 8&#x27;d0; data2 = 8&#x27;d0;</span></div><div class="token-line"><span class="token plain">            #10 ena = 1;</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            //第一组测试</span></div><div class="token-line"><span class="token plain">            #10 data1 = 8&#x27;d8; data2 = 8&#x27;d6; //y = 8 + 5 = 14</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b01; // y = 8 - 6 = 2</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b10; // 8 &gt; 6 y = 1</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            //第二组测试</span></div><div class="token-line"><span class="token plain">            #10 data1 = 8&#x27;d127; data2 = 8&#x27;d127; opcode = 2&#x27;b00; //y = 127 + 127 = 254</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b01; //y = 127 - 127 = 0</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b10; // 127 == 127 y = 0</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            //第三组测试</span></div><div class="token-line"><span class="token plain">            #10 data1 = -8&#x27;d128; data2 = -8&#x27;d128; opcode = 2&#x27;b00; //y = -128 + -128 = -256</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b01; //y = -128 - (-128) = 0</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b10; // -128 == -128 y = 0</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            //第四组测试</span></div><div class="token-line"><span class="token plain">            #10 data1 = -8&#x27;d53; data2 = 8&#x27;d52; opcode = 2&#x27;b00; //y = -53 + 52 = -1</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b01; //y = -53 - 52 = -105</span></div><div class="token-line"><span class="token plain">            #20 opcode = 2&#x27;b10; //-53 &lt; 52 y = 2</span></div><div class="token-line"><span class="token plain">            </span></div><div class="token-line"><span class="token plain">            #100 $finish;</span></div><div class="token-line"><span class="token plain">        end</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //产生时钟</span></div><div class="token-line"><span class="token plain">        always #`half_period clk = ~clk;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //实例化</span></div><div class="token-line"><span class="token plain">        alu m0(.ena(ena), .clk(clk), .opcode(opcode), .data1(data1), .data2(data2), .y(y));</span></div><div class="token-line"><span class="token plain">    endmodule</span></div></pre></div><p>在这个测试用例中，我们构造了一些测试数据来验证ALU模块功能是否正常，接下来我们就可以使用下面的命令对verilog源码进行语法检查，并生成可执行文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">iverilog -o my_alu alu_t.v alu.v</span></div></pre></div><p>生成了可执行文件之后，我们可以使用vvp命令生成.vcd格式的波形仿真文件。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">vvp my_alu</span></div></pre></div><p>接下来，我们再把生成好的波形文件aly_t.vcd拖入gtkwave中，就能看到ALU模块仿真出的波形图了。</p><p>读到这里你可能会疑惑，难道verilog不支持像C语言一样动态调试每一行代码吗？为什么要仿真出波形文件呢？</p><p>其实verilog当然是支持动态调试的，只不过因为硬件芯片在实际运行过程中，有很多逻辑单元都可以并行，如果仅仅依靠动态调试来分析是很困难的。所以在实际开发过程中，我们会先模拟芯片真实运行时的信号波形来进行仿真，才能保证芯片的可靠性。</p><p><img src="/images/httpsstatic001geekbangorgresourceimagec3a9c3b905f03abe1daf6cf3f24fb54e41a9.jpg" alt="" title="verilog仿真"/></p><p>在仿真图波行的signals信号窗口，我们可以看到，ALU在每一个时刻入参和出参都和我们预期是一致的，这说明我们已经正确实现了一个N位的ALU模块。</p><h2 id="现代cpu加速的套路"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#现代cpu加速的套路"><span class="icon icon-link"></span></a>现代CPU加速的套路</h2><p>可能动手体会之后你还是意犹未尽，这是因为这样实现的模块其实还只是一个入门级的低性能ALU。上面的例子也只是为了帮你领会原理，因为追求极致的功耗、性能，所以现在我们使用的手机、电脑中的CPU基本上都不会设计得如此简单。</p><p>因此，如果想要更好使用CPU的机制来设计OS，我们还需要知道真实的工业级CPU如何解决问题，看看它们是如何做到动辄几GHZ的超高性能的。我为你梳理了常见的五种加速套路：</p><h3 id="更多的硬件指令"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#更多的硬件指令"><span class="icon icon-link"></span></a>更多的硬件指令</h3><p>我们前面实现的ALU只实现了三种功能，然而实际真实的CPU还会实现乘法、除法、逻辑运算、浮点数运算等等很多硬件指令。这样就可以在一个时钟周期内实现更多的功能，从而提高效率。</p><h3 id="通过缓存来提高数据装载效率"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#通过缓存来提高数据装载效率"><span class="icon icon-link"></span></a>通过缓存来提高数据装载效率</h3><p>在现代计算机体系中，由于磁盘、RAM、CPU寄存器之间的读写性能开销差别是非常大的，所以在现代CPU在设计的时候会在CPU内设计多级缓存，从而提高指令读写的速度。</p><h3 id="流水线乱序执行与分支预测"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#流水线乱序执行与分支预测"><span class="icon icon-link"></span></a>流水线乱序执行与分支预测</h3><p>我们发现，前面抽象出的CPU运行的6个步骤其实是串行执行的，而现实世界却不一样，其实计算机内的很多算法可以不按顺序并行执行的。</p><p>既然提到了并行，不难联想到我们之前讲的多线程技术。但是多线程开发显然需要对程序做出更多优秀的设计，才能充分利用多核的性能，想要实现比较困难。</p><p>那么有没有办法，在不改造程序的前提下充分利用多核的资源呢？答案就是用<strong>空间资源换时间</strong>。硬件层面把程序由解码器电路拆解成多步，调度到CPU的不同核心上并行、乱序执行。</p><p>比如，加法器在做加法运算的同时，乘法器不应该被闲置，应该也可以执行一些乘法指令。这样我们就可以把程序切分成多个可以并行运行的指令，以此来大幅提升性能了。</p><p>当然，形成流水线之后，理想情况就是所有被切分出来的指令都是正确的，这样就可以并行运算了。可惜事情并没有那么简单，因为我们的程序有可能走入了其他分支，后面的运算要依赖前边的结果才能运行。这时候，我们就需要引入分支预测器这个电路，尽可能猜对后面要执行的指令，这样正确切分指令从而提高并行度。</p><p>但一旦分支预测器预测失败，就需要重新刷新流水线，让指令顺序执行，这显然就会增加额外的时钟开销，造成性能损失。不过好消息是目前的分支预测器的准确率已经可以达到90%以上了。</p><h3 id="多核心cpu"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#多核心cpu"><span class="icon icon-link"></span></a>多核心CPU</h3><p>随着单核心CPU的不断优化，我们会发现单核心下的CPU遇到了工艺等各种原因造成的瓶颈，很难再有更高的性能提升了。</p><p>所以，聪明的工程师又想到了提高并行度的经典套路，将多个CPU核心集成到了一颗芯片上。这时候每个CPU都有独立的ALU、寄存器、L1-L3多级缓存，但多个核心共用了同一条内存总线来操作内存。说到这里，反应快的同学可能会隐约感觉到哪里有些不妥了。</p><p>没错，因为内存中的数据被缓存到了CPU的多级缓存中，CPU的多个核心是并行操作数据的，这时如果没有额外的设计的保障机制，就很可能导致并行读写数据引起的数据一致性问题，也就是出现脏数据。</p><p>为了解决缓存一致性问题，工程师们又发明出了MESI、MOESI等缓存一致性协议来解决这个问题。</p><h3 id="超线程"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#超线程"><span class="icon icon-link"></span></a>超线程</h3><p>我们发现前边整理的CPU核心组件的6个步骤，如果再进一步抽象，又可以简化的分为取指令和执行两部分。这时候我们发现，其实大部分指令在执行的过程中都不一定会占用所有的芯片资源的。</p><p>所以，出于尽可能的“压榨”硬件资源的考量，工程师们又设计了额外的逻辑处理单元用来保证多个可执行程序可以共享同一个CPU内的资源。当然，如果两个程序同时操作同一个资源（如某一个加法器）的时候，也是需要暂停一个程序进行避让的。</p><h2 id="谈谈指令集"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#谈谈指令集"><span class="icon icon-link"></span></a>谈谈指令集</h2><p>从前面ALU的设计过程中，我们发现如果设计一个芯片模块，首先是要根据分析的需求抽象出对应的opcode等指令，而众多约定好的指令则构成了这款芯片的指令集。那么常见的CPU指令集都有哪些呢，让我们一起来看看吧。</p><h3 id="cisc"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#cisc"><span class="icon icon-link"></span></a>CISC</h3><p>复杂指令集Complex Instruction Set Computer简写为CISC，其实计算机早期发展的时候还是比较粗暴的，后来大家发现，让硬件实现更多指令可以有效降低软件运行时间，就疯狂地给硬件芯片设计工程师提需求。</p><p>于是越来越多的奇奇怪怪的指令被加入了CPU，最后指令不但越来越多，还越来越复杂。并且为了实现这些指令不但占用了大量的硬件资源，而且长度还不一致，这些都给以后的扩展以及性能优化挖了不少的坑。</p><p>挖坑总要后面填坑的，甚至Intel X86系列这个经典的CISC指令集的CPU，现在也是通过设计译码器，把变长的IA32指令翻译成简单的微代码，然后交给类似RISC的简单微操作来执行。这在某些层面上，也许也意味着CISC指令集巨头的一次叛逃。</p><h3 id="risc"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#risc"><span class="icon icon-link"></span></a>RISC</h3><p>精简指令集Reduced Instruction Set Computer，简写为RISC。经历了CISC指令集带来的问题，研究人员就对现代计算机运行的指令做了统计和分析，结果发现大部分的程序在大部分情况下，都在运行一小部分指令。</p><p>所以工程师就提出了一个大胆的假设，我们通过少部分相对简短且长度统一的指令集来替代CISC，这样同样能满足所有程序的需求。经过大量论证和实验后，人们发现这样不但解决了CISC指令带来的痛点，还带来了不少性能提升。</p><h3 id="arm与m1芯片"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#arm与m1芯片"><span class="icon icon-link"></span></a>ARM与M1芯片</h3><p>后来ARM应运而生，ARM，是Advanced RISC Machine的缩写。看名字我们就知道。这是一个精简指令集的CPU。</p><p>早期很多CPU都是封闭的，要想设计一款新的CPU只能从头设计，这显然需要极高的成本投入。这时候ARM公司就抓住了市场痛点，ARM公司只做指令集和CPU的设计，然后付费授权（当然，授权费还是挺贵的）给各个厂商，由厂商根据自己的需求再去定制和生产。</p><p>由于ARM相对开放的态度，以及RISC指令集带来的高性能、低功耗、低成本特点，让它迅速从嵌入式领域杀进了移动设备、PC，甚至超级计算机领域。在2020年末，M1芯片一经上市测评数据便刷爆朋友圈，以致于Intel、AMD这些传统CPU在相同功耗的情况下性能被完全吊打，那么苹果到底使用了什么黑科技呢？</p><p>首先，苹果的M1芯片也是基于ARM架构的，它采用了AArch64架构的ARMv8-A指令集，是由台积电采用5nm工艺代工生产的，在芯片内集成了160亿个晶体管。显然，它在继承了ARM优点的同时，还能享受到更先进的芯片制程带来的高性能与低功耗。</p><p>而仅仅单纯继承ARM的优势其实还是不够的，因此M1芯片还额外引入了如增加解码器电路、统一内存架构、MCU等多种优化方式来进行设计。接下来，让我们来看一下苹果具体是如何做的：</p><p>根据我们之前提到了流水线和乱序执行的原理不难推断，<strong>解码器和CPU指令的缓冲空间大小会影响CPU的程序并行计算能力</strong>。</p><p>所以，苹果工程师在设计的时候，将解码器增加到了8个（而AMD、Intel的解码器一般只有4个）。同时，M1芯片的指令缓冲空间也比常见的CPU大了3倍。你可能会好奇，为啥X86系列的CPU不能多增加点解码器呢？</p><p>其实这就是ARM的RISC指令集的优势了。因为在ARM中，每条指令都是4个字节解码器，进行切分处理很容易；而X86的每条指令长度可以是1到15字节。这就导致了解码器不知道下一条指令是从哪里开始的，需要实际分析每条指令才可以，这就增加了解码器电路的复杂度。</p><p>有了提高并行能力的基础，多核心也是必须的。根据<a target="_blank" rel="noopener noreferrer" href="https://www.anandtech.com/show/16252/mac-mini-apple-m1-tested">AnandTech分享<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的资料来看，M1芯片内包含了4个3.2GHz的高性能Firestorm核心和4个0.6～2.064 GHz的低功耗Icestorm核心，这也为M1芯片在各种功耗下进行并行计算提供了基础。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage110f1122c45ae261b067d20e38ede2023f0f.png" alt="" title="M1芯片"/></p><p>我们观察上图可以发现M1芯片还集成了苹果自行设计的8个GPU核心。对手机芯片有了解的同学可能会觉得，高通之类的芯片也集成了GPU呀，这里有什么区别呢？其实这里引入了<strong>统一内存</strong>（Unified memory）的设计。</p><p>传统的做法是如果CPU要和GPU之间传输数据，需要通过PCIe总线在CPU和GPU的存储空间内来回传递。</p><p>这就好比你有两个水杯，但互相倒水只能靠一个很细的吸管。而统一内存则是可以让CPU和GPU等组件共享同一块内存空间，这时候CPU要想传递数据，只需要写入内存之后通知GPU说：“嗨，哥们儿，你要的数据在某个地址空间，你自己直接用就好了。”这样就避免了通过PCIe总线传递数据的开销。</p><p>最后，我想提醒你注意这一点，它非常重要，<strong>严格讲，M1芯片其实并不是CPU</strong>。M1芯片其实是包含了CPU、GPU、IPU、DSP、NPU、IO控制器、网络模块、视频编解码器、安全模块等很多异构的处理器共同组成的系统级（SOC）芯片。</p><p>这样做的好处就是不需要在主板上通过各种总线来回传输数据，同时也避免了额外的信号、功耗开销。既然SOC的思路这么好，传统厂商为什么没有跟进呢？</p><p>原因在于商业模式不同，传统厂商生产CPU，但GPU、网卡、主板等模块是交由其他厂商生产，最终由专门的公司组装成一台计算机才对外销售。而Apple为代表的厂商的业务模式则是自己就有全产业链的整合能力，可以直接设计、交付整机。所以，不同的业务模式最终催生出了不同技术的方案。</p><h2 id="重点回顾"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#重点回顾"><span class="icon icon-link"></span></a>重点回顾</h2><p>通过这节课的学习，我们明白了对于设计一款操作系统而言，对硬件的理解与把控能力非常重要。而硬件中很关键的一个组件就是CPU，我们一起分析了一个CPU的基本组成和运行步骤。</p><p>接着，为了把原理落地，我们一起实现了一个ALU，带你加深了对CPU原理的理解。之后我们还了解了现代CPU的发展历程以及设计思路，并分析了CISC、RISC指令的区别，以及基于ARM指令集的M1芯片的特点。</p><p>苹果的M1芯片，它在继承了ARM优点的同时，还做了很多优化，比如增加解码器提高并行计算能力，利用提高指令缓存空间的机制提升了指令加载与计算的效率，还引入了<strong>统一内存</strong>的巧妙设计。</p><p>在看到这些优势的同时，我们不妨发散思维，想一想为什么这些想法之前没有实现，这其实和业务模式息息相关。</p><p>最后，我特意为你梳理了这节课的导图，帮你巩固记忆。</p><p><img src="/images/httpsstatic001geekbangorgresourceimage026e0241c66ee023b45yy7f790e13bfe226e.jpg" alt=""/></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-base/操作系统实战45讲/13.番外篇虚化的世界/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>除了ARM指令集，如果想开发一款CPU，我们还有更好的RISC指令集可选么？</p><p>欢迎你在留言区和我交流。也欢迎你把这节课分享给有需要的朋友，说不定就能帮他搞懂CPU的原理。</p><p>我是LMOS，我们下节课见！</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/操作系统实战45讲/13.番外篇虚化的世界/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 17:35:24</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-base/umi.js"></script>
  </body>
</html>
