exports.category = "computer";
exports.title = "程序员数学基础";
exports.data = [
  {
    chapterTitle: "开篇词 (1讲)",
    children: [
      {
        title: "开篇词 | 作为程序员，为什么你应该学好数学？",
        herf: "https://time.geekbang.org/column/article/70844",
        id: "70844",
        content:
          '<p>你好，我是黄申，目前在LinkedIn从事数据科学的工作，主要负责全球领英的搜索引擎优化，算法和数据架构的搭建。</p><p>2006年，我博士毕业于上海交通大学计算机科学与工程专业，在接下来十余年时间里，我曾经在微软亚洲研究院、IBM研究院、eBay中国研发中心做机器学习方向的研究工作，也负责过大润发飞牛网和1号店这两家互联网公司的核心搜索和推荐项目，还写过一本书《大数据架构商业之路》。</p><p>对于数学和计算机编程的联系，我之前也没有思考过。直到有一次，在硅谷的一个技术交流Meetup上，我听到一位嘉宾分享说：“如果你只想当一个普通的程序员，那么数学对你来说，并不重要。但是如果你想做一个顶级程序员，梦想着改变世界，那么数学对你来说就很重要了。”</p><p>听完这句话，我马上感受到强烈的共鸣，因为就我自己的工作经历而言，越是往高处走，就越能发现数学的重要性。我知道，数学对于我们每一个程序员来说，都是最熟悉的陌生人。你从小就开始学习数学，中考、高考、研究生考试还要考数学，所以那些熟悉的数学定理、数学公式，陪伴你至少也有10年时间了。</p><p>但是，自从做了程序员，你可能早就把数学抛在了脑后，甚至觉得曾经为了应试而“硬学”的数学应该是彻底没什么用了，终于可以和他们say goodbye了。毕竟作为一个基础学科，数学肯定是没操作系统、数据结构、计算机网络这样的课程看起来“实用”。</p><!-- [[[read_end]]] --><p>起码我之前就是这么认为的。大学的时候，我非常喜欢编程，甚至还翘过数学课，专门在图书馆看计算机类的图书。那会儿我觉得，数学这东西，完全就是应试教育，我更喜欢计算机这样操作类的课程，不喜欢待在教室里听数学老师讲那些枯燥的理论和定理。</p><p>再到后来，我读了硕士，开始接触机器学习，猛然间才发现，机器学习表面上是“写程序”，但实际上剥去外表，本质上就是在研究数学。从那会儿开始，我对数学的认知也才逐步客观和理性起来。</p><p>再到现在，我参加了工作，写了这么多年代码，我想说，数学学得好不好，将会直接决定一个程序员有没有发展潜力。因为往大了说，<strong>数学它其实是一种思维模式，考验的是一个人归纳、总结和抽象的能力</strong>。把这个能力放到程序员的世界里，其实就是解决问题的能力。</p><p>往小了说，不管是数据结构与算法还是程序设计，其实底层很多原理或者思路都是源自数学，所以很多大公司，在招人时，也会优先考虑数学专业的毕业生，这些人他们数学基础很好，学起编程也更容易上手。</p><p>所以我觉得，<strong>如果编程语言是血肉，数学的思想和知识就是灵魂</strong>。它可以帮助你选择合适的数据结构和算法、提升系统效率、并且赋予机器智慧。尤其是在大数据和智能化的时代，更是如此。</p><p>举个例子，比如我们小学就学到的余数，其实在编程的世界里也有很多应用。你经常用到的分页功能，根据记录的总条数和每页展示的条数，最后来计算整体的页数，这里面就会有余数的思想。再难一点，奇偶校验、循环冗余检验、散列函数、密码学等等都有余数相关的知识。</p><p>遇到这些问题的时候，你能说你不懂余数吗？我想你肯定懂，只是很多时候没有想到可以用余数的思想来解决相关问题罢了。那为什么没有想到呢？我认为，本质原因还是你没有数学思维，还是你数学的基础不够好。</p><p>所以，在这个专栏里，我想和你重点聊聊数学。当然，我知道数学博大精深，所以在一开始做专栏的时候，我就和极客时间团队一起定义好了专栏的边界，用一句话来说就是“<strong>只做程序员需要学的数学知识</strong>”。</p><p>首先，我梳理了编程中最常用的数学概念，由浅入深剖析它们的本质，希望能够帮你彻底掌握这些最基础、也最核心的数学知识。其中包括那些你曾经熟悉的数学名词，比如数学归纳法、迭代法、递归、排列、组合等等。</p><p>其次，我把线性代数和概率统计中的抽象概念、公式、定理都由内而外地讲了出来，并分析它们在编程中的应用案例，帮助你提升编程的高阶能力。对于这些内容，我会从基本的概念入手，结合生活和工作中的实际案例，让你更轻松地理解概念的含义。</p><p>比如，对于朴素贝叶斯方法，我会从基本的随机现象、随机变量和概率分布等着手。随后，我会逐步深入，结合这些数学知识在编程算法中的应用进行展开。比方说，贝叶斯定理是什么，随机变量之间的独立性是什么，这些是如何构成朴素贝叶斯方法的，而最终朴素贝叶斯又是如何被运用在机器学习的分类算法之中的。</p><p><img src="https://static001.geekbang.org/resource/image/72/61/7288e9715163adb95f7047ae0c263a61.jpg?wh=1142*856" alt=""></p><p>这样的讲解路线，既能让你巩固基础的概念和知识，同时也能让你明白这些基础性的内容，对计算机编程和算法究竟意味着什么。</p><p>不过话又说回来，我认为数学理论和编程实践的结合其实是“决裂”的，所以学习数学的时候，你不能太功利，觉得今天学完明天就能用得着，我觉得这个学习思路可以用在其他课程上，但放在数学里绝对不合适。</p><p>因为数学知识总是比较抽象，特别是概率统计和线性代数中的概率、数据分布、矩阵、向量等概念。它们真的很不好理解，也需要我们花时间琢磨，但是对于高级一点的程序设计而言，特别是和数据相关的算法，这些概念就非常重要了，这可都是先人总结出来的经验。</p><p>如果你能够将这些基本概念和核心理论都搞懂、搞透，那么面对系统框架设计、性能优化、准确率提升这些难题的时候，你就能从更高的角度出发去解决问题，而不只是站在一个“熟练工”的视角，去增删改查。</p><p>最后，我希望数学能够成为你的一种基础能力，希望这个专栏能帮你用数学思维来分析问题和解决问题。数学思想是启发我们思维的中枢，如果你对数学有更好的理解，遇到问题的时候就能追本溯源，快、准、稳地找到解决方案。</p><p>伽利略曾经说过，“宇宙这本书是用数学语言写成的”，数学是人类科学进步的重要基础，所以，你我都要怀着敬畏的心态去学习、思考数学。同样，我还要求我自己的孩子一定要学好数学，因为我确信，这对于他未来的发展来说，至关重要。</p><p>编程的世界远不止条件和循环语句，程序员的人生应当是创造的舞台。我希望，通过这个专栏的学习，能够让你切实感受到数学这个古老学科的活力和魅力。</p><p>好了，说了这么多，相信你已经下定决心和我一起攻克数学。重新开始就要告别过去，你可以在留言区做个“<strong>数学学习复盘</strong>”，在之前的学习过程中，你的学习状况是怎样的？你遇到的最大困难是什么？现在，你最希望学到的是什么？</p><p>Now，你说，我听！</p>',
        article_title: "开篇词 | 作为程序员，为什么你应该学好数学？",
      },
    ],
  },
  {
    chapterTitle: "导读 (1讲)",
    children: [
      {
        title: "导读：程序员应该怎么学数学？",
        herf: "https://time.geekbang.org/column/article/71139",
        id: "71139",
        content:
          '<p>你好，我是黄申。</p><p>在开篇，我详细讲了程序员为什么需要学数学。那么，怎样的学习方法才是行之有效的呢？我想你现在心里还没有一个固定的答案，而我不想一味地去讲我自己的一家之言，毕竟没有什么学习方法是最好的。</p><p>你能做的是要多看，去找适合自己的。而我能做的，就是尽量给你更多的参考，让你可以自己来选择。所以，我邀请了几位朋友，让他们来谈一谈，自己学习数学的一些心得体会，希望对你有所启发。</p><hr></hr><h2>刘超 | 《趣谈网络协议》专栏作者：“学数学就像学一门新技术”</h2><p><img src="https://static001.geekbang.org/resource/image/55/dc/55cf58a8e2f6b8cad30b898fb93c0edc.jpg" alt=""></p><p>程序员是否需要学好数学？原本学数学分析、概率论、线性代数的时候，我也没想到数学和写程序有啥关系，但是随着研究的开源软件越来越多，我发现很多技术深入下去，本质就是数学。</p><p>程序员应该怎么学习数学呢？我不建议你将大学的数学书拿出来啃一遍，一来耗费大量时间，二来和实际应用结合不起来，往往该看的忽略了，不该看的费了半天劲用不上，过一阵又忘了。</p><p>我们了解一个新技术有三个阶段，第一阶段是，怎么使用；第二阶段是，如何实现，原理是什么；第三阶段是，为什么这样实现。<strong>学数学和学一门新技术一样，也有这样三个阶段，先用起来，了解原理，然后了解为什么。</strong></p><p>用一句话来说，我们不能为了数学而学数学，学数学要和具体的应用结合在一起。</p><!-- [[[read_end]]] --><hr></hr><h2>徐文浩 | bothub.ai创始人：“先广度，再深度”</h2><p><img src="https://static001.geekbang.org/resource/image/8e/a5/8ee01d9d173aff3a2ec52b138b22bea5.jpg" alt=""></p><p>随着过去几年深度学习成为程序员界的显学，不少程序员开始回头复习微积分、概率论和线性代数这样的基础数学课，乃至开始学习最优化、博弈论这样的应用数学课。我自己则是因为从2010年一头扎入了计算广告的大坑之后，重新开始学习数学。</p><p>可以说，这次重新学习数学，为我自己推开了程序世界中另一扇门，使得我在埋头具体写代码之外，有机会重新从另一个角度，去认识和理解“<strong>程序</strong>”和“<strong>问题的解决方案</strong>”这两件事情。</p><h3>我为什么要学点数学?</h3><p>投入时间学习数学，于我来说主要是两个原因，一来，数学在工作中用得上；二来，学点数学很多时候是个有趣的事。</p><p>譬如说，过去几年火起来的深度学习，以及之前没那么火，但是实际上早早就在搜索、广告这些领域，应用的机器学习和推荐算法。这里面其实就是结合了微积分、线性代数、概率论之后的最优化问题。</p><p>事实上，大部分应用领域的核心解决方案，都是把应用领域的问题，形式化为一个个数学问题。在找到数学问题的“解法”之后，用写程序的方式翻译成实际应用的“算法”。而能够应用“数学”的方式来解决问题，是从一个只能套用现成方案的“码农”，向能够将新问题形式化、并找出创新解决方案的“研发工程师”迈出的第一步。</p><p>很多问题当你知道如何用数学来解决的时候，常常会有醍醐灌顶的感觉。譬如当我第一次搞明白，广告中的竞价问题，居然能够变成一个博弈论中“寻找上策均衡”的问题，并且能够通过简简单单的公式表示出来的时候，我是很有满足感的。</p><p>此外，一旦熟悉了机器学习中用到的数学知识，很多想要解决的系统问题，都能通过定义更好的数学优化目标，变成一个能够找到最优解的程序算法，最后通过写个程序，翻译成数学问题来解决，这个过程带给我巨大的身心愉悦。</p><h3>我是如何学数学的？</h3><p>数学整个领域很大，如果想要学点什么，我建议<strong>从工作相关的领域开始，先广度，再深度</strong>。</p><p>从工作相关的领域开始，是让自己一是能有实际用得上学到的知识的机会，二是日常工作中容易耳濡目染，相当于常常在复习。而先有广度，是让自己在心中有一个问题到解决方法的“地图”，遇到具体的问题能够对得上，容易获得正反馈；然后再有深度，具体去对一个特定的主题学习应用。</p><p>当开始深入学一个特定问题的时候，最好的方式是，<strong>追一门在线课程</strong>，譬如Coursera、TEDx，或者在极客时间上找一门课程来学习。</p><p>这是因为，在线课程有明确的节奏，通常还会提供作业和测验。通过作业和测验，让自己对自己的学习有一个联系和反馈的过程。即使实践中没有足够的应用，过一段时间有些知识没有那么熟悉了，但是也容易建立自己很快可以“捡”回来的信心，降低“复习”的启动成本。跟随在线课程的节奏，可以有效避免“三天打渔两天晒网”的恶习，让学习有始有终。</p><p>最后，给你介绍一个有程序员特色的学习方法，<strong>针对学习的内容写一点程序</strong>。把正在学习的问题的解法，写一个算法实现出来。这是一个非常有效的练习方式。譬如学习线性代数，理解仿射，反复读书的效率对我来说，就不如找来Coding The Matrix，通过写程序，让学习、理解变得更深入。</p><hr></hr><h2>王天一 | 《人工智能基础课》《机器学习40讲》专栏作者：“数学是工具而非问题，是手段而非目的”</h2><p><img src="https://static001.geekbang.org/resource/image/38/8e/38b36cabfce40361cf343d22c9a8388e.jpg" alt=""></p><p>在数学的学习中，首要的问题是<strong>明确需求</strong>。作为非数学专业出身的“外行”，我们使用数学的目的不是顶天，而是立地；不是上下求索艰深的理论问题，而是将生活中的具体问题抽象化，进而加以解决。</p><p>因此，对于我们这些票友来说，学习数学的基础在于经验而非哲学，比较实际的思路是秉持功利主义的原则，<strong>用多少学多少</strong>。掌握基本的线性代数与矩阵论、概率论与数理统计知识足以应付日常的使用，盲目地好高骛远通常有害无益。理论化和公理化这些比较深邃的尝试固然让人着迷，但它们可能并没有肉眼可见的实用性，对于绝大部分计算机从业者恐怕过于阳春白雪。</p><p>其次，在学习时还要<strong>理解数学的本质</strong>。数学是工具而非问题，是手段而非目的。探索世界奥秘的学科是“格物穷理”的物理学，相形之下，数学更像是个任人打扮的小姑娘，它存在的意义就是通过合理的设计简化物理学的研究。</p><p>正因如此，在数学中存在着各种各样在现实中不可能出现的理想化模型（比如无穷小和极限的诞生），也存在着对同一个物理过程不同的建模方式（比如矩阵力学和波动力学）。充分理解数学的人造特质，可以在学习中少走很多无谓的弯路。</p><p>理解数学的工具属性就会自然而然地引出了数学学习中的另一个关键点，那就是工具设计的出发点，也就是所谓的<strong>数学思想与数学逻辑</strong>。</p><p>任何一个工具都不是平白无故地设计出来的，它必然要解决某个特定的问题，比如线性代数与矩阵论是对具体对象的抽象表示与运算，比如概率论和数理统计是对不确定性及其定型定量表示的建模。因此，在掌握每一种数学工具的微观技巧之前，理解它们的宏观目标是更加重要的。只有掌握了工具诞生的背景与目的，才有可能有效地使用它们。</p><p>在这里还要多说一句，<strong>数学绝不仅仅是算术，把主要精力放在计算上未免因小失大</strong>。在经典科幻《银河系漫游指南》中，超级计算机告诉人们，世界的终极答案是“42”——这更像是对数字主义者善意嘲讽的一个梗。但对算术的过度强调并不鲜见，在相当数量的现行数学教材中，讲解线性代数时开篇便给出行列式的计算方法，这种编排着实让人费解。</p><p>具体到数学每个子学科的学习方法上，相关的经验教训已然汗牛充栋，很多内容都无需在此赘言。但在我看来，学习时值得突出强调的一点是举一反三的能力。同一种工具及其背后的思想可以出现在不同的场景下，解决不同的问题，但是一旦深入到本质层面，就会发现它们实际上是相通的。如何透过现象看本质，将不同场景融会贯通，才是值得锻炼的高级能力。</p><p>同一个工具存在不同应用的例子不胜枚举：</p><ul>\n<li>\n<p>特征向量计算的是系统的不动点，在数据降维中有举足轻重的作用，但如果熟悉电子通信的话你就会知道，对线性时不变系统的分析（也就是各种变换）都是基于特征向量展开的；</p>\n</li>\n<li>\n<p>在给定隐马尔可夫模型的观测序列时，可以利用维特比算法求解后验概率最大的状态序列，将这一方法应用在信道编码中，就是最经典的卷积码译码算法；</p>\n</li>\n<li>\n<p>在分类问题中，以类间方差最大化为标准可以推导出线性判别分析和决策树等模型，应用在图像处理中，类间方差最大化原理给出的就是图像分割中的Otsu方法。</p>\n</li>\n</ul><p>凡此种种都说明，即使是不同的学科，使用的数学基础也有着千丝万缕的联系，将基本的数学概念和充分的想象力结合起来，触类旁通就变得轻而易举。</p><p>总结起来，我对数学学习的几点拙见是：<strong>把握数学的工具属性，学习具体方法时先溯因再求果，勤于思考解决相同问题的不同方法，与解决不同问题的相同方法之间的联系与区别</strong>。希望这几条建议能够在数学的学习中助你一臂之力。</p><hr></hr><p>好了，三位老师都分享完了自己的学习方法。其实他们有一个共同的观点，那就是数学要是“实用”的，这和我的想法如出一辙。</p><p>因此，我在这里绘制了一张“<strong>程序员的数学应用地图</strong>”，里面包含四个部分，分别是<strong>数据结构</strong>、<strong>编程语句</strong>、<strong>基础算法</strong>，以及<strong>机器学习算法</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/29/50/29d37a8eb43c1d007b15a938213a8b50.jpg" alt=""> </p><center><span class="reference">（长按保存后可查看大图）</span></center><p></p><p>我们来一起看看这张图里都有什么内容。</p><p>首先我们来看最常用的数据结构和编程语句，我想你对它们应该非常熟悉。在我眼里，这些基础的内容，同样富含了数学思维。例如，数组和链表就体现了迭代和递归的思想，判断语句就是使用了逻辑（布尔）代数。</p><p>对于架构在这些数据结构和编程语句之上的算法（为了将这些算法和机器学习的算法区分，我称其为通用算法），除了迭代和递归，也体现了排列、组合和动态规划等思想。</p><p>对于机器学习的算法而言，我们更需要理解概率统计和线性代数的核心思想，包括什么是概率、贝叶斯定理、数据的统计分布、向量、矩阵、线性方程等等。</p><p>整个专栏我基本上都是从数学的角度出发，逐步推进到这些知识在计算机中的应用。不过在绘制这张应用地图的时候，我特意反其道而行之，<strong>从计算机编程的角度出发，为你展示程序员应该如何看待编程中的数学知识</strong>。</p><p>我觉得在开始学习之前，这个地图会给你一个大体的认识，告诉你计算机领域常用的数学思想有哪些。这时，你也许会产生一些疑惑，同时你可以带着自己的思考和问题去逐篇学习。等你学完整个专栏之后，再回头来看看这个地图，应该会有更深的感触。我希望这种双向打通，能够进一步加强你的学习体验。</p><p>另外，我也整理了本专栏中涉及到的<a href="https://github.com/shuang790228/GeekTime-MathLecture-JavaCode">所有代码</a>，以方便你学习。</p><p>好了，听了这么多心得和方法，有没有什么地方是最触动你的呢？下一节我们就要进入正式的学习了，我想听你讲讲，你准备怎么来学习这门课呢？</p><p><span class="orange">欢迎留言和我分享，也欢迎点击“请朋友读”，把今天的内容分</span><span class="orange">享给你的朋友，和他一起精进。</span></p>',
        article_title: "导读：程序员应该怎么学数学？",
      },
    ],
  },
  {
    chapterTitle: "基础思想篇 (18讲)",
    children: [
      {
        title: "01 | 二进制：不了解计算机的源头，你学什么编程",
        herf: "https://time.geekbang.org/column/article/71840",
        id: "71840",
        content:
          '<p>我们都知道，计算机的起源是数学中的二进制计数法。可以说，没有二进制，就没有如今的计算机系统。那什么是二进制呢？为什么计算机要使用二进制，而不是我们日常生活中的十进制呢？如何在代码中操作二进制呢？专栏开始，我们就从计算机认知的起源——二进制出发，讲讲它在计算机中的“玄机”。</p><h2>什么是二进制计数法？</h2><p>为了让你更好地理解二进制计数法，我们先来简单地回顾一下人类计数的发展史。</p><p>原始时代，人类用路边的小石子，来统计放牧归来的羊只数量，这表明我们很早就产生了计数的意识。后来，罗马人用手指作为计数的工具，并在羊皮上画出Ⅰ、Ⅱ、Ⅲ来代替手指的数量。表示一只手时，就写成“Ⅴ”形，表示两只手时，就画成“ⅤⅤ”形等等。</p><p>公元3世纪左右，印度数学家（也有说法是阿拉伯人）发明了阿拉伯数字。阿拉伯数字由从0到9这样10个计数符号组成，并采取<strong>进位制法</strong>，高位在左，低位在右，从左往右书写。由于阿拉伯数字本身笔画简单，演算便利，因此它们逐渐在各国流行起来，成为世界通用的数字。</p><p>日常生活中，我们广泛使用的十进制计数法，也是基于阿拉伯数字的。这也是十进制计数法的基础。因此，相对其他计数方法，十进制最容易被我们所理解。</p><p>让我们来观察一个数字：2871。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/d9/3d/d99f094c432638924f8665a178162c3d.jpg" alt=""></p><p>其中^表示幂或次方运算。十进制的数位（千位、百位、十位等）全部都是10^n的形式。需要特别注意的是，任何非0数字的0次方均为1。在这个新的表示式里，10被称为十进制计数法的<strong>基数</strong>，也是十进制中“十”的由来。这个我想你应该好理解，因为这和我们日常生活的习惯是统一的。</p><p>明白了十进制，我们再试着用类似的思路来理解二进制的定义。我以二进制数字110101为例，解释给你听。我们先来看，这里110101究竟代表了十进制中的数字几呢？</p><p>刚才我们说了，十进制计数是使用10作为基数，那么二进制就是使用2作为基数，类比过来，<strong>二进制的数位就是2^n的形式</strong>。如果需要将这个数字转化为人们易于理解的十进制，我们就可以这样来计算：</p><p><img src="https://static001.geekbang.org/resource/image/c6/c0/c6ae1772d7bf369aa9939fc00ca7b5c0.jpg" alt=""></p><p>按照这个思路，我们还可以推导出八进制（以8为基数）、十六进制（以16为基数）等等计数法，很简单，我在这里就不赘述了。</p><p>至此，你应该已经理解了什么是二进制。但是仅有数学的理论知识是不够的，结合相关的代码实践，相信你会有更深刻的印象。</p><p>基于此，我们来看看二进制和十进制数在Java语言中是如何互相转换的，并验证一下我们之前的推算。我这里使用的是Java语言来实现的，其他主流的编程语言实现方式都是类似的。</p><p>这段代码的实现采用了Java的BigInteger类及其API函数，我都加了代码注释，并且穿插一些解释，你应该可以看懂。</p><p>首先，我们引入BigInteger包，通过它和Integer类的API函数进行二进制和十进制的互相转换。</p><pre><code>import java.math.BigInteger;\n\npublic class Lesson1_1 {\n  \n   /**\n\n    * @Description: 十进制转换成二进制\n    * @param decimalSource\n    * @return String\n    */\n    public static String decimalToBinary(int decimalSource) {\n       BigInteger bi = new BigInteger(String.valueOf(decimalSource)); //转换成BigInteger类型，默认是十进制\n       return bi.toString(2); //参数2指定的是转化成二进制\n    }\n\n    /**\n    * @Description: 二进制转换成十进制\n    * @param binarySource\n    * @return int\n    */\n    public static int binaryToDecimal(String binarySource) {\n       BigInteger bi = new BigInteger(binarySource, 2);  //转换为BigInteger类型，参数2指定的是二进制\n       return Integer.parseInt(bi.toString());     //默认转换成十进制\n    }\n}\n</code></pre><p>然后，我们通过一个十进制数和一个二进制数，来验证一下上述代码的正确性。</p><pre><code> public static void main(String[] args) {     \n\n      int a = 53;\n      String b = &quot;110101&quot;;\n      System.out.println(String.format(&quot;数字%d的二进制是%s&quot;, a, Lesson1_1.decimalToBinary(a))); //获取十进制数53的二进制数\n      System.out.println(String.format(&quot;数字%s的十进制是%d&quot;, b, Lesson1_1.binaryToDecimal(b))); //获取二进制数110101的十进制数\n\n   }\n\n</code></pre><p>这段代码运行的结果是：十进制数字53的二进制是110101，二进制数字110101的十进制是53。</p><p>好了，关于十进制和二进制的概念以及进制之间的相互转换，你应该都很清楚了。既然有十进制，又有二进制，你可能就要问了，为啥计算机使用的是二进制而不是十进制呢？</p><h2>计算机为什么使用二进制？</h2><p>我觉得，计算机使用二进制和现代计算机系统的硬件实现有关。组成计算机系统的逻辑电路通常只有两个状态，即开关的接通与断开。</p><p>断开的状态我们用“0”来表示，接通的状态用“1”来表示。由于每位数据只有断开与接通两种状态，所以即便系统受到一定程度的干扰时，它仍然能够可靠地分辨出数字是“0”还是“1”。因此，在具体的系统实现中，二进制的数据表达具有抗干扰能力强、可靠性高的优点。</p><p>相比之下，如果用十进制设计具有10种状态的电路，情况就会非常复杂，判断状态的时候出错的几率就会大大提高。</p><p>另外，二进制也非常适合逻辑运算。逻辑运算中的“真”和“假”，正好与二进制的“0”和“1”两个数字相对应。逻辑运算中的加法（“或”运算）、乘法（“与”运算）以及否定（“非”运算）都可以通过“0”和“1”的加法、乘法和减法来实现。</p><h2>二进制的位操作</h2><p>了解了现代计算机是基于二进制的，我们就来看看，计算机语言中针对二进制的位操作。这里的<strong>位操作</strong>，也叫作<strong>位运算</strong>，就是直接对内存中的二进制位进行操作。常见的二进制位操作包括向左移位和向右移位的移位操作，以及“或”“与”“异或”的逻辑操作。下面我们一一来看。</p><h3>向左移位</h3><p>我们先来看向左移位。</p><p>二进制110101向左移一位，就是在末尾添加一位0，因此110101就变成了1101010。请注意，这里讨论的是数字没有溢出的情况。</p><p>所谓<strong>数字溢出</strong>，就是二进制数的位数超过了系统所指定的位数。目前主流的系统都支持至少32位的整型数字，而1101010远未超过32位，所以不会溢出。如果进行左移操作的二进制已经超出了32位，左移后数字就会溢出，需要将溢出的位数去除。</p><p><img src="https://static001.geekbang.org/resource/image/cd/76/cdbeb658035f275aa941a0d3f6eac876.jpg" alt=""></p><p>在这个例子中，如果将1101010换算为十进制，就是106，你有没有发现，106正好是53的2倍。所以，我们可以得出一个结论：<strong>二进制左移一位，其实就是将数字翻倍</strong>。</p><h3>向右移位</h3><p>接下来我们来看向右移位。</p><p>二进制110101向右移一位，就是去除末尾的那一位，因此110101就变成了11010（最前面的0可以省略）。我们将11010换算为十进制，就是26，正好是53除以2的整数商。所以<strong>二进制右移一位，就是将数字除以2并求整数商的操作</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/8d/34/8df282639b609d5269582c789796c334.jpg" alt=""></p><p>下面我们来看看，用代码如何进行移位操作。</p><pre><code>import java.math.BigInteger;\n\npublic class Lesson1_2 {  \n\n   /**\n    * @Description: 向左移位\n    * @param num-等待移位的十进制数, m-向左移的位数\n    * @return int-移位后的十进制数\n    */\n   public static int leftShift(int num, int m) {\n      return num &lt;&lt; m;\n   }\n  \n   /**\n    * @Description: 向右移位\n    * @param num-等待移位的十进制数, m-向右移的位数\n    * @return int-移位后的十进制数\n    */\n   public static int rightShift(int num, int m) {\n      return num &gt;&gt;&gt; m;\n   } \n \n}\n</code></pre><p>然后，我们用一段测试代码验证下结果。</p><pre><code>public static void main(String[] args) {     \n\n      int num = 53;\n      int m = 1;\n      System.out.println(String.format(&quot;数字%d的二进制向左移%d位是%d&quot;, num, m, Lesson1_2.leftShift(num, m)));   //测试向左移位\n      System.out.println(String.format(&quot;数字%d的二进制向右移%d位是%d&quot;, num, m, Lesson1_2.rightShift(num, m)));   //测试向右移位     \n\n      System.out.println();\n     \n      m = 3;\n      System.out.println(String.format(&quot;数字%d的二进制向左移%d位是%d&quot;, num, m, Lesson1_2.leftShift(num, m)));   //测试向左移位\n      System.out.println(String.format(&quot;数字%d的二进制向右移%d位是%d&quot;, num, m, Lesson1_2.rightShift(num, m)));   //测试向右移位 \n\n   } \n\n</code></pre><p>这段代码的运行结果是：数字53向左移1位是106；数字53向右移1位是26。数字53向左移3位是424，数字53向右移3位是6。</p><p>我来解释一下。其中，移位1次相当于乘以或除以2，而移位3次就相当于乘以或除以8（即2的3次方）。细心的话，你可能已经发现，Java中的左移位和右移位的表示是不太一样的。</p><p><strong>左移位是&lt;&lt;，那右移位为什么是&gt;&gt;&gt;而不是&gt;&gt;呢？</strong>实际上，&gt;&gt;也是右移操作。简单来说，之所以有这两种表达方式，根本原因是Java的二进制数值中最高一位是符号位。这里我给你详细解释一下。</p><p>当符号位为0时，表示该数值为正数；当符号位为1时，表示该数值为负数。我们以32位Java为例，数字53的二进制为110101，从右往左数的第32位是0，表示该数是正数，只是通常我们都将其省略。</p><p><img src="https://static001.geekbang.org/resource/image/83/ef/831a21734048b1fc3e357609527175ef.jpg" alt=""></p><p>如果数字是-53呢？那么第32位就不是0，而是1。请注意我这里列出的是补码。</p><p><img src="https://static001.geekbang.org/resource/image/85/1e/857248d65d7c4b746b3677d45b2a2c1e.jpg" alt=""></p><p>那么这个时候向右移位，就会产生一个问题：对于符号位（特别是符号位为1的时候），我们是否也需要将其右移呢？因此，Java里定义了两种右移，<strong>逻辑右移</strong>和<strong>算术右移</strong>。逻辑右移1位，左边补0即可。</p><p><img src="https://static001.geekbang.org/resource/image/74/c7/745a4880417a4dcb62f88bad7be800c7.jpg" alt=""></p><p>算术右移时保持符号位不变，除符号位之外的右移一位并补符号位1。补的1仍然在符号位之后。</p><p><img src="https://static001.geekbang.org/resource/image/b0/07/b00b38ba0e8e2349a64b52905852e107.jpg" alt=""></p><p>逻辑右移在Java和Python语言中使用&gt;&gt;&gt;表示，而算术右移使用&gt;&gt;表示。如果你有兴趣，可以自己编码尝试一下，看看这两种操作符输出的结果有何不同。</p><p>在C或C++语言中，逻辑右移和算数右移共享同一个运算符&gt;&gt;。那么，编译器是如何决定使用逻辑右移还是算数右移呢？答案是，取决于运算数的类型。如果运算数类型是unsigned，则采用逻辑右移；而是signed，则采用算数右移。如果你针对unsigned类型的数据使用算数右移，或者针对signed类型的数据使用逻辑右移，那么你首先需要进行类型的转换。</p><p>由于左移位无需考虑高位补1还是补0（符号位可能为1或0），所以不需要区分逻辑左移和算术左移。</p><h3>位的“或”</h3><p>我们刚才说了，二进制的“1”和“0”分别对应逻辑中的“真”和“假”，因此可以针对位进行逻辑操作。</p><p>逻辑“或”的意思是，参与操作的位中只要有一个位是1，那么最终结果就是1，也就是“真”。如果我们将二进制110101和100011的每一位对齐，进行按位的“或”操作，就会得到110111。</p><p><img src="https://static001.geekbang.org/resource/image/83/15/8394b6daf1d9727069736506332c4915.jpg" alt=""></p><h3>位的“与”</h3><p>同理，我们也可以针对位进行逻辑“与”的操作。“与”的意思是，参与操作的位中必须全都是1，那么最终结果才是1（真），否则就为0（假）。如果我们将二进制110101和100011的每一位对齐，进行按位的“与”操作，就会得到100001。</p><p><img src="https://static001.geekbang.org/resource/image/b1/19/b1c520385f4e5a5b719c393f9e1d0019.jpg" alt=""></p><h3>位的“异或”</h3><p>逻辑“异或”和“或”有所不同，它具有排异性，也就是说如果参与操作的位相同，那么最终结果就为0（假），否则为 1（真）。所以，如果要得到1，参与操作的两个位必须不同，这就是此处“异”的含义。我们将二进制110101和100011的每一位对齐，进行按位的“异或”操作，可以得到结果是10110。</p><p><img src="https://static001.geekbang.org/resource/image/c7/87/c7ae84301b2742b6714c01a77e6a6b87.jpg" alt=""></p><p>我总结一下，“异或”操作的本质其实就是，所有数值和自身进行按位的“异或”操作之后都为0。而且要通过“异或”操作得到0，也必须通过两个相同的数值进行按位“异或”。这表明了两个数值按位“异或”结果为0，是这两个数值相等的必要充分条件，可以作为判断两个变量是否相等的条件。</p><p>接下来，我们来学习一下，在代码中如何实现二进制的逻辑操作。Java中使用|表示按位的“或”，&amp;表示按位“与”，^表示按位“异或”。</p><pre><code>import java.math.BigInteger;\n\npublic class Lesson1_3 {  \n\n   /**\n    * @Description: 二进制按位“或”的操作\n    * @param num1-第一个数字，num2-第二个数字\n    * @return 二进制按位“或”的结果\n    */\n   public static int or(int num1, int num2) {\n        \n      return (num1 | num2);\n     \n   }  \n\n   /**\n    * @Description: 二进制按位“与”的操作\n    * @param num1-第一个数字，num2-第二个数字\n    * @return 二进制按位“与”的结果\n    */\n   public static int and(int num1, int num2) {     \n   \n      return (num1 &amp; num2);\n     \n   } \n\n   /**\n\n    * @Description: 二进制按位“异或”的操作\n    * @param num1-第一个数字，num2-第二个数字\n    * @return 二进制按位“异或”的结果\n    */\n\n   public static int xor(int num1, int num2) {     \n\n      return (num1 ^ num2);\n     \n   }  \n\n\n}\n</code></pre><p>同样，我们写一段测试代码，验证一下上面三个函数。</p><pre><code> public static void main(String[] args) {\n\n      int a = 53;\n      int b = 35;\n\n      System.out.println(String.format(&quot;数字%d(%s)和数字%d(%s)的按位‘或’结果是%d(%s)&quot;,\n            a, decimalToBinary(a), b, decimalToBinary(b), Lesson2_3.or(a, b), decimalToBinary(Lesson1_3.or(a, b)))); //获取十进制数53和35的按位“或”     \n\n      System.out.println(String.format(&quot;数字%d(%s)和数字%d(%s)的按位‘与’结果是%d(%s)&quot;,\n            a, decimalToBinary(a), b, decimalToBinary(b), Lesson2_3.and(a, b), decimalToBinary(Lesson1_3.and(a, b))));  //获取十进制数53和35的按位“与”     \n\n      System.out.println(String.format(&quot;数字%d(%s)和数字%d(%s)的按位‘异或’结果是%d(%s)&quot;,\n            a, decimalToBinary(a), a, decimalToBinary(a), Lesson2_3.xor(a, a), decimalToBinary(Lesson1_3.xor(a, a))));  //获取十进制数53和35的按位“异或”     \n\n   } \n\n\n</code></pre><p>这段代码的运行结果是：数字53(110101)和数字35(100011)的按位‘或’结果是55(110111)，数字53(110101)和数字35(100011)的按位‘与’结果是33(100001)，数字53(110101)和数字53(110101)的按位‘异或’结果是0(0)。</p><h2>小结</h2><p>今天我们聊了二进制，你可能会问：学习二进制究竟有什么用呢？平时的编程中，我们好像并没有使用相关的知识啊？确实，目前的高级语言可以帮助我们将人类的思维逻辑转换为使用0和1的机器语言，我们不用再为此操心了。但是，二进制作为现代计算机体系的基石，这些基础的概念和操作，你一定要非常了解。</p><p>二进制贯穿在很多常用的概念和思想中，例如逻辑判断、二分法、二叉树等等。逻辑判断中的真假值就是用二进制的1和0来表示的；二分法和二叉树都是把要处理的问题一分为二，正好也可以通过二进制的1和0来表示。因此，理解了二进制，你就能更加容易地理解很多计算机的数据结构和算法，也为我们后面的学习打下基础。</p><p><img src="https://static001.geekbang.org/resource/image/20/74/209f1b06efdf9a7413fb793571c7ed74.jpg" alt=""></p><h2>思考题</h2><p>如果不使用Java语言自带的BigInteger类，我们还有什么方法来实现十进制到二进制的转换呢？（提示：可以使用二进制的移位和按位逻辑操作来实现。）</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "01 | 二进制：不了解计算机的源头，你学什么编程",
      },
      {
        title: "02 | 余数：原来取余操作本身就是个哈希函数",
        herf: "https://time.geekbang.org/column/article/72163",
        id: "72163",
        content:
          '<p>你好，我是黄申。今天我们来聊聊“余数”。</p><p>提起来余数，我想你肯定不陌生，因为我们生活中就有很多很多与余数相关的例子。</p><p>比如说，今天是星期三，你想知道50天之后是星期几，那你可以这样算，拿50除以7（因为一个星期有7天），然后余1，最后在今天的基础上加一天，这样你就能知道50天之后是星期四了。</p><p>再比如，我们做Web编程的时候，经常要用到分页的概念。如果你要展示1123条数据，每页10条，那该怎么计算总共的页数呢？我想你肯定是拿1123除以10，最后得到商是112，余数是3，所以你的总页数就是112+1=113，而最后的余数就是多出来，凑不够一页的数据。</p><p>看完这几个例子，不知道你有没有发现，<strong>余数总是在一个固定的范围内</strong>。</p><p>比如你拿任何一个整数除以7，那得到的余数肯定是在0～6之间的某一个数。所以当我们知道1900年的1月1日是星期一，那便可以知道这一天之后的第1万天、10万天是星期几，是不是很神奇？</p><p>你知道，整数是没有边界的，它可能是正无穷，也可能是负无穷。但是余数却可以通过某一种关系，让整数处于一个确定的边界内。我想这也是人类发明星期或者礼拜的初衷吧，任你时光变迁，我都是以7天为一个周期，“周”而复始地过着确定的生活。因为从星期的角度看，不管你是哪一天，都会落到星期一到星期日的某一天里。</p><!-- [[[read_end]]] --><p>我们再拿上面星期的例子来看。假如今天是星期一，从今天开始的100天里，都有多少个星期呢？你拿100除以7，得到商14余2，也就是说这100天里有14周多2天。换个角度看，我们可以说，这100天里，你的第1天、第8天、第15天等等，在余数的世界里都被认为是同一天，因为它们的余数都是1，都是星期一，你要上班的日子。同理，第2天、第9天、第16天余数都是2，它们都是星期二。</p><p>这些数的余数都是一样的，所以被归类到了一起，有意思吧？是的，我们的前人早已注意到了这一规律或者特点，所以他们把这一结论称为<strong>同余定理</strong>。简单来说，就是两个整数a和b，如果它们除以正整数m得到的余数相等，我们就可以说a和b对于模m同余。</p><p>也就是说，上面我们说的100天里，所有星期一的这些天都是同余的，所有星期二的这些天就是同余的，同理，星期三、星期四等等这些天也都是同余的。</p><p>还有，我们经常提到的奇数和偶数，其实也是同余定理的一个应用。当然，这个应用里，它的模就是2了，2除以2余0，所以它是偶数；3除以2余1，所以它是奇数。2和4除以2的余数都是0，所以它们都是一类，都是偶数。3和5除以2的余数都是1，所以它们都是一类，都是奇数。</p><p>你肯定会说，同余定理就这么简单吗，这个定理到底有什么实际的用途啊？其实，我上面已经告诉你答案了，你不妨先自己思考下，同余定理的意义到底是什么。</p><p>简单来说，<strong>同余定理其实就是用来分类的</strong>。你知道，我们有无穷多个整数，那怎么能够全面、多维度地管理这些整数？同余定理就提供了一个思路。</p><p>因为不管你的模是几，最终得到的余数肯定都在一个范围内。比如我们上面除以7，就得到了星期几；我们除以2，就得到了奇偶数。所以按照这种方式, 我们就可以把无穷多个整数分成有限多个类。</p><p>这一点，在我们的计算机中，可是有大用途。</p><p>哈希（Hash）你应该不陌生，在每个编程语言中，都会有对应的哈希函数。哈希有的时候也会被翻译为散列，简单来说，它就是<strong>将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出</strong>。这话听着是不是有点耳熟？我们上面的求余过程不就是在做这事儿吗？</p><p>举个例子，假如你想要快速读写100万条数据记录，要达到高速地存取，最理想的情况当然是开辟一个连续的空间存放这些数据，这样就可以减少寻址的时间。但是由于条件的限制，我们并没有能够容纳100万条记录的连续地址空间，这个时候该怎么办呢？</p><p>我们可以考察一下，看看系统是否可以提供若干个较小的连续空间，而每个空间又能存放一定数量的记录。比如我们找到了100个较小的连续空间，也就是说，这些空间彼此之间是被分隔开来的，但是内部是连续的，并足以容纳1万条记录连续存放，那么我们就可以使用余数和同余定理来设计一个散列函数，并实现哈希表的结构。</p><p>那这个函数应该怎么设计呢？你可以先停下来思考思考，提醒你下，你可以再想想星期几的那个例子，因为这里面用的就是余数的思想。</p><p><img src="https://static001.geekbang.org/resource/image/f1/8d/f156cef76582b3ee77b038cd2347968d.jpg" alt=""></p><p>下面是我想到的一种方法：</p><p><img src="https://static001.geekbang.org/resource/image/b3/58/b32e791f822044f579b80ad2cfe48c58.jpg" alt=""></p><p>在这个公式中，x表示等待被转换的数值，而size表示有限存储空间的大小，mod表示取余操作。<strong>通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后根据这个新的数值，来确定将数据存放在何处。</strong></p><p>具体来说，我们可以通过记录标号模100的余数，指定某条记录存放在哪个空间。这个时候，我们的公式就变成了这样：</p><p><img src="https://static001.geekbang.org/resource/image/fe/ac/fe96e521ed9d0a574ddaeeb0f00bbaac.jpg" alt=""></p><p>假设有两条记录，它们的记录标号分别是1和101。我们把这些模100之后余数都是1的，存放到第1个可用空间里。以此类推，将余数为2的2、102、202等，存放到第2个可用空间，将100、200、300等存放到第100个可用空间里。</p><p>这样，我们就可以根据求余的快速数字变化，对数据进行分组，并把它们存放到不同的地址空间里。而求余操作本身非常简单，因此几乎不会增加寻址时间。</p><p><img src="https://static001.geekbang.org/resource/image/37/2c/372f09d2ff666150fd2855506a84f02c.jpg" alt=""></p><p>除此之外，为了增加数据散列的随机程度，我们还可以在公式中加入一个较大的随机数MAX，于是，上面的公式就可以写成这样：</p><p><img src="https://static001.geekbang.org/resource/image/78/c0/78a943e119d823d39cdcaf35a75a42c0.jpg" alt=""></p><p>我们假设随机数MAX是590199，那么我们针对标号为1的记录进行重新计算，最后的计算结果就是0，而针对标号101的记录，如果随机数MAX取627901，对应的结果应该是2。这样先前被分配到空间1的两条记录，在新的计算公式作用下，就会被分配到不同的可用空间中。</p><p>你可以尝试记录2和102，或者记录100和200，最后应该也是同样的情况。你会发现，使用了MAX这个随机数之后，被分配到同一个空间中的记录就更加“随机”，更适合需要将数据重新洗牌的应用场景，比如加密算法、MapReduce中的数据分发、记录的高速查询和定位等等。</p><p>让我以加密算法为例，在这里面引入MAX随机数就可以增强加密算法的保密程度，是不是很厉害？举个例子，比如说我们要加密一组三位数，那我们设定一个这样的加密规则：</p><ol>\n<li>\n<p>先对每个三位数的个、十和百位数，都加上一个较大的随机数。</p>\n</li>\n<li>\n<p>然后将每位上的数都除以7，用所得的余数代替原有的个、十、百位数；</p>\n</li>\n<li>\n<p>最后将第一位和第三位交换。</p>\n</li>\n</ol><p>这就是一个基本的加密变换过程。</p><p>假如说，我们要加密数字625，根据刚才的规则，我们来试试。假设随机数我选择590127。那百、十和个位分别加上这个随机数，就变成了590133，590129，590132。然后，三位分别除以7求余后得到5，1，4。最终，我们可以得到加密后的数字就是415。因为加密的人知道加密的规则、求余所用的除数7、除法的商、以及所引入的随机数590127，所以当拿到415的时候，加密者就可以算出原始的数据是625。是不是很有意思？</p><h2>小结</h2><p>到这里，余数的所有知识点我们都讲完了。我想在此之前，你肯定是知道余数，也明白怎么求余。但对于余数的应用不知道你之前是否有思考过呢？我们经常说，数学是计算机的基础，在余数这个小知识点里，我们就能找到很多的应用场景，比如我前面介绍的散列函数、加密算法，当然，也还有我们没有介绍到的，比如循环冗余校验等等。</p><p>余数只是数学知识中的沧海一粟。你在中学或者大学的时候，肯定接触过很多的数学知识和定理，编程的时候也会经常和数字、公式以及数据打交道，但是真正学懂数学的人却没几个。希望我们可以从余数这个小概念开始，让你认识到数学思想其实非常实用，用好这些知识，对你的编程，甚至生活都有意想不到的作用。</p><p><img src="https://static001.geekbang.org/resource/image/97/5a/97a4d55737df060e213a12da82963e5a.jpg" alt=""></p><h2>思考题</h2><p>你可以想想，在生活和编程中，还有哪些地方用到了余数的思想呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "02 | 余数：原来取余操作本身就是个哈希函数",
      },
      {
        title: "03 | 迭代法：不用编程语言的自带函数，你会如何计算平方根？",
        herf: "https://time.geekbang.org/column/article/72243",
        id: "72243",
        content:
          '<p>你好，我是黄申。</p><p>今天我们来说一个和编程结合得非常紧密的数学概念。在解释这个重要的概念之前，我们先来看个有趣的小故事。</p><blockquote>\n<p>古印度国王舍罕酷爱下棋，他打算重赏国际象棋的发明人宰相西萨·班·达依尔。这位聪明的大臣指着象棋盘对国王说：“陛下，我不要别的赏赐，请您在这张棋盘的第一个小格内放入一粒麦子，在第二个小格内放入两粒，第三小格内放入给四粒，以此类推，每一小格内都比前一小格加一倍的麦子，直至放满64个格子，然后将棋盘上所有的麦粒都赏给您的仆人我吧！”</p>\n</blockquote><p>国王自以为小事一桩，痛快地答应了。可是，当开始放麦粒之后，国王发现，还没放到第二十格，一袋麦子已经空了。随着，一袋又一袋的麦子被放入棋盘的格子里，国王很快看出来，即便拿来全印度的粮食，也兑现不了对达依尔的诺言。</p><p>放满这64格到底需要多少粒麦子呢？这是个相当相当大的数字，想要手动算出结果并不容易。如果你觉得自己厉害，可以试着拿笔算算。其实，这整个算麦粒的过程，在数学上，是有对应方法的，这也正是我们今天要讲的概念：<strong>迭代法</strong>（Iterative Method）。</p><h2>到底什么是迭代法？</h2><p><strong>迭代法，简单来说，其实就是不断地用旧的变量值，递推计算新的变量值</strong>。</p><p>我这么说可能还是比较抽象，不容易理解。我们还回到刚才的故事。大臣要求每一格的麦子都是前一格的两倍，那么前一格里麦子的数量就是旧的变量值，我们可以先记作$X_{n-1}$；而当前格子里麦子的数量就是新的变量值，我们记作$X_{n}$。这两个变量的递推关系就是这样的：</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/c8/0e/c82c80cbf7d766f77422c564418cc70e.jpg" alt=""></p><p>如果你稍微有点编程经验，应该能发现，迭代法的思想，很容易通过计算机语言中的<strong>循环语言</strong>来实现。你知道，计算机本身就适合做重复性的工作，我们可以通过循环语句，让计算机重复执行迭代中的递推步骤，然后推导出变量的最终值。</p><p>那接下来，我们就用循环语句来算算，填满格子到底需要多少粒麦子。我简单用Java语言写了个程序，你可以看看。</p><pre><code>public class Lesson3_1 {\n    /**\n    * @Description: 算算舍罕王给了多少粒麦子\n    * @param grid-放到第几格\n    * @return long-麦粒的总数\n    */\n\n    public static long getNumberOfWheat(int grid) {\n     \n     long sum = 0;      // 麦粒总数\n     long numberOfWheatInGrid = 0;  // 当前格子里麦粒的数量\n     \n     numberOfWheatInGrid = 1;  // 第一个格子里麦粒的数量\n     sum += numberOfWheatInGrid;  \n     \n     for (int i = 2; i &lt;= grid; i ++) {\n      numberOfWheatInGrid *= 2;   // 当前格子里麦粒的数量是前一格的2倍\n      sum += numberOfWheatInGrid;   // 累计麦粒总数\n     }\n     \n     return sum;\n\n    }\n}\n</code></pre><p>下面是一段测试代码，它计算了到第63格时，总共需要多少麦粒。</p><pre><code>  public static void main(String[] args) {\n  System.out.println(String.format(&quot;舍罕王给了这么多粒：%d&quot;,   Lesson3_1.getNumberOfWheat(63)));\n  }\n</code></pre><p>计算的结果是9223372036854775807，多到数不清了。我大致估算了一下，一袋50斤的麦子估计有130万粒麦子，那么9223372036854775807相当于70949亿袋50斤的麦子！</p><p>这段代码有两个地方需要注意。首先，用于计算每格麦粒数的变量以及总麦粒数的变量都是Java中的long型，这是因为计算的结果实在是太大了，超出了Java int型的范围；第二，我们只计算到了第63格，这是因为计算到第64格之后，总数已经超过Java中long型的范围。</p><h2>迭代法有什么具体应用？</h2><p>看到这里，你可能大概已经理解迭代法的核心理念了。迭代法在无论是在数学，还是计算机领域都有很广泛的应用。大体上，迭代法可以运用在以下几个方面：</p><ul>\n<li>\n<p><strong>求数值的精确或者近似解</strong>。典型的方法包括二分法（Bisection method）和牛顿迭代法（Newton’s method）。</p>\n</li>\n<li>\n<p><strong>在一定范围内查找目标值。</strong>典型的方法包括二分查找。</p>\n</li>\n<li>\n<p><strong>机器学习算法中的迭代</strong>。相关的算法或者模型有很多，比如K-均值算法（K-means clustering）、PageRank的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为<strong>很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解</strong>。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。</p>\n</li>\n</ul><p>这里，我详细讲解一下求数值的解和查找匹配记录这两个应用。</p><h3>1.求方程的精确或者近似解</h3><p>迭代法在数学和编程的应用有很多，如果只能用来计算庞大的数字，那就太“暴殄天物”了。迭代还可以帮助我们进行无穷次地逼近，求得方程的精确或者近似解。</p><p>比如说，我们想计算某个给定正整数n（n&gt;1）的平方根，如果不使用编程语言自带的函数，你会如何来实现呢？</p><p>假设有正整数n，这个平方根一定小于n本身，并且大于1。那么这个问题就转换成，在1到n之间，找一个数字等于n的平方根。</p><p>我这里采用迭代中常见的<strong>二分法</strong>。每次查看区间内的中间值，检验它是否符合标准。</p><p>举个例子，假如我们要找到10的平方根。我们需要先看1到10的中间数值，也就是11/2=5.5。5.5的平方是大于10的，所以我们要一个更小的数值，就看5.5和1之间的3.25。由于3.25的平方也是大于10的，继续查看3.25和1之间的数值，也就是2.125。这时，2.125的平方小于10了，所以看2.125和3.25之间的值，一直继续下去，直到发现某个数的平方正好是10。</p><p>我把具体的步骤画成了一张图，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/89/7d/89c9c38113624288091cd65ff3d8957d.jpg" alt=""></p><p>我这里用Java代码演示一下效果，你可以结合上面的讲解，来理解迭代的过程。</p><pre><code>public class Lesson3_2 {\n \n /**\n    * @Description: 计算大于1的正整数之平方根\n    * @param n-待求的数, deltaThreshold-误差的阈值, maxTry-二分查找的最大次数\n    * @return double-平方根的解\n    */\n    public static double getSqureRoot(int n, double deltaThreshold, int maxTry) {\n     \n     if (n &lt;= 1) {\n      return -1.0;\n     }\n     \n     double min = 1.0, max = (double)n;\n     for (int i = 0; i &lt; maxTry; i++) {\n      double middle = (min + max) / 2;\n      double square = middle * middle;\n      double delta = Math.abs((square / n) - 1);\n      if (delta &lt;= deltaThreshold) {\n       return middle;\n      } else {\n       if (square &gt; n) {\n        max = middle;\n       } else {\n        min = middle;\n       }\n      }\n     }\n     \n     return -2.0;\n\n    }\n}\n</code></pre><p>这是一段测试代码，我们用它来找正整数10的平方根。如果找不到精确解，我们就返回一个近似解。</p><pre><code>public static void main(String[] args) {\n  \n  int number = 10;\n  double squareRoot = Lesson3_2.getSqureRoot(number, 0.000001, 10000);\n  if (squareRoot == -1.0) {\n   System.out.println(&quot;请输入大于1的整数&quot;);\n  } else if (squareRoot == -2.0) {\n   System.out.println(&quot;未能找到解&quot;);\n  } else {\n   System.out.println(String.format(&quot;%d的平方根是%f&quot;, number, squareRoot));\n  }\n  \n }\n</code></pre><p>这段代码的实现思想就是我前面讲的迭代过程，这里面有两个小细节我解释下。</p><p>第一，我使用了deltaThreshold来控制解的精度。虽然理论上来说，可以通过二分的无限次迭代求得精确解，但是考虑到实际应用中耗费的大量时间和计算资源，绝大部分情况下，我们并不需要完全精确的数据。</p><p>第二，我使用了maxTry来控制循环的次数。之所以没有使用while(true)循环，是为了避免死循环。虽然，在这里使用deltaThreshold，理论上是不会陷入死循环的，但是出于良好的编程习惯，我们还是尽量避免产生的可能性。</p><p>说完了二分迭代法，我这里再简单提一下牛顿迭代法。这是牛顿在17世纪提出的一种方法，用于求方程的近似解。这种方法以微分为基础，每次迭代的时候，它都会去找到比上一个值$x_{0}$更接近的方程的根，最终找到近似解。该方法及其延伸也被应用在机器学习的算法中，在之后机器学习中的应用中，我会具体介绍这个算法。</p><h3>2.查找匹配记录</h3><p><strong>二分法中的迭代式逼近，不仅可以帮我们求得近似解，还可以帮助我们查找匹配的记录。</strong>我这里用一个查字典的案例来说明。</p><p>在自然语言处理中，我们经常要处理同义词或者近义词的扩展。这时，你手头上会有一个同义词/近义词的词典。对于一个待查找的单词，我们需要在字典中找出这个单词，以及它所对应的同义词和近义词，然后进行扩展。比如说，这个字典里有一个关于“西红柿”的词条，其同义词包括了“番茄”和“tomato”。</p><p><img src="https://static001.geekbang.org/resource/image/2d/5a/2de8a4c2b934a86ef5e8b915b6926d5a.jpg" alt=""></p><p>那么，在处理文章的时候，当我们看到了“西红柿”这个词，就去字典里查一把，拿出“番茄”“tomato”等等，并添加到文章中作为同义词/近义词的扩展。这样的话，用户在搜索“西红柿”这个词的时候，我们就能确保出现“番茄”或者“tomato”的文章会被返回给用户。</p><p>乍一看到这个任务的时候，你也许想到了哈希表。没错，哈希表是个好方法。不过，如果不使用哈希表，你还有什么其他方法呢？这里，我来介绍一下，用二分查找法进行字典查询的思路。</p><p>第一步，将整个字典先进行排序（假设从小到大）。二分法中很关键的前提条件是，所查找的区间是有序的。这样才能在每次折半的时候，确定被查找的对象属于左半边还是右半边。</p><p>第二步，使用二分法逐步定位到被查找的单词。每次迭代的时候，都找到被搜索区间的中间点，看看这个点上的单词，是否和待查单词一致。如果一致就返回；如果不一致，要看被查单词比中间点上的单词是小还是大。如果小，那说明被查的单词如果存在字典中，那一定在左半边；否则就在右半边。</p><p>第三步，根据第二步的判断，选择左半边或者后半边，继续迭代式地查找，直到范围缩小到单个的词。如果到最终仍然无法找到，则返回不存在。</p><p>当然，你也可以对单词进行从大到小的排序，如果是那样，在第二步的判断就需要相应地修改一下。</p><p>我把在a到g的7个字符中查找f的过程，画成了一张图，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/d3/99/d39dfcea9385baef98846d2a5914a599.jpg" alt=""></p><p>这个方法的整体思路和二分法求解平方根是一致的，主要区别有两个方面：第一，每次判断是否终结迭代的条件不同。求平方根的时候，我们需要判断某个数的平方是否和输入的数据一致。而这里，我们需要判断字典中某个单词是否和待查的单词相同。第二，二分查找需要确保被搜索的空间是有序的。</p><p>我把具体的代码写出来了，你可以看一下。</p><pre><code>import java.util.Arrays;\n\npublic class Lesson3_3 {\n \n /**\n    * @Description: 查找某个单词是否在字典里出现\n    * @param dictionary-排序后的字典, wordToFind-待查的单词\n    * @return boolean-是否发现待查的单词\n    */\n    public static boolean search(String[] dictionary, String wordToFind) {\n     \n     if (dictionary == null) {\n      return false;\n     }\n     \n     if (dictionary.length == 0) {\n      return false;\n     }\n     \n     int left = 0, right = dictionary.length - 1;\n     while (left &lt;= right) {\n      int middle = (left + right) / 2;\n      if (dictionary[middle].equals(wordToFind)) {\n       return true;\n      } else {\n       if (dictionary[middle].compareTo(wordToFind) &gt; 0) {\n        right = middle - 1;\n       } else {\n        left = middle + 1;\n       }\n      }\n     }\n     \n     return false;\n\n    }\n\n}\n\n\n</code></pre><p>我测试代码首先建立了一个非常简单的字典，然后使用二分查找法在这个字典中查找单词“i”。</p><pre><code>public static void main(String[] args) {\n  \n  \n  String[] dictionary = {&quot;i&quot;, &quot;am&quot;, &quot;one&quot;, &quot;of&quot;, &quot;the&quot;, &quot;authors&quot;, &quot;in&quot;, &quot;geekbang&quot;};\n  \n  Arrays.sort(dictionary);\n\n  String wordToFind = &quot;i&quot;;\n  \n  boolean found = Lesson3_3.search(dictionary, wordToFind);\n  if (found) {\n   System.out.println(String.format(&quot;找到了单词%s&quot;, wordToFind));\n  } else {\n   System.out.println(String.format(&quot;未能找到单词%s&quot;, wordToFind));\n  }\n  \n }\n</code></pre><p>说的这两个例子，都属于迭代法中的二分法，我在第一节的时候说过，二分法其实也体现了二进制的思想。</p><h2>小结</h2><p>到这里，我想你对迭代的核心思路有了比较深入的理解。</p><p>实际上，人类并不擅长重复性的劳动，而计算机却很适合做这种事。这也是为什么，以重复为特点的迭代法在编程中有着广泛的应用。不过，日常的实际项目可能并没有体现出明显的重复性，以至于让我们很容易就忽视了迭代法的使用。所以，你要多观察问题的现象，思考其本质，看看不断更新变量值或者缩小搜索的区间范围，是否可以获得最终的解（或近似解、局部最优解），如果是，那么你就可以尝试迭代法。</p><p><img src="https://static001.geekbang.org/resource/image/cf/23/cff999fbe0e89b76736f41aacc944623.jpg" alt=""></p><h2>思考题</h2><p>在你曾经做过的项目中，是否使用过迭代法？如果有，你觉得迭代法最大的特点是什么？如果还没用过，你想想看现在的项目中是否有可以使用的地方？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "03 | 迭代法：不用编程语言的自带函数，你会如何计算平方根？",
      },
      {
        title: "04 | 数学归纳法：如何用数学归纳提升代码的运行效率？",
        herf: "https://time.geekbang.org/column/article/73036",
        id: "73036",
        content:
          '<p>你好，我是黄申。</p><p>上次我们聊了迭代法及其应用，并用编程实现了几个小例子。不过你知道吗，对于某些迭代问题，我们其实可以避免一步步的计算，直接<strong>从理论上证明某个结论</strong>，节约大量的计算资源和时间，这就是我们今天要说的<strong>数学归纳法</strong>。</p><p>平时我们谈的“归纳”，是一种从经验事实中找出普遍特征的认知方法。比如，人们在观察了各种各样动物之后，通过它们的外观、行为特征、生活习性等得出某种结论，来区分哪些是鸟、哪些是猫等等。比如我这里列出的几个动物的例子。</p><p><img src="https://static001.geekbang.org/resource/image/f6/37/f606627d96040653c5eeca1541788a37.jpg" alt=""></p><p>通过上面的表格，我们可以进行归纳，并得出这样的结论：</p><ul>\n<li>\n<p>如果一个动物，身上长羽毛并且会飞，那么就是属于鸟；</p>\n</li>\n<li>\n<p>如果一个动物，身上长绒毛、不会飞、而且吃小鱼和老鼠，那么就属于猫。</p>\n</li>\n</ul><p>通过观察$5$个动物样本的$3$个特征，从而得到某种动物应该具有何种特征，这种方法就是我们平时所提到的归纳法。</p><p>我们日常生活中所说的这种归纳法和数学归纳法是不一样的，它们究竟有什么区别呢？具体数学归纳法可以做什么呢？我们接着上一节舍罕王赏麦的故事继续说。</p><h2>什么是数学归纳法？</h2><p>上节我们提到，在棋盘上放麦粒的规则是，第一格放一粒，第二格放两粒，以此类推，每一小格内都比前一小格多一倍的麦子，直至放满$64$个格子。</p><!-- [[[read_end]]] --><p>我们假想一下自己穿越到了古印度，正站在国王的身边，看着这个棋盘，你发现第$1$格到第$8$格的麦子数分别是：$1、2、4、8、16、32、64、128$。这个时候，国王想知道总共需要多少粒麦子。我们小时候都玩过“找规律”，于是，我发现了这么一个规律，你看看是不是这样？</p><p><img src="https://static001.geekbang.org/resource/image/8e/8c/8eba65a8d57d5cc84cb6ea4dd20ba68c.jpg" alt=""></p><p>根据这个观察，我们是不是可以大胆假设，前$n$个格子的麦粒总数就是$2^{n}-1$ 呢？如果这个假设成立，那么填满64格需要的麦粒总数，就是$1+2+2^{2}+2^{3}+2^{4}+……＋ 2^{63}$<br>\n$＝2^{64}-1＝18446744073709551615$。</p><p>这个假设是否成立，我们还有待验证。但是对于类似这种无穷数列的问题，我们通常可以采用<strong>数学归纳法</strong>（Mathematical Induction）来证明。</p><p>在数论中，数学归纳法用来证明任意一个给定的情形都是正确的，也就是说，第一个、第二个、第三个，一直到所有情形，概不例外。</p><p>数学归纳法的一般步骤是这样的：</p><ul>\n<li>\n<p><strong>证明基本情况（通常是$n=1$的时候）是否成立</strong><strong>；</strong></p>\n</li>\n<li>\n<p><strong>假设$n=k-1$成立，再证明$n=k$也是成立的</strong><strong>（$k$为任意大于$1$的自然数）</strong>。</p>\n</li>\n</ul><p>只要学过数学，我想你对这个步骤都不陌生。但是，现在你需要牢记这个步骤，然后我们用这个步骤来证明下开头的例子。</p><p>为了让你更好地理解，我将原有的命题分为两个子命题来证明。第一个子命题是，第$n$个棋格放的麦粒数为$2^{n-1}$。第二个子命题是，前$n$个棋格放的麦粒数总和为$2^{n}-1$。</p><p>首先，我们来证明第一个子命题。</p><ul>\n<li>\n<p>基本情况：我们已经验证了$n=1$的时候，第一格内的麦粒数为$1$，和$2^{1-1}$相等。因此，命题在$k=1$的时候成立。</p>\n</li>\n<li>\n<p>假设第$k-1$格的麦粒数为$2^{k-2}$。那么第$k$格的麦粒数为第$k-1$格的$2$倍，也就是$2^{k - 2}*2=2^{k-1}$。因此，如果命题在$k=n-1$的时候成立，那么在$k=n$的时候也成立。</p>\n</li>\n</ul><p>所以，第一个子命题成立。在这个基础之上，我再来证明第二个子命题。</p><ul>\n<li>\n<p>基本情况：我们已经验证了$n=1$的时候，所有格子的麦粒总数为$1$。因此命题在$k=1$的时候成立。</p>\n</li>\n<li>\n<p>假设前$k-1$格的麦粒总数为$2^{k-1}-1$，基于前一个命题的结论，第k格的麦粒数为$2^{k-1}$。那么前$k$格的麦粒总数为$(2^{k-1}-1)+(2^{k-1})=2*2^{k-1}-1=2^{k}-1$。因此，如果命题在$k=n-1$的时候成立，那么在$k=n$的时候也成立。</p>\n</li>\n</ul><p>说到这里，我已经证明了这两个命题都是成立的。<strong>和使用迭代法的计算相比，数学归纳法最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</strong></p><p>说到这里，我们也可以看出，数学归纳法中的“归纳”是指的从第一步正确，第二步正确，第三步正确，一直推导到最后一步是正确的。这就像多米诺骨牌，只要确保第一张牌倒下，而每张牌的倒下又能导致下一张牌的倒下，那么所有的骨牌都会倒下。从这里，你也能看出来，这和开篇提到的广义归纳法是不同的。数学归纳法并不是通过经验或样本的观察，总结出事物的普遍特征和规律。</p><p>好了，对数学归纳法的概念，我想你现在已经理解了。这里，我对上一节中有关麦粒的代码稍作修改，增加了一点代码来使用数学归纳法的结论，并和迭代法的实现进行了比较，你可以看看哪种方法耗时更长。</p><pre><code>public static void main(String[] args) {\n  \n  int grid = 63;\n  long start, end = 0;\n  start = System.currentTimeMillis();\n  System.out.println(String.format(&quot;舍罕王给了这么多粒：%d&quot;, Lesson3_1.getNumberOfWheat(grid)));\n  end = System.currentTimeMillis();\n  System.out.println(String.format(&quot;耗时%d毫秒&quot;, (end - start)));\n  \n  start = System.currentTimeMillis();\n  System.out.println(String.format(&quot;舍罕王给了这么多粒：%d&quot;, (long)(Math.pow(2, grid)) - 1));\n  end = System.currentTimeMillis();\n  System.out.println(String.format(&quot;耗时%d毫秒&quot;, (end - start)));\n  \n }\n</code></pre><p>在我的电脑上，这段代码运行的结果是：舍罕王给了$9223372036854775807$粒，耗时$4$毫秒。舍罕王给了这么多粒：$9223372036854775806$，耗时$0$毫秒。</p><p>你可能已经发现，当grid=$63$时，结果差了$1$个。这个是由于Math.pow()函数计算精度导致的误差。正确的结果应该是$9223372036854775807$。不过，基于数学归纳结论的计算明显在耗时上占有优势。虽然在我的笔记本电脑上只有4毫秒的差距，但是在生产项目的实践中，这种点点滴滴的性能差距都有可能累积成明显的问题。</p><h2>递归调用和数学归纳的逻辑是一样的？</h2><p>我们不仅可以使用数学归纳法从理论上指导编程，还可以使用编程来模拟数学归纳法的证明。如果你仔细观察一下数学归纳法的证明过程，会不会觉得和函数的<strong>递归调用</strong>很像呢？</p><p>这里我通过总麦粒数的命题来示范一下。首先，我们要把这个命题的数学归纳证明，转换成一段伪代码，这个过程需要经过这样两步：</p><p>第一步，如果$n$为$1$，那么我们就判断麦粒总数是否为$2^{1-1}=1$。同时，返回当前棋格的麦粒数，以及从第$1$格到当前棋格的麦粒总数。</p><p>第二步，如果$n$为$k-1$的时候成立，那么判断$n$为$k$的时候是否也成立。此时的判断依赖于前一格$k-1$的麦粒数、第$1$格到$k-1$格的麦粒总数。这也是上一步我们所返回的两个值。</p><p>你应该看出来了，这两步分别对应了数学归纳法的两种情况。在数学归纳法的第二种情况下，我们只能假设$n=k-1$的时候命题成立。但是，在代码的实现中，我们可以将伪代码的第二步转为函数的递归（嵌套）调用，直到被调用的函数回退到$n=1$的情况。然后，被调用的函数逐步返回$k-1$时命题是否成立。</p><p>如果要写成具体的函数，就类似下面这样：</p><pre><code>class Result {\n public long wheatNum = 0;  // 当前格的麦粒数\n public long wheatTotalNum = 0;  // 目前为止麦粒的总数\n}\n\npublic class Lesson4_2 {\n \n /**\n    * @Description: 使用函数的递归（嵌套）调用，进行数学归纳法证明\n    * @param k-放到第几格，result-保存当前格子的麦粒数和麦粒总数\n    * @return boolean-放到第k格时是否成立\n    */\n \n    public static boolean prove(int k, Result result) {\n     \n     // 证明n = 1时，命题是否成立\n     if (k == 1) {\n      if ((Math.pow(2, 1) - 1) == 1) {\n       result.wheatNum = 1;\n       result.wheatTotalNum = 1;\n       return true;\n      } else return false;\n     }\n     // 如果n = (k-1)时命题成立，证明n = k时命题是否成立\n     else {\n      \n      boolean proveOfPreviousOne = prove(k - 1, result);\n      result.wheatNum *= 2;\n      result.wheatTotalNum += result.wheatNum;\n      boolean proveOfCurrentOne = false;\n      if (result.wheatTotalNum == (Math.pow(2, k) - 1)) proveOfCurrentOne = true; \n      \n      if (proveOfPreviousOne &amp;&amp; proveOfCurrentOne) return true;\n      else return false;\n      \n     }\n     \n    }\n\n}\n\n</code></pre><p>其中，类Result用于保留每一格的麦粒数，以及目前为止的麦粒总数。这个代码递归调用了函数prove(int, Result)。</p><p>从这个例子中，我们可以看出来，<strong>递归调用的代码和数学归纳法的逻辑是一致的</strong>。一旦你理解了数学归纳法，就很容易理解递归调用了。只要数学归纳证明的逻辑是对的，递归调用的逻辑就是对的，我们没有必要纠结递归函数是如何嵌套调用和返回的。</p><p>不过，和数学归纳证明稍有不同的是，递归编程的代码需要返回若干的变量，来传递$k-1$的状态到$k$。这里，我使用类Result来实现这一点。</p><p>这里是一段测试的代码。</p><pre><code>public static void main(String[] args) {\n  \n  int grid = 63;\n  \n  Result result = new Result();\n  System.out.println(Lesson4_2.prove(grid, result));\n  \n }\n\n</code></pre><p>我们最多测试到$63$。因为如果测试到第$64$格，麦粒总数就会溢出Java的long型数据。</p><p>你可以自己分析一下函数的调用和返回。我这里列出了一开始嵌套调用和到递归结束并开始返回值得的几个状态：</p><p><img src="https://static001.geekbang.org/resource/image/02/2d/02dfa54d6968676b90ac757a0711342d.png" alt=""></p><p>从这个图可以看出，函数从$k=63$开始调用，然后调用$k-1$，也就是$62$，一直到$k=1$的时候，嵌套调用结束，$k=1$的函数体开始返回值给$k=2$的函数体，一直到$k=63$的函数体。从$k=63, 62, …, 2, 1$的嵌套调用过程，其实就是体现了数学归纳法的核心思想，我把它称为<strong>逆向递推</strong>。而从$k=1, 2, …, 62, 63$的值返回过程，和上一篇中基于循环的迭代是一致的，我把它称为<strong>正向递推</strong>。</p><h2>小结</h2><p>今天，我介绍了一个编程中非常重要的数学概念：数学归纳法。</p><p>上一节我讲了迭代法是如何通过重复的步骤进行计算或者查询的。与此不同的是，数学归纳法在理论上证明了命题是否成立，而无需迭代那样反复计算，因此可以帮助我们节约大量的资源，并大幅地提升系统的性能。</p><p>数学归纳法实现的运行时间几乎为$0$。不过，数学归纳法需要我们能做出合理的命题假设，然后才能进行证明。虽然很多时候要做这点比较难，确实也没什么捷径。你就是要多做题，多去看别人是怎么解题的，自己去积累经验。</p><p>最后，我通过函数的递归调用，模拟了数学归纳法的证明过程。如果你细心的话，会发现递归的函数值返回实现了从$k=1$开始到$k=n$的迭代。说到这里，你可能会好奇：既然递归最后返回值的过程和基于循环的迭代是一致，那为什么还需要使用递归的方法呢？下一节，我们继续聊这个问题。</p><p><img src="https://static001.geekbang.org/resource/image/0d/81/0dc6eaf8597eccad3ee4411e14acf081.jpg" alt=""></p><h2>思考题</h2><p>在你日常工作的项目中，什么地方用到了数学归纳法来提升代码的运行效率？如果没有遇到过，你可以尝试做做实验，看看是否有提升？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "04 | 数学归纳法：如何用数学归纳提升代码的运行效率？",
      },
      {
        title: "05 | 递归（上）：泛化数学归纳，如何将复杂问题简单化？",
        herf: "https://time.geekbang.org/column/article/73511",
        id: "73511",
        content:
          '<p>你好，我是黄申。上一节的结尾，我们用递归模拟了数学归纳法的证明。同时，我也留下了一个问题：<strong>既然递归的函数值返回过程和基于循环的迭代法一致，我们直接用迭代法不就好了，为什么还要用递归的数学思想和编程方法呢</strong>？这是因为，在某些场景下，递归的解法比基于循环的迭代法更容易实现。这是为什么呢？我们继续来看舍罕王赏麦的故事。</p><h2>如何在限定总和的情况下，求所有可能的加和方式？</h2><p>舍罕王和他的宰相西萨·班·达依尔现在来到了当代。这次国王学乖了，他对宰相说：“这次我不用麦子奖赏你了，我直接给你货币。另外，我也不用棋盘了，我直接给你一个固定数额的奖赏。”</p><p>宰相思考了一下，回答道：“没问题，陛下，就按照您的意愿。不过，我有个小小的要求。那就是您能否列出所有可能的奖赏方式，让我自己来选呢？假设有四种面额的钱币，1元、2元、5元和10元，而您一共给我10元，那您可以奖赏我1张10元，或者10张1元，或者5张1元外加1张5元等等。如果考虑每次奖赏的金额和先后顺序，那么最终一共有多少种不同的奖赏方式呢？”</p><p>让我们再次帮国王想想，如何解决这个难题吧。这个问题和之前的棋盘上放麦粒有所不同，它并不是要求你给出最终的总数，而是<strong>在限定总和的情况下，求所有可能的加和方式。</strong>你可能会想，虽然问题不一样，但是求和的重复性操作仍然是一样的，因此是否可以使用迭代法？好，让我们用迭代法来试一下。</p><!-- [[[read_end]]] --><p>我还是使用迭代法中的术语，考虑k=1,2,3,…,n的情况。在第一步，也就是当n=1的时候，我们可以取四种面额中的任何一种，那么当前的奖赏就是1元、2元、5元和10元。当n=2的时候，奖赏的总和就有很多可能性了。如果第一次奖赏了1元，那么第二次有可能取1、2、5元三种面额（如果取10，总数超过了10元，因此不可能）。</p><p>所以，在第一次奖赏1元，第二次奖赏1元后，总和为2元；第一次奖赏1元，第二次奖赏2元后，总和为3元；第一次奖赏1元，第二次奖赏5元后，总和为6元。好吧，这还没有考虑第一次奖赏2元和5元的情况。我来画个图，从图中你就能发现这种可能的情况在快速地“膨胀”。</p><p><img src="https://static001.geekbang.org/resource/image/76/61/761c7053947cc4340950200f8626e661.jpg" alt=""></p><p>你应该能看到，虽然迭代法的思想是可行的，但是如果用循环来实现，恐怕要保存好多中间状态及其对应的变量。说到这里，你是不是很容易就想到计算编程常用的<strong>函数递归</strong>？</p><p>在递归中，每次嵌套调用都会让函数体生成自己的局部变量，正好可以用来保存不同状态下的数值，为我们省去了大量中间变量的操作，极大地方便了设计和编程。</p><p>不过，这里又有新的问题了。之前用递归模拟数学归纳法还是非常直观的。可是，这里不是要计算一个最终的数值，而是要列举出所有的可能性。那应该如何使用递归来解决呢？上一节，我只是用递归编程体现了数学归纳法的思想，但是如果我们把这个思想泛化一下，那么递归就会有更多、更广阔的应用场景。</p><h2>如何把复杂的问题简单化？</h2><p>首先，我们来看，<strong>如何将数学归纳法的思想泛化成更一般的情况</strong>？数学归纳法考虑了两种情况：</p><ol>\n<li>\n<p>初始状态，也就是n=1的时候，命题是否成立；</p>\n</li>\n<li>\n<p>如果n=k-1的时候，命题成立。那么只要证明n=k的时候，命题也成立。其中k为大于1的自然数。</p>\n</li>\n</ol><p>将上述两点顺序更换一下，再抽象化一下，我写出了这样的递推关系：</p><ol>\n<li>\n<p>假设n=k-1的时候，问题已经解决（或者已经找到解）。那么只要求解n=k的时候，问题如何解决（或者解是多少）；</p>\n</li>\n<li>\n<p>初始状态，就是n=1的时候，问题如何解决（或者解是多少）。</p>\n</li>\n</ol><p>我认为这种思想就是将<strong>复杂的问题，每次都解决一点点，并将剩下的任务转化成为更简单的问题等待下次求解，如此反复，直到最简单的形式</strong>。回到开头的例子，我们再将这种思想具体化。</p><ol>\n<li>\n<p>假设n=k-1的时候，我们已经知道如何去求所有奖赏的组合。那么只要求解n=k的时候，会有哪些金额的选择，以及每种选择后还剩下多少奖金需要支付就可以了。</p>\n</li>\n<li>\n<p>初始状态，就是n=1的时候，会有多少种奖赏。</p>\n</li>\n</ol><p>有了这个思路，就不难写出这个问题的递归实现。我这里列一个基本的实现。</p><pre><code>import java.util.ArrayList;\n\npublic class Lesson5_1 {\n\t\n\tpublic static long[] rewards = {1, 2, 5, 10};\t// 四种面额的纸币\n\t\n\t/**\n    * @Description:\t使用函数的递归（嵌套）调用，找出所有可能的奖赏组合\n    * @param totalReward-奖赏总金额，result-保存当前的解\n    * @return void\n    */\n\t\n    public static void get(long totalReward, ArrayList&lt;Long&gt; result) {\n    \t\n    \t// 当totalReward = 0时，证明它是满足条件的解，结束嵌套调用，输出解\n    \tif (totalReward == 0) {\n    \t\tSystem.out.println(result);\n    \t return;\n     }\n    \t// 当totalReward &lt; 0时，证明它不是满足条件的解，不输出\n    \telse if (totalReward &lt; 0) {\n    \t\treturn;\n    \t} else {\n    \t\tfor (int i = 0; i &lt; rewards.length; i++) {\n    \t\t\tArrayList&lt;Long&gt; newResult = (ArrayList&lt;Long&gt;)(result.clone());\t// 由于有4种情况，需要clone当前的解并传入被调用的函数\n    \t\t\tnewResult.add(rewards[i]);\t\t\t\t\t\t// 记录当前的选择，解决一点问题\n    \t\t\tget(totalReward - rewards[i], newResult);\t\t// 剩下的问题，留给嵌套调用去解决\n    \t\t}\n    \t}\n    \t\n    }\n\n}\n</code></pre><p>我们测试一下总金额为10元的时候，有多少种解。</p><pre><code> public static void main(String[] args) {\n  \n  int totalReward = 10;\n  Lesson5_1.get(totalReward, new ArrayList&lt;Long&gt;());\n  \n }\n</code></pre><p>最终，程序运行后大致是这种结果：</p><pre><code>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1, 1, 1, 1, 2]\n[1, 1, 1, 1, 1, 1, 1, 2, 1]\n[1, 1, 1, 1, 1, 1, 2, 1, 1]\n[1, 1, 1, 1, 1, 1, 2, 2]\n...\n[5, 5]\n[10]\n</code></pre><p>这里面每一行都是一种可能。例如第一行表示分10次奖赏，每次1元；第二行表示分9次奖赏，最后一次是2元；以此类推。最终结果的数量还是挺多的，一共有129种可能。试想一下，如果总金额为100万的话，会有多少种可能啊！</p><p>这个代码还有几点需要留意的地方，我再来解释一下：</p><p>1.由于一共只有4种金额的纸币，所以无论是n=1的时候还是n=k的时候，我们只需要关心这4种金额对组合产生的影响，而中间状态和变量的记录和跟踪这些繁琐的事情都由函数的递归调用负责。</p><p>2.这个案例的限制条件不再是64个棋格，而是奖赏的总金额，因此判断嵌套调用是否结束的条件其实不是次数k，而是总金额。这个金额确保了递归不会陷入死循环。</p><p>3.我这里从奖赏的总金额开始，每次嵌套调用的时候减去一张纸币的金额，直到所剩的金额为0或者少于0，然后结束嵌套调用，开始返回结果值。当然，你也可以反向操作，从金额0开始，每次嵌套调用的时候增加一张纸币的金额，直到累计的金额达到或超过总金额。</p><h2>小结</h2><p><strong>递归和循环其实都是迭代法的实现，而且在某些场合下，它们的实现是可以相互转化的。</strong>但是，对于某些应用场景，递归确很难被循环取代。我觉得主要有两点原因：</p><p>第一，递归的核心思想和数学归纳法类似，并更具有广泛性。这两者的类似之处体现在：<strong>将当前的问题化解为两部分：一个当前所采取的步骤和另一个更简单的问题。</strong></p><p><strong>1.一个当前所采取的步骤</strong>。这种步骤可能是进行一次运算（例如每个棋格里的麦粒数是前一格的两倍），或者做一个选择（例如选择不同面额的纸币），或者是不同类型操作的结合（例如今天讲的赏金的案例）等等。</p><p><strong>2.另一个更简单的问题</strong>。经过上述步骤之后，问题就会变得更加简单一点。这里“简单一点”，指运算的结果离目标值更近（例如赏金的总额），或者是完成了更多的选择（例如纸币的选择）。而“更简单的问题”，又可以通过嵌套调用，进一步简化和求解，直至达到结束条件。</p><p>我们只需要保证递归编程能够体现这种将复杂问题逐步简化的思想，那么它就能帮助我们解决很多类似的问题。</p><p>第二，递归会使用计算机的函数嵌套调用。而函数的调用本身，就可以保存很多中间状态和变量值，因此极大的方便了编程的处理。</p><p>正是如此，递归在计算机编程领域中有着广泛的应用，而不仅仅局限在求和等运算操作上。在下一节中，我将介绍如何使用递归的思想，进行“分而治之”的处理。</p><p><img src="https://static001.geekbang.org/resource/image/c5/63/c5dfb38f4310af08eb6b3d05006dbf63.jpg" alt=""></p><h2>思考题</h2><p>一个整数可以被分解为多个整数的乘积，例如，6可以分解为2x3。请使用递归编程的方法，为给定的整数n，找到所有可能的分解（1在解中最多只能出现1次）。例如，输入8，输出是可以是1x8, 8x1, 2x4, 4x2, 1x2x2x2, 1x2x4, ……</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "05 | 递归（上）：泛化数学归纳，如何将复杂问题简单化？",
      },
      {
        title: "06 | 递归（下）：分而治之，从归并排序到MapReduce",
        herf: "https://time.geekbang.org/column/article/73834",
        id: "73834",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我解释了如何使用递归，来处理迭代法中比较复杂的数值计算。说到这里，你可能会问了，有些迭代法并不是简单的数值计算，而要通过迭代的过程进行一定的操作，过程更加复杂，需要考虑很多中间数据的匹配或者保存。例如我们之前介绍的用二分查找进行数据匹配，或者我们今天将要介绍的归并排序中的数据排序等等。那么，这种情况下，还可以用递归吗？具体又该如何来实现呢？</p><p>我们可以先分析一下，这些看似很复杂的问题，是否可以简化为某些更小的、更简单的子问题来解决，这是一般思路。如果可以，那就意味着我们仍然可以使用递归的核心思想，将复杂的问题逐步简化成最基本的情况来求解。因此，今天我会从归并排序开始，延伸到多台机器的并行处理，详细讲讲递归思想在“分而治之”这个领域的应用。</p><h2>归并排序中的分治思想</h2><p>首先，我们来看，如何使用递归编程解决数字的排序问题。</p><p>对一堆杂乱无序的数字，按照从小到大或者从大到小的规则进行排序，这是计算机领域非常经典，也非常流行的问题。小到Excel电子表格，大到搜索引擎，都需要对一堆数字进行排序。因此，计算机领域的前辈们研究排序问题已经很多年了，也提出了许多优秀的算法，比如归并排序、快速排序、堆排序等等。其中，归并排序和快速排序都很好地体现了分治的思想，今天我来说说其中之一的<strong>归并排序</strong>（merge sort）。</p><!-- [[[read_end]]] --><p>很明显，归并排序算法的核心就是“归并”，也就是把两个有序的数列合并起来，形成一个更大的有序数列。</p><p>假设我们需要按照从小到大的顺序，合并两个有序数列A和B。这里我们需要开辟一个新的存储空间C，用于保存合并后的结果。</p><p>我们首先比较两个数列的第一个数，如果A数列的第一个数小于B数列的第一个数，那么就先取出A数列的第一个数放入C，并把这个数从A数列里删除。如果是B的第一个数更小，那么就先取出B数列的第一个数放入C，并把它从B数列里删除。</p><p>以此类推，直到A和B里所有的数都被取出来并放入C。如果到某一步，A或B数列为空，那直接将另一个数列的数据依次取出放入C就可以了。这种操作，可以保证两个有序的数列A和B合并到C之后，C数列仍然是有序的。</p><p>为了你能更好地理解，我举个例子说明一下，这是合并有序数组{1, 2, 5, 8}和{3, 4, 6}的过程。</p><p><img src="https://static001.geekbang.org/resource/image/3c/49/3c27ae183127b1a9fa3aa2ac10538149.jpg" alt=""></p><p>为了保证得到有序的C数列，我们必须保证参与合并的A和B也是有序的。可是，等待排序的数组一开始都是乱序的，如果无法保证这点，那归并又有什么意义呢？</p><p>还记得上一篇说的递归吗？这里我们就可以利用递归的思想，把问题不断简化，也就是把数列不断简化，一直简化到只剩1个数。1个数本身就是有序的，对吧？</p><p>好了，现在剩下的疑惑就是，每一次如何简化问题呢？最简单的想法是，我们把将长度为n的数列，每次简化为长度为n-1的数列，直至长度为1。不过，这样的处理没有并行性，要进行n-1次的归并操作，效率就会很低。</p><p><img src="https://static001.geekbang.org/resource/image/4d/6e/4dd0cfbf5827c9d075483c9499a66a6e.jpg" alt=""></p><p>所以，我们可以在归并排序中引入了<strong>分而治之</strong>（Divide and Conquer）的思想。<strong>分而治之，我们通常简称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了</strong>。</p><p>归并排序通过分治的思想，把长度为n的数列，每次简化为两个长度为n/2的数列。这更有利于计算机的并行处理，只需要log<sub>2</sub>n次归并。</p><p><img src="https://static001.geekbang.org/resource/image/23/ab/2395178b639c3314a427dd658ae924ab.jpg" alt=""></p><p>我们把归并和分治的思想结合起来，这其实就是归并排序算法。这种算法每次把数列进行二等分，直到唯一的数字，也就是最基本的有序数列。然后从这些最基本的有序数列开始，两两合并有序的数列，直到所有的数字都参与了归并排序。</p><p>我用一个包含0～9这10个数字的数组，给你详细讲解一下归并排序的过程。</p><ul>\n<li>\n<p>假设初始的数组为{7, 6, 2, 4, 1, 9, 3, 8, 0, 5}，我们要对它进行从小到大的排序。</p>\n</li>\n<li>\n<p>第一次分解后，变成两个数组{7, 6, 2, 4, 1}和{9, 3, 8, 0, 5}。</p>\n</li>\n<li>\n<p>然后，我们将{7, 6, 2, 4, 1}分解为{7, 6}和{2, 4, 1}，将{9, 3, 8, 0, 5}分解为{9, 3}和{8, 0, 5}。</p>\n</li>\n<li>\n<p>如果细分后的组仍然多于一个数字，我们就重复上述分解的步骤，直到每个组只包含一个数字。到这里，这些其实都是递归的嵌套调用过程。</p>\n</li>\n<li>\n<p>然后，我们要开始进行合并了。我们可以将{4, 1}分解为{4}和{1}。现在无法再细分了，我们开始合并。在合并的过程中进行排序，所以合并的结果为{1,4}。合并后的结果将返回当前函数的调用者，这就是函数返回的过程。</p>\n</li>\n<li>\n<p>重复上述合并的过程，直到完成整个数组的排序，得到{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}。</p>\n</li>\n</ul><p>为了方便你的理解，我画了张图，给你解释整个归并排序的过程。</p><p><img src="https://static001.geekbang.org/resource/image/53/c5/53f4f60370f04796685f913f22e8c8c5.jpg" alt=""></p><p>说到这里，我想问你，这个归并排序、分治和递归到底是什么关系呢？用一句话简单地说就是，<strong>归并排序使用了分治的思想，而这个过程需要使用递归来实现。</strong></p><p>归并排序算法用分治的思想把数列不断地简化，直到每个数列仅剩下一个单独的数，然后再使用归并逐步合并有序的数列，从而达到将整个数列进行排序的目的。而这个归并排序，正好可以使用递归的方式来实现。为什么这么说？首先，我们来看看这张图，分治的过程是不是和递归的过程一致呢？</p><p><img src="https://static001.geekbang.org/resource/image/29/a8/2945ead8def203f95053852c5dbd57a8.jpg" alt=""></p><p>分治的过程可以通过递归来表达，因此，归并排序最直观的实现方式就是递归。所以，我们从递归的步骤出发，来看归并排序如何实现。</p><p>我们假设n=k-1的时候，我们已经对较小的两组数进行了排序。那我们只要在n=k的时候，将这两组数合并起来，并且保证合并后的数组仍然是有序的就行了。</p><p>所以，在递归的每次嵌套调用中，代码都将一组数分解成更小的两组，然后将这两个小组的排序交给下一次的嵌套调用。而本次调用只需要关心，如何将排好序的两个小组进行合并。</p><p>在初始状态，也就是n=1的时候，对于排序的案例而言，只包含单个数字的分组。由于分组里只有一个数字，所以它已经是排好序的了，之后就可以开始递归调用的返回阶段。我这里画了张图，便于你的理解。</p><p><img src="https://static001.geekbang.org/resource/image/54/12/5410fb301ffce57355ad7ef074e8fd12.jpg" alt=""></p><p>你现在应该已经明白了归并排序的基本过程，最难的已经过去了，编写代码实现就不难了。我这里给出示范性代码，你可以参考看看。</p><pre><code>import java.util.Arrays;\n\npublic class Lesson6_1 {\n\t\n\t/**\n    * @Description:\t使用函数的递归（嵌套）调用，实现归并排序（从小到大）\n    * @param to_sort-等待排序的数组\n    * @return int[]-排序后的数组\n    */\n\t\n\tpublic static int[] merge_sort(int[] to_sort) {\n\t\t\n\t\tif (to_sort == null) return new int[0];\n\t\t\n\t\t// 如果分解到只剩一个数，返回该数\n\t\tif (to_sort.length == 1) return to_sort;\n\t\t\n\t\t// 将数组分解成左右两半\n\t\tint mid = to_sort.length / 2;\n\t\tint[] left = Arrays.copyOfRange(to_sort, 0, mid);\n\t\tint[] right = Arrays.copyOfRange(to_sort, mid, to_sort.length);\n\t\t\n\t\t// 嵌套调用，对两半分别进行排序\n\t\tleft = merge_sort(left);\n\t\tright = merge_sort(right);\n\t\t\n\t\t// 合并排序后的两半\n\t\tint[] merged = merge(left, right);\n\t\t\n\t\treturn merged;\n\t\t\n\t}\n   \n\n}\n</code></pre><p>这里要注意一下，在归并的步骤中，由于递归的调用确保了被合并的两个较小的数组是有序的，所以我们无需比较组内的数字，只需要比较组间的数字就行了。</p><p>这个合并过程具体的实现代码是这样的：</p><pre><code>/**\n    * @Description: 合并两个已经排序完毕的数组（从小到大）\n    * @param a-第一个数组，b-第二个数组\n    * @return int[]-合并后的数组\n    */\n    \n    public static int[] merge(int[] a, int[] b) {\n     \n     if (a == null)  a = new int[0];\n     if (b == null) b = new int[0];\n     \n     int[] merged_one = new int[a.length + b.length];\n     \n     int mi = 0, ai = 0, bi = 0;\n     \n     // 轮流从两个数组中取出较小的值，放入合并后的数组中\n     while (ai &lt; a.length &amp;&amp; bi &lt; b.length) {\n      \n      if (a[ai] &lt;= b[bi]) {\n       merged_one[mi] = a[ai];\n       ai ++;\n      } else {\n       merged_one[mi] = b[bi];\n       bi ++;\n      }\n      \n      mi ++;\n      \n     }\n     \n     // 将某个数组内剩余的数字放入合并后的数组中\n     if (ai &lt; a.length) {\n      for (int i = ai; i &lt; a.length; i++) {\n       merged_one[mi] = a[i];\n       mi ++;\n      }\n     } else {\n      for (int i = bi; i &lt; b.length; i++) {\n       merged_one[mi] = b[i];\n       mi ++;\n      }\n     }\n     \n     return merged_one;\n     \n    }\n</code></pre><p>上述两段代码的结合，就是归并排序的递归实现。你可以用这段代码进行测试：</p><pre><code>public static void main(String[] args) {\n  \n  int[] to_sort = {3434, 3356, 67, 12334, 878667, 387};\n  int[] sorted = Lesson6_1.merge_sort(to_sort);\n  \n  for (int i = 0; i &lt; sorted.length; i++) {\n   System.out.println(sorted[i]);\n  }\n }\n</code></pre><h2>分布式系统中的分治思想</h2><p>聊到这里，你应该已经了解归并排序算法是如何运作的了，也对分而治之的思想有了认识。不过，分而治之更有趣的应用其实是在分布式系统中。</p><p>例如，当需要排序的数组很大（比如达到1024GB的时候），我们没法把这些数据都塞入一台普通机器的内存里。该怎么办呢？有一个办法，我们可以把这个超级大的数据集，分解为多个更小的数据集（比如16GB或者更小），然后分配到多台机器，让它们并行地处理。</p><p>等所有机器处理完后，中央服务器再进行结果的合并。由于多个小任务间不会相互干扰，可以同时处理，这样会大大增加处理的速度，减少等待时间。</p><p>在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据分组以及合并就行了。而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机器上。</p><p><img src="https://static001.geekbang.org/resource/image/78/31/78eefc6b61bad62f257f2b5e4972f031.jpg" alt=""></p><p>在这个框架图中，你应该可以看到，分布式集群中的数据切分和合并，同单台机器上归并排序的过程是一样的，因此也是使用了分治的思想。从理论的角度来看，上面这个图很容易理解。不过在实际运用中，有个地方需要注意一下。</p><p>上图中的父结点，例如机器1、2、3，它们都没有被分配排序的工作，只是在子结点的排序完成后进行有序数组的合并，因此集群的性能没有得到充分利用。那么，另一种可能的数据切分方式是，每台机器拿出一半的数据给另一台机器处理，而自己来完成剩下一半的数据。</p><p><img src="https://static001.geekbang.org/resource/image/1d/58/1d278b81c4bd3b6bc522f34cbe298c58.jpg" alt=""></p><p>如果分治的时候，只进行一次问题切分，那么上述层级型的分布式架构就可以转化为类似MapReduce的架构。我画出了MapReduce的主要步骤，你可以看看，这里面有哪些步骤体现了分治的思想？</p><p><img src="https://static001.geekbang.org/resource/image/08/5a/08155dd375f7b049424a6686bcb6475a.jpg" alt=""></p><p>这里面主要有三个步骤用到了分治的思想。</p><h3>1. 数据分割和映射</h3><p>分割是指将数据源进行切分，并将分片发送到Mapper上。映射是指Mapper根据应用的需求，将内容按照键-值的匹配，存储到哈希结构中。这两个步骤将大的数据集合切分为更小的数据集，降低了每台机器节点的负载，因此和分治中的问题分解类似。不过，MapReduce采用了哈希映射来分配数据，而普通的分治或递归不一定需要。</p><h3>2.归约</h3><p>归约是指接受到的一组键值配对，如果是键内容相同的配对，就将它们的值归并。这和本机的递归调用后返回结果的过程类似。不过，由于哈希映射的关系，MapReduce还需要洗牌的步骤，也就是将键-值的配对不断地发给对应的Reducer进行归约。普通的分治或递归不一定需要洗牌的步骤。</p><h3>3.合并</h3><p>为了提升洗牌阶段的效率，可以选择减少发送到归约阶段的键-值配对。具体做法是在数据映射和洗牌之间，加入合并的过程，在每个Mapper节点上先进行一次本地的归约。然后只将合并的结果发送到洗牌和归约阶段。这和本机的递归调用后返回结果的过程类似。</p><p>说了这么多，你现在对分治应该有比较深入的理解了。实际上，分治主要就是用在将复杂问题转化为若干个规模相当的小问题上。分治思想通常包括问题的细分和结果的合并，正好对应于递归编程的函数嵌套调用和函数结果的返回。细分后的问题交给嵌套调用的函数去解决，而结果合并之后交由函数进行返回。所以，分治问题适合使用递归来实现。同时，分治的思想也可以帮助我们设计分布式系统和并行计算，细分后的问题交给不同的机器来处理，而其中的某些机器专门负责收集来自不同机器的处理结果，完成结果的合并。</p><h2>小结</h2><p>这两节我们学习了递归法。递归采用了和数学归纳法类似的思想，但是它用的是逆向递推，化繁为简，把复杂的问题逐步简化。再加上分治原理，我们就可以更有效地把问题细分，进行并行化的处理。</p><p>而计算机编程中的函数嵌套调用，正好对应了数学中递归的逆向递推，所以你只要弄明白了数学递推式，就能非常容易的写出对应的递归编码。这是为什么递归在编程领域有着非常广泛的应用。不过，需要注意的是，递归编程在没有开始返回结果之前，保存了大量的中间结果，所以比较消耗系统资源。这也是一般的编程语言都会限制递归的深度（也就是嵌套的次数）的原因。</p><p><img src="https://static001.geekbang.org/resource/image/09/fe/0908dbae238006c1b8bafb09f9839bfe.jpg" alt=""></p><h2>思考题</h2><p>你有没有想过，在归并排序的时候，为什么每次都将原有的数组分解为两组，而不是更多组呢？如果分为更多组，是否可行？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "06 | 递归（下）：分而治之，从归并排序到MapReduce",
      },
      {
        title: "07 | 排列：如何让计算机学会“田忌赛马”？",
        herf: "https://time.geekbang.org/column/article/75129",
        id: "75129",
        content:
          '<p>你好，我是黄申。</p><p>“田忌赛马”的故事我想你肯定听过吧？田忌是齐国有名的将领，他常常和齐王赛马，可是总是败下阵来，心中非常不悦。孙膑想帮田忌一把。他把这些马分为上、中、下三等。他让田忌用自己的下等马来应战齐王的上等马，用上等马应战齐王的中等马，用中等马应战齐王的下等马。三场比赛结束后，田忌只输了第一场，赢了后面两场，最终赢得与齐王的整场比赛。</p><p>孙膑每次都从田忌的马匹中挑选出一匹，一共进行三次，排列出战的顺序。是不是感觉这个过程很熟悉？这其实就是数学中的<strong>排列</strong>过程。</p><p>我们初高中的时候，都学过排列，它的概念是这么说的：从n个不同的元素中取出m（1≤m≤n）个不同的元素，按照一定的顺序排成一列，这个过程就叫<strong>排列</strong>（Permutation）。当m=n这种特殊情况出现的时候，比如说，在田忌赛马的故事中，田忌的三匹马必须全部出战，这就是<strong>全排列</strong>（All Permutation）。</p><p>如果选择出的这m个元素可以有重复的，这样的排列就是为<strong>重复排列</strong>（Permutation with Repetition），否则就是<strong>不重复排列</strong>（Permutation without Repetition）。</p><p><img src="https://static001.geekbang.org/resource/image/98/15/98df21876ad52195217709e298707515.jpg" alt=""></p><p>看出来没有？这其实是一个树状结构。从树的根结点到叶子结点，每种路径都是一种排列。有多少个叶子结点就有多少种全排列。从图中我们可以看出，最终叶子结点的数量是3x2x1=6，所以最终排列的数量为6。</p><!-- [[[read_end]]] --><pre><code>{上等，中等，下等}\n{上等，下等，中等}\n{中等，上等，下等}\n{中等，下等，上等}\n{下等，上等，中等}\n{下等，中等，上等}\n</code></pre><p>我用t1，t2和t3分别表示田忌的上、中、下等马跑完全程所需的时间，用q1，q2和q3分别表示齐王的上、中、下等马跑全程所需的时间，因此，q1&lt;t1&lt;q2&lt;t2&lt;q3&lt;t3。</p><p>如果你将这些可能的排列，仔细地和齐王的上等、中等和下等马进行对比，只有{下等，上等，中等}这一种可能战胜齐王，也就是t3&gt;q1，t1&lt;q2，t2&lt;q3。</p><p>对于最终排列的数量，这里我再推广一下：</p><ul>\n<li>\n<p>对于n个元素的全排列，所有可能的排列数量就是nx(n-1)x(n-2)x…x2x1，也就是n!；</p>\n</li>\n<li>\n<p>对于n个元素里取出m(0&lt;m≤n)个元素的不重复排列数量是nx(n-1)x(n-2)x…x(n - m + 1)，也就是n!/(n-m)!。</p>\n</li>\n</ul><p>这两点都是可以用数学归纳法证明的，有兴趣的话你可以自己尝试一下。</p><h2>如何让计算机为田忌安排赛马？</h2><p>我们刚才讨论了3匹马的情况，这倒还好。可是，如果有30匹马、300匹马，怎么办？30的阶乘已经是天文数字了。更糟糕的是，如果两组马之间的速度关系也是非常随机的，例如q1&lt;q2&lt;t1&lt;t2&lt;q3&lt;t3， 那就不能再使用“最差的马和对方最好的马比赛”这种战术了。这个时候，人手动肯定是算不过来了，计算机又要帮我们大忙啦！我们使用代码来展示如何生成所有的排列。</p><p>如果你细心的话，就会发现在新版舍罕王赏麦的案例中，其实已经涉及了排列的思想，不过那个案例不是以“选取多少个元素”为终止条件，而是以“选取元素的总和”为终止条件。尽管这样，我们仍然可以使用递归的方式来快速地实现排列。</p><p>不过，要把田忌赛马的案例，转成计算机所能理解的内容，还需要额外下点功夫。</p><p>首先，在不同的选马阶段，我们都要保存已经有几匹马出战、它们的排列顺序、以及还剩几匹马没有选择。我使用变量result来存储到当前函数操作之前，已经出战的马匹及其排列顺序。而变量horses存储了到当前函数操作之前，还剩几匹马还没出战。变量new_result和rest_horses是分别从result和horses克隆而来，保证不会影响上一次的结果。</p><p>其次，孙膑的方法之所以奏效，是因为他看到每一等马中，田忌的马只比齐王的差一点点。如果相差太多，可能就会有不同的胜负结局。所以，在设置马匹跑完全程的时间上，我特意设置为q1&lt;t1&lt;q2&lt;t2&lt;q3&lt;t3，只有这样才能保证计算机得出和孙膑相同的结论。</p><pre><code>import java.util.ArrayList;\nimport java.util.Arrays; \nimport java.util.HashMap;\n\npublic class Lesson7_1 {\n\t\n\t// 设置齐王的马跑完所需时间\n\tpublic static HashMap&lt;String, Double&gt; q_horses_time = new HashMap&lt;String, Double&gt;(){\n\t\t{\n\t\t \t  put(&quot;q1&quot;, 1.0);\n\t\t \t  put(&quot;q2&quot;, 2.0);\n\t\t    put(&quot;q3&quot;, 3.0);\n\t\t}\n\t};\n\t\n\t// 设置田忌的马跑完所需时间\n\tpublic static HashMap&lt;String, Double&gt; t_horses_time = new HashMap&lt;String, Double&gt;(){\n\t\t{\n\t\t \t  put(&quot;t1&quot;, 1.5);\n\t\t \t  put(&quot;t2&quot;, 2.5);\n\t\t    put(&quot;t3&quot;, 3.5);\n\t\t}\n\t};\n\t\n\tpublic\tstatic ArrayList&lt;String&gt; q_horses = new ArrayList&lt;String&gt;(Arrays.asList(&quot;q1&quot;, &quot;q2&quot;, &quot;q3&quot;));\n\t\n\t/**\n    * @Description:\t使用函数的递归（嵌套）调用，找出所有可能的马匹出战顺序\n    * @param horses-目前还剩多少马没有出战，result-保存当前已经出战的马匹及顺序\n    * @return void\n    */\n\t\n    public static void permutate(ArrayList&lt;String&gt; horses, ArrayList&lt;String&gt; result) {\n    \t\n    \t// 所有马匹都已经出战，判断哪方获胜，输出结果\n    \tif (horses.size() == 0) {\n    \t\tSystem.out.println(result);\n    \t\tcompare(result, q_horses);\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n \t \t\t\treturn;\n   \t\t}\n    \t\n   \t\tfor (int i = 0; i &lt; horses.size(); i++) {\n    \t\t// 从剩下的未出战马匹中，选择一匹，加入结果\n \t \t\t\tArrayList&lt;String&gt; new_result = (ArrayList&lt;String&gt;)(result.clone());\n   \t\t\tnew_result.add(horses.get(i));\n  \t \t\t\n    \t\t// 将已选择的马匹从未出战的列表中移出\n \t \t\t\tArrayList&lt;String&gt; rest_horses = ((ArrayList&lt;String&gt;)horses.clone());\n \t \t\t\trest_horses.remove(i);\n    \t\t\n    \t\t// 递归调用，对于剩余的马匹继续生成排列\n   \t\t\tpermutate(rest_horses, new_result);\n   \t\t}\n    \t\n    }\n\n\n}\n \n</code></pre><p>另外，我还使用了compare的函数来比较田忌和齐王的马匹，看哪方获胜。</p><pre><code>    public static void compare(ArrayList&lt;String&gt; t, ArrayList&lt;String&gt; q) {\n    \tint t_won_cnt = 0;\n    \tfor (int i = 0; i &lt; t.size(); i++) {\n\t\t\tSystem.out.println(t_horses_time.get(t.get(i)) + &quot; &quot; +  q_horses_time.get(q.get(i)));\n\t\t\tif (t_horses_time.get(t.get(i)) &lt; q_horses_time.get(q.get(i))) t_won_cnt ++;\n\t\t}\n\t\t\n\t\tif (t_won_cnt &gt; (t.size() / 2)) System.out.println(&quot;田忌获胜！&quot;);\n\t\telse System.out.println(&quot;齐王获胜！&quot;);\n\t\t\n\t\tSystem.out.println();\n    }\n \n</code></pre><p>下面是测试代码。当然你可以设置更多的马匹，并增加相应的马匹跑完全程的时间。</p><pre><code>  public static void main(String[] args) {\n\t\t\n\t\tArrayList&lt;String&gt; horses = new\tArrayList&lt;String&gt;(Arrays.asList(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;));\n\t\tLesson7_1.permutate(horses,\tnew ArrayList&lt;String&gt;());\n\t\t\n\t}\n\n</code></pre><p>在最终的输出结果中，6种排列中只有一种情况是田忌获胜的。</p><pre><code>[t3, t1, t2]\n3.5 1.0\n1.5 2.0\n2.5 3.0\n田忌获胜！\n</code></pre><p>如果田忌不听从孙膑的建议，而是随机的安排马匹出战，那么他只有1/6的获胜概率。</p><p>说到这里，我突然产生了一个想法，如果齐王也是随机安排他的马匹出战顺序，又会是怎样的结果？如果动手来实现的话，大体思路是我们为田忌和齐王两方都生成他们马匹的全排序，然后再做交叉对比，看哪方获胜。这个交叉对比的过程也是个排列的问题，田忌这边有6种顺序，而齐王也是6种顺序，所以一共的可能性是6x6=36种。</p><p>我用代码模拟了一下，你可以看看。</p><pre><code>public static void main(String[] args) {\n\t\t\n\t\tArrayList&lt;String&gt; t_horses = new ArrayList&lt;String&gt;(Arrays.asList(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;));\n\t\tLesson7_2.permutate(t_horses, new ArrayList&lt;String&gt;(), t_results);\n\t\t\n\t\tArrayList&lt;String&gt; q_horses = new ArrayList&lt;String&gt;(Arrays.asList(&quot;q1&quot;, &quot;q2&quot;, &quot;q3&quot;));\n\t\tLesson7_2.permutate(q_horses, new ArrayList&lt;String&gt;(), q_results);\n\t\t\n\t\tSystem.out.println(t_results);\n\t\tSystem.out.println(q_results);\n\t\tSystem.out.println();\n\t\t\n\t\tfor (int i = 0; i &lt; t_results.size(); i++) {\n\t\t\tfor (int j = 0; j &lt; q_results.size(); j++) {\n\t\t\t\tLesson7_2.compare(t_results.get(i), q_results.get(j));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n \n</code></pre><p>由于交叉对比时只需要选择2个元素，分别是田忌的出战顺序和齐王的出战顺序，所以这里使用2层循环的嵌套来实现。从最后的结果可以看出，田忌获胜的概率仍然是1/6。</p><h2>暴力破解密码如何使用排列思想？</h2><p>聊了这么多，相信你对排列有了更多了解。在概率中，排列有很大的作用，因为排列会帮助我们列举出随机变量取值的所有可能性，用于生成这个变量的概率分布，之后在概率统计篇我还会具体介绍。此外，排列在计算机领域中有着很多应用场景。我这里讲讲最常见的密码的暴力破解。</p><p>我们先来看去年网络安全界的两件大事。第一件发生在2017年5月，新型“蠕虫”式勒索病毒WannaCry爆发。当时这个病毒蔓延得非常迅速，电脑被感染后，其中的文件会被加密锁住，黑客以此会向用户勒索比特币。第二件和美国的信用评级公司Equifax有关。仅在2017年内，这个公司就被黑客盗取了大约1.46亿用户的数据。</p><p>看样子，黑客攻击的方式多种多样，手段也高明了很多，但是窃取系统密码仍然是最常用的攻击方式。有时候，黑客们并不需要真的拿到你的密码，而是通过“猜”，也就是列举各种可能的密码，然后逐个地去尝试密码的正确性。如果某个尝试的密码正好和原先管理员设置的一样，那么系统就被破解了。这就是我们常说的<strong>暴力破解法</strong>。</p><p>我们可以假设一个密码是由英文字母组成的，那么每位密码有52种选择，也就是大小写字母加在一起的数量。那么，生成m位密码的可能性就是52^m种。也就是说，从n（这里n为52）个元素取出m（0&lt;m≤n）个元素的可重复全排列，总数量为n^m。如果你遍历并尝试所有的可能性，就能破解密码了。</p><p>不过，即使存在这种暴力法，你也不用担心自己的密码很容易被人破解。我们平时需要使用密码登录的网站或者移动端App程序，基本上都限定了一定时间内尝试密码的次数，例如1天之内只能尝试5次等等。这些次数一定远远小于密码排列的可能性。</p><p>这也是为什么有些网站或App需要你一定使用多种类型的字符来创建密码，比如字母加数字加特殊符号。因为类型越多，n^m中的n越大，可能性就越多。如果使用英文字母的4位密码，就有52^4=7311616种，超过了700万种。如果我们在密码中再加入0～9这10个阿拉伯数字，那么可能性就是62^4=14776336种，超过了1400万。</p><p>同理，我们也可以增加密码长度，也就是用n^m中的m来实现这一点。如果在英文和阿拉伯数字的基础上，我们把密码的长度增加到6位，那么就是62^6=56800235584种，已经超过了568亿了！这还没有考虑键盘上的各种特殊符号。有人估算了一下，如果用上全部256个ASCII码字符，设置长度为8的密码，那么一般的黑客需要10年左右的时间才能暴力破解这种密码。</p><h2>小结</h2><p>排列可以帮助我们生成很多可能性。由于这种特性，排列最多的用途就是穷举法，也就是，列出所有可能的情况，一个一个验证，然后看每种情况是否符合条件的解。</p><p>古代的孙膑利用排列的思想，穷举了田忌马匹的各种出战顺序，然后获得了战胜齐王的策略。现代的黑客，通过排列的方法，穷举了各种可能的密码，试图破坏系统的安全性。如果你所面临的问题，它的答案也是各种元素所组成的排列，那么你就可以考虑，有没有可能排列出所有的可能性，然后通过穷举的方式来获得最终的解。</p><p><img src="https://static001.geekbang.org/resource/image/84/45/84f9e15c857ca0dbc49837ff0e107945.jpg" alt=""></p><h2>思考题</h2><p>假设有一个4位字母密码，每位密码是a～e之间的小写字母。你能否编写一段代码，来暴力破解该密码？（提示：根据可重复排列的规律，生成所有可能的4位密码。）</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "07 | 排列：如何让计算机学会“田忌赛马”？",
      },
      {
        title: "08 | 组合：如何让计算机安排世界杯的赛程？",
        herf: "https://time.geekbang.org/column/article/75662",
        id: "75662",
        content:
          '<p>你好，我是黄申。</p><p>2018年足球世界杯结束有半年了，当时激烈的赛况你现在还记忆犹新吧？你知道这场足球盛宴的比赛日程是怎么安排的吗？如果现在你是组委会，你会怎么安排比赛日程呢？我们可以用上一节的排列思想，让全部的32支入围球队都和其他球队进行一次主客场的比赛。</p><p>自己不可能和自己比赛，因此在这种不可重复的排列中，主场球队有32种选择，而客场球队有31种选择。那么一共要进行多少场比赛呢？很简单，就是32x31=992场！这也太夸张了吧？一天看2场，也要1年多才能看完！即使球迷开心了，可是每队球员要踢主客场共62场，早已累趴下了。</p><p>好吧，既然这样，我们是否可以取消主客场制，让任意两个球队之间只要踢1场就好啦？取消主客场，这就意味着原来两队之间的比赛由2场降为1场，那么所有比赛场次就是992/2=496场。还是很多，对吧？</p><p>是的，这就是为什么要将所有32支队伍分成8个小组先进行小组赛的原因。一旦分成小组，每个小组的赛事就是(4x3)/2=6场。所有小组赛就是6x8=48场。</p><p>再加上在16强阶段开始采取淘汰制，两两淘汰，所以需要8+4+2+2=16场淘汰赛（最后一次加2是因为还有3、4名的决赛），那么整个世界杯决赛阶段就是48+16=64场比赛。</p><!-- [[[read_end]]] --><p>当然，说了这么多，你可能会好奇，这两两配对比赛的场次，我是如何计算出来的？让我引出今天的概念，<strong>组合</strong>（Combination）。</p><p>组合可以说是排列的兄弟，两者类似但又有所不同，这两者的区别，不知道你还记得不，上学的时候，老师肯定说过不止一次，那就是，组合是不考虑每个元素出现的顺序的。</p><p>从定义上来说，组合是指，从n个不同元素中取出m（1≤m≤n）个不同的元素。例如，我们前面说到的世界杯足球赛的例子，从32支球队里找出任意2支球队进行比赛，就是从32个元素中取出2个元素的组合。如果上一讲中，田忌赛马的规则改一下，改为从10匹马里挑出3匹比赛，但是并不关心这3匹马的出战顺序，那么也是一个组合的问题。</p><p>对于所有m取值的组合之全集合，我们可以叫作<strong>全组合</strong>（All Combination）。例如对于集合{1, 2, 3}而言，全组合就是{空集, {1}, {2}, {3}, {1, 2}, {1,3} {2, 3}, {1, 2, 3}}。</p><p>如果我们安排足球比赛时，不考虑主客场，也就是不考虑这两只球队的顺序，两队只要踢一次就行了。那么从n个元素取出m个的组合，有多少种可能呢？</p><p>我们假设某种运动需要3支球队一起比赛，那么32支球队就有32x31x30种排列，如果三支球队在一起只要比一场，那么我们要抹除多余的比赛。三支球队按照任意顺序的比赛有3x2x1=6场，所以从32支队伍里取出3支队伍的组合是(32x31x30)/(3x2x1)。基于此，我们可以扩展成以下两种情况。</p><ul>\n<li>\n<p>n个元素里取出m个的组合，可能性数量就是n个里取m个的排列数量，除以m个全排列的数量，也就是(n! / (n-m)!) / m!。</p>\n</li>\n<li>\n<p>对于全组合而言，可能性为2^n种。例如，当n=3的时候，全组合包括了8种情况。</p>\n</li>\n</ul><p>这两点都可以用数学归纳法证明，有兴趣的话你可以自己尝试一下。</p><h2>如何让计算机来组合队伍？</h2><p>上一节，我用递归实现了全排列。全组合就是将所有元素列出来，没有太大意义，所以我这里就带你看下，如何使用递归从3个元素中选取2个元素的组合。</p><p>我们假设有3个队伍，t1，t2和t3。我还是把递归的选择画成图，这样比较直观，你也好理解。从图中我们可以看出，对于组合而言，由于{t1, t2}已经出现了，因此就无需{t2, t1}。同理，出现{t1, t3}，就无需{t3, t1}等等。对于重复的，我用叉划掉了。这样，最终只有3种组合了。</p><p><img src="https://static001.geekbang.org/resource/image/82/4b/827020c47c2c4b825dc5d51697f5cd4b.jpg" alt=""></p><p>那么，如何使用代码来实现呢？一种最简单粗暴的做法是：</p><ol>\n<li>\n<p>先实现排列的代码，输出所有的排列。例如{t1, t2}, {t2, t1}；</p>\n</li>\n<li>\n<p>针对每种排列，对其中的元素按照一定的规则排序。那么上述两种排列经过排序后，就是{t1, t2}, {t1, t2}；</p>\n</li>\n<li>\n<p>对排序后的排列，去掉重复的那些。上述两种排列最终只保留一个{t1, t2}。</p>\n</li>\n</ol><p>这样做效率就会比较低，很多排列生成之后，最终还是要被当做重复的结果去掉。</p><p>显然，还有更好的做法。从图中我们可以看出被划掉的那些，都是那些出现顺序和原有顺序颠倒的元素。</p><p>例如，在原有集合中，t1在t2的前面，所以我们划掉了{t2, t1}的组合。这是因为，我们知道t1出现在t2之前，t1的组合中一定已经包含了t2，所以t2的组合就无需再考虑t1了。因此，我只需要在原有的排列代码中，稍作修改，每次传入嵌套函数的剩余元素，不再是所有的未选择元素，而是出现在当前被选元素之后的那些。具体代码是这样的：</p><pre><code>import java.util.ArrayList;\nimport java.util.Arrays; \n\npublic class Lesson8_1 {\n\t\n\t/**\n    * @Description:\t使用函数的递归（嵌套）调用，找出所有可能的队伍组合\n    * @param teams-目前还剩多少队伍没有参与组合，result-保存当前已经组合的队伍\n    * @return void\n    */\n\t\n    public static void combine(ArrayList&lt;String&gt; teams, ArrayList&lt;String&gt; result, int m) {\n    \t\n    \t// 挑选完了m个元素，输出结果\n    \tif (result.size() == m) {\n    \t\tSystem.out.println(result);\n    \t\treturn;\n    \t}\n    \t\n    \tfor (int i = 0; i &lt; teams.size(); i++) {\n    \t\t// 从剩下的队伍中，选择一队，加入结果\n    \t\tArrayList&lt;String&gt; newResult = (ArrayList&lt;String&gt;)(result.clone());\n    \t\tnewResult.add(teams.get(i));\n    \t\t\n    \t\t// 只考虑当前选择之后的所有队伍\n    \t\tArrayList&lt;String&gt; rest_teams = new ArrayList&lt;String&gt;(teams.subList(i + 1, teams.size()));\n    \t\t\n    \t\t// 递归调用，对于剩余的队伍继续生成组合\n    \t\tcombine(rest_teams, newResult, m);\n    \t}\n    \t\n    }\n    \n}\n\n</code></pre><p>这是一段测试代码，可以帮助我们找到从3个元素中选择2个元素的所有组合。</p><pre><code>public static void main(String[] args) {\n  \n  ArrayList&lt;String&gt; teams = new ArrayList&lt;String&gt;(Arrays.asList(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;));\n  Lesson8_1.combine(teams, new ArrayList&lt;String&gt;(), 2);\n  \n }\n\n</code></pre><h2>组合的应用：如何高效地处理词组？</h2><p>组合在计算机领域中也有很多的应用场景。比如大型比赛中赛程的自动安排、多维度的数据分析以及自然语言处理的优化等等。</p><p>在我之前的研究工作中，经常要处理一些自然语言，用组合的思想提升系统性能。今天我结合自己亲身的经历，先来说说组合在自然语言处理中的应用。</p><p>当时，我们需要将每篇很长的文章，分隔成一个个的单词，然后对每个单词进行索引，便于日后的查询。但是很多时候，光有单个的单词是不够的，还要考虑多个单词所组成的词组。例如，“red bluetooth mouse”这样的词组。</p><p>处理词组最常见的一种方式是<strong>多元文法</strong>。什么是多元文法呢？这词看起来很复杂，其实就是把临近的几个单词合并起来，组合一个新的词组。比如我可以把“red”和“bluetooth”合并为“red bluetooth”，还可以把“bluetooth”和“mouse”合并为“bluetooth mouse”。</p><p>设计多元文法只是为了方便计算机的处理，而不考虑组合后的词组是不是有正确的语法和语义。例如“red bluetooth”，从人类的角度来看，这个词就很奇怪。但是毕竟它还会生成很多合理的词组，例如“bluetooth mouse”。所以，如果不进行任何深入的语法分析，我们其实没办法区分哪些多元词组是有意义的，哪些是没有意义的，因此最简单的做法就是保留所有词组。</p><p>普通的多元文法本身存在一个问题，那就是定死了每个元组内单词出现的顺序。例如，原文中可能出现的是“red bluetooth mouse”，可是用户在查询的时候可能输入的是“bluetooth mouse red”。这么输入肯定不符合语法，但实际上互联网上的用户经常会这么干。</p><p>那么，在这种情况下，如果我们只保留原文的“red bluetooth mouse”，就无法将其和用户输入的“bluetooth red mouse”匹配了。所以，如果我们并不要求查询词组中单词所出现的顺序和原文一致，那该怎么办呢？</p><p>我当时就在想，可以把每个二元或三元组进行全排列，得到所有的可能。但是这样的话，二元组的数量就会增加1倍，三元组的数量就会增加5倍，一篇文章的数据保存量就会增加3倍左右。我也试过对用户查询做全排列，把原有的二元组查询变为2个不同的二元组查询，把原有的三元组查询变为6个不同的三元组查询，但是事实是，这样会增加实时查询的耗时。</p><p>于是，我就想到了组合。多个单词出现时，我并不关心它们的顺序（也就是不关心排列），而只关心它们的组合。因为无需关心顺序，就意味着我可以对多元组内的单词进行某种形式的标准化。即使原来的单词出现顺序有所不同，经过这个标准化过程之后，都会变成唯一的顺序。</p><p>例如，“red bluetooth mouse”，这三个词排序后就是“bluetooth,mouse,red”，而“bluetooth red mouse”排序后也是“bluetooth,mouse,red”，自然两者就能匹配上了。我需要做的事情就是在保存文章多元组和处理用户查询这两个阶段分别进行这种排序。这样既可以减少保存的数据量，同时可以减少查询的耗时。这个问题很容易就解决了。怎么样，组合是不是非常神奇？</p><p>此外，组合思想还广泛应用在多维度的数据分析中。比如，我们要设计一个连锁店的销售业绩报表。这张报表有若干个属性，包括分店名称、所在城市、销售品类等等。那么最基本的总结数据包括每个分店的销售额、每个城市的销售额、每个品类的销售额。除了这些最基本的数据，我们还可以利用组合的思想，生成更多的筛选条件。</p><h2>小结</h2><p>组合和排列有相似之处，都是从n个元素中取出若干个元素。不过，排列考虑了取出的元素它们之间的顺序，而组合无需考虑这种顺序。这是排列和组合最大的区别。因此，组合适合找到多个元素之间的联系而并不在意它们之间的先后顺序，例如多元文法中的多元组，这有利于避免不必要的数据保存或操作。</p><p>具体到编程，组合和排列两者的实现非常类似。区别在于，组合并不考虑挑选出来的元素之间，是如何排序的。所以，在递归的时候，传入下一个嵌套调用函数的剩余元素，只需要包含当前被选元素之后的那些，以避免重复的组合。</p><p><img src="https://static001.geekbang.org/resource/image/b2/ee/b2cbd776947f32b6a3e5e30f388e0eee.jpg" alt=""></p><h2>思考题</h2><p>假设现在需要设计一个抽奖系统。需要依次从100个人中，抽取三等奖10名，二等奖3名和一等奖1名。请列出所有可能的组合，需要注意的每人最多只能被抽中1次。</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "08 | 组合：如何让计算机安排世界杯的赛程？",
      },
      {
        title: "09 | 动态规划（上）：如何实现基于编辑距离的查询推荐？",
        herf: "https://time.geekbang.org/column/article/75807",
        id: "75807",
        content:
          '<p>你好，我是黄申。</p><p>上一篇讲组合的时候，我最后提到了有关文本的关键字查询。今天我接着文本搜索的话题，来聊聊查询推荐（Query Suggestion）的实现过程，以及它所使用的数学思想，<strong>动态规划</strong>（Dynamic Programming）。</p><p>那什么是动态规划呢？在递归那一节，我说过，我们可以通过不断分解问题，将复杂的任务简化为最基本的小问题，比如基于递归实现的归并排序、排列和组合等。不过有时候，我们并不用处理所有可能的情况，只要找到满足条件的最优解就行了。在这种情况下，我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解。这个寻找最优解的过程其实就是动态规划。</p><p>动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们通常把这些子问题之间的转移称为<strong>状态转移</strong>，并把用于刻画这些状态转移的表达式称为<strong>状态转移方程</strong>。很显然，找到合适的状态转移方程，是动态规划的关键。</p><p>因此，这两节我会通过实际的案例，给你详细解释如何使用动态规划法寻找最优解，包括如何分解问题、发现状态转移的规律，以及定义状态转移方程。</p><h2>编辑距离</h2><p>当你在搜索引擎的搜索框中输入单词的时候，有没有发现，搜索引擎会返回一系列相关的关键词，方便你直接点击。甚至，当你某个单词输入有误的时候，搜索引擎依旧会返回正确的搜索结果。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/1c/eb/1c337d39b48ef544ef811c926c70fbeb.png" alt=""></p><p>搜索下拉提示和关键词纠错，这两个功能其实就是<strong>查询推荐</strong>。查询推荐的核心思想其实就是，对于用户的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是<strong>编辑距离</strong>（Edit Distance）。</p><p>我刚才说了，查询推荐的这两个功能是针对输入有缺失或者有错误的字符串，依旧返回相应的结果。那么，将错误的字符串转成正确的，以此来返回查询结果，这个过程究竟是怎么进行的呢？</p><p>由一个字符串转成另一个字符串所需的最少编辑操作次数，我们就叫作<strong>编辑距离</strong>。这个概念是俄罗斯科学家莱文斯坦提出来的，所以我们也把编辑距离称作莱文斯坦距离（Levenshtein distance）。很显然，编辑距离越小，说明这两个字符串越相似，可以互相作为查询推荐。<strong>编辑操作</strong>有这三种：把一个字符替换成另一个字符；插入一个字符；删除一个字符。</p><p>比如，我们想把mouuse转换成mouse，有很多方法可以实现，但是很显然，直接删除一个“u”是最简单的，所以这两者的编辑距离就是1。</p><h2>状态转移</h2><p>对于mouse和mouuse的例子，我们肉眼很快就能观察出来，编辑距离是1。但是我们现实的场景中，常常不会这么简单。如果给定任意两个非常复杂的字符串，如何高效地计算出它们之间的编辑距离呢？</p><p>我们之前讲过排列和组合。我们先试试用排列的思想来进行编辑操作。比如，把一个字符替换成另一个字符，我们可以想成把A中的一个字符替换成B中的一个字符。假设B中有m个不同的字符，那么替换的时候就有m种可能性。对于插入一个字符，我们可以想成在A中插入来自B的一个字符，同样假设B中有m个不同的字符，那么也有m种可能性。至于删除一个字符，我们可以想成在A中删除任何一个字符，假设A有n个不同的字符，那么有n种可能性。</p><p>可是，等到实现的时候，你会发现实际情况比想象中复杂得多。</p><p>首先，计算量非常大。我们假设字符串A的长度是n，而B字符串中不同的字符数量是m，那么A所有可能的排列大致在m^n这个数量级，这会导致非常久的处理时间。对于查询推荐等实时性的服务而言，服务器的响应时间太长，用户肯定无法接受。</p><p>其次，如果需要在字符串A中加字符，那么加几个呢，加在哪里呢？同样，删除字符也是如此。因此，可能的排列其实远不止m^n。</p><p>我们现在回到问题本身，其实编辑距离只需要求最小的操作次数，并不要求列出所有的可能。而且排列过程非常容易出错，还会浪费大量计算资源。看来，排列的方法并不可行。</p><p>好，这里再来思考一下，其实我们并不需要排列的所有可能性，而只是关心最优解，也就是最短距离。那么，我们能不能每次都选择出一个到目前为止的最优解，并且只保留这种最优解？如果是这样，我们虽然还是使用迭代或者递归编程来实现，但效率上就可以提升很多。</p><p>我们先考虑<strong>最简单的情况</strong>。假设字符串A和B都是空字符串，那么很明显这个时候编辑距离就是0。如果A增加一个字符a1，B保持不动，编辑距离就增加1。同样，如果B增加一个字符b1，A保持不动，编辑距离增加1。但是，如果A和B有一个字符，那么问题就有点复杂了，我们可以细分为以下几种情况。</p><p>我们先来看<strong>插入字符</strong>的情况。A字符串是a1的时候，B空串增加一个字符变为b1；或者B字符串为b1的时候，A空串增加一个字符变为a1。很明显，这种情况下，编辑距离都要增加1。</p><p>我们再来看<strong>替换字符</strong>的情况。当A和B都是空串的时候，同时增加一个字符。如果要加入的字符a1和b1不相等，表示A和B之间转化的时候需要替换字符，那么编辑距离就是加1；如果a1和b1相等，无需替换，那么编辑距离不变。</p><p>最后，我们取上述三种情况中编辑距离的最小值作为当前的编辑距离。注意，这里我们只需要保留这个最小的值，而舍弃其他更大的值。这是为什么呢？因为编辑距离随着字符串的增长，是单调递增的。所以，要求最终的最小值，必须要保证对于每个子串，都取得了最小值。有了这点，之后我们就可以使用迭代的方式，一步步推导下去，直到两个字符串结束比较。</p><p>刚才我说的情况中没有删除，这是因为删除就是插入的逆操作。如果我们从完整的字符串A或者B开始，而不是从空串开始，这就是删除操作了。</p><p>从上述的过程可以看出，我们确实可以把求编辑距离这个复杂的问题，划分为更多更小的子问题。而且，更为重要的一点是，我们在每一个子问题中，都只需要保留一个最优解。之后的问题求解，只依赖这个最优值。这种求编辑距离的方法就是动态规划，而这些子问题在动态规划中被称为不同的状态。</p><p>如果文字描述不是很清楚的话，我这里又画一张表，把各个状态之间的转移都标示清楚，你就一目了然了。</p><p>我还是用mouuse和mouse的例子。我把mouuse的字符数组作为表格的行，每一行表示其中一个字母，而mouse的字符数组作为列，每列表示其中一个字母，这样就得到下面这个表格。</p><p><img src="https://static001.geekbang.org/resource/image/3f/cd/3f696455617c8a0da422df3cdb64d0cd.png" alt=""></p><p>这张表格里的不同状态之间的转移，就是<strong>状态转移</strong>。其中红色部分表示字符串演变（或者说状态转移）的方式以及相应的编辑距离计算。对于表格中其他空白的部分，我暂时不给出，你可以试着自己来推导。</p><p>编辑距离是具有对称性的，也就是说从字符串A到B的编辑距离，和从字符串B到A的编辑距离，两者一定是相等的。这个应该很好理解。</p><p>你可以把刚才那个状态转移表的行和列互换一下，再推导一下，看看得出的编辑距离是否还是1。我现在从理论上解释下这一点。这其实是由编辑距离的三种操作决定的。比如说，从字符串A演变到B的每一种操作，都可以转换为从字符串B演变到A的某一种操作。</p><p><img src="https://static001.geekbang.org/resource/image/18/e8/1824ca86219e0f05591aa48fe7f6dee8.jpg" alt=""></p><p>所以说，从字符串A演变到B的每一种变化方式，都可以找到对应的从字符串B演变到A的某种方式，两者的操作次数一样。自然，代表最小操作次数的编辑距离也就一样了。</p><h2>小结</h2><p>我今天介绍了用于查询推荐的编辑距离。编辑距离的定义很好理解，不过，求任意两个字符串之间的编辑距离可不是一件容易的事情。我先尝试用排列来分析问题，发现这条路走不通，而后我们仍然使用了化繁为简的思路，把编辑距离的计算拆分为3种情况，并建立了子串之间的联系。</p><p>你不要觉得这样的分析过程比较繁琐，我想说的是，学数学固然是为了得到结果，但是学习的过程，是要学会解决问题的方法和思路。比如面对一个问题的时候，你可能不知道用什么方法来解决，但是你可以尝试用我们学过的这些基础思想去分析，去比对，在这个分析的过程中去总结这些方法的使用规律，久而久之，你就能摸索出自己解决问题的套路。</p><p>比如说，动态规划虽然也采用了把问题逐步简化的思想，但是它和基于递归的归并排序、排列组合等解法有所不同。能够使用动态规划解决的问题，通常只关心一个最优解，而这个最优解是单调改变的，例如最大值、最小值等等。因此，动态规划中的每种状态，通常只保留一个当前的最优解，这也是动态规划效率比较高的原因。</p><p><img src="https://static001.geekbang.org/resource/image/f3/94/f37da4a1ef98494dea70016b90922594.jpg" alt=""></p><h2>思考题</h2><p>理解了动态规划法和状态转移之后，你觉得根据编辑距离来衡量字符串之间的相似程度有什么局限性？你有什么优化方案吗？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "09 | 动态规划（上）：如何实现基于编辑距离的查询推荐？",
      },
      {
        title: "10 | 动态规划（下）：如何求得状态转移方程并进行编程实现？",
        herf: "https://time.geekbang.org/column/article/76183",
        id: "76183",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我从查询推荐的业务需求出发，介绍了编辑距离的概念，今天我们要基于此，来获得状态转移方程，然后才能进行实际的编码实现。</p><h2>状态转移方程和编程实现</h2><p>上一节我讲到了使用状态转移表来展示各个子串之间的关系，以及编辑距离的推导。不过，我没有完成那张表格。现在我把它补全，你可以和我的结果对照一下。</p><p><img src="https://static001.geekbang.org/resource/image/26/8c/265fb5d134bfebb2fd2cf712f759468c.png" alt=""></p><p>这里面求最小值的min函数里有三个参数，分别对应我们上节讲的三种情况的编辑距离，分别是：替换、插入和删除字符。在表格的右下角我标出了两个字符串的编辑距离1。</p><p>概念和分析过程你都理解了，作为程序员，最终还是要落脚在编码上，我这里带你做些编码前的准备工作。</p><p>我们假设字符数组A[]和B[]分别表示字符串A和B，A[i]表示字符串A中第i个位置的字符，B[i]表示字符串B中第i个位置的字符。二维数组d[,]表示刚刚用于推导的二维表格，而d[i,j]表示这张表格中第i行、第j列求得的最终编辑距离。函数r(i, j)表示替换时产生的编辑距离。如果A[i]和B[j]相同，函数的返回值为0，否则返回值为1。</p><p>有了这些定义，下面我们用迭代来表达上述的推导过程。</p><ul>\n<li>\n<p>如果i为0，且j也为0，那么d[i, j]为0。</p>\n</li>\n<li>\n<p>如果i为0，且j大于0，那么d[i, j]为j。</p>\n</li>\n<li>\n<p>如果i大于0，且j为0，那么d[i, j]为i。</p>\n</li>\n<li>\n<p>如果i大于0，且 j大于0，那么d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))。</p>\n</li>\n</ul><!-- [[[read_end]]] --><p>这里面最关键的一步是d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))。这个表达式表示的是动态规划中从上一个状态到下一个状态之间可能存在的一些变化，以及基于这些变化的最终决策结果。我们把这样的表达式称为<strong>状态转移方程</strong>。我上节最开始就说过，在所有动态规划的解法中，状态转移方程是关键，所以你一定要掌握它。</p><p>有了状态转移方程，我们就可以很清晰地用数学的方式，来描述状态转移及其对应的决策过程，而且，有了状态转移方程，具体的编码其实就很容易了。基于编辑距离的状态转移方程，我在这里列出了一种编码的实现，你可以看看。</p><p>我们首先要定义函数的参数和返回值，你需要注意判断一下a和b为null的情况。</p><pre><code> public class Lesson10_1 {\n\t\n\t/**\n    * @Description:\t使用状态转移方程，计算两个字符串之间的编辑距离\n    * @param a-第一个字符串，b-第二个字符串\n    * @return int-两者之间的编辑距离\n    */\n\t\n\tpublic static int getStrDistance(String a, String b) {\n\t\t\n\t\tif (a == null || b == null) return -1;\n</code></pre><p>然后，初始化状态转移表。我用int型的二维数组来表示这个状态转移表，并对i为0且j大于0的元素，以及i大于0且j为0的元素，赋予相应的初始值。</p><pre><code>  // 初始用于记录化状态转移的二维表\n\t\tint[][] d = new int[a.length() + 1][b.length() + 1];\n\t\t\n\t\t// 如果i为0，且j大于等于0，那么d[i, j]为j\n\t\tfor (int j = 0; j &lt;= b.length(); j++) {\n\t\t\td[0][j] = j;\n\t\t}\n\t\t\n\t\t// 如果i大于等于0，且j为0，那么d[i, j]为i\n\t\tfor (int i = 0; i &lt;= a.length(); i++) {\n\t\t\td[i][0] = i;\n\t\t}\n</code></pre><p>我这里实现的时候，i和j都是从0开始，所以我计算的d[i+1, j+1]，而不是d[i, j]。而d[i+1, j+1] = min(d[i, j+1] + 1, d[i+1, j] + 1, d[i, j] + r(i, j)。</p><pre><code>  // 实现状态转移方程\n\t\t// 请注意由于Java语言实现的关系，代码里的状态转移是从d[i, j]到d[i+1, j+1]，而不是从d[i-1, j-1]到d[i, j]。本质上是一样的。\n\t\tfor (int i = 0; i &lt; a.length(); i++) {\n\t\t\tfor (int j = 0; j &lt; b.length(); j++) {\n\t\t\t\t\n\t\t\t\tint r = 0;\n\t\t\t\tif (a.charAt(i) != b.charAt(j)) {\n\t\t\t\t\tr = 1;\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tint first_append = d[i][j + 1] + 1;\n\t\t\t\tint second_append = d[i + 1][j] + 1;\n\t\t\t\tint replace = d[i][j] + r;\n\t\t\t\t\n\t\t\t\tint min = Math.min(first_append, second_append);\n\t\t\t\tmin = Math.min(min, replace);\n\t\t\t\td[i + 1][j + 1] = min;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn d[a.length()][b.length()];\n\t\t\t\t\n\t}\n\n}\n</code></pre><p>最后，我们用测试代码测试不同字符串之间的编辑距离。</p><pre><code>public static void main(String[] args) {\n  // TODO Auto-generated method stub\n  System.out.println(Lesson10_1.getStrDistance(&quot;mouse&quot;, &quot;mouuse&quot;));\n\n }\n</code></pre><p>从推导的表格和最终的代码可以看出，我们相互比较长度为m和n的两个字符串，一共需要求mxn个子问题，因此计算量是mxn这个数量级。和排列法的m^n相比，这已经降低太多太多了。</p><p>我们现在可以快速计算出编辑距离，所以就能使用这个距离作为衡量字符串之间相似度的一个标准，然后就可以进行查询推荐了。</p><p>到这里，使用动态规划来实现的编辑距离其实就讲完了。我把两个字符串比较的问题，分解成很多子串进行比较的子问题，然后使用状态转移方程来描述状态（也就是子问题）之间的关系，并根据问题的定义，保留最小的值作为当前的编辑距离，直到过程结束。</p><p>如果我们使用动态规划法来实现编辑距离的测算，那就能确保查询推荐的效率和效果。不过，基于编辑距离的算法也有局限性，它只适用于拉丁语系的相似度衡量，所以通常只用于英文或者拼音相关的查询。如果是在中文这种亚洲语系中，差一个汉字（或字符）语义就会差很远，所以并不适合使用基于编辑距离的算法。</p><h2>实战演练：钱币组合的新问题</h2><p>和排列组合等穷举的方法相比，动态规划法关注发现某种最优解。如果一个问题无需求出所有可能的解，而是要找到满足一定条件的最优解，那么你就可以思考一下，是否能使用动态规划来降低求解的工作量。</p><p>还记得之前我们提到的新版舍罕王奖赏的故事吗？国王需要支付一定数量的赏金，而宰相要列出所有可能的钱币组合，这使用了排列组合的思想。如果这个问题再变化为“给定总金额和可能的钱币面额，能否找出钱币数量最少的奖赏方式？”，那么我们是否就可以使用动态规划呢？</p><p>思路和之前是类似的。我们先把这个问题分解成很多更小金额的子问题，然后试图找出状态转移方程。如果增加一枚钱币c，那么当前钱币的总数量就是增加c之前的钱币总数再加上当前这枚。举个例子，假设这里我们有三种面额的钱币，2元、3元和7元。为了凑满100元的总金额，我们有三种选择。</p><p>第一种，总和98元的钱币，加上1枚2元的钱币。如果凑到98元的最少币数是$x_{1}$，那么增加一枚2元后就是($x_{1}$ + 1)枚。</p><p>第二种，总和97元的钱币，加上1枚3元的钱币。如果凑到97元的最少币数是$x_{2}$，那么增加一枚3元后就是($x_{2}$ + 1)枚。</p><p>第三种，总和93元的钱币，加上1枚7元的钱币。如果凑到93元的最少币数是$x_{3}$，那么增加一枚7元后就是($x_{3}$ + 1)枚。</p><p><img src="https://static001.geekbang.org/resource/image/e5/d9/e5a9b9e6d931049bfae92ead29e37cd9.jpg" alt=""></p><p>比较一下以上三种情况的钱币总数，取最小的那个就是总额为100元时，最小的钱币数。换句话说，由于奖赏的总金额是固定的，所以最后选择的那枚钱币的面额，将决定到上一步为止的金额，同时也决定了上一步为止钱币的最少数量。根据这个，我们可以得出如下状态转移方程：</p><p><img src="https://static001.geekbang.org/resource/image/d8/27/d81e704031156e605b61610ef681c427.jpg" alt=""></p><p>其中，c[i]表示总额为i的时候，所需要的最少钱币数，其中j=1,2,3,…,n，表示n种面额的钱币，value[j]表示第j种钱币的面额。c[i - values(j)]表示选择第j种钱币的时候，上一步为止最少的钱币数。需要注意的是，i - value(j)需要大于等于0，而且c[0] = 0。</p><p>我这里使用这个状态转移方程，做些推导，具体的数据你可以看下面这个表格。表格每一行表示奖赏的总额，前3列表示3种钱币的面额，最后一列记录最少的钱币数量。表中的“/”表示不可能，或者说无解。</p><p><img src="https://static001.geekbang.org/resource/image/e7/58/e78354fe2f577d07649882fed69bd358.png" alt=""></p><p>这张状态转移表同样可以帮助你来理解状态转移方程的正确性。一旦状态转移方程确定了，要编写代码来实现就不难了。</p><h2>小结</h2><p>通过这两节的内容，我讲述了动态规划主要的思想和应用。如果仅仅看这两个案例，也许你觉得动态规划不难理解。不过，在实际应用中，你可能会产生这些疑问：什么时候该用动态规划？这个问题可以用动态规划解决啊，为什么我没想到？我这里就讲一些我个人的经验。</p><p>首先，如果一个问题有很多种可能，看上去需要使用排列或组合的思想，但是最终求的只是某种最优解（例如最小值、最大值、最短子串、最长子串等等），那么你不妨试试是否可以使用动态规划。</p><p>其次，状态转移方程是个关键。你可以用状态转移表来帮助自己理解整个过程。如果能找到准确的转移方程，那么离最终的代码实现就不远了。当然，最好的方式，还是结合工作中的项目，不断地实践，尝试，然后总结。</p><p><img src="https://static001.geekbang.org/resource/image/7e/5b/7e084bc699b4939b78226718756fd65b.jpg" alt=""></p><h2>思考题</h2><p>对于总金额固定、找出最少钱币数的题目，用循环或者递归的方式该如何进行编码呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "10 | 动态规划（下）：如何求得状态转移方程并进行编程实现？",
      },
      {
        title: "11 | 树的深度优先搜索（上）：如何才能高效率地查字典？",
        herf: "https://time.geekbang.org/column/article/76481",
        id: "76481",
        content:
          '<p>你好，我是黄申。</p><p>你还记得迭代法中的的二分查找吗？在那一讲中，我们讨论了一个查字典的例子。如果要使用二分查找，我们首先要把整个字典排个序，然后每次都通过二分的方法来缩小搜索范围。</p><p>不过在平时的生活中，咱们查字典并不是这么做的。我们都是从单词的最左边的字母开始，逐个去查找。比如查找“boy”这个单词，我们一般是这么查的。首先，在a～z这26个英文字母里找到单词的第一个字母b，然后在b开头的单词里找到字母o，最终在bo开头的单词里找到字母y。</p><p>你可以看我画的这种树状图，其实就是从树顶层的根结点一直遍历到最下层的叶子结点，最终逐步构成单词前缀的过程。对应的数据结构就是<strong>前缀树</strong>（prefix tree）<strong>，或者叫字典树</strong>（trie）。我个人更喜欢前缀树这个名称，因为看到这个名词，这个数据结构的特征就一目了然。</p><p><img src="https://static001.geekbang.org/resource/image/f4/34/f4cffbdefa0cd94eda18294c47bf8e34.jpg" alt=""></p><p>那前缀树究竟该如何构建呢？有了前缀树，我们又该如何查询呢？今天，我会从图论的基本概念出发，来给你讲一下什么样的结构是树，以及如何通过树的深度优先搜索，来实现前缀树的构建和查询。</p><h2>图论的一些基本概念</h2><p>前缀树是一种有向树。那什么是有向树？顾名思义，有向树就是一种树，特殊的就是，它的边是有方向的。而树是没有简单回路的连通图。</p><!-- [[[read_end]]] --><p>如果一个图里所有的边都是有向边，那么这个图就是有向图。如果一个图里所有的边都是无向边，那么这个图就是无向图。既含有向边，又含无向边的图，称为混合图。</p><p><img src="https://static001.geekbang.org/resource/image/bb/7d/bb472743016ead750fc7a80d8fc6bf7d.jpg" alt=""></p><p>在有向图中，以结点$v$为出发点的边的数量，我们叫作$v$的<strong>出度</strong>。而以$v为$终点的边之数量，称为$v$的<strong>入度</strong>。在上图中，结点$v_{2}$的入度是1，出度是2。</p><p>还有两个和有向树有关的概念，回路和连通，我这里简单给你解释一下，你很容易就能明白了。</p><p>结点和边的交替序列组成的就是<strong>通路</strong>。所以，通路上的任意两个结点其实就是互为连通的。如果一条通路的起始点$v_{1}$和终止点$v_{n}$相同，这种特殊的通路我们就叫作<strong>回路</strong>。从起始点到终止点所经过的边之数量，就是通路的长度。这里我画了一张图，这里面有1条通路和1条回路，第一条非回路通路的长度是3，第二条回路的长度是4。</p><p><img src="https://static001.geekbang.org/resource/image/d6/7b/d6f3fc3ffa213ba714a25091485ff97b.jpeg" alt=""></p><p>理解了图的基本概念，我们再来看树和有向树。<strong>树</strong>是一种特殊的图，它是没有简单回路的连通无向图。这里的简单回路，其实就是指，除了第一个结点和最后一个结点相同外，其余结点不重复出现的回路。你可以看我画的这几幅图。</p><p><img src="https://static001.geekbang.org/resource/image/e8/92/e8705553ef8e27adf0e2f5005671f492.jpg" alt=""></p><p>那么，什么是<strong>有向树</strong>呢？顾名思义，有向树是一种特殊的树，其中的边都是有向的，而且它满足以下几个条件：</p><ul>\n<li>\n<p>有且仅有一个结点的入度为0，这个结点被称为根；</p>\n</li>\n<li>\n<p>除根以外的所有结点，入度都为1。从树根到任一结点有且仅有一条有向通路。</p>\n</li>\n</ul><p>除了这些基本定义，有向树还有几个重要的概念，父结点、子结点、兄弟结点、先辈结点、后辈结点、叶子结点、结点的高度（或深度）、树的高度（或深度）。这些都不难理解，我画个图展示一下，你就能明白了。我把根结点的高度设置为0，根据需要你也可以设置为1。</p><p><img src="https://static001.geekbang.org/resource/image/36/13/366d75b7566adfb09f71f3ae4ad7dd13.jpg" alt=""></p><h2>前缀树的构建和查询</h2><p>好了，说了这么些，你对有向树应该有了理解。接下来，我们来看，如何使用有向树来实现前缀树呢？这整个过程主要包括两个部分：构建前缀树和查询前缀树。</p><h3>1. 构建前缀树</h3><p>首先，我们把空字符串作为树的根。对于每个单词，其中每一个字符都代表了有向树的一个结点。而前一个字符就是后一个字符的父结点，后一个字符是前一个字符的子结点。这也意味着，每增加一个字符，其实就是在当前字符结点下面增加一个子结点，相应地，树的高度也增加了1。</p><p>我们以单词geek为例，从根结点开始，第一次我增加字符g，在根结点下增加一个“g”的结点。第二次，我在“g”结点下方增加一个“e”结点。以此类推，最终我们可以得到下面的树。</p><p><img src="https://static001.geekbang.org/resource/image/d0/26/d06e56e85242f66552672d0f7ada7b26.jpg" alt=""></p><p>那如果这个时候，再增加一个单词，geometry会怎样？我们继续重复这个过程，就能得到下面这个图。</p><p><img src="https://static001.geekbang.org/resource/image/95/8f/950f2b49edf271a36a5f96cf2187638f.jpg" alt=""></p><p>到这里为止，我们已经建立了包含两个单词的前缀树。在这棵树的两个叶子结点“k”和“y”上，我们可以加上额外的信息，比如单词的解释。那么在匹配成功之后，就可以直接返回这些信息，实现字典的功能了。假设我把牛津词典里所有的英文单词都按照上述的方法处理一遍，就能构造一棵包含这个字典里所有单词的前缀树，并实现常用单词的查找和解释。</p><h3>2. 查询前缀树</h3><p>假设我们已经使用牛津词典，构建完了一个完整的前缀树，现在我们就能按照开篇所说的那种方式，查找任何一个单词了。从前缀树的根开始，查找下一个结点，顺着这个通路走下去，一直走到到某个结点。如果这个结点及其前缀代表了一个存在的单词，而待查找的单词和这个结点及其前缀正好完全匹配，那就说明成功找到了一个单词。否则，就表示无法找到。</p><p>这里还有几种特殊情况，需要注意。</p><ul>\n<li>\n<p>如果还没到叶子结点的时候，待查的单词就结束了。这个时候要看最后匹配上的非叶子结点是否代表一个单词；如果不是，那说明被查单词并不在字典中。</p>\n</li>\n<li>\n<p>如果搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母。由于叶子结点没有子结点，这时候，被查单词不可能在字典中。</p>\n</li>\n<li>\n<p>如果搜索到一半，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的字符匹配了。这时候，被查单词不可能在字典中。</p>\n</li>\n</ul><p>前缀树的构建和查询这两者在本质上其实是一致的。构建的时候，我们需要根据当前的前缀进行查询，然后才能找到合适的位置插入新的结点。而且，这两者都存在一个不断重复迭代的查找过程，我们把这种方式称为<strong>深度优先搜索</strong>（Depth First Search）。</p><p>所谓树的深度优先搜索，其实就是从树中的某个结点出发，沿着和这个结点相连的边向前走，找到下一个结点，然后以这种方式不断地发现新的结点和边，一直搜索下去，直到访问了所有和出发点连通的点、或者满足某个条件后停止。</p><p>如果到了某个点，发现和这个点直接相连的所有点都已经被访问过，那么就回退到在这个点的父结点，继续查看是否有新的点可以访问；如果没有就继续回退，一直到出发点。由于单棵树中所有的结点都是连通的，所以通过深度优先的策略可以遍历树中所有的结点，因此也被称为<strong>深度优先遍历</strong>。</p><p>为了让你更容易理解，我用下面这张图来展示在一棵有向树中进行深度优先搜索时，结点被访问的顺序。</p><p><img src="https://static001.geekbang.org/resource/image/fd/f9/fdc74a1d4797eee2b397e7c6fe5992f9.jpg" alt=""></p><p>其中，结点上的数字表示结点的ID，而虚线表示遍历前进的方向，结点边上的数字表示该结点在深度优先搜索中被访问的顺序。在深度优先的策略下，我们从点110出发，然后发现和110相连的点123，访问123后继续发现和123相连的点162，再往后发现162没有出度，因此回退到123，查看和123相连的另一个点587，根据587的出度继续往前推进，如此类推。</p><p>把深度优先搜索，和在前缀树中查询单词的过程对比一下，你就会发现两者的逻辑是一致的。不过，使用前缀树匹配某个单词的时候，只需要沿着一条可能的通路搜索下去，而无需遍历树中所有的结点。</p><h2>小结</h2><p>在这一讲，我从数学中图的一些基本定义入手，介绍了有向树，以及有向树的一个应用，前缀树。树在计算机领域中运用非常广泛。比如，二叉树和满二叉树。</p><p>二叉树是每个结点最多有两个子树的树结构，它可用于二叉查找树和二叉堆。二叉树甚至可以用于图示化我们之前聊过的二分迭代。</p><p>满二叉树是一棵高度为n（高度从1开始计），且有2^n-1个结点的二叉树。在高度为k(0&lt;k≤n）的这一层上，结点的数量为2^(k-1)。如果把树的根标为0，每个结点的左子结点标为0，每个结点的右子结点标为1，那么把根到叶子结点的所有0或1连起来，就正好对应一个二进制数。</p><p><img src="https://static001.geekbang.org/resource/image/56/89/564ee1181fe4b351a12f8af690311d89.jpg" alt=""></p><p>既然树是如此重要，那么我们该如何高效率地访问树中的结点呢？下一讲，我会继续前缀树的话题，讨论如何遍历树中所有结点。</p><p><img src="https://static001.geekbang.org/resource/image/79/09/79701ece6ee3d1a7efdcba51c5684e09.jpg" alt=""></p><h2>思考题</h2><p>现在给你一个字典，请尝试实现其前缀树，包括树的构建和查询两个过程。这里，字典可以用字符串数组来表示，每个字符串代表一个单词。</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title: "11 | 树的深度优先搜索（上）：如何才能高效率地查字典？",
      },
      {
        title: "12 | 树的深度优先搜索（下）：如何才能高效率地查字典？",
        herf: "https://time.geekbang.org/column/article/76822",
        id: "76822",
        content:
          '<p>你好，我是黄申。今天咱们继续聊前缀树。</p><p>上节结尾我给你留了道思考题：如何实现前缀树的构建和查询？如果你动手尝试之后，你会发现，这个案例的实现没有我们前面讲的那些排列组合这么直观。</p><p>这是因为，从数学的思想，到最终的编程实现，其实需要一个比较长的流程。我们首先需要把问题转化成数学中的模型，然后使用数据结构和算法来刻画数学模型，最终才能落实到编码。</p><p>而在前缀树中，我们需要同时涉及树的结构、树的动态构建和深度优先搜索，这个实现过程相对比较复杂。所以，这节我就给你仔细讲解一下，这个实现过程中需要注意的点。只要掌握这些点，你就能轻而易举实现深度优先搜索。</p><h2>如何使用数据结构表达树？</h2><p>首先，我想问你一个问题，什么样的数据结构可以表示树？</p><p>我们知道，计算机中最基本的数据结构是数组和链表。数组适合快速地随机访问。不过，数组并不适合稀疏的数列或者矩阵，而且数组中元素的插入和删除操作也比较低效。相对于数组，链表的随机访问的效率更低，但是它的优势是，不必事先规定数据的数量，表示稀疏的数列或矩阵时，可以更有效地利用存储空间，同时也利于数据的动态插入和删除。</p><p>我们再来看树的特点。树的结点及其之间的边，和链表中的结点和链接在本质上是一样的，因此，我们可以模仿链表的结构，用编程语言中的指针或对象引用来构建树。</p><!-- [[[read_end]]] --><p>除此之外，我们其实还可以用二维数组。用数组的行或列元素表示树中的结点，而行和列共同确定了两个树结点之间是不是存在边。可是在树中，这种二维关系通常是非常稀疏的、非常动态的，所以用数组效率就比较低下。</p><p>基于上面这些考虑，我们可以设计一个TreeNode类，表示有向树的结点和边。这个类需要体现前缀树结点最重要的两个属性。</p><ul>\n<li>\n<p>这个结点所代表的字符，要用label变量表示。</p>\n</li>\n<li>\n<p>这个结点有哪些子结点，要用sons哈希映射表示。之所以用哈希，是为了便于查找某个子结点（或者说对应的字符）是否存在。</p>\n</li>\n</ul><p>另外，我们还可以用变量prefix表示当前结点之前的前缀，用变量explanation表示某个单词的解释。和之前一样，为了代码的简洁，所有属性都用了public，避免读取和设置类属性的代码。</p><p>这里我写了一段TreeNode类的代码，来表示前缀树的结点和边，你可以看看。</p><pre><code>/**\n* @Description: 前缀树的结点\n* \n*/\n \n public class TreeNode {\n  \n  public char label;  // 结点的名称，在前缀树里是单个字母\n  public HashMap&lt;Character, TreeNode&gt; sons = null; // 使用哈希映射存放子结点。哈希便于确认是否已经添加过某个字母对应的结点。\n  public String prefix = null;   // 从树的根到当前结点这条通路上，全部字母所组成的前缀。例如通路b-&gt;o-&gt;y，对于字母o结点而言，前缀是b；对于字母y结点而言，前缀是bo\n  public String explanation = null;  // 词条的解释\n  \n  // 初始化结点\n  public TreeNode(char l, String pre, String exp) {\n   label = l;\n   prefix = pre; \n   explanation = exp;\n   sons = new HashMap&lt;&gt;();\n   \n  }\n  \n }\n</code></pre><p>说到这里，你可能会好奇，为什么只有结点的定义，而没有边的定义呢？实际上，这里的有向边表达的是父子结点之间的关系，我把这种关系用sons变量来存储父结点。</p><p>需要注意的是，我们需要动态地构建这棵树。每当接收一个新单词时，代码都需要扫描这个单词的每个字母，并使用当前的前缀树进行匹配。如果匹配到某个结点，发现相应的字母结点并不存在，那么就建立一个新的树结点。这个过程不好理解，我也写了几行代码，你可以结合来看。其中，str表示还未处理的字符串，parent表示父结点。</p><pre><code>// 处理当前字符串的第一个字母\nchar c = str.toCharArray()[0];\nTreeNode found = null;\n\n// 如果字母结点已经存在于当前父结点之下，找出它。否则就新生成一个\nif (parent.sons.containsKey(c)) {\n\tfound = parent.sons.get(c);\n} else {\n\tTreeNode son = new TreeNode(c, pre, &quot;&quot;);\n\tparent.sons.put(c, son);\n\tfound = son;\n}\n</code></pre><h2>如何使用递归和栈实现深度优先搜索？</h2><p>构建好了数据结构，我们现在需要考虑，<strong>什么样的编程方式可以实现对树结点和边的操作？</strong></p><p>仔细观察前缀树构建和查询，你会发现这两个不断重复迭代的过程，都可以使用递归编程来实现。换句话说，<strong>深度优先搜索的过程和递归调用在逻辑上是一致的</strong>。</p><p>我们可以把函数的嵌套调用，看作访问下一个连通的结点；把函数的返回，看作没有更多新的结点需要访问，回溯到上一个结点。在之前的案例中，我已经讲过很多次递归编程的例子，这里我就不列举代码细节了。如果忘记的话，你可以回去前面章节复习一下。</p><p>在查询的过程中，至少有三种情况是无法在字典里找到被查的单词的。于是，我们需要在递归的代码中做相应的处理。</p><p><strong>第一种情况：被查单词所有字母都被处理完毕，但是我们仍然无法在字典里找到相应的词条。</strong></p><p>每次递归调用的函数开始，我们都需要判断待查询的单词，看看是否还有字母需要处理。如果没有更多的字母需要匹配了，那么再确认一下当前匹配到的结点本身是不是一个单词。如果是，就返回相应的单词解释，否则就返回查找失败。对于结点是不是一个单词，你可以使用Node类中的explanation变量来进行标识和判断，如果不是一个存在的单词，这个变量应该是空串或者Null值。</p><p><strong>第二种情况：搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母，就返回查找失败。</strong></p><p>我们可以通过结点对象的sons变量来判断这个结点是不是叶子结点。如果是叶子结点，这个变量应该是空的HashMap，或者Null值。</p><p><strong>第三种情况：搜索到中途，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的label匹配，返回查找失败。是不是叶子仍然通过结点对象的sons变量来判断。</strong></p><p>好了，现在你已经可以很方便地在字典里查找某个单词，看看它是否存在，或者看看它的解释是什么。我这里又有一个新的问题了：<strong>如果我想遍历整个字典中所有的单词，那该怎么办呢？</strong></p><p>仔细观察一下，你应该能发现，查找一个单词的过程，其实就是在有向树中，找一条从树的根到代表这个单词的结点之通路。那么如果要遍历所有的单词，就意味着我们要找出从根到所有代表单词的结点之通路。所以，在每个结点上，我们不再是和某个待查询单词中的字符进行比较，而是要遍历该结点所有的子结点，这样才能找到所有可能的通路。我们还可以用递归来实现这一过程。</p><p>尽管函数递归调用非常直观，可是也有它自身的弱点。函数的每次嵌套，都可能产生新的变量来保存中间结果，这可能会消耗大量的内存。所以这里我们可以用一个更节省内存的数据结构，栈（Stack）。</p><p>栈的特点是先进后出（First In Last Out），也就是，最先进入栈的元素最后才会得到处理。我画了一张元素入栈和出栈的过程图，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/53/c1/5391e9f266cb795cec532cc54928b8c1.jpg" alt=""></p><p>为什么栈可以进行深度优先搜索呢？你可以先回顾一下上一节，我解释深度优先搜索时候的例子。为了方便你回想，我把图放在这里了。</p><p><img src="https://static001.geekbang.org/resource/image/90/b7/900c981c816375268eefdf274cb149b7.jpg" alt=""></p><p>然后，我们用栈来实现一下这个过程。</p><p>第1步，将初始结点110压入栈中。</p><p>第2步，弹出结点110，搜出下一级结点123、879、945和131。</p><p>第3步，将结点123、879、945和131压入栈中。</p><p>第4步，重复第2步和第3步弹出和压入的步骤，处理结点123，将新发现结点162和587压入栈中。</p><p>第5步，处理结点162，由于162是叶子结点，所以没有发现新的点。第6步，重复第2和第3步，处理结点587，将新发现结点681压入栈中。</p><p>……</p><p>第n-1步，重复第2和第3步，处理结点131，将新发现结点906压入栈中。</p><p>第n步，重复第2和第3步，处理结点906，没有发现新的结点，也没有更多待处理的结点，整个过程结束。</p><p><img src="https://static001.geekbang.org/resource/image/89/45/893203ec268e095397966b58e1c71d45.jpg" alt=""></p><p>从上面的步骤来看，栈先进后出的特性，可以模拟函数的递归调用。实际上，计算机系统里的函数递归，在内部也是通过栈来实现的。如果我们不使用函数调用时自动生成的栈，而是手动使用栈的数据结构，就能始终保持数据的副本只有一个，大大节省内存的使用量。</p><p>用TreeNode类和栈实现深度优先搜索的代码我写出来了，你可以看看。</p><pre><code>// 使用栈来实现深度优先搜索\npublic void dfsByStack(TreeNode root) {\n\n  Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); \n\t  // 创建堆栈对象，其中每个元素都是TreeNode类型\n  stack.push(root);\t\t// 初始化的时候，压入根结点\n\n  while (!stack.isEmpty()) {\t// 只要栈里还有结点，就继续下去\n\t\n\tTreeNode node = stack.pop();\t// 弹出栈顶的结点\n\t\n\tif (node.sons.size() == 0) {\n\t\t// 已经到达叶子结点了，输出\n\t\tSystem.out.println(node.prefix + node.label);\n\t} else {\n\t\t// 非叶子结点，遍历它的每个子结点\n\t\tIterator&lt;Entry&lt;Character, TreeNode&gt;&gt; iter \n\t\t\t= node.sons.entrySet().iterator();\n\t\t\n\t\t// 注意，这里使用了一个临时的栈stackTemp\n\t\t// 这样做是为了保持遍历的顺序，和递归遍历的顺序是一致的\n\t\t// 如果不要求一致，可以直接压入stack\n\t\tStack&lt;TreeNode&gt; stackTemp = new Stack&lt;TreeNode&gt;();\n\t\twhile (iter.hasNext()) {\n\t\t\tstackTemp.push(iter.next().getValue());\n\t\t}\n\t\twhile (!stackTemp.isEmpty()) {\n\t\t\tstack.push(stackTemp.pop());\n\t\t}\n\t}\n  }\n\n}\t\n</code></pre><p>这里面有个细节需要注意一下。当我们把某个结点的子结点压入栈的时候，由于栈“先进后出”的特性，会导致子结点的访问顺序，和递归遍历时子结点的访问顺序相反。如果你希望两者保持一致，可以用一个临时的栈stackTemp把子结点入栈的顺序颠倒过来。</p><h2>小结</h2><p>这一节我们用递归来实现了深度优先搜索。说到这，你可能会想到，之前讨论的归并排序、排列组合等课题，也采用了递归来实现，那它们是不是也算深度优先搜索呢？</p><p>我把归并排序和排列的分解过程放在这里，它们是不是也可以用有向树来表示呢？</p><p>在归并排序的数据分解阶段，初始的数据集就是树的根结点，二分之前的数据集代表父节点，而二分之后的左半边的数据集和右半边的数据集都是父结点的子结点。分解过程一直持续到单个的数值，也就是最末端的叶子结点，很明显这个阶段可以用树来表示。如果使用递归编程来进行数据的切分，那么这种实现就是深度优先搜索的体现。</p><p><img src="https://static001.geekbang.org/resource/image/54/12/5410fb301ffce57355ad7ef074e8fd12.jpg" alt=""></p><p>在排列中，我们可以把空集认为是树的根结点，如果把每次选择的元素作为父结点，那么剩下可选择的元素，就构成了这个父结点的子结点。而每多选择一个元素，就会把树的高度加1。因此，我们也可以使用递归和深度优先搜索，列举所有可能的排列。</p><p><img src="https://static001.geekbang.org/resource/image/98/15/98df21876ad52195217709e298707515.jpg" alt=""></p><p>从这两个例子，我们可以看出有些数学思想都是相通的，例如递归、排列和深度优先搜索等等。</p><p>我来总结一下，其实深度优先搜索的核心思想，就是按照当前的通路，不断地向前进，当遇到走不通的时候就回退到上一个结点，通过另一个新的边进行尝试。如果这一个点所有的方向都走不通的时候，就继续回退。这样一次一次循环下去，直到到达目标结点。树中的每个结点，既可以表示某个子问题和它所对应的抽象状态，也可以表示某个数据结构中一部分具体的值。</p><p>所以，我们需要做的是，观察问题是否可以使用递归的方式来逐步简化，或者是否需要像前缀树这样遍历，如果是，就可以尝试使用深度优先搜索来帮助我们思考并解决问题。</p><p><img src="https://static001.geekbang.org/resource/image/ae/c7/aeef1d5f6be9b5d09618a189520055c7.jpg" alt=""></p><h2>思考题</h2><p>这两节我讲的是树的深度优先搜索。如果是在一般的图中进行深度优先搜索，会有什么不同呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "12 | 树的深度优先搜索（下）：如何才能高效率地查字典？",
      },
      {
        title: "13 | 树的广度优先搜索（上）：人际关系的六度理论是真的吗？",
        herf: "https://time.geekbang.org/column/article/77129",
        id: "77129",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我们探讨了如何在树的结构里进行深度优先搜索。说到这里，有一个问题，不知道你有没有思考过，树既然是两维的，我们为什么一定要朝着纵向去进行深度优先搜索呢？是不是也可以朝着横向来进行搜索呢？今天我们就来看另一种搜索机制，广度优先搜索。</p><h2>社交网络中的好友问题</h2><p>LinkedIn、Facebook、微信、QQ这些社交网络平台都有大量的用户。在这些社交网络中，非常重要的一部分就是人与人之间的“好友”关系。</p><p>在数学里，为了表示这种好友关系，我们通常使用图中的结点来表示一个人，而用图中的边来表示人和人之间的相识关系，那么社交网络就可以用图论来表示。而“相识关系”又可以分为单向和双向。</p><p>单向表示，两个人a和b，a认识b，但是b不认识a。如果是单向关系，我们就需要使用有向边来区分是a认识b，还是b认识a。如果是双向关系，双方相互认识，因此直接用无向边就够了。在今天的内容里，我们假设相识关系都是双向的，所以我们今天讨论的都是无向图。</p><p><img src="https://static001.geekbang.org/resource/image/26/52/26d0c89c9d6b968a9cd3fb889663f752.jpg" alt=""></p><p>从上面的例图可以看出，人与人之间的相识关系，可以有多条路径。比如，张三可以直接连接赵六，也可以通过王五来连接赵六。比较这两条通路，最短的通路长度是1，因此张三和赵六是一度好友。也就是说，这里我用两人之间最短通路的长度，来定义他们是几度好友。照此定义，在之前的社交关系示意图中，张三、王五和赵六互为一度好友，而李四和赵六、王五为二度好友。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/3d/cb/3da7b008f235bfde1ca29ff8d66415cb.jpg" alt=""></p><p>寻找两个人之间的最短通路，或者说找出两人是几度好友，在社交中有不少应用。例如，向你推荐新的好友、找出两人之间的关系的紧密程度、职场背景调查等等。在LinkedIn上，有个功能就是向你推荐了你可能感兴趣的人。下面这张图是我的LinkedIn主页里所显示的好友推荐。</p><p><img src="https://static001.geekbang.org/resource/image/61/8f/61bfeb62a8d60da3a8aeb5c4b2a32d8f.png" alt=""></p><p>这些被推荐的候选人，和我都有不少的共同连接，也就是共同好友。所以他们都是我的二度好友。但是，他们和我之间还没有建立直接的联系，因此不是一度好友。也就是说，对于某个当前用户，LinkedIn是这么来选择好友推荐的：</p><ul>\n<li>\n<p>被推荐的人和当前用户不是一度好友；</p>\n</li>\n<li>\n<p>被推荐的人和当前用户是二度好友。</p>\n</li>\n</ul><p>那为什么我们不考虑“三度“甚至是“四度”好友呢？我前面已经说过，两人之间最短的通路长度，表示他们是几度好友。那么三度或者四度，就意味着两人间最短的通路也要经历2个或更多的中间人，他们的关系就比较疏远，互相添加好友的可能性就大大降低。</p><p>所以呢，总结一下，如果我们想进行好友推荐，那么就要优先考虑用户的“二度“好友，然后才是“三度”或者“四度”好友。那么，下一个紧接着要面临的问题就是：给定一个用户，如何优先找到他的二度好友呢？</p><h2>深度优先搜索面临的问题</h2><p>这种情况下，你可能会想到上一篇介绍的深度优先搜索。深度优先搜索不仅可以用在树里，还可以应用在图里。不过，我们要面临的问题是图中可能存在回路，这会增加通路的长度，这是我们在计算几度好友时所不希望的。所以在使用深度优选搜索的时候，一旦遇到产生回路的边，我们需要将它过滤。具体的操作是，判断新访问的点是不是已经在当前通路中出现过，如果出现过就不再访问。</p><p>如果过滤掉产生回路的边，从一个用户出发，我们确实可以使用深度优先的策略，搜索完他所有的n度好友，然后再根据关系的度数，从二度、三度再到四度进行排序。这是个解决方法，但是效率太低了。为什么呢？</p><p>你也许听说过社交关系的六度理论。这个理论神奇的地方在于，它说地球上任何两个人之间的社交关系不会超过六度。咋一听，感觉不太可能。仔细想想，假设每个人平均认识100个人（我真心不觉得100很多，不信你掰着指头数数看自己认识多少人），那么你的二度好友就是100^2，这个可以用我们前面讲的排列思想计算而来。</p><p>以此类推，三度好友是100^3，到五度好友就有100亿人了，已经超过了地球目前的总人口。即使存在一些好友重复的情况下，例如，你的一度好友可能也出现在你的三度好友中，那这也不可能改变结果的数量级。所以目前来看，地球上任何两个人之间的社会关系不会超过六度。</p><p>六度理论告诉我们，你的社会关系会随着关系的度数增加，而呈指数级的膨胀。这意味着，在深度搜索的时候，每增加一度关系，就会新增大量的好友。但是你仔细回想一下，当我们在用户推荐中查看可能的好友时，基本上不会看完所有推荐列表，最多也就看个几十个人，一般可能也就看看前几个人。所以，如果我们使用深度优先搜索，把所有可能的好友都找到再排序，那效率实在太低了。</p><h2>什么是广度优先搜索？</h2><p>更高效的做法是，我们只需要先找到所有二度的好友，如果二度好友不够了，再去找三度或者四度的好友。这种好友搜索的模式，其实就是我们今天要介绍的广度优先搜索。</p><p><strong>广度优先搜索</strong>（Breadth First Search），也叫<strong>宽度优先搜索</strong>，是指从图中的某个结点出发，沿着和这个点相连的边向前走，去寻找和这个点距离为1的所有其他点。只有当和起始点距离为1的所有点都被搜索完毕，才开始搜索和起始点距离为2的点。当所有和起始点距离为2的点都被搜索完了，才开始搜索和起始点距离为3的点，如此类推。</p><p>我用上一节介绍深度优先搜索顺序的那棵树，带你看一下广度优先搜索和深度优先搜索，在结点访问的顺序上有什么不一样。</p><p><img src="https://static001.geekbang.org/resource/image/8f/d4/8feed421333ad442eb8dec4e574eb4d4.jpg" alt=""></p><p>同样，我们用结点上的数字表示结点的ID，用虚线表示遍历前进的方向，用结点边上的数字表示该结点在广度优先搜索中被访问的顺序。从这个图中，你有没有发现，广度优先搜索其实就是横向搜索一颗树啊！</p><p>尽管广度优先和深度优先搜索的顺序是不一样的，它们也有两个共同点。</p><p>第一，在前进的过程中，我们不希望走重复的结点和边，所以会对已经被访问过的点做记号，而在之后的前进过程中，就只访问那些还没有被标记的点。这一点上，广度优先和深度优先是一致的。有所不同的是，在广度优先中，如果发现和某个结点直接相连的点都已经被访问过，那么下一步就会看和这个点的兄弟结点直接相连的那些点，从中看看是不是有新的点可以访问。</p><p>例如，在上图中，访问完结点945的两个子结点580和762之后，广度优先策略发现945没有其他的子结点了，因此就去查看945的兄弟结点131，看看它有哪些子结点可以访问，因此下一个被访问的点是906。而在深度优先中，如果到了某个点，发现和这个点直接相连的所有点都已经被访问过了，那么不会查看它的兄弟结点，而是回退到这个点的父节点，继续查看和父结点直接相连的点中是不是存在新的点。例如在上图中，访问完结点945的两个子结点之后，深度优先策略会回退到点110，然后访问110的子结点131。</p><p>第二，广度优先搜索也可以让我们访问所有和起始点相通的点，因此也被称为广度优先遍历。如果一个图包含多个互不连通的子图，那么从起始点开始的广度优先搜索只能涵盖其中一个子图。这时，我们就需要换一个还没有被访问过的起始点，继续广度优先遍历另一个子图。广度优先搜索可以使用同样的方式来遍历有多个连通子图的图，这也回答了上一讲的思考题。</p><h2>如何实现社交好友推荐？</h2><p>第12讲中我说深度优先是利用递归的嵌套调用、或者是栈的数据结构来实现的。然而，广度优先的访问顺序是不一样的，我们需要优先考虑和某个给定结点距离为1的所有其他结点。等距离为1的结点访问完，才会考虑距离为2的结点。等距离为2的结点访问完，才会考虑距离为3的结点等等。在这种情况下，我们无法不断地根据结点的边走下去，而是要先遍历所有距离为1的点。</p><p>那么，如何在记录所有已被发现的结点情况下，优先访问距离更短的点呢？仔细观察，你会发现和起始点更近的结点，会先更早地被发现。也就是说，越早被访问到的结点，越早地处理它，这是不是很像我们平时排队的情形？早到的人可以优先接受服务，而晚到的人需要等前面的人都离开，才能轮到。所以这里我们需要用到队列这种先进先出（First In First Out）的数据结构。</p><p>如果你不是很熟悉队列的数据结构，我这里简短地回顾一下。队列是一种线性表，要被访问的下一个元素来自队列的头部，而所有新来的元素都会加入队列的尾部。</p><p>我画了张图给你讲队列的工作过程。首先，读取已有元素的时候，都是从队列的头部来取，例如$x_{1}$，$x_{2}$等等。所有新的元素都加入队列的尾部，例如$x_{m}$，$x_{m+1}$。</p><p><img src="https://static001.geekbang.org/resource/image/b2/a1/b2962dffa28a5c2f3b51bd6039242da1.jpg" alt=""></p><p>那么在广度优先搜索中，队列是如何工作的呢？这主要分为以下几个步骤。</p><p>首先，把初始结点放入队列中。然后，每次从队列首位取出一个结点，搜索所有在它下一级的结点。接下来，把新发现的结点加入队列的末尾。重复上述的步骤，直到没有发现新的结点为止。</p><p>我以上面的树状图为例，并通过队列实现广度优先搜索。</p><p><img src="https://static001.geekbang.org/resource/image/bf/90/bf8188bd3eccee22dcdda1b2a939c790.jpg" alt=""></p><p>第1步，将初始结点110加入队列中。</p><p>第2步，取出结点110，搜出下一级结点123、879、945和131。</p><p>第3步，将点123、879、945和131加入队列的末尾。</p><p>第4步，重复第2和第3步，处理结点123，将新发现结点162和587加入队列末尾。</p><p>第5步，重复第2和第3步，处理结点879，没有发现新结点。</p><p>第6步，重复第2和第3步，处理结点945，将新发现的结点580和762加入队列末尾。</p><p>……</p><p>第n-1步，重复第2和第3步，处理结点906，没有发现新结点。</p><p>第n步，重复第2和第3步，处理结点681，没有发现新的结点，也没有更多待处理的结点，整个过程结束。</p><p>理解了如何使用队列来实现广度优先搜索之后，我们就可以开始着手编写代码。我们现在没有现成的用户关系网络数据，所以我们需要先模拟生成一些用户结点及其间的相识关系，然后利用队列的数据结构进行广度优先的搜索。基于此，主要使用的数据结构包括：</p><ul>\n<li>\n<p><strong>用户结点Node</strong>。这次设计的用户结点和前缀树结点TreeNode略有不同，包含了用户的ID user_id，以及这个用户的好友集合。我用HashSet实现，便于在生成用户关系图的时候，确认是否会有重复的好友。</p>\n</li>\n<li>\n<p>表示整个图的<strong>结点数组Node[]</strong>。由于每个用户使用user_id来表示，所以我可以使用连续的数组表示所有的用户。用户的user_id就是数组的下标。</p>\n</li>\n<li>\n<p><strong>队列Queue</strong>。由于Java中Queue是一个接口，因此需要用一个拥有具体实现的LinkedList类。</p>\n</li>\n</ul><p>首先我们列出结点Node类的示例代码。</p><pre><code>public class Node {\n\t\t\n\t\tpublic int user_id;\t\t// 结点的名称，这里使用用户id\n\t\tpublic HashSet&lt;Integer&gt; friends = null;\t\n\t\t\t\t// 使用哈希映射存放相连的朋友结点。哈希便于确认和某个用户是否相连。\n\t\tpublic int degree;\t\t// 用于存放和给定的用户结点，是几度好友\n\t\t\n\t\t// 初始化结点\n\t\tpublic Node(int id) {\n\t\t\tuser_id = id;\n\t\t\tfriends = new HashSet&lt;&gt;();\n\t\t\tdegree = 0;\n  }\t\t\n\t}\n</code></pre><p>我们可以用代码随机生成用户间的关系。首先根据指定的用户数量，生成Node[]数组，以及数组中的每个用户的节点Node。然后根据边的数量，生成用户之间的相识关系。需要注意的是，自己不能是自己的好友，而且某个用户的所有好友之中不能有重复的人。</p><pre><code>Node[] user_nodes = new Node[user_num];\n\n// 生成所有表示用户的结点\nfor (int i = 0; i &lt; user_num; i++) {\n\tuser_nodes[i] = new Node(i);\n}\n\n// 生成所有表示好友关系的边\nfor (int i = 0; i &lt; relation_num; i++) {\n\tint friend_a_id = rand.nextInt(user_num);\n\tint friend_b_id = rand.nextInt(user_num);\n\tif (friend_a_id == friend_b_id) continue;\t\n      // 自己不能是自己的好友。如果生成的两个好友id相同，跳过\n\tNode friend_a = user_nodes[friend_a_id];\n\tNode friend_b = user_nodes[friend_b_id];\n\n          friend_a.friends.add(friend_b_id);\n          friend_b.friends.add(friend_a_id);\n}\n</code></pre><p>其中，user_num-用户的数量，也就是结点的数量。relation_num-好友关系的数量，也就是边的数量。由于HashSet有去重的功能，所以我这里做了简化处理，没有判断是否存在重复的边，也没有因为重复的边而重新生成另一条边。</p><p>随后我们的主角，广度优先搜索就要出场了。这里我使用了一个visited变量，存放已经被访问过的结点，防止回路的产生。</p><pre><code>/**\n* @Description:\t通过广度优先搜索，查找好友\n* @param user_nodes-用户的结点；user_id-给定的用户ID，我们要为这个用户查找好友\n* @return void\n*/\n\npublic static void bfs(Node[] user_nodes, int user_id) {\n\t\t\n\t\tif (user_id &gt; user_nodes.length) return;\t// 防止数组越界的异常\n\t\t\n\t\tQueue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\t// 用于广度优先搜索的队列\n\t\t\n\t\tqueue.offer(user_id);\t\t// 放入初始结点\n\t\tHashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;();\t// 存放已经被访问过的结点，防止回路\n\t\tvisited.add(user_id);\n\t\t\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint current_user_id = queue.poll();\t\t// 拿出队列头部的第一个结点\n\t\t\tif (user_nodes[current_user_id] == null) continue;\n\t\t\t\n\t\t\t// 遍历刚刚拿出的这个结点的所有直接连接结点，并加入队列尾部\n\t\t\tfor (int friend_id : user_nodes[current_user_id].friends) {\n\t\t\t\tif (user_nodes[friend_id] == null) continue;\n\t\t\t\tif (visited.contains(friend_id)) continue;\n\t\t\t\tqueue.offer(friend_id);\n\t\t\t\tvisited.add(friend_id);\t// 记录已经访问过的结点\n\t\t\t\tuser_nodes[friend_id].degree = user_nodes[current_user_id].degree + 1;\t\t// 好友度数是当前结点的好友度数再加1\n\t\t\t\tSystem.out.println(String.format(&quot;\\t%d度好友：%d&quot;,  user_nodes[friend_id].degree, friend_id));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n</code></pre><p>需要注意的是，这里用户结点之间的边是随机生成的，所以每次结果会有所不同。如果想重现固定的结果，可以从某个文件加载用户之间的关系。</p><h2>小结</h2><p>在遍历树或者图的时候，如果使用深度优先的策略，被发现的结点数量可能呈指数级增长。如果我们更关心的是最近的相连结点，比如社交关系中的二度好友，那么这种情况下，广度优先策略更高效。也正是由于这种特性，我们不能再使用递归编程或者栈的数据结构来实现广度优先，而是需要用到具有先进先出特点的队列。</p><p><img src="https://static001.geekbang.org/resource/image/2b/40/2b985dc5dba11a41d968cca57254d640.jpg" alt=""></p><h2>思考题</h2><p>在计算机的操作系统中，我们常常需要查看某个目录下的文件或子目录。现在给定一个目录的路径，请分别使用深度优先和广度优先搜索，列出该目录下所有的文件和子目录。对于子目录，需要进一步展示其下的文件和子目录，直到没有更多的子目录。</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title:
          "13 | 树的广度优先搜索（上）：人际关系的六度理论是真的吗？",
      },
      {
        title:
          "14 | 树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？",
        herf: "https://time.geekbang.org/column/article/77474",
        id: "77474",
        content:
          '<p>你好，我是黄申。</p><p>上一讲，我们通过社交好友的关系，介绍了为什么需要广度优先策略，以及如何通过队列来实现它。有了广度优先搜索，我们就可以知道某个用户的一度、二度、三度等好友是谁。不过，在社交网络中，还有一个经常碰到的问题，那就是给定两个用户，如何确定他们之间的关系有多紧密？</p><p>最直接的方法是，使用这两人是几度好友来衡量他们关系的紧密程度。今天，我就这个问题，来聊聊广度优先策略的一种扩展：双向广度优先搜索，以及这种策略在工程中的应用。</p><h2>如何更高效地求两个用户间的最短路径？</h2><p>基本的做法是，从其中一个人出发，进行广度优先搜索，看看另一个人是否在其中。如果不幸的话，两个人相距六度，那么即使是广度优先搜索，同样要达到万亿级的数量。</p><p>那究竟该如何更高效地求得两个用户的最短路径呢？我们先看看，影响效率的问题在哪里？很显然，随着社会关系的度数增加，好友数量是呈指数级增长的。所以，如果我们可以控制这种指数级的增长，那么就可以控制潜在好友的数量，达到提升效率的目的。</p><p>如何控制这种增长呢？我这里介绍一种“<strong>双向广度优先搜索</strong>”。它巧妙地运用了两个方向的广度优先搜索，大幅降低了搜索的度数。现在我就带你看下，这个方法的核心思想。</p><p>假设有两个人$a$、$b$。我们首先从$a$出发，进行广度优先搜索，记录$a$的所有一度好友$a_{1}$，然后看点$b$是否出现在集合$a_{1}$中。如果没有，就再从$b$出发，进行广度优先搜索，记录所有一度好友$b_{1}$，然后看$a$和$a_{1}$是否出现在$b$和$b_{1}$的并集中。如果没有，就回到$a$，继续从它出发的广度优先搜索，记录所有二度好友$a_{2}$，然后看$b$和$b_{1}$是否出现在$a$、$a_{1}$和$a_{2}$三者的并集中。如果没有，就回到$b$，继续从它出发的广度优先搜索。如此轮流下去，直到找到$a$的好友和$b$的好友的交集。</p><!-- [[[read_end]]] --><p>如果有交集，就表明这个交集里的点到$a$和$b$都是通路。我们假设$c$在这个交集中，那么把$a$到$c$的通路长度和$b$到$c$的通路长度相加，得到的就是从$a$到$b$的最短通路长（这个命题可以用反证法证明），也就是两者为几度好友。这个过程略有点复杂，我画了一张图帮助你来理解。</p><p><img src="https://static001.geekbang.org/resource/image/b6/0e/b665fdbd81e7d0fb3245fbcd3b21230e.jpg" alt=""></p><p>思路你应该都清楚了，现在我们来看看如何用代码来实现。</p><p>要想实现双向广度优先搜索，首先我们要把结点类Node稍作修改，增加一个变量degrees。这个变量是HashMap类型，用于存放从不同用户出发，到当前用户是第几度结点。比如说，当前结点是4，从结点1到结点4是3度，结点2到结点4是2度，结点3到结点4是4度，那么结点4的degrees变量存放的就是如下映射：</p><p><img src="https://static001.geekbang.org/resource/image/e2/47/e27d792a83dbe325ad5d0432910ffb47.png" alt=""></p><p>有了变量degrees，我们就能随时知道某个点和两个出发点各自相距多少。所以，在发现交集之后，根据交集中的点，和两个出发点各自相距多少，就能很快地算出最短通路的长度。理解了这点之后，我们在原有的Node结点内增加degrees变量的定义和初始化。</p><pre><code>public class Node {\n\t\t......\n\t\tpublic HashMap&lt;Integer, Integer&gt; degrees;\t\t// 存放从不同用户出发，当前用户结点是第几度\n\t\t\n\t\t// 初始化结点\n\t\tpublic Node(int id) {\n\t\t\t......\n\t\t\tdegrees = new HashMap&lt;&gt;();\n\t\t\tdegrees.put(id, 0);\n\t\t}\n\t}\n\n</code></pre><p>为了让双向广度优先搜索的代码可读性更好，我们可以先实现两个模块化的函数：getNextDegreeFriend和hasOverlap。函数getNextDegreeFriend是根据给定的队列，查找和起始点相距度数为指定值的所有好友。而函数hasOverlap用来判断两个集合是不是有交集。有了这些模块化的函数，双向广度优先搜索的代码就更直观了。</p><p>在函数一开始，我们先进行边界条件判断。</p><pre><code>/**\n* @Description:\t通过双向广度优先搜索，查找两人之间最短通路的长度\n* @param user_nodes-用户的结点；user_id_a-用户a的ID；user_id_b-用户b的ID\n* @return void\n*/\n\tpublic static int bi_bfs(Node[] user_nodes, int user_id_a, int user_id_b) {\n\t\t\n\t\tif (user_id_a &gt; user_nodes.length || user_id_b &gt; user_nodes.length) return -1;\t// 防止数组越界的异常\n\t\t\n\t\tif (user_id_a == user_id_b) return 0;\t\t// 两个用户是同一人，直接返回0\n</code></pre><p>由于同时从两个用户的结点出发，对于所有有两条搜索的路径，我们都需要初始化两个用于广度优先搜索的队列，以及两个用于存放已经被访问结点的HashSet。</p><pre><code>  Queue&lt;Integer&gt; queue_a = new LinkedList&lt;Integer&gt;();\t// 队列a，用于从用户a出发的广度优先搜索\n\t\tQueue&lt;Integer&gt; queue_b = new LinkedList&lt;Integer&gt;();\t// 队列b，用于从用户b出发的广度优先搜索\n\t\t\n\t\tqueue_a.offer(user_id_a);\t\t// 放入初始结点\n\t\tHashSet&lt;Integer&gt; visited_a = new HashSet&lt;&gt;();\t// 存放已经被访问过的结点，防止回路\n\t\tvisited_a.add(user_id_a);\n\t\t\n\t\tqueue_b.offer(user_id_b);\t\t// 放入初始结点\n\t\tHashSet&lt;Integer&gt; visited_b = new HashSet&lt;&gt;();\t// 存放已经被访问过的结点，防止回路\n\t\tvisited_b.add(user_id_b);\n\t\t\n</code></pre><p>接下来要做的是，从两个结点出发，沿着各自的方向，每次广度优先搜索一度，并查找是不是存在重叠的好友。</p><pre><code>int degree_a = 0, degree_b = 0, max_degree = 20;\t\t// max_degree的设置，防止两者之间不存在通路的情况\n\nwhile ((degree_a + degree_b) &lt; max_degree) {\n\t\t\tdegree_a ++;\n\t\t\tgetNextDegreeFriend(user_id_a, user_nodes, queue_a, visited_a, degree_a);\n\t// 沿着a出发的方向，继续广度优先搜索degree + 1的好友\n\t\t\tif (hasOverlap(visited_a, visited_b)) return (degree_a + degree_b);\n\t// 判断到目前为止，被发现的a的好友，和被发现的b的好友，两个集合是否存在交集\n\t\t\t\n\t\t\tdegree_b ++;\n\t\t\tgetNextDegreeFriend(user_id_b, user_nodes, queue_b, visited_b, degree_b);\n\t// 沿着b出发的方向，继续广度优先搜索degree + 1的好友\n\t\t\tif (hasOverlap(visited_a, visited_b)) return (degree_a + degree_b);\n\t// 判断到目前为止，被发现的a的好友，和被发现的b的好友，两个集合是否存在交集\n\t\t\t\n\t\t}\n  \n\t\treturn -1;\t\t\t\n    // 广度优先搜索超过max_degree之后，仍然没有发现a和b的重叠，认为没有通路\n\t\t\n\t}\n</code></pre><p>你可以同时实现单向广度优先搜索和双向广度优先搜索，然后通过实验来比较两者的执行时间，看看哪个更短。如果实验的数据量足够大（比如说结点在1万以上，边在5万以上），你应该能发现，双向的方法对时间和内存的消耗都更少。为什么双向搜索的效率更高呢？我以平均好友度数为4，给你举例讲解。</p><p>左边的图表示从结点$a$单向搜索走2步，右边的图表示分别从结点$a$和$b$双向搜索各走1步。很明显，左边的结点有16个，明显多于右边的8个结点。而且，随着每人认识的好友数、搜索路径的增加，这种差距会更加明显。</p><p><img src="https://static001.geekbang.org/resource/image/15/5b/1518aaa073b379b20ba3dca8dde08d5b.jpg" alt=""></p><p>我们假设每个地球人平均认识100个人，如果两个人相距六度，单向广度优先搜索要遍历100^6=1万亿左右的人。如果是双向广度优先搜索，那么两边各自搜索的人只有100^3=100万。</p><p>当然，你可能会说，单向广度优先搜索之后查找匹配用户的开销更小啊。的确如此，假设我们要知道结点$a$和$b$之间的最短路径，单向搜索意味着要在$a$的1万亿个好友中查找$b$。如果采用双向搜索的策略，从结点$a$和$b$出发进行广度优先搜索，每个方向会产生100万的好友，那么需要比较这两组100万的好友是否有交集。假设我们使用哈希表来存储$a$的1万亿个好友，并把搜索$b$是否存在其中的耗时记作x，而把判断两组100万好友是否有交集的耗时记为y，那么通常x&lt;y。</p><p>不过，综合考虑广度优先搜索出来的好友数量，双向广度优先搜索还是更有效。为什么这么说呢？稍后介绍算法复杂度的概念和衡量方法时，我会具体来分析这个例子。</p><p>广度优先搜索的应用场景有很多，下面我来说说这种策略的一个应用。</p><h2>如何实现更有效的嵌套型聚合？</h2><p>广度优先策略可以帮助我们大幅优化数据分析中的聚合操作。聚合是数据分析中一个很常见的操作，它会根据一定的条件把记录聚集成不同的分组，以便我们统计每个分组里的信息。目前，SQL语言中的GROUP BY语句，Python和Spark语言中data frame的groupby函数，Solr的facet查询和Elasticsearch的aggregation查询，都可以实现聚合的功能。</p><p>我们可以嵌套使用不同的聚合，获得层级型的统计结果。但是，实际上，针对一个规模超大的数据集，聚合的嵌套可能会导致性能严重下降。这里我来谈谈如何利用广度优先的策略，对这种问题进行优化。</p><p>首先，我用一个具体的例子来给你讲讲，什么是多级嵌套的聚合，以及为什么它会产生严重的性能问题。</p><p>这里我列举了一个数据表，它描述了一个社交网络中，每个人的职业经历。字段包括项目的ID、用户ID、公司ID和同事的IDs。</p><p><img src="https://static001.geekbang.org/resource/image/82/02/8216d39c6bdc3925e5ea139071a41202.png" alt=""></p><p>对于这张表，我们可以进行三层嵌套的聚集。第一级是根据用户ID来聚，获取每位用户一共参与了多少项目。第二级是根据公司ID来聚，获取每位用户在每家公司参与了多少项目。第三级根据同事ID来聚，获取每位用户在每家公司，和每位同事共同参与了多少项目。最终结果应该是类似下面这样的：</p><pre><code>用户u88，总共50个项目（包括在公司c42中的10个，c26中的8个...）\n\t\t在公司c42中，参与10个项目（包括和u120共事的4个，和u99共事的3个...）\n\t\t\t\t和u120共同参与4个项目\n\t\t\t\t和u99共同参与3个项目\n\t\t\t\t和u72共同参与3个项目\n\t\t在公司c26中，参与了8个项目\n\t\t\t\t和u145共同参与5个项目\n\t\t\t\t和u128共同参与3个项目\n\t\t（用户u88在其他公司的项目...）\n\n用户u66，总共47个项目\n\t\t在公司c28中，参与了16个项目\n\t\t  和u65共同参与了5个项目\n(用户u66的剩余数据...）\n...\t\t\n（其他用户的数据...）\n</code></pre><p>为了实现这种嵌套式的聚合统计，你会怎么来设计呢？看起来挺复杂的，其实我们可以用最简单的排列的思想，分别为“每个用户”“每个用户+每个公司”“每个用户+每个公司+每位同事”，生成很多很多的计数器。可是，如果用户的数量非常大，那么这个“很多”就会成为一个可怕的数字。</p><p>我们假设这个社交网有5万用户，每位用户平均在5家公司工作过，而用户在每家公司平均有10名共事的同事，那么针对用户的计数器有5万个，针对“每个用户+每个公司”的计数器有25万个，而到了“每个用户+每个公司+每位同事”的计数器，就已经达到250万个了，三个层级总共需要280万计数器。</p><p><img src="https://static001.geekbang.org/resource/image/61/d8/61dc9b211bf5f7e4f33bf24b1dba9cd8.jpg" alt=""></p><p>我们假设一个计数器是4个字节，那么280万个计数器就需要消耗超过10M的内存。对于高并发、低延迟的实时性服务，如果每个请求都要消耗10M内存，很容易就导致服务器崩溃。另外，实时性的服务，往往只需要前若干个结果就足以满足需求了。在这种情况下，完全基于排列的设计就有优化的空间了。</p><p>从刚才那张图中，其实我们就能想到一些优化的思路。</p><p>对于只需要返回前若干结果的应用场景，我们可以对图中的树状结构进行剪枝，去掉绝大部分不需要的结点和边，这样就能节省大量的内存和CPU计算。</p><p>比如，如果我们只需要返回前100个参与项目最多的用户，那么就没有必要按照深度优先的策略，去扩展树中高度为2和3的结点了，而是应该使用广度优先策略，首先找出所有高度为1的结点，根据项目数量进行排序，然后只取出前100个，把计数器的数量从5万个一下子降到100个。</p><p>以此类推，我们还可以控制高度为2和3的结点之数量。如果我们只要看前100位用户，每位用户只看排名第一的公司，而每家公司只看合作最多的3名同事，那么最终计数器数量就只有50000+100x5+100x1x10=51500。只有文字还是不太好懂，我画了一张图，帮你理解这个过程。</p><p><img src="https://static001.geekbang.org/resource/image/81/d6/8183dff98d2f84b053ca103cb26566d6.jpg" alt=""><img src="https://static001.geekbang.org/resource/image/86/25/86e89d1df417e7e1d364e1416855b625.jpg" alt=""></p><p>如果一个项目用到排列组合的思想，我们需要在程序里使用大量的变量，来保存数据或者进行计算，这会导致内存和CPU使用量的急剧增加。在允许的情况下，我们可以考虑使用广度优先策略，对排列组合所生成的树进行优化。这样，我们就可以有效地缩减树中靠近根的结点数量，避免之后树的爆炸性生长。</p><h2>小结</h2><p>广度优先搜索，相对于深度优先搜索，没有函数的嵌套调用和回溯操作，所以运行速度比较快。但是，随着搜索过程的进行，广度优先需要在队列中存放新遇到的所有结点，因此占用的存储空间通常比深度优先搜索多。</p><p>相比之下，深度优先搜索法只保留用于回溯的结点，而扩展完的结点会从栈中弹出并被删除。所以深度优先搜索占用空间相对较少。不过，深度优先搜索的速度比较慢，而并不适合查找结点之间的最短路径这类的应用。</p><p><img src="https://static001.geekbang.org/resource/image/d7/64/d735ed146cac3ca1f81df5acbe634664.jpg" alt=""></p><h2>思考题</h2><p>今天所说的双向广度优先比单向广度优先更高效，其实是要基于一个前提条件的。你能否说出，在什么情况下，单向广度优先更高效呢？针对这种情况，又该如何优化双向广度优先呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title:
          "14 | 树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？",
      },
      {
        title: "15 | 从树到图：如何让计算机学会看地图？",
        herf: "https://time.geekbang.org/column/article/77849",
        id: "77849",
        content:
          '<p>你好，我是黄申。</p><p>我们经常使用手机上的地图导航App，查找出行的路线。那计算机是如何在多个选择中找到最优解呢？换句话说，计算机是如何挑选出最佳路线的呢？</p><p>前几节，我们讲了数学中非常重要的图论中的概念，图，尤其是树中的广度优先搜索。在广度优先的策略中，因为社交网络中的关系是双向的，所以我们直接用无向边来求解图中任意两点的最短通路。</p><p>这里，我们依旧可以用图来解决这个问题，但是，影响到达最终目的地的因素有很多，比如出行的交通工具、行驶的距离、每条道路的交通状况等等，因此，我们需要赋予到达目的地的每条边不同的权重。而我们想求的最佳路线，其实就是各边权重之和最小的通路。</p><p>我们前面说了，广度优先搜索只测量通路的长度，而不考虑每条边上的权重。那么广度优先搜索就无法高效地完成这个任务了。那我们能否把它改造或者优化一下呢？</p><p>我们需要先把交通地图转为图的模型。图中的每个结点表示一个地点，每条边表示一条道路或者交通工具的路线。其中，边是有向的，表示单行道等情况。其次，边是有权重的。</p><p>假设你关心的是路上所花费的时间，那么权重就是从一点到另一点所花费的时间；如果你关心的是距离，那么权重就是两点之间的物理距离。这样，我们就把交通导航转换成图论中的一个问题：在边有权重的图中，如何让计算机查找最优通路？</p><!-- [[[read_end]]] --><h2>基于广度优先或深度优先搜索的方法</h2><p>我们以寻找耗时最短的路线为例来看看。</p><p>一旦我们把地图转换成了图的模型，就可以运用广度优先搜索，计算从某个出发点，到图中任意一个其他结点的总耗时。基本思路是，从出发点开始，广度优先遍历每个点，当遍历到某个点的时候，如果该点还没有耗时的记录，记下当前这条通路的耗时。如果该点之前已经有耗时记录了，那就比较当前这条通路的耗时是不是比之前少。如果是，那就用当前的替换掉之前的记录。</p><p>实际上，地图导航和之前社交网络最大的不同在于，每个结点被访问了一次还是多次。在之前的社交网络的案例中，使用广度优先策略时，对每个结点的首次访问就能获得最短通路，因此每个结点只需要被访问一次，这也是为什么广度优先比深度优先更有效。</p><p>而在地图导航的案例中，从出发点到某个目的地结点，可能有不同的通路，也就意味着耗时不同。而耗时是通路上每条边的权重决定的，而不是通路的长度。因此，为了获取达到某个点的最短时间，我们必须遍历所有可能的路线，来取得最小值。这也就是说，我们对某些结点的访问可能有多次。</p><p>我画了一张图，方便你理解多条通路对最终结果的影响。这张图中有A、B、C、D、E五个结点，分别表示不同的地点。</p><p><img src="https://static001.geekbang.org/resource/image/c1/b2/c155d6b1babe59e0c42928337686f9b2.jpg" alt=""></p><p>从这个图中可以看出，从A点出发到到目的地B点，一共有三条路线。如果你直接从A点到B点，度数为1，需要50分钟。从A点到C点再到B点，虽然度数为2，但总共只要40分钟。从A点到D点，到E点，再到最后的B点，虽然度数为3，但是总耗时只有35分钟，比其他所有的路线更优。这种情形之下，使用广度优先找到的最短通路，不一定是最优的路线。所以，对于在地图上查找最优路线的问题，无论是广度优先还是深度优先的策略，都需要遍历所有可能的路线，然后取最优的解。</p><p>在遍历所有可能的路线时，有几个问题需要注意。</p><p>第一，由于要遍历所有可能的通路，因此一个点可能会被访问多次。当然，这个“多次“是指某个结点出现在不同通路中，而不是多次出现在同一条通路中。因为我们不想让用户总是兜圈子，所以需要避免回路。</p><p>第二，如果某个结点x和起始点s之间存在多个通路，每当x到s之间的最优路线被更新之后，我们还需要更新所有和x相邻的结点之最优路线，计算复杂度会很高。</p><h2>一个优化的版本：Dijkstra算法</h2><p>无论是广度优先还是深度优先的实现，算法对每个结点的访问都可能多于一次。而访问多次，就意味着要消耗更多的计算机资源。那么，有没有可能在保证最终结果是正确的情况下，尽可能地减少访问结点的次数，来提升算法的效率呢？</p><p>首先，我们思考一下，对于某些结点，是不是可以提前获得到达它们的最终的解（例如最短耗时、最短距离、最低价格等等），从而把它们提前移出遍历的清单？如果有，是哪些结点呢？什么时候可以把它们移出呢？Dijkstra算法要登场了！它简直就是为了解决这些问题量身定制的。</p><p>Dijkstra算法的核心思想是，对于某个结点，如果我们已经发现了最优的通路，那么就无需在将来的步骤中，再次考虑这个结点。Dijkstra算法很巧妙地找到这种点，而且能确保已经为它找到了最优路径。</p><h3>1.Dijkstra算法的主要步骤</h3><p>让我们先来看看Dijkstra算法的主要步骤，然后再来理解，它究竟是如何确定哪些结点已经拥有了最优解。</p><p>首先你需要了解几个符号。</p><p>第一个是source，我们用它表示图中的起始点，缩写是s。</p><p>然后是weight，表示二维数组，保存了任意边的权重，缩写为w。w[m, n]表示从结点m到结点n的有向边之权重，大于等于0。如果m到n有多条边，而且权重各自不同，那么取权重最小的那条边。</p><p>接下来是min_weight，表示一维数组，保存了从s到任意结点的最小权重，缩写为mw。假设从s到某个结点m有多条通路，而每条通路的权重是这条通路上所有边的权重之和，那么mw[m]就表示这些通路权重中的最小值。mw[s]=0，表示起始点到自己的最小权重为0。</p><p>最后是Finish，表示已经找到最小权重的结点之集合，缩写为F。一旦结点被放入集合F，这个结点就不再参与将来的计算。</p><p>初始的时候，Dijkstra算法会做三件事情。第一，把起始点s的最小权重赋为0，也就是mw[s] = 0。第二，往集合F里添加结点s，F包含且仅包含s。第三，假设结点s能直接到达的边集合为M，对于其中的每一条边m，则把mw[m]设为w[s, m]，同时对于所有其他s不能直接到达的结点，将通路的权重设为无穷大。</p><p>然后，Dijkstra算法会重复下列两个步骤。</p><p><strong>第一步，查找最小mw</strong>。从mw数组选择最小值，则这个值就是起始点s到所对应的结点的最小权重，并且把这个点加入到F中，针对这个点的计算就算完成了。比如，当前mw中最小的值是mw[x]=10，那么结点s到结点x的最小权重就是10，并且把结点x放入集合F，将来没有必要再考虑点x，mw[x]可能的最小值也就确定为10了。</p><p><strong>第二步，更新权重</strong>。然后，我们看看，新加入F的结点x，是不是可以直接到达其他结点。如果是，看看通过x到达其他点的通路权重，是否比这些点当前的mw更小，如果是，那么就替换这些点在mw中的值。例如，x可以直接到达y，那么把(mw[x] + w[x, y])和mw[y]比较，如果(mw[x] + w[x, y])的值更小，那么把mw[y]更新为这个更小的值，而我们把x称为y的前驱结点。</p><p>然后，重复上述两步，再次从mw中找出最小值，此时要求mw对应的结点不属于F，重复上述动作，直到集合F包含了图的所有结点，也就是说，没有结点需要处理了。</p><p>字面描述有些抽象，我用一个具体的例子来解释一下。你可以看我画的这个图。</p><p><img src="https://static001.geekbang.org/resource/image/79/aa/796ad4473319311570c64646875370aa.jpg" alt=""></p><p>我们把结点s放入集合F。同s直接相连的结点有a、b、c和d，我把它们的mw更新为w数组中的值，就可以得到如下结果：</p><p><img src="https://static001.geekbang.org/resource/image/85/7e/85d93aaa912327053fa18157f02c067e.png" alt=""></p><p>然后，我们从mw选出最小的值0.2，把对应的结点c加入集合F，并更新和c直接相连的结点f、h的mw值，得到如下结果：</p><p><img src="https://static001.geekbang.org/resource/image/7a/bf/7abb384727aa14482c5c1a99e841fabf.png" alt=""></p><p>然后，我们从mw选出最小的值0.3，把对应的结点b加入集合F，并更新和b直接相连的结点a和f的mw值。以此逐步类推，可以得到如下的最终结果：</p><p><img src="https://static001.geekbang.org/resource/image/ac/46/acfbc2ef21b572cb0b7d1a8ea248d346.png" alt=""></p><p>你可以试着自己从头到尾推导一下，看看结果是不是和我的一致。</p><p>说到这里，你可能会产生一个疑问：Dijkstra算法提前把一些结点排除在计算之外，而且没有遍历全部可能的路径，那么它是如何确保找到最优路径的呢？下面，我们就来看看这个问题的答案。Dijkstra算法的步骤看上去有点复杂，不过其中最关键的两步是：第一个是每次选择最小的mw；第二个是，假设被选中的最小mw，所对应的结点是x，那么查看和x直接相连的结点，并更新它们的mw。</p><h3>2.为什么每次都要选择最小的mw？</h3><p>最小的、非无穷大的mw值，对应的结点是还没有加入F集合的、且和s有通路的那些结点。假设当前mw数组中最小的值是mw[x]，对应的结点是x。如果边的权重都是正值，那么通路上的权重之和是单调递增的，所以其他通路的权重之和一定大于当前的mw[x]，因此即使存在其他的通路，其权重也会比mw[x]大。</p><p>你可以结合这个图，来理解我刚才这段话。</p><p><img src="https://static001.geekbang.org/resource/image/c6/d3/c6d1365f398861d997a8b443a6fdfbd3.jpg" alt=""></p><p>图中的虚线表示省去了通路中间的若干结点。mw[x]是当前mw数组中的最小值，所以它小于等于任何一个mw[xn]，其中xn不等于x。</p><p>我们假设存在另一个通路，通过$x_{n}$达到x，那么通路的权重总和为mw[$x_{n}$] + w[$x_{n}$, x] ≥ mw[$x_{n}$] ≥ mw[x]。所以我们可以得到一个结论：拥有最小mw值的结点x不可能再找到更小的mw值，可以把它放入“已完成“的集合F。</p><p>这就是为什么每次都要选择最小的mw值，并认为对应的结点已经完成了计算。和广度优先或者深度优先的搜索相比，Dijkstra算法可以避免对某些结点，重复而且无效的访问。因此，每次选择最小的mw，就可以提升了搜索的效率。</p><h3>3.为什么每次都要看x直接相连的结点？</h3><p>我们已经确定mw[x]是从点s到点x的最小权重，那么就可以把这个确定的值传播到和x直接相连、而且不在F中的结点。通过这一步，我们就可以获得从点s到这些点、而且经过x的通路中最小的那个权重。我画了张图帮助你理解。</p><p><img src="https://static001.geekbang.org/resource/image/ec/f2/ec5b72711eba1bf5c4e2f9c03beedaf2.jpg" alt=""></p><p>在这个图中，x直接相连$y_{1}$，$y_{2}$，…，$y_{n}$。从点s到点x的mw[x]已经确定了，那么对于从s到yn的所有通路，只有两种可能，经过x和不经过x。如果这条通路经过x，那么其权重的最小值就是mw’[$y_{i}$] = mw[x] + w[x, $y_{i}$]中的一个（1≤i≤n），我们只需要把这个值和其他未经过x结点的通路之权重对比就足够了。这就是为什么每次要更新和x直接相连的结点之mw。</p><p>这一步和广度优先策略中的查找某个结点的所有相邻结点类似。但是，之后，Dijkstra算法重复挑选最小权重的步骤，既没有遵从广度优先，也没有遵从深度优先。即便如此，它仍然保证了不会遗漏任意一点和起始点s之间、拥有最小权重的通路，从而保证了搜索的覆盖率。你可能会奇怪，这是如何得到保证的？我使用数学归纳法，来证明一下。</p><p>你还记得数学归纳法的一般步骤吗？刚好借由这个例子我们也来复习一下。</p><p><strong>我们的命题是，对于任意一个点，Dijkstra算法都可以找到它和起始点s之间拥有最小权重的通路。</strong></p><p>首先，当n=1的时候，也就是只有起始点s和另一个终止点的时候，Dijkstra算法的初始化阶段的第3步，保证了命题的成立。</p><p>然后，我们假设n=k-1的时候命题成立，同时需要证明n=k的时候命题也成立。命题在n=k-1时成立，表明从点s到k-1个终点的任何一个时，Dijkstra算法都能找到拥有最小权重的通路。那么再增加一个结点x，Dijkstra算法同样可以为包含x的k个终点找到最小权重通路。</p><p>这里我们只需要考虑x和这k-1个点连通的情况。因为如果不连通，就没有必要考虑x了。既然连通，x可能会指向之前k-1个结点，也有可能被这k-1个结点所指向。假设x指向了y，而z指向了x，y和z都是之前k-1个结点中的一员。</p><p><img src="https://static001.geekbang.org/resource/image/59/b1/59dfee4aefe052d5a7da2cea7bf20cb1.jpg" alt=""></p><p>我们先来看x对y的影响。如果x不在从s到y的最小权重通路上，那么x的加入并不影响mw[y]的最终结果。如果x在从s到y的最小权重通路上，那么就意味着mw[x] + w[x, y]≤mw’[y]，mw’表示没有引入结点x的时候，mw的值。所以有mw[x]≤mw’[y]，这就意味着Dijkstra算法在查找最小mw的步骤中，会在mw’[y]之前挑出mw[x]，也就是找到了从s到y，且经过x的最小权重通路。</p><p>我们再来看z对x的影响。假设有多个z指向x，分别是$z_{1}$, $z_{2}$, …,$z_{m}$，从s到x的通路必定会经过这m个z结点中的一个。Dijkstra算法中找最小mw的步骤，一定会遍历mw[$z_{i}$]（1&lt;=i&lt;=m），而更新权重的步骤，可以并保证从(mw[$z_{i}$] + w[$z_{i}$, x])中找出最小值，最终找到从s到x的最优通路。</p><p>有了详细的推导，想要写出代码就不难了。我这里只给你说几点需要注意的地方。</p><p>在自动生成图的函数中，你需要把广度优先搜索的相应代码做两处修改。第一，现在边是有向的了，所以生成的边只需要添加一次；第二，要给边赋予一个权重值，例如可以把边的权重设置为[0,1.0)之间的float型数值。</p><p>为了更好地模块化，你可以实现两个函数：findGeoWithMinWeight和updateWeight。它们分别对应于我之前提到的最重要的两步：每次选择最小的mw；更新和x直接相连的结点之mw。</p><p>每次查找最小mw的时候，我们需要跳过已经完成的结点，只考虑那些不在F集合中的点。这也是Dijkstra算法比较高效的原因。此外，如果你想输出最优路径上的每个结点，那么在updateWeight函数中就要记录每个结点的前驱结点。</p><p>如果你能跟着我进行一步步的推导，并且手写代码进行练习，相信你对Dijkstra算法会有更深刻的印象。</p><h2>小结</h2><p>我们使用Dijkstra算法来查找地图中两点之间的最短路径，而今天我所介绍的Dijkstra使用了更为抽象的“权重”。如果我们把结点作为地理位置，边的权重设置为路上所花费的时间，那么Dijkstra算法就能帮助我们找到，任意两个点之间耗时最短的路线。</p><p>除了时间之外，你也可以对图的边设置其他类型的权重，比如距离、价格，这样Dijkstra算法可以让用户找到地图任意两点之间的最短路线，或者出行的最低价格等等。有的时候，边的权重越大越好，比如观光车开过某条路线的车票收入。对于这种情况，Dijkstra算法就需要调整一下，每次找到最大的mw，更新邻近结点时也要找更大的值。所以，你只要掌握核心的思路就可以了，具体的实现可以根据情况去灵活调整。</p><p><img src="https://static001.geekbang.org/resource/image/48/9f/48b3029c0e5310bf9b5f2e5564463a9f.jpg" alt=""></p><h2>思考题</h2><p>今天的思考题和地图数据的特殊情况有关。</p><ol>\n<li>\n<p>如果边的权重是负数，我们还能用今天讲的Dijkstra算法吗？</p>\n</li>\n<li>\n<p>如果地图中存在多条最优路径，也就是说多条路径的权重和都是相等的，那么我刚刚介绍的Dijkstra算法应该如何修改呢？</p>\n</li>\n</ol><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "15 | 从树到图：如何让计算机学会看地图？",
      },
      {
        title: "16 | 时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？",
        herf: "https://time.geekbang.org/column/article/78186",
        id: "78186",
        content:
          '<p>你好，我是黄申。</p><p>作为程序员，你一定非常清楚复杂度分析对编码的重要性。计算机系统从最初的设计、开发到最终的部署，要经过很多的步骤，而影响系统性能的因素有很多。我把这些因素分为三大类：<strong>算法理论上的计算复杂度</strong>、<strong>开发实现的方案</strong>和<strong>硬件设备的规格</strong>。</p><p>如果将整个系统的构建比作生产汽车，那么计算复杂度相当于在蓝图设计阶段，对整个汽车的性能进行评估。如果我们能够进行准确的复杂度分析，那么就能从理论上预估汽车的各项指标，避免生产出一辆既耗油又开得很慢的汽车。</p><p>可是，你也常常会发现，要准确地分析复杂度并不容易。这一讲，我来说说如何使用数学的思维，来进行系统性的复杂度分析。</p><h2>基本概念</h2><p>我先带你简短回顾一下几个重要概念，便于你稍后更好地理解本节的内容。</p><p><strong>算法复杂度</strong>是一个比较抽象的概念，通常只是一个估计值，它用于衡量程序在运行时所需要的资源，用于比较不同算法的性能好坏。同一段代码处理不同的输入数据所消耗的资源也可能不同，所以分析复杂度时，需要考虑三种情况，最差情况、最好情况和平均情况。</p><p>复杂度分析会考虑性能的各个方面，不过我们最关注的是两个部分，时间和空间。时间因素是指程序执行的耗时多少，空间因素是程序占用内存或磁盘存储的多少。因此，我们把复杂度进一步细分为时间复杂度和空间复杂度。</p><!-- [[[read_end]]] --><p>我们通常所说的时间复杂度是指<strong>渐进时间复杂度</strong>，表示程序运行时间随着问题复杂度增加而变化的规律。同理，空间复杂度是指<strong>渐进空间复杂度</strong>，表示程序所需要的存储空间随着问题复杂度增加而变化的规律。我们可以使用大O来表示这两者。</p><p>我这里不会讲太多的基本概念，而是通过数学的思维，总结一些比较通用的方法和规则，帮助你快速、准确地进行复杂度分析。</p><h2>6个通用法则</h2><p>复杂度分析有时看上去很难，其实呢，我们只要通过一定的方法进行系统性的分析，就能得找正确的结论。我通过自身的一些经验，总结了6个法则，相信它们对你会很有帮助。</p><h3>1.四则运算法则</h3><p>对于时间复杂度，代码的添加，意味着计算机操作的增加，也就是时间复杂度的增加。如果代码是平行增加的，就是加法。如果是循环、嵌套或者函数的嵌套，那么就是乘法。</p><p>比如二分查找的代码中，第一步是对长度为n的数组排序，第二步是在这个已排序的数组中进行查找。这两个部分是平行的，所以计算时间复杂度时可以使用加法。第一步的时间复杂度是O(nlogn)，第二步的时间复杂度是O(logn)，所以时间复杂度是O(nlogn)+O(logn)。</p><p>你还记得在第3讲我讲的查字典的例子吗？</p><pre><code>String[] dictionary = {&quot;i&quot;, &quot;am&quot;, &quot;one&quot;, &quot;of&quot;, &quot;the&quot;, &quot;authors&quot;, &quot;in&quot;, &quot;geekbang&quot;};\n\t\t\nArrays.sort(dictionary);  // 时间复杂度为O(nlogn)\n\nString wordToFind = &quot;i&quot;;\n\t\t\nboolean found = Lesson3_3.search(dictionary, wordToFind); //时间复杂度O(logn)\nif (found) {\n  System.out.println(String.format(&quot;找到了单词%s&quot;, wordToFind));\n} else {\n  System.out.println(String.format(&quot;未能找到单词%s&quot;, wordToFind));\n}\n</code></pre><p>这里面的Arrays.sort(dictionary)，我用了Java自带的排序函数，时间复杂度为O(nlogn)，而Lesson3_3.search是我自己实现的二分查找，时间复杂度为O(logn)。两者是并行的，并依次执行，因此总的时间复杂度是两者相加。</p><p>我们再来看另外一个例子。从n个元素中选出3个元素的可重复排列，使用3层循环的嵌套，或者是3层递归嵌套，这里时间复杂度计算使用乘法。由于n*n*n=n<sup>3</sup>，时间复杂度是O(n<sup>3</sup>)。对应加法和乘法，分别是减法和除法。如果去掉平行的代码，就减掉相应的时间复杂度。如果去掉嵌套内的循环或函数，就除去相应的时间复杂度。</p><p>对于空间复杂度，同样如此。需要注意的是，空间复杂度看的是对内存空间的使用，而不是计算的次数。如果语句中没有新开辟空间，那么无论是平行增加还是嵌套增加代码，都不会增加空间复杂度。</p><h3>2.主次分明法则</h3><p>这个法则主要是运用了数量级和运算法则优先级的概念。在刚刚介绍的第一个法则中，我们会对代码不同部分所产生的复杂度进行相加或相乘。使用加法或减法时，你可能会遇到不同数量级的复杂度。这个时候，我们只需要看最高数量级的，而忽略掉常量、系数和较低数量级的复杂度。</p><p>在介绍第一个法则的时候，我说了先排序、后二分查找的总时间复杂度是O(nlogn) + O(logn)。实际上，我贴出的代码中还有数组初始化、变量赋值、Console输出等步骤，如果细究的话，时间复杂度应该是O(nlogn) + O(logn) + O(3)，但是和O(nlogn)相比，常量和O(logn)这种数量级都是可以忽略的，所以最终简化为O(nlogn)。</p><p>再举个例子，我们首先通过随机函数生成一个长度为n的数组，然后生成这个数组的全排列。通过循环，生成n个随机数的时间复杂度为O(n)，而全排列的时间复杂度为O(n!)，如果使用四则运算法则，总的时间复杂为O(n)+O(n!)。</p><p>不过，由于n!的数量级远远大于n，所以我们可以把总时间复杂度简化为O(n!)。这对于空间复杂度同样适用。假设我们计算一个长度为n的向量和一个维度为[n*n]的矩阵之乘积，那么总的空间复杂度可以由(O(n)+O(n<sup>2</sup>))简化为O(n<sup>2</sup>)。</p><p>注意，这个法则对于乘法或除法并不适用，因为乘法或除法会改变参与运算的复杂度的数量级。</p><h3>3.齐头并进法则</h3><p>这个法则主要是运用了多元变量的概念，其核心思想是复杂度可能受到多个因素的影响。在这种情况下，我们要同时考虑所有因素，并在复杂度公式中体现出来。</p><p>我在之前的文章中，介绍了使用动态规划解决的编辑距离问题。从解决方案的推导和代码可以看出，这个问题涉及两个因素：参与比较的第一个字符串的长度n和第二个字符串的长度m。代码使用了两次嵌套循环，第一层循环的长度是n，第二层循环的长度为m，根据乘法法则，时间复杂度为O(n*m)。而空间复杂度，很容易从推导结果的状态转移表得出，也是O(n*m)。</p><h3>4.排列组合法则</h3><p>排列组合的思想不仅出现在数学模型的设计中，同样也会出现在复杂度分析中，它经常会用在最好、最坏和平均复杂度分析中。</p><p>我们来看个简单的算法题。</p><p>给定两个不同的字符a和b，以及一个长度为n的字符数组。字符数组里的字符都只出现过一次，而且一定存在一个a和一个b，请输出a和b之间的所有字符，包括a和b。假设我们的算法是按照数组下标从低到高的顺序依次扫描数组，那么时间复杂度是多少呢？这里时间复杂度是由被扫描的数组元素之数量决定的，但是要准确的求解并不容易。仔细思考一下，你会发现被扫描的元素之数量存在很多可能的值。</p><p>首先，考虑字母出现的顺序，第一个遇到的字母有2个选择，a或者b。而第二个字母只有1个选择，这就是2个元素的全排列。下面我们把两种情况分开来看.</p><p>第一种情况是a在b之前出现。接下来是a和b之间的距离，这会决定我们要扫描多少个字符。两者之间的距离最大为n-1，最小为1，所以最坏的时间复杂度为O(n-1)，根据主次分明法则，简化为O(n)，最好复杂度为O(1)。</p><p>平均复杂度的计算稍微繁琐一些。如果距离为n-1，只有1种可能，a为数组中第一个字符，b为数组中最后一个字符。如果距离为n-2，那么a字符的位置有2种可能，b在a位置确定的情况下只有1种可能，因此排列数是2。以此类推，如果距离为n-3，那么有3种可能，一直到距离1，有n-1种可能。所以平均的扫描次数为(1 *(n-1) + 2 *(n-2) + 3 <em>(n -3) + … + (n-1)</em> 1) / (1 + 2 + … + n)，最后时间复杂度简化为O(n)。</p><p>第二种情况是b在a之前出现。这个分析过程和第一种情况类似。我们假设第一种和第二种情况出现的几率相等，那么综合两种情况，可以得出平均复杂度为O(n)。</p><h3>5.一图千言法则</h3><p>在之前的文章中，我提到了很多数学和算法思想都体现了树这种结构，通过画图它们内在的联系就一目了然了。同样，这些树结构也可以帮助我们分析某些算法的复杂度。</p><p>就以我们之前介绍的归并排序为例。这个算法分为数据的切分和归并两大阶段，每个阶段的数据划分不同，分组数量也不同，感觉上时间复杂度不太好计算。下面我们来看一个例子，帮助你理解。</p><p>假设等待排序的数组长为n。首先，看数据切分阶段。数据切分的次数，就是切分阶段那棵树的非叶子结点之数量。这个切分阶段的树是一棵满二叉树，叶子结点是n个，那么非叶子结点的数量就是n-1个，所以切分的次数也就是n-1次。如果我们切分数据的时候，并不重新生成新的数据，而只是生成切分边界的下标，那么时间复杂度就是O(n-1)。</p><p><img src="https://static001.geekbang.org/resource/image/a3/20/a32499c23229ae55d9049e89e756a420.jpg" alt=""></p><p>在数据归并阶段，我们看二叉树的高度，为log<sub>2</sub>n，因此归并的次数为log<sub>2</sub>n。另外，无论数组被细分成多少个小的部分，每次归并都需要扫描整个长度为n的数组，因此归并阶段的时间复杂度为nlog<sub>2</sub>n。</p><p><img src="https://static001.geekbang.org/resource/image/f2/9a/f2385f58fa03dba21cab1ba0e26f4d9a.jpg" alt=""></p><p>两个阶段加起来的时间复杂度为O(n-1)+nlog<sub>2</sub>n，最终简化为nlogn。是不是很直观？</p><p>我再放出我们之前讲二分查找所用的图，你可以结合这个例子进一步理解。</p><p><img src="https://static001.geekbang.org/resource/image/7e/90/7e0de8eefdaf43cbb62291e074c93e90.png" alt=""></p><p>当然，除了图论，很多简单的图表也能帮助到我们的分析。</p><p>例如，在使用动态规划法的时候，我们经常要画出状态转移的表格。看到这类表格，我们可以很容易地得出该算法的时间复杂度和空间复杂度。以编辑距离为例，参看下面这个示例的图表，我们可以发现每个单元格都对应了3次计算，以及一个存储单元，而总共的单元格数量为m*n，m为第一个字符串的长度，n为第二个字符串的长度。所以，我们很快就能得出这种算法的时间复杂度为O(3m*n)，简写为O(m*n)，空间复杂度为O(m*n)。</p><p><img src="https://static001.geekbang.org/resource/image/a4/fe/a42623209645217d04637f122d793efe.png" alt=""></p><h3>6.时空互换法则</h3><p>在给定的计算量下，通常时间复杂度和空间复杂度呈现数学中的反比关系。这就说明，如果我们没法降低整体的计算量，那么也许可以通过增加空间复杂度来达到降低时间复杂度的目的，或者反之，通过增加时间复杂度来降低空间复杂度。</p><p>对于这个规则最直观的例子就是缓存系统。在没有缓存系统的时候，每次请求都要服务器来处理，因此时间复杂度比较高。如果使用了缓存系统，那么我们会消耗更多的内存空间，但是降低了请求相应的时间。</p><p>说到这，你也许会问，在使用广度优先策略优化聚合操作的时候，无论是时间还是空间复杂度，都大幅降低了啊？请注意，这里时空互换法则有个前提条件，就是计算量固定。而聚合操作的优化，是利用了广度优先的特点，大幅减少了整体的计算量，因此可以保证时间和空间复杂度都得到降低。</p><h2>小结</h2><p>时间复杂度和空间复杂度的概念，你一定不陌生。可是，在实际运用中，你可能就会发现复杂度分析并不是那么简单。这一节我通过个人的一些经验，从数学思维的角度出发，总结了几条常用的法则，对你会有所帮助。</p><p>这些总结可能还是过于抽象，下一讲中，我会通过几个案例分析，来讲讲如何使用这些法则。</p><p><img src="https://static001.geekbang.org/resource/image/af/b1/af160564e13906e8ed99e127df4830b1.jpg" alt=""></p><h2>思考题</h2><p>请尝试使用本次介绍的规则，分析一下双向广度优先搜索的时间和空间复杂度。</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "16 | 时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？",
      },
      {
        title: "17 | 时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？",
        herf: "https://time.geekbang.org/column/article/78457",
        id: "78457",
        content:
          '<p>你好，我是黄申，今天我们接着聊复杂度分析的实战。</p><p>上一讲，我从数学的角度出发，结合自身经验给你总结了几个分析复杂度的法则。但是在实际工作中我们会碰到很多复杂的问题，这个时候，正确地运用这些法则并不是件容易的事。今天，我就结合几个案例，教你一步步使用这几个法则。</p><h2>案例分析一：广度优先搜索</h2><p>在有关图遍历的专栏中，我介绍了单向广度优先和双向广度优先搜索。当时我提到了通常情况下，双向广度优先搜索性能更好。那么，我们应该如何从理论上分析，谁的效率更高呢？</p><p>首先我们来看单向广度优先搜索。我们先快速回顾一下搜索的主要步骤。</p><p>第一步，判断边界条件，时间和空间复杂度都是O(1)。</p><p>第二步，生成空的队列。常量级的CPU和内存操作，根据<strong>主次分明法则</strong>，时间和空间复杂度都是O(1)。</p><p>第三步，把搜索的起始结点放入队列queue和已访问结点的哈希集合visited，类似上一步，常量级操作，时间和空间复杂度都是O(1)。</p><p>第四步，也是最核心的步骤，包括了while和for的两个循环嵌套。</p><p>我们首先看时间复杂度。根据<strong>四则运算法则</strong>，时间复杂度是两个循环的次数相乘。对于嵌套在内的for循环，这个次数很好理解，和每个结点的直接连接点有关。如果要计算平均复杂度，我们就取直接连接点的平均数量，假设它为m。</p><!-- [[[read_end]]] --><p>现在的难题在于，第一个while循环次数是多少呢？我们考虑一下<strong>齐头并进法则</strong>，是否存在其他的因素来决定计算的次数？第一次的while循环，只有起始点一个。从起始点出发，会找到m个一度连接点，把它们放入队列，那么第二次while循环就是m次，依次类推，到第l次，那么总次数就是(m+m*m+m*m*m+…+m^l)。这里我们假设被重复访问的结点不多，可以忽略不计。</p><p>在循环内部，所有操作都是常量级的，包括通过哈希集合判断是否找到终止结点。所以时间复杂度就是O(m+m*m+m*m*m+…+m^l)，取最高数量级m^l，最后可以简化成O(m^l)，其中l是从起始点开始所走的边数。这就是除了m之外的第二个关键因素。</p><p>如果你觉得还是不太好理解，可以使用<strong>一图千言法则</strong>，我画了一张图来帮助你理解。</p><p><img src="https://static001.geekbang.org/resource/image/67/35/6752724f60af35508e1e71be50b91935.jpg" alt=""></p><p>我们再来看这个步骤的空间复杂度。通过代码你应该可以看出来，只有queue和visited变量新增了数据，而图的结点本身没有发生改变。所以，考虑内存空间使用时，只需要考虑queue和visited的使用情况。两者都是在新发现一个结点时进行操作，因此新增的内存空间和被访问过的结点数成正比，同样为O(m^l)。</p><p>最后，这四步是平行的，所以我们只需要把这几个时间复杂度相加就行了。很明显前三步都是常量，只有最后一步是决定性因素，因此时间和空间复杂度都是O(m^l)。</p><p>我这里没有考虑图的生成，因为这步在单向搜索和双向搜索中是一样的，而且在实际项目中，我们也不会采用随机生成的方式。</p><p>接下来，我们来看看双向广度优先搜索。我刚才已经把单向的搜索过程分析得很透彻了，所以双向的复杂度你应该很容易就能得出来。但是，有两处关键点需要你注意。</p><p>第一个关键点是双向搜索所要走的边数。如果单向需要走l条边，那么双向是l/2。因此时间和空间复杂度都会变为O(2*m^(l/2)，简写为O(m^(l/2))。这里l/2中的2不能省去，因为它是在指数上，改变了数量级。仅从这点来看，双向比单向的复杂度低。</p><p>第二个关键点是双向搜索过程中，判断是否找到通路的方式。单向搜索只需要判断一个点是否存在集合中，每次只有O(1)的复杂度。而双向搜索需要比较两个集合是否存在交集，复杂度肯定要高于O(1)。最常规的实现方法是，循环遍历其中一个集合A，看看A中的每个元素是不是出现在集合B中。假设两个集合中元素的数量都为n，那么循环n次，那么时间复杂度就为O(n)。基于这些，我们重新写一下双向广度优先搜索的时间复杂度。</p><p>假设我们分别从$a$点和$b$点出发。从$a$点出发，找到m个一度连接点$a_{1}$，时间复杂度O(m)，然后查看$b$是否在这m个结点中，时间复杂度是O(1)。然后从$b$点出发，找到m个一度连接点$b_{1}$，时间复杂度O(m)，然后查看$a$和$a_{1}$是不是在$b$和$b_{1}$中，时间复杂度是O(m+1)，简写为O(m)。从$a$点继续推进到第二度的结点$a_{2}$，这个时候$a$、$a_{1}$和$a_{2}$的并集的数量已经有1+m+m^2，而$b$和$b_{1}$的并集数量只有1+m，因此，针对$b$和$b_{1}$的集合进行循环更高效一些，时间复杂度是O(m)。</p><p><img src="https://static001.geekbang.org/resource/image/5e/81/5e1d92f9a34d267fba7139aff29ffa81.jpg" alt=""></p><p>逐步递推下去，我们可以得到下面这个式子：</p><pre><code>O(m) + O(1) + O(m) + O(m) + O(m^2) + O(m) ... + O(m^(l/2)) + O(m^(l/2)) = O(1) + O(4m) + O(4m^2) + ... + O(3m^(l/2))\n</code></pre><p>虽然这个式子简化后仍然为O(m^(l/2))，但是我们可以通过这些推导的步骤了解整个算法运行的过程，以及对最终复杂度的影响。</p><p>最后比较单向广度搜索的复杂度O(m^l)和双向广度搜索的复杂度O(m^(l/2))，双向的方法更优。</p><p>不过，上面讨论的内容，都是假设每个点的直接相连点数量都很均匀，都是m个。如果数据不是均匀的呢？你可以利用排列组合的思想，想想看各种不同的情况。我想到了三种情况。</p><p>第一种情况，我用a=b来表示，也就是前面讨论的，不管从a和b哪个点出发，每个点的直接连接数量都是相当的。这个时候的最好、最坏和平均复杂度非常接近。</p><p>第二种情况，我用a&lt;b来表示，表示从a点出发，每个点的直接连接数量远远小于从b点出发的那些。例如，从a点出发，2度之内所有的点都只有1、2个直接相连点，而从b点出发，2度之内的大部分点都有100个以上的直接相连点。</p><p>第三种情况和第二种类似，我用a&gt;b表示，表示从b点出发，每个点的直接连接数量远远小于从a点出发的那些。</p><p>对于第二和第三种情况，双向搜索的最坏、最好和平均的复杂度是多少？还会是双向的方法更优吗？仔细分析一下各种情况，你就能回答第14讲的思考题了。</p><h2>案例分析二：全文搜索</h2><p>刚才的分析中，我们已经使用了6个复杂度分析法则中的5个，不过还没涉及最后一个时空互换。这个原则有自己的特殊性，我们需要通过牺牲空间复杂度来降低时间复杂度，或者反其道行之。因此，在实际运用中，我们更多的是使用这个原则来指导和优化系统的设计。今天，我用搜索引擎的例子，来给你讲讲如何做到这一点。</p><p>搜索引擎你一定用的很多了，它最基本的也最重要的功能，就是根据你输入的关键词，查找指定的数据对象。这里，我以文本搜索为例。要查找某个关键词是不是出现在一篇文章里，最基本的处理方式有两种。</p><p>第一，把全文作为一个很长的字符串，把用户输入的关键词作为一个子串，那这个搜索问题就变成了子串匹配的问题。假设字符串平均长度为n个字符，关键词平均长度为m个字符，使用最简单的暴力法，就是把代表全文的字符串的每个字符，和关键词字符串的每个字符两两相比，那么时间复杂度就是O(n*m)。</p><p>第二，对全文进行分词，把全文切分成一个个有意义的词，那么这个搜索问题就变成了把输入关键词和这些切分后的词进行匹配的问题。</p><p>拉丁文分词比较简单，基本上就是根据各种分隔符来切分。而中文分词涉及很多算法，不过这不是我们讨论的重点，我们假设无论何种语言、何种分词方法，时间复杂度都是O(n)，其中n为文章的长度。而在词的集合中查找输入的关键词，时间复杂度是O(m)，m为词集合中元素的数量。我们也可以先对词的集合排序，时间复杂度是O(m*logm)，然后使用二分查找，时间复杂度都只有O(logm)。如果文章很少改变，那么全文的分词和词的排序，基本上都属于一次性的开销，对于关键词查询来说，每次的时间复杂度都只有O(logm)。</p><p>无论使用上述哪种方法，看上去时间复杂都不算太高，是吧？可是，别忘了，我们可是在海量的文章中查找信息，还需要考虑文章数量这个因素。假设文章数量是k，那么时间复杂度就变为O(k*n)，或者O(k*logm)，数量级一下子就增加了。</p><p>为了降低搜索引擎在查询时候的时间复杂度，我们要引入倒排索引（或逆向索引），这就是典型的牺牲空间来换取时间。如果你对倒排索引的概念不熟悉，我打个比方给你解释一下。</p><p>假设你是一个热爱读书的人，当你进入图书馆或书店的时候，怎样快速找到自己喜爱的书籍？没错，就是看书架上的标签。如果看到一个架子上标着“极客时间 - 数学专栏”，那么恭喜你，离程序员的数学书就不远了。而倒排索引做的就是“贴标签”的事情。</p><p>为了实现倒排索引，对于每篇文章我们都要先进行分词，然后将分好的词作为该篇的标签。让我们看看下面三篇样例文章和对应的分词，也就是标签。其中，分词之后，我也做了一些标准化的处理，例如全部转成小写、去掉时态等。</p><p><img src="https://static001.geekbang.org/resource/image/18/33/188f28947e82254de3a6bb8e5b022a33.png" alt=""></p><p>上面这个表格看上去并没有什么特别。好，体现“倒排”的时刻来了。我们转换一下，不再从文章的角度出发，而是从标签的角度出发来看问题。也就是说，从每个标签，我们能找到哪些文章？通过这样的思考，我们可以得到下面这张表。</p><p><img src="https://static001.geekbang.org/resource/image/7d/f8/7d4f5ee599916f96aad9910ab10a0bf8.png" alt=""></p><p>你看看，有了这张表格，想知道查找某个关键词在哪些文章中出现，是不是很容易了呢？整个过程就像在哈希表中查找一样，时间复杂度只有O(1)了。当然，我们所要付出的成本就是倒排索引这张表。假设有n个不同的单词，而每个单词所对应的文章平均数为m的话，那么这种索引的空间复杂度就是O(n*m)。好在n和m通常不会太大，对内存和磁盘的消耗都是可以接受的。</p><h2>小结</h2><p>这一讲，我分析了两个复杂度的案例，并在其中穿插了6个法则的运用和讲解。随着项目经验的累积，你会发现复杂度分析是个很有趣，也很有成就感的事情。更重要的是，它可以告诉我们哪些方法是可行的，哪些是不可行的，避免不必要的资源浪费。这里资源浪费可能是硬件资源的浪费，也有可能是开发资源的浪费。这些法则中的数学思想并不高深，却可以帮我们有效地分析复杂度，运筹帷幄于帐中，决胜于千里之外。</p><h2>思考题</h2><p>在你日常的工作中，有没有经历过性能分析相关的项目？如果有，你都使用了哪些方法来分析问题的症结？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "17 | 时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？",
      },
      {
        title: "18 | 总结课：数据结构、编程语句和基础算法体现了哪些数学思想？",
        herf: "https://time.geekbang.org/column/article/78790",
        id: "78790",
        content:
          '<p>你好，我是黄申。</p><p>之前的17讲，我们从小处着眼，介绍了离散数学中最常用的一些知识点。我讲到了很多<strong>数据结构</strong>、<strong>编程语句</strong>和<strong>基础性算法</strong>。这些知识点看似是孤立的，但是内部其实有很多联系。今天这一节，我们就来总结一下前面讲过的内容，把之前讲过的内容串联起来。</p><h2>数据结构</h2><p>首先，我们来看一些基本的数据结构，<strong>你可别小看这些数据结构，它们其实就是一个个解决问题的“模型”</strong><strong>。</strong>有了这些模型，你就能把一个个具体的问题抽象化，然后再来解决。</p><p>我们从最简单的数据结构数组开始说。自从你开始接触计算机编程，<strong>数组</strong>一定是你经常使用的数据结构。它的特点你应该很清楚。数组可以通过下标，直接定位到所需的数据，因此数组特别适合快速地随机访问。它常常和循环语句相结合，来实现迭代法，例如二分查找、斐波那契数列等等。</p><p>另外，我们将要在“线性代数篇”介绍的矩阵，也可以使用多维数组来表示。不过，数组只对稠密的数列更有效。如果数列非常稀疏，那么很多数组的元素就是无效值，浪费了存储空间。此外，数组中元素的插入和删除也比较麻烦，需要进行数据的批量移动。</p><p>那么对于稀疏的数列而言，什么样的数据结构更有效呢？答案是<strong>链表</strong>。链表中的结点存储了数据，而链表结点之间的相连关系，在C和C++语言中是通过指针来实现的，而在Java语言中是通过对象引用来实现的。</p><!-- [[[read_end]]] --><p>链表的特点是不能通过下标来直接访问数据，而是必须按照存储的结构逐个读取。这样做的优势在于，不必事先规定数据的数量，也不再需要保存无效的值，表示稀疏的数列时可以更有效的利用存储空间，同时也利于数据的动态插入和删除。但是，相对于数组而言，链表无法支持快速地随机访问，进行读写操作时就更耗时。</p><p>和数组一样，链表也可以是多维的。对于非常稀疏的矩阵，也可以用多维链表的结构来表达。此外，在链表结构中，点和点之间的连接，分别体现了图论中的顶点和边。因此，我们还可以使用指针、对象引用等来表示图结构中的顶点和边。常见的图模型，例如多叉树、无向图和有向图等，都可以用指针或引用来实现。</p><p>在数组和链表这些基础的数据结构之上，我们可以构建更复杂的数据结构，比如哈希表、队列和栈等等。这些数据结构，提供了逻辑更复杂的模型，可以通过数组、链表或两者的结合来实现。</p><p><a href="https://time.geekbang.org/column/article/72163">第2讲</a>我提到了哈希的概念，而哈希表就可以通过数组和链表来构造。在很多编程语言中，哈希表的实现采用的是<strong>链地址哈希表</strong>。这种方法的主要思想是，先分配一个很大的数组空间，而数组中的每一个元素都是一个链表的头部。随后，我们就可以根据哈希函数算出的哈希值（也叫哈希的key），找到数组的某个元素及对应的链表，然后把数据添加到这个链表中。</p><p>之所以要这样设计，是因为存在<strong>哈希冲突</strong>。对于不同的数据，哈希函数可能产生相同的哈希值，这就是哈希冲突。如果数组的每个元素都只能存放一个数据，那就无法解决冲突。如果每个元素对应了一个链表，那么当发生冲突的时候，我们就可以把多个数据添加到同一个链表中。可是，把多个数据存放在一个链表，就代表访问效率不高。所以，我们要尽量找到一个合理的哈希函数，减少冲突发生的机会，提升检索的效率。</p><p>在第2讲中，我还提到了使用求余相关的操作来实现哈希函数。我这里举个例子。你可以看我画的这幅图。</p><p><img src="https://static001.geekbang.org/resource/image/83/c2/834ad2a0c5aefd05e0c57aa6d0528fc2.jpg" alt=""></p><p>我们把对100求余作为哈希函数。因此数组的长度是100。对于每一个数字，通过它对100求余，确定它在数组中的位置。如果多个数字的求余结果一样，就产生冲突，使用链表来解决。我们可以看到，表中位置98的链表没有冲突，而0、1、2、3和99位置的链表都有冲突。</p><p>说完了哈希，我们来看看栈这种数据结构。我在介绍树的深度优先搜索时讲到栈。它是先进后出的。在我们进行函数递归的时候，函数调用和返回的顺序，也是先进后出，所以，栈体现了递归的思想，可以实现基于递归的编程。实际上，计算机系统里的函数递归，在内部也是通过栈来实现的。虽然直接通过栈来实现递归不如函数递归调用那么直观，但是，由于栈可以避免过多的中间变量，它可以节省内存空间的使用。</p><p>我在介绍广度优先搜索策略时，谈到了队列。队列和栈最大的不同在于，它是一种先进先出的数据结构，先进入队列的元素会优先得到处理。队列模拟了日常生活中人们排队的现象，其思想已经延伸到很多大型的数据系统中，例如消息队列。</p><p>在消息系统中，生产者会源源不断地推送新的数据，而消费者会对这些消息进行处理。可是，有时消费者的处理速度会慢于生产者推送的速度，这会带来很多复杂的后续问题，因此我们可以通过队列实现消息的缓冲。新产生的数据会先进入队列，直到消费者处理它。经过这样的异步处理，消息的队列实现了生产者和消费者的松耦合，对消费者起到了保护作用，使它不容易被数据洪流冲垮。</p><p>比哈希表，队列和栈更为复杂的数据结构是基于图论中的各种模型，例如各种二叉树、多叉树、有向图和无向图等等。通常，这些模型表示了顶点和顶点之间的稀疏关系，所以它们常常是基于指针或者对象引用来实现的。我在讲前缀树、社交关系图和交通地图的案例中，都使用了这些模型。另外，树模型中的多叉树、特别是二叉树体现了递归的思想。之前的递归编程的案例中的图示也可以对应到多叉树的表示。</p><h2>编程语句</h2><p>在你刚刚开始学习编程的时候，肯定接触过条件语句、循环语句和函数调用这些基本的语句。</p><p>条件语句的一个关键元素是布尔表达式。它其实体现了逻辑代数中逻辑和集合的概念。逻辑代数，也被称为布尔代数，主要包括了逻辑表达式及其相关的逻辑运算，可以帮助我们消除自然语言所带来的歧义，并严格、准确地描述事物。在编程语言中，我们把逻辑表达式和控制语言结合起来，比如Java语言的If语句：</p><pre><code>if(表达式) {函数体1} else {函数体2}：若表达式为真，执行函数体1，否则执行函数体2。\n</code></pre><p>当然，逻辑代数在计算机中的应用，远不止条件语句。例如SQL语言中的Select语句和布尔检索模型。Select是SQL查询语言中十分常用的语句。这个语句将根据指定的逻辑表达式，在一个数据库中进行查询并返回结果，而返回的结果就是满足条件的记录之集合。类似地，布尔检索模型利用逻辑表达式，确定哪些文档满足检索的条件并把它们作为结果返回。</p><p>这里顺便提一下，除了条件语句中的布尔表达式，逻辑代数还体现在编程中的其他地方。例如，SQL语言中的Join操作。Join有多种类型，每种类型其实都对应了一种集合的操作。</p><ul>\n<li>\n<p>内连接（inner join）：假设被连接的两张数据表分别是左表和右表，那么内连接查询能将左表和右表中能关联起来的数据连接后返回，返回的结果就是两个表中所有相匹配的数据。如果认为左表是集合A，右表是集合B，那么从集合的角度来说，内连接产生的结果是A、B两个集合的交集。</p>\n</li>\n<li>\n<p>外连接（outer join）：外连接可以保留左表，右表或全部表。根据这些行为的不同，可分为左外连接、右外连接和全连接。无论哪一种，都是对应于不同的集合操作。</p>\n</li>\n</ul><p>循环语句可以让我们进行有规律性的重复性操作，直到满足某个条件。这和迭代法中反复修改某个值的操作非常一致。所以循环常用于迭代法的实现，例如二分或者牛顿法求解方程的根。在之前的迭代法讲解中，我经常使用循环来实现编码。另外，循环语句也会经常和布尔表达式相结合。嵌套的多层循环，常常用于比较多个元素的大小，或者计算多个元素之间的相似度等等，这也体现了排列组合的思想。</p><p>至于函数的调用，一个函数既可以调用自己，也可以调用其他不同的函数。如果不断地调用自己，这就体现了递归的思想。同时，函数的递归调用也可以体现排列组合的思想。</p><h2>基础算法</h2><p>在前面的专栏中，我介绍了一些常见算法及其对应的数学思想。而这些思想，在算法中的体现无处不在。</p><p>介绍分治思想的时候，我谈及了MapReduce的数据切分。在分布式系统中，除了数据切分，我们还要经常处理的问题是：如何确定服务请求被分配到哪台机器上？这就引出了负载均衡算法。</p><p>常见的包括轮询或者源地址哈希算法。轮询算法把请求按顺序轮流地分配到后端服务器上，它并不关心每台服务器当前的负载。如果我们对每个请求标上一个自动增加的ID，我们可以认为轮询算法是对请求的ID进行求余操作（或者是求余的哈希函数），被除数就是可用服务器的数量，余数就是接受请求的服务器ID。而源地址哈希进一步扩展了这个思想，扩展主要体现在：</p><ul>\n<li>\n<p>它可以对请求的IP或其他唯一标识进行哈希，而不一定是请求的ID；</p>\n</li>\n<li>\n<p>哈希函数的变换操作不一定是求余。</p>\n</li>\n</ul><p>不管是对何种数据进行哈希变换，也不管是何种哈希函数，只要能为每个请求确定哈希key之后，我们就能为它查找对应的服务器。</p><p>另外，在<a href="https://time.geekbang.org/column/article/75807">第9节</a>中，我谈到了字符串的编辑距离，但是没有涉及字符串匹配的算法。知名的RK（Rabin-Karp）匹配算法，在暴力匹配（Brute Force）基础之上，充分利用了迭代法和哈希，提升了算法的效率。</p><p>首先，RK算法可以根据两个字符串哈希后的值。来判断它们是不是相同。如果哈希值不同，则两个字符串肯定不同，不用再比较；此外，RK算法中的哈希设计非常巧妙，让相邻两个子字符串的哈希值产生了固定的联系，让我们可以通过前一个子串的哈希值，推导出后一个子串的哈希值，这样就能使用迭代法来计算每个子串的哈希值，大大减少了用于哈希函数的计算。</p><p>除了分治和动态规划，另一个常用的算法思想是回溯。我们可以使用回溯来解决的问题包括八皇后和0/1背包等等。回溯实际上体现了递归和排列的思想。不过，它对搜索空间做了一些优化，提前排除了不可能的情况，提升了算法整体的效率。当然，既然回溯体现了递归的思想，也可以把整个搜索状态表示成树，而对结果的搜索就是树的深度优先遍历。</p><p>在前两节讲述算法复杂度分析的时候，我已经从数学的角度出发，总结了几个常用的法则，包括四则运算、主次分明、齐头并进、排列组合、一图千言和时空互换。这些法则体现了数学中的运算优先级、数量级、多元变量、图论等思想。这些我们上两节刚刚讲过，我就不多说了，你可以参考之前的内容快速复习一下。</p><h2>小结</h2><p>这一讲，我对常用的数据结构、编程语句和算法中所体现的数学思想，做了一个大体的梳理。可以看到，<strong>不同的数据结构，都是在编程中运用数学思维的产物。每种数据结构都有自身的特点，有利于我们更方便地实现某种特定的数学模型。</strong></p><p>从数据结构的角度来看，最基本的数组遍历体现了迭代的思想，而链表和树的结构可用于刻画图论中的模型。栈的先进后出、以及队列的先进先出，分别适用于图的深度优先和广度优先遍历。哈希表则充分利用了哈希函数的特点，大幅降低了查询的时间复杂度。</p><p>当然，仅仅使用数据结构来存储数据还不够，我们还需要操作这些数据。为了实现操作的流程，条件语句使用了布尔代数来控制编程逻辑，循环和函数嵌套使用迭代、递归和排列组合等思想来实现更精细的数学模型。</p><p>但是，有时候我们面对的问题太复杂了，除了数据结构和基本的编程语句，我们还需要发明一些算法。为了提升算法的效率，我们需要对其进行复杂度分析。通常，这些算法中的数学思想就更为明显，因为它们都是为了解决特定的问题，根据特定的数学模型而设计的。</p><p>有的时候，某个算法会体现多种数学思想，例如RK字符串匹配算法，同时使用了迭代法和哈希。此外，多种数学思维可能都是相通的。比如，递归的思想、排列的结果、二进制数的枚举都可以用树的结构来图示化，因此我们可以通过树来理解。</p><p>所以，在平时学习编程的时候，你可以多从数学的角度出发，思考其背后的数学模型。这样不仅有利于你对现有知识的融会贯通，还可以帮助你优化数据结构和算法。</p><h2>思考题</h2><p>在你日常的工作项目中，应该经常用到数据结构和算法，能不能列举一下，其中有哪些数学思想呢？</p><p><span class="orange">欢迎在留言区交作业，并写下你今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "18 | 总结课：数据结构、编程语句和基础算法体现了哪些数学思想？",
      },
    ],
  },
  {
    chapterTitle: "概率统计篇 (14讲)",
    children: [
      {
        title: "19 | 概率和统计：编程为什么需要概率和统计？",
        herf: "https://time.geekbang.org/column/article/79441",
        id: "79441",
        content:
          '<p>你好，我是黄申。</p><p>通过第一个模块的学习，我想你对离散数学在编程领域中的应用，已经有了比较全面的认识。可以看出来，数据结构和基础算法体现的大多数都是离散数学的思想。这些思想更多的时候是给我们提供一种解决问题的思路，在具体指导我们解决问题的时候，我们还需要更多的数学知识。</p><p>比如说，在机器学习、数据挖掘等领域，概率统计就发挥着至关重要的作用。那关于概率统计，我们需要掌握哪些知识呢？这些知识究竟可以用在什么地方呢？第二模块的第一节，我们就来聊聊这些问题，让你对这一模块的学习做到心中有数。</p><h2>概率和统计里有哪些需要掌握的概念？</h2><p>在第一个模块中，我们认为所有事件都是一分为二的，要么必然发生，要么必然不发生。换句话说，事件的发生只有必然性，没有随机性。但是现实生活中，我们常常会碰到一些模棱两可的情况。</p><p>比如，你读到一则新闻，它报道了某个娱乐圈明星投资了一家互联网公司。那么，这则报道是属于娱乐新闻，还是科技新闻呢？你仔细读了读，觉得全篇大部分的内容都是讲述这家互联网企业的发展，而只有少部分的内容涉及了这位明星的私生活。你可能会说，这篇新闻80%的可能属于科技新闻，只有20%的可能属于娱乐新闻。这里面的数字表示了事件发生的可能性。<strong>概率</strong>（Probability）就是描述这种可能性的一个数值。</p><!-- [[[read_end]]] --><p>在概率的世界里，有很多概念。但是这几个非常基本的概念，你一定要知道。</p><p>我们用<strong>随机变量</strong>（Random Variable）来描述事件所有可能出现的状态，并使用<strong>概率分布</strong>（Probability Distribution）来描述每个状态出现的可能性。而随机变量又可以分为<strong>离散型随机变量</strong>（Discrete Random Variable）和<strong>连续型随机变量</strong>（Continuous Random Variable）。</p><p>这几个概念非常简单，但是其实也很抽象。我举个具体的例子，帮你加深印象。</p><p>假设我们使用一个随机变量x来表示新闻类型，如果在100篇新闻中，有60篇是娱乐新闻，有20篇是科技新闻，有20篇是体育新闻，那么你看到娱乐新闻的概率就是60%，看到科技新闻的概率就是20%，看到体育新闻的概率就是20%。而这三组数据就可以构成变量x的<strong>概率分布</strong>P(x)。</p><p>在这个概率分布中，我们只有一个随机变量x，现在我再添加另一个随机变量y，表示新闻属于国际的还是国内的。这个时候，新的概率分布就需要由x和y这两个变量联合起来才能决定，我们把这种概率称为<strong>联合概率</strong>（Joint Probability）。</p><p>比如说，刚才那100篇新闻中有30篇是国际新闻，而这30篇中有5篇是科技新闻，那么国际科技新闻的联合概率就是5/100=5%。不同的x和y取值的组合，就对应了不同的联合概率，我们用P(x, y)来表示。</p><p>对于离散型随机变量，通过联合概率P(x, y)在y上求和，就可以得到P(x)，这个P(x)就是<strong>边缘概率</strong>（Marginal Probability）。对于连续型随机变量，我们可以通过联合概率P(x, y)在y上的积分，推导出边缘概率P(x)。边缘概率有啥用呢？有的时候，情况看起来很复杂，而我们其实只需要研究单个事件对概率分布的影响就可以了。这个时候，边缘概率可以帮助我们去除那些我们不需要关心的事件，把联合概率转换为非联合概率，例如从P(x, y)得到P(x)，从而忽略y事件。</p><p>对于多个随机变量，还有一个很重要的概念是<strong>条件概率</strong>。我估计很多人可能搞不清楚这个概念。我还是举例子跟你说。比如说，我们现在假设100篇中有30篇是国际新闻，而这30篇中有5篇是科技新闻，那在国际新闻中出现科技新闻的概率是多少呢？</p><p>这时候，我们就需要条件概率了。也就是某个事件受其他事件影响之后出现的概率，放到咱们的例子里，在国际新闻中出现科技新闻的概率就是5/30=16.67%，在科技新闻中出现国际新闻的概率就是5/20=25%。</p><p>说了这么多，不知道你有没有一种感觉，<strong>其实<strong><strong>概率论研究</strong></strong>的就是这些概率<strong><strong>之间相互转化的关系</strong></strong>，比如联合概率、条件概率和边缘概率</strong>。通过这些关系，概率论中产生了著名的<strong>贝叶斯定理</strong>（Bayes’ theorem）。加上变量的独立性，我们就可以构建<strong>朴素贝叶斯（Naive Bayes）分类算法</strong>，这个算法在机器学习中的应用非常广泛，我们后面也会有一节课专门来讲。</p><p>此外，基于概率发展而来的信息论，提出了很多重要的概率，例如<strong>信息熵</strong>（Entropy）/ <strong>香农熵</strong>（Shannon Entropy）、<strong>信息增益</strong>（Information Gain）、<strong>基尼指数</strong>（Gini）等。这些概念都被运用到了<strong>决策树</strong>（Decision Tree）的算法中。</p><p>提到概率论，就一定要提统计学。这是因为，<strong>概率和统计</strong><strong>其实是互逆的。</strong>怎么个互逆呢？概率论是对数据产生的过程进行建模，然后研究某种模型所产生的数据有什么特性。而统计学正好相反，它需要通过已知的数据，来推导产生这些数据的模型是怎样的。因此统计特别关注数据的各种分布、统计值及其对应的统计意义。</p><p>比如，现在有一大堆的新闻稿，我们想知道这里面有多少是娱乐新闻，有多少是科技新闻等等。我们可以先拿出一小部分采样数据，逐个来判断它属于哪个类型。比如说，分析了10篇之后，我们发现有7篇是科技新闻，2篇是娱乐新闻，1篇是体育新闻，那么从统计结果来看，三个类型的概率分别是70%、20%和10%。然后，我们根据从这个小采样得来的结论，推测出科技新闻、娱乐新闻和体育新闻所占的比例。这就是统计学要做的事情。</p><p>在真实的世界里，我们通常只能观测到一些数据，而无法事先知道，是什么模型产生了这些数据，这时候就要依赖统计学。所以，海量数据的分析、实验和机器学习，都离不开统计学。</p><h2>概率和统计可以帮我们做什么？</h2><p>弄清楚这些基本概念之后，我们来看看概率和统计的知识能帮我们做点什么。</p><p>首先，我还是要提到复杂度分析。你可能会奇怪，之前讨论的复杂度分析好像没有涉及到概率啊。这是因为，在计算平均复杂度的时候，我们其实做了一个假设：所有情况出现的概率都是一样的。</p><p>我以最简单的查找算法为例。假设一个数组包含了n个元素，我们对其中的元素采取逐个扫描的方式，来查找其中的某个元素。如果这个元素一定会被找到，那么最好时间复杂度是O(1)，最差时间复杂度是O(n)，平均时间复杂度是O((n+1)/2)。</p><p>等等，为什么平均复杂度是O((n+1)/2)呢？我们假设一共扫描了n次，第1次扫描了1个元素，第2次扫描了2个元素，一直到第n次扫描了n个元素，那么总共的扫描次数是(1+2+…+n) = ((n+1)*n)/2，然后除以n次，得到每次扫描的元素数量平均值是(n+1)/2，所以时间复杂度就是O((n+1)/2)。</p><p>我把上述求和式改写成下面这样：</p><center><img src="https://static001.geekbang.org/resource/image/76/65/76e322a0aa5db3bf9cc2e21ae4c6b265.png"></center><p>如果1/n是每种情况发生的概率，那么平均的扫描次数就是，不同情况下扫描次数按照概率进行的加权平均。问题来了，为什么这n种情况发生的概率都是1/n呢？这是因为之前我们做了一个默认的假设，我们每种情况发生的概率是一样的。但在实际生活中，概率很可能不是均匀分布的。</p><p>比如说，一个网站要对它的用户发放优惠券，那我们就需要先找到这些用户。我们用一个长度为n的数组代表某个网站的用户列表。我们假设第一个注册用户ID是1，第二个注册用户的ID是2，以此类推，最近刚刚注册的用户ID为n。如果网站的发放策略是倾向于奖励新用户，那么被查找的用户ID有很大的概率会非常接近n，因此平均复杂度就会非常接近O(n)。相反，如果网站的发放策略是倾向于奖励老用户，那么搜索的用户ID有很大的概率是非常接近1的，因此平均复杂度会非常接近O(1)。</p><p>你可以看到，现实中每种情况出现的可能性是不一样的，这也就意味者概率分布其是不均匀的。而不均匀的概率分布，最终会影响平均复杂度的加权平均计算。因此，要想获得更加准确的复杂度分析结果，我们必须要学习概率知识。</p><p>除此之外，概率和统计对于机器学习和大数据分析而言更为重要。对于机器学习而言，统计的运用是显而易见的。机器学习中的监督式学习，就是通过训练样本，估计出模型的参数，最后使用训练得出的模型，对新的数据进行预测。通过训练样本来估计模型，我们可以交给统计来完成。在机器学习的特征工程步骤中，我们可以使用统计的正态分布，<strong>标准化</strong>（standardization）不同取值范围的特征，让它们具有可比性。</p><p>此外，对机器学习算法进行效果评估时，AB测试可以减少不同因素对评测结果的干扰。为了获得更可靠的结论，我们需要理解统计意义，并为每个AB测试计算相应的统计值。</p><p>最后，概率模型从理论上对某些机器学习算法提供了支持。朴素贝叶斯分类充分利用了贝叶斯定理，使用先验概率推导出后验概率，并通过变量之间相互独立的假设，把复杂的计算进行大幅的简化。简化之后，我们就可以把这个算法运用在海量文本的分类任务上。</p><p>而决策树使用了信息熵和信息增益，挑出最具有区分力的条件，构建决策树的结点和分支。这样构建出的树，不仅分类效率更高，而且更利于人脑的理解。谷歌的PageRank算法利用马尔科夫链的概率转移，有效地刻画了人们浏览互联网的行为，大幅提升了互联网搜索的体验。</p><h2>学习这部分内容，需要做哪些准备？</h2><p>听我说了这么多专栏的内容，你是不是有点担心，专栏的内容太深奥，不好理解。甚至在想，有没有必要做些准备？</p><p>学习不是件容易的事，因此进步的过程，从来不会轻松。努力需要你自己来，但是我也会从我的角度出发助力你的学习。我会争取讲清楚每个知识点背后的前因后果，以及不同知识点之间的联系，避免平铺直叙地罗列一堆理论和公式。但是，这部分内容，有公式是不可避免的，我尽量只保留那些最核心的公式。因此，即使你之前不太了解概率和统计，也没有关系。只有跟着我的节奏，搞懂每一节的重点，相信你很快就能领悟其中的精髓。</p><p>另外，我们无法脱离应用来讲知识，不然就本末倒置了。毕竟，我们学任何知识，都是为了用的。机器学习的知识纷繁复杂，涉及广泛，很多问题甚至是跨学科、跨领域的。不过，你不用担心，这里面会有太多看不懂的名词。我在讲解的时候，尽量给你抽象出最核心的部分，讲清楚来龙去脉，让你了解它整体的运作方式，不影响你对核心知识点的吸收。</p><p>当然，你可以适度地补一些概率知识，这样理解起来会更快。我在之前的<a href="https://time.geekbang.org/column/article/79048">加餐三</a>中推荐了几本书，你可以找来看看，了解一些基本概念。另外，你可以准备一些实际工作和项目中的问题。例如，你之前参与的任务，哪些可以使用概率论来解决？碰到的难题有哪些？你是如何解决的？带着这些问题，再来看我的专栏，并且多在留言区写下你的疑问和收获，这样效果会更好。</p><h2>小结</h2><p>概率中的概念看起来很多，但是，其实最重要就是你耳熟能详的这几个：随机变量、概率分布、联合概率、条件概率和边缘概率。它们是整个概率的基础，我后面会详细来讲。</p><p>通过这些概念之间的相互推导，我们可以得到贝叶斯定理，这是朴素贝叶斯等系列算法的核心。而在概率基础之上发展而来的信息论，定义了信息熵、信息增益和基尼指数等，构成了决策树等系列算法的核心。</p><p>概率研究的是模型如何产生数据，统计研究的是如何通过数据来推导其背后的模型。所以说，概率和统计其实是互逆的。</p><p>概率和统计的运用非常多，我这里主要讲了三个方面。第一，概率可以帮助我们进行更精准的复杂度分析；第二，概率统计更多的是用在机器学习和大数据分析中；第三，概率统计还可以用在各种机器学习的算法中。这些内容，在之后的章节我会进行非常详细的讲解。</p><h2>思考题</h2><p>之前你对概率统计的认识是什么样的呢？对这块内容，你觉得最难的是什么？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。</span><span class="orange">你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title: "19 | 概率和统计：编程为什么需要概率和统计？",
      },
      {
        title:
          "20 | 概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值",
        herf: "https://time.geekbang.org/column/article/79915",
        id: "79915",
        content:
          '<p>你好，我是黄申。</p><p>相信你对变量这个概念并不陌生，数学方程式和编程代码里经常会用到变量。那什么是变量呢？我们在概率中常说的<strong>随机变量</strong>（ random variable）和普通的<strong>变量</strong>（variable）又有什么不同呢？</p><p>这些问题其实很简单，我一说你就明白了。</p><p>在没有发生运算之前，普通变量的值并不会发生变化，也就是说，它可以取不同的值，但是一旦取值确定之后，它总会是一个固定的值，除非有新的运算操作。而随机变量的值并不固定，比如说，某个随机变量可能有10%的概率等于10，有20%的概率等于5，有30%的概率等于28等等。</p><p>我们上节说了，随机变量根据其取值是否连续，可分为离散型随机变量和连续型随机变量。举几个例子，抛硬币出现正反面的次数以及每周下雨的天数，都是离散的值，所以对应的随机变量为离散型。而汽车每小时行驶的速度和银行排队的时间，都是连续的值，对应的随机变量为连续型。换句话，从计算的角度来说，我们可以直接求和得出的，就是“离散的”，需要用积分计算的，就是“连续的”。</p><p>而随机变量的取值对应了随机现象的一种结果。正是结果的不确定性，才导致了随机变量取值的不确定性，于是我们就引入了概率。我们可以说，每种值是以一定的概率出现的。</p><!-- [[[read_end]]] --><h2>概率分布</h2><p>随机变量的每种取值的出现都遵从一定的可能性，把这个可能性用具体的数值表示出来就是<strong>概率</strong>。如果将随机变量所有可能出现的值，及其对应的概率都罗列出来，我们就能获得这个变量的概率分布。</p><p>我们拿最简单的抛硬币事件来看。从理论上说来，出现正面和反面的概率都是50%（我们假设不存在硬币站立的情况）。</p><p><img src="https://static001.geekbang.org/resource/image/53/8e/534e71694ac590887737299ddcd5f48e.png" alt=""></p><p>我们可以通过一小段Python代码，做个模拟实验，验证一下这个分布。</p><pre><code>import random\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef flip_coin(times):\n  data_array = np.empty(times)\n  weights_array = np.empty(times)\n  weights_array.fill(1 / times)\n\n  for i in range(0, times):                       #抛times次的硬币\n    data_array[i] = random.randint(0, 1)        #假设0表示正面，1表示反面\n\n  data_frame = pd.DataFrame(data_array)\n  data_frame.plot(kind = \'hist\', legend = False)  #获取正反面统计次数的直方图\n  data_frame.plot(kind = \'hist\', legend = False, weights = weights_array).set_ylabel(&quot;Probability&quot;)  #获取正反面统计概率的直方图\n  plt.show()\n\nflip_coin(10)\n</code></pre><p>该代码随机生成若干次的0或1（0表示硬币正面朝上，1表示硬币反面朝上）。下表是我生成10次的结果，其中正面4次，反面6次。</p><p><img src="https://static001.geekbang.org/resource/image/b0/37/b0d2b522b903b2adcf706d47312a3537.png" alt=""></p><p>对应的正反面次数和概率直方图如下，而概率的直方图就表示了其概率分布。</p><p><img src="https://static001.geekbang.org/resource/image/07/9d/07b7a79563da20219034a3eb0afd3c9d.png" alt=""></p><p><img src="https://static001.geekbang.org/resource/image/34/eb/34703edccffa3b566924c785ffb17eeb.png" alt=""></p><p>通过修改flip_coin函数中的数字，我们可以修改抛硬币的次数。我又尝试“抛了”100次，得到的结果是正面47次，反面53次。</p><p><img src="https://static001.geekbang.org/resource/image/be/2e/beb0f943c9f4c0900d2d53a8afdcb42e.png" alt=""></p><p>接下来是抛10000次的结果，正面是4982次，反面是5018次。</p><p><img src="https://static001.geekbang.org/resource/image/2c/ec/2caf3cf4ee18c553e48524c01c5680ec.png" alt=""></p><p>你可能已经发现了，根据计算机模拟的结果所统计的概率，并不是精确的正反面各50%。如果你运行同样的代码，也会发现类似的情况。这是因为理论上的概率，是基于无限次的实验。而我们这里实验的次数是有限的，是一种统计采样。</p><p>从10次、100次到10000次，我们能看到，概率会变得越来越稳定，越来越趋近于正反各50%的分布。也就是说，<strong>统计的采样次数越多，越趋近于我们理论上的情况</strong>。因此，从这个统计实验我们可以看出，<strong>概率分布描述的其实就是随机变量的概率规律</strong>。</p><p>抛硬币正面次数、每周下雨天数这种离散型随机变量，对应的概率分布是很好理解的，但是对于连续型的随机变量，如何理解它们的概率分布呢？</p><p>如果我们把连续的值离散化，你会发现这个问题其实不难理解。就拿汽车每小时行驶的公里数来说吧。现实生活中我们通过汽车的仪表盘所读取速度，都是整数值，例如每小时60公里。也许比较高档的车会显示数字化的速度，带有小数位，但实际上汽车最精确的速度是一个无限位数的小数，是从0到最高公里数的一个任意数值。所以仪表盘所显示的数字，是将实际速度离散化处理之后的数字。除了仪表盘上的速度，汽车行驶在时间维度上也是连续的。类似地，我们还需要对时间进行离散化，比如每分钟查看仪表盘一次并读取速度值。</p><p>好的，理解了这些之后，我同样使用代码来随机一些行驶速度的数据。第一次模拟，假设我们手头上有一辆老爷车，它的仪表盘最小刻度是5，也就是说，它只能显示55、60、65这种公里数。然后我们每1分钟采样一次（读一次仪表盘），那么1小时内我们将生成60个数据。示例代码如下：</p><pre><code>def check_speed(time_gap, speed_gap, total_time, min_speed, max_speed):\n\n  times = (int)(total_time / time_gap)   #获取读取仪表盘的次数\n\n  data_array = np.empty(times)\n  weights_array = np.empty(times)\n  weights_array.fill(1 / times)\n\n  for i in range(0, times):\n    if (speed_gap &lt; 1):\n      data_array[i] = random.random() * max_speed  #随机生成一个最高速和最低速之间的速度\n    else:\n      data_array[i] = random.randint(0, max_speed / speed_gap) * speed_gap  #随机生成一个最高速和最低速之间的速度，先除以speed_gap然后乘以speed_gap进行离散化\n\n  data_frame = pd.DataFrame(data_array)\n  bin_range = np.arange(0, 200, speed_gap)\n  data_frame.plot(kind = \'hist\', bins = bin_range, legend = False)  #获取时速统计次数的直方图\n  data_frame.plot(kind = \'hist\', bins = bin_range, legend = False, weights = weights_array, ).set_ylabel(&quot;Probability&quot;)  #获取时速统计概率的直方图\n  plt.show()\n\ncheck_speed(1, 5, 60, 0, 200)\n</code></pre><p>对生成的60个数据，我们统计其出现在每个速度区间的频次以及相应的概率。</p><p><img src="https://static001.geekbang.org/resource/image/92/da/92e5097642a26c6ff5d0ac727e7e1dda.png" alt=""></p><p>我们将频次和概率以直方图的形式来展示。</p><p><img src="https://static001.geekbang.org/resource/image/08/66/08ec24a94441da4f4c59b5ec65e5bf66.png" alt=""></p><p><img src="https://static001.geekbang.org/resource/image/5f/e8/5f2c939a75584eadd38fce7eac68e5e8.png" alt=""></p><p>第二次模拟，假设我们把车升级到当今的主流车，仪表盘的最小刻度已经到1了，然后时间维度上，我们细分到0.1分钟，那么1小时我们将生成600个数据。我们还可以进行第三次、第四次、甚至是无穷次的模拟，每次模拟的时候我们都将行驶速度的精度进一步提升、将时间间隔进一步缩小，让两者都趋近于0，那么我们的模拟就从离散逐步趋近于连续的值了。</p><p>随机变量的概率分布由离散型的直方图变为了连续型的曲线图。通过下面的图，你可以看到这整个演变的过程。</p><p>当速度间隔和时间间隔（精度）逐步缩小的时候，直方图的分组（bin）就越小，所以你会看到x轴上的数据越浓密，y轴上的数据越平滑。当间隔或精度无穷小并趋近于0的时候，y轴的数据就会随着x轴连续变化而变化。</p><p><img src="https://static001.geekbang.org/resource/image/d6/29/d6bad265a25873d453bc326740688829.png" alt=""></p><p>不过，当时间间隔小于数秒时，我们需要考虑随机产生的数据是否具备真实性，毕竟现实中汽车的速度不可能在数秒中从0到200公里，因此临近两次的采样数据不能相差太大。</p><p>上面我通过两个模拟实验，分别展示了离散型和连续型概率的分布。其实，人们在实际运用中，已经总结出了一些概率分布，我这里挑几个最常见的给你讲解。</p><p>首先我们来看看离散分布模型。常用的离散分布有伯努利分布、分类分布、二项分布、泊松分布等等，这里我重点给你介绍两个。</p><p>第一个是<strong>伯努利分布</strong>（Bernoulli Distribution），这是单个随机变量的分布，而且这个变量的取值只有两个，0或1。伯努利分布通过参数λ来控制这个变量为1的概率，我把具体的公式列出来，并画了张图便于你理解。</p><p><img src="https://static001.geekbang.org/resource/image/ef/10/efb6477333146f0ee91302532fc46210.png" alt=""></p><p>或者写作：</p><p><img src="https://static001.geekbang.org/resource/image/66/03/664d462b28f84da64951ae0b3516f103.png" alt=""></p><p>其中x只能为0或1。</p><p><img src="https://static001.geekbang.org/resource/image/1a/d0/1a64837e5e00b4be301c25da3eb56bd0.png" alt=""></p><p>从这个图也可以看出，之前抛硬币的概率分布就属于伯努利分布。</p><p>另一个是<strong>分类分布</strong>（Categorical Distribution），也叫Multinoulli分布。它描述了一个具有k个不同状态的单个随机变量。这里的k，是有限的数值，如果k为2的时候，那么分类分布就变成了伯努利分布。我把这个分布的公式和图解都列了出来。</p><p><img src="https://static001.geekbang.org/resource/image/0b/28/0b4e8b39a81b24946f6baf3ac7d1ee28.png" alt=""></p><p><img src="https://static001.geekbang.org/resource/image/a2/0a/a2142147a07d4bc4cd45b730cac6850a.png" alt=""></p><p>离散型随机变量的状态数量是有限的，所以可以通过伯努利和分类分布来描述。可是对于连续型随机变量来说，状态是无穷多的，这时我们就需要连续分布模型。比较经典的连续分布有正态分布、均匀分布、指数分布、拉普拉斯分布等等。如果你只需要掌握一个的话，那肯定是正态分布。</p><p>这个分布可以近似表示日常生活中很多数据的分布，我们经常使用它进行机器学习的特征工程，对原始数据实施标准化，使得不同范围的数据具有可比性。所以，如果想要学习机器学习，一定要掌握正态分布。</p><p><strong>正态分布</strong>（Normal Distribution），也叫高斯分布（Gaussian Distribution）。我把这个分布的公式列在这里：</p><p><img src="https://static001.geekbang.org/resource/image/6e/34/6e732d5fdca4786ead38e439493a8d34.png" alt=""></p><p>在这个公式中有两个参数，μ表示均值，σ表示方差。看这个公式不太直观，我们来看一看对应的分布图。</p><p><img src="https://static001.geekbang.org/resource/image/b5/82/b514674826625cfec19bbe3bfec89e82.png" alt=""></p><p>从这个图可以看出，越靠近中心点μ，出现的概率越高，而随着渐渐远离μ，出现的概率先是加速下降，然后减速下降，直到趋近于0。蓝色区域上的数字，表示了这个区域的面积，也就是数据取值在这个范围内的概率。例如，数据取值在[-1σ, μ]之间的概率为34.1%。</p><p>现实中，很多数据分布都是近似于正态分布的。例如人类的身高体重。拿身高来说，大部分人都是接近平均值身高，偏离平均身高越远，相对应的人数越少。这也是为什么正态分布很常用的原因。</p><p>正态分布可以扩展到多元正态分布或多维正态分布（Multivariate Normal Distribution），不过最实用的还是一元标准正态分布，这种分布的μ为0，σ为1。在专栏后面的内容里，我会详细介绍如何使用这种分布，进行特征值的标准化。</p><h2>期望值</h2><p>理解了概率分布，你还需要了解期望值。为什么要了解期望值呢？</p><p>期望值，也叫数学期望，是每次随机结果的出现概率乘以其结果的总和。如果我们把每种结果的概率看作权重，那么期望值就是所有结果的加权平均值。它在我们的生活中十分常见，例如计算多个数值的平均值，其实就是求期望值，只不过我们假设每个数值出现的概率是相同的。</p><p>上一节，我提到如何使用概率来解决复杂度分析，通过概率的加权平均来获得平均时间复杂度，就是时间复杂度的期望值。当然，这个概念能帮助你解决的实际问题远不止这些。</p><p>在我看来，一个问题只要满足两个要素，我们就可以考虑使用期望值：</p><p>第一个要素，在这个问题中可能出现不同的情况，而且各种情况的出现满足了一定的概率分布；</p><p>第二个要素，每种情况都对应一个数值，这个数值代表了具体的应用含义。</p><p>如果你觉得这个还是过于抽象，我再回到本节的案例给你讲解。我先给你提个问题：给定了行驶速度的概率分布，如何计算汽车在1小时内每分钟行驶的平均速度？我们还从比较容易理解的离散型随机变量开始。</p><p>没错，这个问题的答案就是使用1小时所行驶的总距离除以60分钟。以之前的每分钟读取仪表盘、仪表盘最小刻度是5为例。概率分布如下图。</p><p><img src="https://static001.geekbang.org/resource/image/fb/a3/fb92ed0e83943a61579c55759fa0caa3.png" alt=""></p><p>1小时行驶的总距离为每种速度乘以用该速度行驶的时间的乘积之总和。</p><p><img src="https://static001.geekbang.org/resource/image/b3/3d/b31d1664765392d57c21f1ffd3a2b53d.png" alt=""></p><p>1小时内每分钟平均的行驶速度为总距离除以60分钟。</p><p><img src="https://static001.geekbang.org/resource/image/6c/c2/6c9704ffe74872dde0930ecc02d0e7c2.png" alt=""></p><p>将上述式子变化一下，我们可以得到：</p><p><img src="https://static001.geekbang.org/resource/image/7c/cd/7c65637c636ec02333334f4478ecbacd.png" alt=""></p><p>你会发现，每分钟的平均值，就是每种速度的加权平均，而每种速度的权重就是其在概率分布中出现的概率。汽车可能按照不同的速度行驶，每种速度都有一个出现的概率，就是我前面提到的第一个要素。而每种速度所对应的每分钟多少公里这个数值，就是第二个要素。结合这两个要素，计算得到的平均值，也是汽车每分钟行驶速度的期望值。</p><p>那么，对于连续型的随机变量，这种期望值应该如何计算呢？我们需要使用下面的积分公式：</p><p><img src="https://static001.geekbang.org/resource/image/5c/3b/5c206d77edcc3c2a282fab733fba4f3b.png" alt=""></p><h2>总结</h2><p>通过这讲的内容，你对概率的基本知识应该有所了解。本讲中，我通过抛硬币和汽车驾驶的例子，讲述了概率论中一些最基本，也是最重要的概念，包括随机现象、随机变量、概率分布和期望值。</p><p>离散型的随机变量在计算机编程中的应用更为广泛。它可以和排列组合的思想结合起来，通过不同排列或组合的数量，计算每种情况出现的概率。如果把这种概率和每种情况下的复杂度数值结合起来，就可以计算复杂度的期望值。</p><p>另外，离散型概率也可以运用在机器学习的分类算法中。例如，对于文本进行分类时，我们可以通过离散型随机变量，表示每个分类或者每个单词出现的概率。当然，仅靠今天的内容，还不足以让我们打造一个分类算法。我们还需要了解联合概率、条件概率、贝叶斯定理等重要的概念。下一讲，我会详细解释它们。</p><h2>思考题</h2><p>每天我们的朋友圈都会浮现很多新的“动态”。假设我们按照字数，把这些动态分为以下几类：10个字以内，10～30个字，30～50字，50～100字，100字以上。</p><p>尝试统计一下你朋友圈某个时间段的动态，看看每个类有多少条，转换成概率分布应该如何表示？你的分布和今天介绍的哪个概率分布最接近？请注意，统计字数时只需要看你朋友自己所写的内容，无需考虑转发的文章。</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "20 | 概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值",
      },
      {
        title:
          "21 | 概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？",
        herf: "https://time.geekbang.org/column/article/80393",
        id: "80393",
        content:
          '<p>你好，我是黄申。</p><p>上一节我介绍了随机现象、随机变量以及概率分布这些比较简单的概念。学习这些概念是为了做什么呢？其实就是为了更精确地描述我们生活中的现象，用数学的视角看世界，以此解决其中的问题。</p><p>但是实际生活中的现象并非都会像“投硬币”那样简单。有很多影响因素都会影响我们去描述这些现象。比如，看似很简单的“投硬币”，我们其实只是考虑最主要的情况，粗暴地把硬币出现的情况一分为二。比如说，不同类型的硬币是否会影响正反面的概率分布呢？站立的情况如何考虑呢？再比如说，在汽车速度的例子中，经过的交通路线，不同的路线是否会影响速度的概率分布呢？</p><p>一旦影响因素变多了，我们需要考虑的问题就多了。想要解决刚才那几个问题，更精确地描述这些现象，我们就需要理解几个新的概念，联合概率、条件概率以及贝叶斯法则。从数学的角度来说，这些概念能描述现实世界中更为复杂的现象，建立更精细的数学模型。比如，我们后面要讲的朴素贝叶斯算法就是建立在联合概率、条件概率和边缘概率之上的。所以，这一节的内容也非常重要，你一定要认真学习并且掌握。</p><h2>联合概率、条件概率和边缘概率</h2><p>最近，我一直在操心儿子的教育问题，所以一直在研究他班级的成绩单。为了弄清我儿子在班级上的成绩排名，我向老师要了张全班成绩的分布表。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/cf/3d/cf93c9001c0638f0e85c033a3d9aa23d.png" alt=""></p><p>这张表中有两个随机变量，一个是学生的性别，一个是分数区间。我们很容易就可以得出，这个班中男生的概率是P(男生)=10/20=50%，90分及以上的学生的概率是P(90-100)=4/20=20%。那全班考了90分以上的男生的概率是多少呢？我们只要找到90分以上的男生人数，用这个人数除以全班总人数就行了，也就是P(男生, 90-100)=2/20=10%。</p><p>你有没有发现，“90分以上的男生”这个概率和之前单独求男生的概率或90分以上的概率不一样。之前只有一个决定因素，现在这个概率由性别和分数这两个随机变量同时决定。这种由多个随机变量决定的概率我们就叫<strong>联合概率，<strong>它的概率分布就是</strong>联合概率分布</strong>。随机变量x和y的联合概率使用P(x, y)表示。我算出了这个例子里所有的联合概率分布。</p><p><img src="https://static001.geekbang.org/resource/image/24/6b/2428d89357f2a27e0e9f0a4efa97d06b.png" alt=""></p><p>这里的例子只有两个随机变量，但是我们可以很容易扩展到更多的随机变量，比如再增加一个学科的变量。那么，我们就可以观测这样的数据：“班级上女生的数学考了90分及以上的概率是多少？”，其中女生是关于性别变量，数学是关于学科变量，而90分及以上是关于分数变量。</p><p>那么联合概率和单个随机变量的概率之间有什么关联呢？对于离散型随机变量，我们可以通过通过联合概率P(x, y)在y上求和，就可以得到P(x)。对于连续型随机变量，我们可以通过联合概率P(x, y)在y上的积分，推导出概率P(x)。这个时候，我们称P(x)为<strong>边缘概率</strong>。</p><p>除了边缘概率的推导，多个变量的联合概率和单个变量的概率之间还存在一个有趣的关系。在解释这个关系之前，让我先来介绍<strong>条件概率</strong>。</p><p>条件概率也是由多个随机变量决定，但是和联合概率不同的是，它计算了给定某个（或多个）随机变量的情况下，另一个（或多个）随机变量出现的概率，其概率分布叫做<strong>条件概率分布</strong>。给定随机变量x，随机变量y的条件概率使用P(y | x)表示。</p><p>回到成绩分布的案例。我能理解在不同的阶段，男生和女生的成绩可能无法直接相比。所以我更关心的是，自己儿子和其他男生相比是否落后了。那么我的脑子里就产生了这样一个问题：“在男生中，考90分及以上的概率是多少？”。</p><p>仔细看，这个问题和前面几个有所不同，我只关心男生这个群体，所以解答应该是找到考了90分以上的男生之人数，然后用这个人数除以男生总人数（注意，不再是全部总人数）。根据上述表格的数据来计算，P(90-100|男生)= 2/10=20%。</p><p>解释清楚了条件概率，我就可以列出概率、条件概率和联合概率之间的“三角”关系了。简单的说，联合概率是条件概率和概率的乘积，采用通用的公式来表达就是：</p><p><img src="https://static001.geekbang.org/resource/image/51/54/5100c87e5cdec55d5e7eac4f9531a154.png" alt=""></p><p>同样的道理，我们也可以得到：</p><p><img src="https://static001.geekbang.org/resource/image/e4/40/e496e2cf7a9bb127dc38b1220b6e8140.png" alt=""></p><p>我们仍然可以使用成绩的案例，来验证这个公式。为了更清晰地表述这个问题，我们使用如下的符号：</p><ul>\n<li>\n<p>|男, 90-100|表示考了90分以上的男生人数；</p>\n</li>\n<li>\n<p>|男|表示男生人数；</p>\n</li>\n<li>\n<p>|全班|表示全班人数。</p>\n</li>\n</ul><p>男生中考了90分及以上的概率为P(90-100 | 男生) = |男生, 90-100| / |男生|，全班中男生的概率为P(男) = |男生| / |全班|。如果我们将p(90-100 | 男生) 乘以 P(男) 会得到什么结果呢？</p><p>(|男, 90-100| / |男生|) * (|男生| / |全班|) = |男, 90-100| / |全班|</p><p>咦，这不就是全班中男生考了90分及以上的联合概率吗？其实，概率、条件概率和联合概率之间的这种“三角”关系，也是著名的贝叶斯定理的核心，下面我来详细解释什么是贝叶斯定理，以及它可以运用在什么场景之中。</p><h2>贝叶斯定理</h2><p>我们假设有这样一个场景，我想知道男生考了90～100分的概率有多少，来评估一下儿子在男生中算什么水平。可是老师出于隐私保护，并没有把全班数据的分布告诉我，她说道“我可以告诉你全班考90～100分的概率，以及90～100分中男生的概率，但是不能告诉你其他信息了”。这个时候，贝叶斯定理就可以帮上忙啦。</p><p>刚刚我们提到：</p><p><img src="https://static001.geekbang.org/resource/image/51/54/5100c87e5cdec55d5e7eac4f9531a154.png" alt=""><img src="https://static001.geekbang.org/resource/image/e4/40/e496e2cf7a9bb127dc38b1220b6e8140.png" alt=""></p><p>所以就有：</p><p><img src="https://static001.geekbang.org/resource/image/d0/79/d082a9fc31d9378f4511dc23807df179.png" alt=""></p><p>这就是非常经典的贝叶斯法则。为什么说经典呢？是因为它有很多应用的场景，比如朴素贝叶斯，你可以多多熟悉一下这个公式。在这个公式中，还包含了先验概率（Prior Probability）、似然函数（Likelihood）、边缘概率（Marginal Probability）和后验概率（Posterior Probability）的概念。</p><p>在这里面，我们把P(x)称为先验概率。之所以称为“先验”，是因为它是从数据资料统计得到的，不需要经过贝叶斯定理的推算。</p><p>P(y | x)是给定x之后y出现的条件概率。在统计学中，我们也把P(y | x)写作似然函数L(y | x)。在数学里，似然函数和概率是有区别的。概率是指已经知道模型的参数来预测结果，而似然函数是根据观测到的结果数据，来预估模型的参数。不过，当y值给定的时候，两者在数值上是相等的，在应用中我们可以不用细究。</p><p>另外，我们没有必要事先知道P(y)。P(y)可以通过联合概率P(x, y)计算边缘概率得来，而联合概率P(x, y)可以由P(y|x) * P(x)推出。针对离散型和连续型的边缘概率推导分别如下：</p><p><img src="https://static001.geekbang.org/resource/image/8b/d6/8bed8df818f0ebb7367ccfc2d27549d6.png" alt=""><img src="https://static001.geekbang.org/resource/image/8d/61/8d2a747caa6a629c6c38f6fc26c8ec61.png" alt=""></p><p>而P(x|y)是根据贝叶斯定理，通过先验概率P(x)、似然函数P(y | x)和边缘概率P(y)推算而来，因此我们把它称作后验概率。</p><p>回到刚刚的案例，我可以通过这样的式子来计算男生考90-100分的概率：</p><p>P(90-100 | 男生) = (P(男生 | 90-100) * P(90 -100)) / P(男生)</p><p>我只需要数数看，班上男生有多少、总人数多少，就能算出P(男生)。在加上之前，老师告诉我的P(男生 | 90-100)和P(90 -100)，就能推算出P(90-100 | 男生)了。这个例子就是通过先验概率，推导出后验概率，这就是贝叶斯定理神奇的地方，也是它最主要的应用场景。</p><h2>随机变量之间的独立性</h2><p>说到多个随机变量的联合和条件概率，你可能会产生一个问题：这些随机变量是否会相互影响呢？比如，性别和分数之间有怎样的关系？性别是否会影响分数的概率分布？在之前的成绩分布表中，我们可以得到：</p><p>p(90-100 | 男生) = 20%</p><p>p(90-100 | 女生) = 20%</p><p>p(90-100) = 20%</p><p>所以，p(90-100 | 男生) = p(90-100 | 女生) = p(90-100)，也就是全班中考90分及以上的概率、男生中考90分及以上的概率、以及女生中考90分及以上的概率，这三者都是一样。以此类推到其他的分数区间，同样如此，那么，从这个数据上得出的结论是性别对考分的区间没有影响。反之，我们也可以看到p(男生 | 90-100) = p(男生 | 80-90) = p(男生 | 70-80) = … = p(男生) = 50%，也就是说考分区间对性别没有影响。这种情况下我们就说性别和分数这两个随机变量是<strong>相互独立</strong>的。</p><p>相互独立会产生一些有趣的现象，刚刚我们提到：</p><p><img src="https://static001.geekbang.org/resource/image/84/d9/84b5540ed5aec766f05d1a01d734e8d9.png" alt=""><img src="https://static001.geekbang.org/resource/image/98/d5/986898f743d134c4d4d0b6b6718f39d5.png" alt=""></p><p>另外，将p(x | y) = p(x)带入贝叶斯公式，就可以得出：</p><p><img src="https://static001.geekbang.org/resource/image/5e/43/5ea567d9b3f7129f1ae34f8186d46443.png" alt=""></p><p>变量之间的独立性，可以帮我们简化计算。举个例子，假设有6个随机变量，而每个变量有10种可能的取值，那么计算它们的联合概率p($x_{1}$, $x_{2}$, $x_{3}$, $x_{4}$, $x_{5}$, $x_{6}$)，在实际中是非常困难的一件事情。</p><p>根据排列，可能的联合取值，会达到10的6次方，也就是100万这么多。那么使用实际的数据进行统计时，我们也至少需要这个数量级的样本，否则的话很多联合概率分布的值就是0，产生了数据稀疏的问题。但是，如果假设这些随机变量都是相互独立的，那么我们就可以将联合概率p($x_{1},$ $x_{2}$, $x_{3}$, $x_{4}$, $x_{5}$, $x_{6}$)转换为p($x_{1}$) * p($x_{2}$) * p($x_{3}$) * p($x_{4}$) * p($x_{5}$) * p($x_{6}$)。如此一来，我们只需要计算p($x_{1}$)到 p($x_{6}$ )就行了。</p><p>不过，班主任刚刚打电话给我，说之前的数据表格有点笔误，实际的分布应该是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/a9/be/a960147eb4468c870a104a471c73b6be.png" alt=""></p><p>你再推算一下，就会发现p(分数 | 性别) = p(分数)和 p(性别 | 分数) = p(性别)并不成立，所以两者不再是相互独立的。所以下面这个式子就不再成立了，这点你在计算的时候需要注意。</p><p><img src="https://static001.geekbang.org/resource/image/5e/43/5ea567d9b3f7129f1ae34f8186d46443.png" alt=""></p><p>在实际项目中，我们会假设多个随机变量是相互独立的，并基于这个假设大幅简化计算，降低对数据统计量的要求。虽然这个假设通常是不成立的，但是仍然可以帮助我们得到近似的解。相比较实现的可行性和求解的精确度，可行性更为重要。在讲解朴素贝叶斯方法中，我会充分利用这一点，从有限的训练样本中构建分类器。</p><h2>总结</h2><p>这一讲我继续讨论了概率分布相关的内容，不过这次的重点是多个随机变量相关的联合概率、条件概率、边缘概率。这里概念有点多，但是都很重要，因为这三者之间的推算关系，直接构成了贝叶斯定理的核心，所以你要花点时间理解并记住它们。</p><p>而贝叶斯定理定义了先验概率、后验概率和似然函数，后验概率和似然函数及先验概率的乘积成正比关系。此外，通过多个变量之间的独立性，我们可以简化联合概率的计算问题。贝叶斯定理和变量之间独立性的假设，对后面理解朴素贝叶斯算法很有帮助。</p><p>如果有一定数量的标注数据，那么通过统计的方法，我们可以很方便地得到先验概率和似然函数，然后推算出后验概率，最后依据后验概率来做预测。这整个过程符合监督式机器学习的模型训练和新数据预测这两个阶段，因此朴素贝叶斯算法被广泛运用在机器学习的分类问题中。下一节中，我们详细讨论这个算法。</p><h2>思考题</h2><p>大年三十晚上，爷爷奶奶发红包。爷爷准备的红包是4个50元的，6个100元的。奶奶准备的红包是8个50元的，4个100元的。全家人随机抽，你运气很好，拿到一个100元的红包。请问这个红包来自爷爷的概率有多少？来自奶奶的概率有多少？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title:
          "21 | 概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？",
      },
      {
        title: "22 | 朴素贝叶斯：如何让计算机学会自动分类？",
        herf: "https://time.geekbang.org/column/article/80868",
        id: "80868",
        content:
          '<p>你好，我是黄申。今天我们来聊聊朴素贝叶斯。</p><p>在开始正式的内容之前，我想问你一个问题，你是如何区分苹果、甜橙和西瓜的？你可能要说了，这个问题还用得着讲吗？是不是你们博士都喜欢将简单的问题复杂化？还真不是，如果你将计算机想象成一个两三岁的孩子，你会怎么教一个孩子区分这些水果呢？</p><p>比如我曾经就和一个小朋友有过这样一段对话：</p><p>小朋友：黄叔叔，你和我讲讲，什么样的水果才是苹果呀？</p><p>我：圆形的、绿色的水果。</p><p>小朋友：那西瓜也是圆形的、绿色的呀？</p><p>我：嗯……苹果也有可能是黄色或红色的，但西瓜不是。</p><p>小朋友：那甜橙也是圆形的、黄色的呀？</p><p>我：好吧，你看到的大部分情况下的甜橙都是黄色的，而苹果只有很少情况（少数品种）是黄色的。而且你还可以尝尝，它们的味道也是不同的。</p><p><img src="https://static001.geekbang.org/resource/image/0e/db/0e626ddb70a0f4c7133e0a54d18c8fdb.png" alt=""></p><p>哈哈，你是不是觉得想要描述清楚，并没有想象中的那么容易？但是，在这个对话中，有两点我觉得你需要关注一下：</p><ul>\n<li>\n<p>我使用了“可能”“大部分情况”“很少情况”等等这种词语，这些词包含了<strong>概率</strong>的概念；</p>\n</li>\n<li>\n<p>我使用了<strong>多个条件</strong>来判断一个水果属于哪个类别。</p>\n</li>\n</ul><p>基于此，我接下来就要聊聊，我们是如何通过数学的思想和方法，系统性地解决这个问题的。这其中，<strong>朴素贝叶斯</strong>（Naive Bayesian）就提供了一个切实可行的方案。不过，在深入了解它之前，我们还需要做点准备工作。</p><!-- [[[read_end]]] --><h2>如何将原始信息转化为计算机能看懂的数据？</h2><p>事实上，计算机并不像两三岁的小孩那样，可以看到水果的颜色、形状和纹理，或者能尝到水果的味道。<strong>我们需要将水果的特征转化为计算机所能理解的数据</strong>。<strong>最常用的方式就是提取现实世界中的对象之属性，并将这些转化为数字。</strong></p><p>以水果为例，你会提取它们的哪些属性呢？我会考虑这些，比如：形状、外皮颜色、斑马纹理、重量、握感、口感。我手边刚好有一个苹果、一个甜橙和一个西瓜，我把它们的属性分别统计了一下，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/0c/8c/0c4508f42a2179d4de22654ffe17778c.png" alt=""></p><p>然后，我们需要这些属性转化为计算机能够理解的东西——数字，也就是说，我给每种属性都定义了具体的数值，用来代表它们的具体属性。</p><p><img src="https://static001.geekbang.org/resource/image/8c/5d/8ce159eb36bbed80bda6ab7f6d10bc5d.png" alt=""></p><p>比较细心的话，你可能已经发现了，我偷偷地把重量由连续值转化成了离散值，这是因为朴素贝叶斯处理的都是离散值。</p><p>好了，仅仅3个水果还不足以构成朴素贝叶斯分类所需的训练样本。为了保证训练的质量，我们可以继续扩展到10个水果。</p><p><img src="https://static001.geekbang.org/resource/image/e0/08/e0f92302ec5f9a7353177644db88a408.png" alt=""></p><h2>朴素贝叶斯的核心思想</h2><p>我们现在已经拿到了这10个水果的数据，那如果现在我手上有一个新的水果，它也有一定的形状、颜色、口感等等，你怎么判断它是哪种水果呢？</p><p>之前的文章我们讲过先验概率、后验概率、条件概率和贝叶斯法则，它们是朴素贝叶斯分类的核心组成部分。通过贝叶斯法则，我们可以根据先验概率和条件概率，推导出后验概率。首先让我们快速回想一下贝叶斯公式。</p><p><img src="https://static001.geekbang.org/resource/image/0e/57/0ed1d08bd7a3197231ec1b596cadd857.png" alt=""></p><p>上一节，我已经详细解释了这个公式的推导和每一部分的含义，这里再强调一下贝叶斯定理的核心思想：<strong>用先验概率和条件概率估计后验概率</strong>。</p><p>那具体到这里的分类问题，我们该如何运用这个公式呢？为了便于理解，我们可以将上述公式改写成这样：</p><p><img src="https://static001.geekbang.org/resource/image/00/2a/00cdccfb26258a21de50862ccd22a52a.png" alt=""></p><p>其中，c表示一个<strong>分类</strong>（class），f表示属性对应的<strong>数据字段</strong>（field）。如此一来，等号左边的P(c|f)就是待分类样本中，出现属性值f时，样本属于类别c的概率。而等号右边的P(f|c)是根据训练数据统计，得到分类c中出现属性f的概率。P©是分类c在训练数据中出现的概率，P(f)是属性f在训练样本中出现的概率。</p><p>看到这里，你可能要问了，这里的贝叶斯公式只描述了单个属性值属于某个分类的概率，可是我们要分析的水果每个都有很多属性啊，这该怎么办呢？</p><p>别急，朴素贝叶斯在这里就要发挥作用了。这是基于一个简单假设建立的一种贝叶斯方法，并假定数据对象的不同属性对其归类影响时是相互独立的。此时若数据对象o中同时出现属性fi与fj，则对象o属于类别c的概率就是这样：</p><p><img src="https://static001.geekbang.org/resource/image/51/32/51a8c96cd9a8ae06acdff25a87438332.png" alt=""></p><p>现在，我们应该已经可以用10个水果的数据，来建立朴素贝叶斯模型了。</p><p>其中，苹果的分类中共包含3个数据实例，对于形状而言，出现2次不规则圆、1次圆形和0次椭圆形，因此各自的统计概率为0.67、0.33和0.00。我们将这些值称为，给定一个水果分类时，出现某个属性值的<strong>条件概率</strong>。以此类推，所有的统计结果就是下面这个表格中这样：</p><p><img src="https://static001.geekbang.org/resource/image/50/22/504f97b994046fc3fee82690acdd5622.png" alt=""></p><p>对于上表中出现的0.00概率，在做贝叶斯公式中的乘积计算时，会出现结果为0的情况，因此我们通常取一个比这个数据集里最小统计概率还要小的极小值，来代替“零概率”。比如，我们这里取0.01。在填充训练数据中从来没有出现过的属性值的时候，我们就会使用这种技巧，我们给这种技巧起个名字就叫作<strong>平滑</strong>（Smoothing）。</p><p>有了这些条件概率，以及各类水果和各个属性出现的先验概率，我们已经建立起了朴素贝叶斯模型。现在，我们就可以用它进行朴素贝叶斯分类了。</p><p>假设我们有一个新的水果，它的形状是圆形，口感是甜的，那么根据朴素贝叶斯，它属于苹果、甜橙和西瓜的概率分别是多少呢？我们先来计算一下，它属于苹果的概率有多大。</p><p><img src="https://static001.geekbang.org/resource/image/4b/10/4b9b7fc57f85344a90fde596b58ef110.png" alt=""></p><p>其中，apple表示分类为苹果，shape-2表示形状属性的值为2（也就是圆形），taste-2表示口感属性的值为2。以此类推，我们还可计算该水果属于甜橙和西瓜的概率。</p><p><img src="https://static001.geekbang.org/resource/image/49/1e/490bc17c05070918564c20b943daed1e.png" alt=""></p><p>比较这三个数值，0.00198&lt;0.00798&lt;0.26934，所以计算机可以得出的结论，该水果属于甜橙的可能性是最大的，或者说，这个水果最有可能是甜橙。</p><p>你可能已经注意到了，这几个公式里的概率乘积通常都非常小，在物品的属性非常多的时候，这个乘积可能就小到计算机无法处理的地步。因此，在实际运用中，我们还会采用一些数学手法进行转换（比如取log将小数转换为绝对值大于1的负数），原理都是一样的。</p><p>内容比较多，我稍微总结一下。朴素贝叶斯分类主要包括这几个步骤：</p><ul>\n<li>\n<p>准备数据：针对水果分类这个案例，我们收集了若干水果的实例，并从水果的常见属性入手，将其转化为计算机所能理解的数据。这种数据也被称为<strong>训练样本</strong>。</p>\n</li>\n<li>\n<p>建立模型：通过手头上水果的实例，我们让计算机统计每种水果、属性出现的先验概率，以及在某个水果分类下某种属性出现的条件概率。这个过程也被称为<strong>基于样本的训练</strong>。</p>\n</li>\n<li>\n<p>分类新数据：对于一颗新水果的属性数据，计算机根据已经建立的模型进行推导计算，得到该水果属于每个分类的概率，实现了分类的目的。这个过程也被称为<strong>预测</strong>。</p>\n</li>\n</ul><h2>朴素贝叶斯分类VS其他分类算法</h2><p>用朴素贝叶斯进行分类的内容差不多就是这样，你可能要问了，朴素贝叶斯是唯一的分类算法吗？现实中需要分类的场景那么多，朴素贝叶斯都适用吗？确实，我们有很多种分类算法，它们也都有各自的优劣。我这里就把朴素贝叶斯和常用的几种分类算法做个总结和比较。</p><ul>\n<li>\n<p>和<strong>KNN最近邻</strong>相比，朴素贝叶斯需要更多的时间进行模型的训练，但是它在对新的数据进行分类预测的时候，通常效果更好、用时更短。</p>\n</li>\n<li>\n<p>和<strong>决策树</strong>相比，朴素贝叶斯并不能提供一套易于人类理解的规则，但是它可以提供决策树通常无法支持的模糊分类（一个对象可以属于多个分类）。</p>\n</li>\n<li>\n<p>和<strong>SVM支持向量机</strong>相比，朴素贝叶斯无法直接支持连续值的输入。所以，在前面的案例中，我将连续值转化成了离散值，便于朴素贝叶斯进行处理。</p>\n</li>\n</ul><p>为了便于你理解记忆，我这里也做一下总结。</p><p>如果一个分类的应用场景中，待分类对象的属性值大部分都是离散的（或者很容易转化为离散的）、需要支持模糊分类，并且需要快速可靠的实时分类，那么这种场景通常就非常适合使用朴素贝叶斯方法。</p><h2>总结</h2><p>今天我从一个看似非常简单的判断水果的例子出发，介绍了如何通过物体的属性及其数值，让计算机理解现实世界中的事物，并通过朴素贝叶斯方法来对其进行分类。</p><p>在朴素贝叶斯方法的推导过程中，我给你讲了如何使用贝叶斯法则，将后验概率的估计转换为先验概率和条件概率。朴素贝叶斯训练过程包括基于样本数据的先验概率和条件概率统计，分类过程就包括了使用贝叶斯法则，结合新样本的属性数据以及训练好的模型数据，进行最终的预测。</p><p>最后，我将朴素贝叶斯和其他常见分类算法，比如KNN近邻、决策树、SVM向量机，做了对比。朴素贝叶斯适用离散属性值中，训练过程耗时长但是分类预测速度快，支持模糊分类。这一节的内容比较偏理论，下一节，我会着重来讲朴素贝叶斯的应用场景，告诉你哪些场合下更适合使用朴素贝叶斯法。</p><h2>思考题</h2><p>除了文本分类，你还知道什么地方可以使用朴素贝叶斯方法来处理分类问题？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。</span><span class="orange">你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "22 | 朴素贝叶斯：如何让计算机学会自动分类？",
      },
      {
        title: "23 | 文本分类：如何区分特定类型的新闻？",
        herf: "https://time.geekbang.org/column/article/81009",
        id: "81009",
        content:
          '<p>你好，我是黄申。</p><p>你平时应该见过手机App推送的新闻吧？你有没有觉得这些App的推荐算法很神奇？它们竟然可以根据你的喜好来推荐新闻。想要实现这些推荐算法，有一个非常重要的步骤就是给新闻分类。可是，新闻头条这种综合性的平台，需要处理的新闻都是海量的，我们不可能完全靠人工手动处理这些事情。这个时候，我们就要用到计算机技术，来对文本进行自动分类。</p><p>上一节，我给你介绍了如何利用朴素贝叶斯方法，教会计算机进行最基本的水果分类。基于水果分类，今天我们继续深入分类这个话题，告诉你如何利用自然语言处理和朴素贝叶斯方法，对新闻这种长篇文本进行分类。</p><h2>文本分类系统的基本框架</h2><p>想要实现一个完整的文本分类系统，我们通常需要进行这些步骤：</p><h3>1.采集训练样本</h3><p>对于每个数据对象，我们必须告诉计算机，它属于哪个分类。上一节的水果案例里，我们给每个水果打上“苹果”“甜橙”和“西瓜”的标签，这就是采集训练样本。</p><p>同样，我们可以给每一篇新闻打上标签，也就是说，我们首先要分辨某条新闻是什么类型的，比如是政治的、军事的、财经的、体育的，还是娱乐的等等。这一点非常关键，因为分类标签就相当于计算机所要学习的标准答案，其质量高低直接决定了计算机的分类效果。此外，我们也可以在一开始就预留一些训练样本，专门用于测试分类的效果。</p><!-- [[[read_end]]] --><h3>2.预处理自然语言</h3><p>在水果的案例中，当我们把这些水果的特征值提取出来后，能很容易地将它们的属性转化成计算机所能处理的数据，可是这一步对于文本而言就没有那么容易了。好在专家们已经发明出了一套相对成熟的方法，包括词包（bag of words）、分词、词干（Stemming）和归一化（Normalization）、停用词（Stopword）、同义词（Synonyms）和扩展词处理。这里你只需要了解有这么些方法就可以了，我们使用这些方法的目的就是让计算机能够理解文本，所以如果你对刚才提到的这些专业词汇比较陌生，完全不用担心，这并不会影响对后面知识的理解。</p><h3>3.训练模型</h3><p>训练模型就是算法通过训练数据进行模型拟合的过程。对于朴素贝叶斯方法而言，训练的过程就是要获取每个分类的先验概率、每个属性的先验概率以及给定某个分类时，出现某个属性的条件概率。</p><h3>4.实时分类预测</h3><p>算法模型在训练完毕后，根据新数据的属性来预测它属于哪个分类的过程。对于朴素贝叶斯方法而言，分类预测的过程就是根据训练阶段所获得的先验概率和条件概率，来预估给定一系列属性的情况下属于某个分类的后验概率。</p><p>整个流程大致可以用下图来描述：</p><p><img src="https://static001.geekbang.org/resource/image/65/42/65d4db7dbe14f24ae820cff5a83ff242.png" alt=""></p><p>这四个步骤你大致了解就可以了，这里面有两点我会重点讲一下，一是对文本中的自然语言进行预处理，并从文本集合建立字典；另一个是如何使用建好的字典，统计朴素贝叶斯方法所需的数据。自然语言的预处理是让计算机“理解”人类语言的关键步骤，如果没有这一步，计算机就无法将大量的自然语言转换成自己可以处理的数据。而条件概率和先验概率是朴素贝叶斯方法所必须的，因此如何准确地统计它们也是需要详细解释的。</p><h2>基于自然语言的预处理</h2><p>和之前的水果案例相比，新闻这种文本数据最大的区别在于，它包含了大量的自然语言。那么如何让计算机理解自然语言呢？我们的计算机体系没有思维，要理解人类的语言在现阶段是不现实的。但是，我们仍然可以对自然语言进行适当的处理，将其变为机器所能处理的数据。</p><p>首先，我们要知道，文本的的重要属性是什么，这样我们才能提取出它的特征。怎么才能知道哪些属性是重要的呢？</p><p>我举个例子，假如说，有人给你一篇几千字的文章，让你在10秒钟之内说出文章大意，你会怎么办？我想大部分人的解决方案是“<strong>找关键词</strong>”！没错，我们也可以交给计算机用同样的办法。而计算机处理文本的基本单位就是字和单词，这就是人们最常用的方法：词袋（Bag  of words）模型。</p><p>这种模型会忽略文本中的词语出现的顺序以及相应的语法，将整篇文章仅仅看做是一个大量单词的组合。文本中每个词的出现都是独立的，不依赖于其他词的出现情况。讲到这里，你有没有发现在词包模型中，所有单词相互之间是独立的，这个假设和朴素贝叶斯模型的独立假设是不是一致呀？</p><p>没错！这里我们就可以很巧妙地将朴素贝叶斯和文本处理结合起来了。不过先不要急，我们还要掌握一些方法，才能将文本中的长篇大论处理成关键词。</p><h3>1.分词</h3><p>计算机处理自然语言的基本单位是单词和词组。对于英语等拉丁语系的语言来说，单词之间是以空格作为自然分界符的，所以我们可以直接使用空格对句子进行分割，然后来获取每个单词。但是，中文、日文、韩文这些语言在书写的时候，词和词之间并没有空格可以进行自然分界，所以我们就需要使用一些算法，来估计词语之间的划分，我们将这个过程称为<strong>分词</strong>。</p><p>这里有一个给中文句子分词的例子，你可以看一看。</p><pre><code>分词前：今天我们一起来学习计算机学科中的数学知识\n分词后：今天 我们 一起 来 学习 计算机 学科 中 的 数学 知识\n</code></pre><p>是不是觉得给句子分词很简单？这是因为你的中文水平比较高，你想想，计算机怎么才能知道如何分词呢？我们有很多现成的分词模型可以使用。我这里介绍两种目前比较主流的分词模型，你只需要了解就行。</p><p>第一种是<strong>基于字符串匹配</strong>。其实就是扫描字符串。如果发现字符串的子串和词相同，就算匹配成功。匹配规则通常是“正向最大匹配”“逆向最大匹配”“长词优先”。这些算法的优点是只需使用基于字典的匹配，因此计算复杂度低；缺点是处理歧义词效果不佳。</p><p>第二种是<strong>基于统计和机器学习</strong>。这类分词基于人工标注的词性和统计特征，对中文进行建模。训练阶段，根据标注好的语料对模型参数进行估计。 在分词阶段再通过模型计算各种分词出现的概率，将概率最大的分词作为最终结果。常见的序列标注模型有<strong>隐马尔科夫模型</strong>（HMM，Hidden Markov Model）和<strong>条件随机场</strong>（CRF，Conditional Random Field），我们后面章节会讲到，这里我先不展开。</p><h3>2.取词干和归一化</h3><p>我们刚才说了，相对中文而言，英文完全不需要考虑分词。不过它也有中文不具有的单复数、各种时态，因此它需要考虑<strong>取词干</strong>（stemming）。取词干的目标就是为了减少词的变化形式，将派生词转化为基本形式，就像下面这样：</p><pre><code>将am，is，are，was，were全部转换为be\n将car，cars，car’s，cars’全部转换为car\n</code></pre><p>最后，我们还要考虑大小写转化和多种拼写（例如color和colour）这样的统一化，我们把这种做法称为<strong>归一化</strong>。</p><h3>3.停用词</h3><p>无论何种语言，都会存在一些不影响（或基本不影响）相关性的词。有的时候干脆可以指定一个叫<strong>停用词</strong>（stop word）的字典，直接将这些词过滤，不予以考虑。例如英文中的a、an、the、that、is、good、bad等。中文“的、个、你、我、他、好、坏”等。</p><p>如此一来，我们可以在基本不损失语义的情况下，减少数据文件的大小，提高计算机处理的效率。当然，也要注意停用词的使用场景，例如用户观点分析，good和bad这样的形容词反而成为了关键。不仅不能过滤，反而要加大它们的权重。</p><h3>4.同义词和扩展词</h3><p>不同的地域或者不同时代，会导致人们对于同样的物品叫法也不同。例如，在中国北方“番茄“应该叫“西红柿”，而台湾地区将“菠萝”称为“凤梨”。对于计算机而言，需要意识到这两个词是等价的。添加同义词就是一个很好的手段。我们可以维护如下一个同义词的词典：</p><pre><code>番茄，西红柿\n菠萝，凤梨\n洋山芋，土豆\n泡面，方便面，速食面，快餐面\n山芋，红薯\n鼠标，滑鼠\n……\n</code></pre><p>有了这样的词典，当看到文本中出现“番茄”关键词的时候，计算机系统就会将其等同于“西红柿”这个词。有的时候我们还需要扩展词。如果简单地将Dove分别和多芬、德芙简单地等价，那么多芬和德芙这两个完全不同的品牌也变成了同义词，这样做明显是有问题的。那么我们可以采用扩展关系，当系统看到文本中的“多芬”时将其等同于“Dove”，看到“德芙”时将其等同于“Dove”。但是看到“Dove”的时候并不将其等同于“多芬”或“德芙”。</p><p>通过词包模型的假设，以及上述这些自然语言处理的方法，我们可以将整篇的文字，切分为一个个的单词，这些是表示文章的关键属性。你不难发现，每个单词可以作为文章的属性，而通过这些单词的词频（出现的频率），我们很容易进行概率的统计。下面我对分类的先验概率、单词的先验概率、某个分类下某个单词的条件概率分别给出了示例。</p><p><img src="https://static001.geekbang.org/resource/image/20/90/204896aa4fd777102d579764cbf08d90.png" alt=""><img src="https://static001.geekbang.org/resource/image/83/f3/83baf008f9888a6afb6ec5720270aaf3.png" alt=""><img src="https://static001.geekbang.org/resource/image/7e/77/7ed70239e88b4fffaaa7d26e93305877.png" alt=""></p><p>在上表中，你会发现某些单词从未在某个分类中出现，例如“航母”这个词从未在“体育”和“娱乐”这两个分类中出现。对于这种情况，我们可以使用<strong>平滑</strong>（smoothing）的技术，将其词频或条件概率设置为一个极小的值。这里，我设置了最小的词频，也就是1。</p><p>有了这些单词属性以及相应的概率统计，下一步就是如何使用朴素贝叶斯模型进行文本的分类了。</p><h2>运用朴素贝叶斯模型</h2><p>首先我们先来回顾下，上一节推导的朴素贝叶斯公式。</p><p><img src="https://static001.geekbang.org/resource/image/51/32/51a8c96cd9a8ae06acdff25a87438332.png" alt=""></p><p>在新闻分类中，<strong>o</strong>就表示一篇文章，而<strong>c</strong>表示新闻的种类（包括政治、军事、财经等等）。而属性字段<strong>f</strong>就是我们从文档集而建立的各种单词。公式等号左边的<strong>P(c|f)</strong>就是待分类新闻中，出现单词f时，该新闻属于类别c的概率。而等号右边的P(f|c)是根据训练数据统计，得到分类c中出现单词f的概率。P( c )是分类c在新闻训练数据中出现的概率，P(f)是单词f在训练样本中出现的概率。</p><p>我们用刚才表格中的数据来计算下“中国航母”这个短语属于每个分类的概率。</p><p><img src="https://static001.geekbang.org/resource/image/dc/ef/dc38e39930981fd69a4021a4b9fda4ef.png" alt=""><img src="https://static001.geekbang.org/resource/image/1b/d1/1b0c4ffb16a1cca9f3a3f211a7a69dd1.png" alt=""><img src="https://static001.geekbang.org/resource/image/24/8d/24420c243fe5c2f439654596be6f2c8d.png" alt=""><img src="https://static001.geekbang.org/resource/image/f4/5a/f4bc1a5f6737296e49385ae9c809465a.png" alt=""><img src="https://static001.geekbang.org/resource/image/ad/91/ad93545cdbf0214e81ac589e17d60491.png" alt=""></p><p>可以看出来，“中国航母”这个短语本身属于“政治”和“军事”分类的可能性最高，而属于“财经”的可能性最低。需要注意的是，我在上述公式使用了中文词便于你的理解，在真正的实现中，我们需要将中文词和中文分类名称转换为数字型的ID，以提高系统的效率。</p><p>当然，一篇文章所包含的不同的单词数量要远远大于2个，之前如果我们只看“中国航母”这个短语，那么它属于“政治”和“军事”的概率基本一致。如果我们考虑更长的文章（也就是更多的单词），那么这个情况也许就会发生变化。为了支持更多的单词，我们将上述公式扩展为：</p><p><img src="https://static001.geekbang.org/resource/image/92/1e/929ef79bdb208063ad744c285e51231e.png" alt=""></p><p>这里需要注意一个很实际的问题：文章的篇幅很长，常常会导致非常多的P(f|c)连续乘积。而P(f|c)通常是非常小的数值，因此最后的乘积将快速趋近于0以至于计算机无法识别。这里可以使用我们之前提到的一些数学手法进行转换，比如取log，将小数转换为绝对值大于1的负数。这样的转换，虽然会改变每篇文章属于每个分类的概率之绝对值，但是并不会改变这些概率的相对大小。</p><h2>总结</h2><p>在这一讲中，我讲了一个文本分类系统的几个关键步骤，其中最重要的是自然语言的处理和分类模型的训练和预测。</p><p>自然语言的处理是关键的预处理步骤，它将文本转换成计算机所能处理的数据。常见方法包括中文分词，英文的取词干和归一化，还有适用于各种语言的停用词、同义词和扩展词等。如果不考虑这些词出现的先后顺序，以及表达的深层次语义，那么我们就可以使用词包的方法，将大段的文章和语句转化成单词所组成的集合。之后，我们就能统计每个单词属于每个分类的条件概率，以及分类和单词的先验概率。</p><p>一旦将文章表示为单词的集合，我们就会发现，朴素贝叶斯的模型非常适合文章的分类。因为所有单词出现的词频都是离散值，非常适合统计概率。此外，许多新闻之类的文章本身也是跨了多个领域，因此有可能属于多个分类，朴素贝叶斯也能支持这点。我们针对“中国航母”这个短语进行了测试，发现其属于“政治”和“军事”分类的可能性最高。不过要注意的是，文章可能包含非常多的单词，朴素贝叶斯模型中的连续乘积会导致过小的值，甚至计算机都无法处理。为了避免这种情况，我们可以使用log的数学变换。</p><h2>思考题</h2><p>你也许已经通过“中国航母”这个简单的例子，见识到了计算机自动分类的神奇功效。使用同样的分类模型和概率分布，你能否计算一下“美国电影”属于政治、军事、财经、体育和娱乐分类的概率，分别是多少？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "23 | 文本分类：如何区分特定类型的新闻？",
      },
      {
        title: "24 | 语言模型：如何使用链式法则和马尔科夫假设简化概率模型？",
        herf: "https://time.geekbang.org/column/article/81105",
        id: "81105",
        content:
          '<p>你好，我是黄申。</p><p>之前我给你介绍了用于分类的朴素贝叶斯算法。我们讲了，朴素贝叶斯算法可以利用贝叶斯定理和变量之间的独立性，预测一篇文章属于某个分类的概率。除了朴素贝叶斯分类，概率的知识还广泛地运用在其他机器学习算法中，例如语言模型、马尔科夫模型、决策树等等。</p><p>今天我就来说说，基于概率和统计的语言模型。语言模型在不同的领域、不同的学派都有不同的定义和实现，因此为了避免歧义，我这里先说明一下，我们谈到的语言模型，都是指基于概率和统计的模型。</p><h2>语言模型是什么？</h2><p>在解释语言模型之前，我们先来看两个重要的概念。第一个是链式法则，第二个是马尔科夫假设及其对应的多元文法模型。为什么要先说这两个概念呢？这是因为链式法则可以把联合概率转化为条件概率，而马尔科夫假设通过变量间的独立性来减少条件概率中的随机变量，两者结合就可以大幅简化计算的复杂度。</p><h3>1.链式法则</h3><p>链式法则是概率论中一个常用法则。它使用一系列条件概念率和边缘概率，来推导联合概率，我用一个公式来给你看看它的具体表现形式。</p><p><img src="https://static001.geekbang.org/resource/image/de/0c/de5d37d9392a18225b4f9d522b4f180c.png" alt=""></p><p>其中，$x_{1}$到$x_{n}$表示了n个随机变量。</p><!-- [[[read_end]]] --><p>这个公式是怎么来的呢？你还记得联合概率、条件概率和边缘概率之间的“三角”关系吗？我们用这三者的关系来推导一下，最终我们可以得到链式法则。</p><p><img src="https://static001.geekbang.org/resource/image/35/a2/35bbc4bd80d8fba7bd6a63c1cdbd86a2.png" alt=""></p><p>推导的每一步，都是使用了三种概率之间的关系，这个应该不难理解。</p><h3>2.马尔科夫假设</h3><p>理解了链式法则，我们再来看看马尔可夫假设。这个假设的内容是：任何一个词$w_{i}$出现的概率只和它前面的1个或若干个词有关。基于这个假设，我们可以提出<strong>多元文法（Ngram）模型</strong>。Ngram中的“N”很重要，它表示任何一个词出现的概率，只和它前面的N-1个词有关。</p><p>我以二元文法模型为例，来给你解释。按照刚才的说法，二元文法表示，某个单词出现的概率只和它前面的1个单词有关。也就是说，即使某个单词出现在一个很长的句子中，我们也只需要看前面那1个单词。用公式来表示出来就是这样：</p><p><img src="https://static001.geekbang.org/resource/image/b0/e9/b0bc4bb97ba4b233e0ae9db0291059e9.png" alt=""></p><p>如果是三元文法，就说明某个单词出现的概率只和它前面的2个单词有关。即使某个单词出现在很长的一个句子中，它也只看相邻的前2个单词。用公式来表达就是这样：</p><p><img src="https://static001.geekbang.org/resource/image/a6/94/a619504d5c698f0c519904cd6eddf094.png" alt=""></p><p>你也许会好奇，那么一元文法呢？按照字面的意思，就是每个单词出现的概率和前面0个单词有关。这其实说明，每个词的出现都是相互独立的。用公式来表达就是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/52/25/523ff06450418d4d91d8e6d2756e1025.png" alt=""></p><p>弄明白链式法则和马尔科夫假设之后，我们现在来看语言模型。</p><p>假设我们有一个统计样本文本$d$，$s$表示某个有意义的句子，由一连串按照特定顺序排列的词$w_{1}，w_{2},…,w_{n}$组成，这里$n$是句子里单词的数量。现在，我们想知道根据文档d的统计数据，$s$在文本中出现的可能性，即$P(s|d)$，那么我们可以把它表示为$P(s|d)=P(w_{1}, w_{2}, …, w_{n} | d$)。假设我们这里考虑的都是在集合d的情况下发生的概率，所以可以忽略$d$，写为$P(s)=P(w_{1}, w_{2}, …, w_{n})$。</p><p>到这里，我们碰到了第一个难题，就是如何计算$P(w_{1}, w_{2}, …, w_{n})$要在集合中找到一模一样的句子，基本是不可能的。这个时候，我们就需要使用链式法则。我们可以把这个式子改写为：</p><p><img src="https://static001.geekbang.org/resource/image/2f/23/2fe51ac1be8efbad2082627860aada23.png" alt=""></p><p>咋一看，问题似乎是解决了。因为通过文档集合C，你可以知道$P(w_{1})$，$P(w_{2}|w_{1})$这种概率。不过，再往后看，好像$P(w_{3}|w_{1},w_{2})$出现概率很低，$P(w_{4}|w_{1},w_{2},w_{3})$出现的概率就更低了。一直到$P(w_{n}|w_{1}, w_{2}, …, w_{n-1})$，基本上又为0了。我们可以使用上一节提到的平滑技巧，减少0概率的出现。不过，如果太多的概率都是通过平滑的方式而得到的，那么模型和真实的数据分布之间的差距就会加大，最终预测的效果也会很差，所以平滑也不是解决0概率的最终办法。</p><p>除此之外，$P(w_{1}, w_{2}, …, w_{n})和P(w_{n}|w_{1}, w_{2}, …, w_{n-1})$还不只会导致0概率，它还会使得模型存储空间的急速增加。</p><p>为了统计现有文档集合中$P(w_{1}, w_{2}, …, w_{n})$这类值，我们就需要生成很多的计数器。我们假设文档集合中有m个不同的单词，那么从中挑出$n$个单词的可重复排列，数量就是$m^{n}$。此外，还有$m^{n-1}$, $m^{n-2}$等等。这也意味着，如果要统计并存储的所有$P(w_{1}, w_{2}, …, w_{n})$或$P(w_{n}|w_{1}, w_{2}, …, w_{n-1})$这类概率，就需要大量的内存和磁盘空间。当然，你可以做一些简化，不考虑单词出现的顺序，那么问题就变成了可重复组合，但是数量仍然非常巨大。</p><p>如何解决0概率和高复杂度的问题呢？马尔科夫假设和多元文法模型能帮上大忙了。如果我们使用三元文法模型，上述公式可以改写为：</p><p><img src="https://static001.geekbang.org/resource/image/6d/b1/6dfe1f3c267787677090a611fee964b1.png" alt=""></p><p>这样，系统的复杂度大致在(C(m, 1) + C(m, 2) + C(m, 3))这个数量级，而且$P(w_{n}|w_{n-2}, w_{n-1})$为0的概率也会大大低于$P(w_{n}|w_{1}, w_{2}, …, w_{n-1})$ （其中$n&gt;&gt;3$）为0的概率。当然，多元文法模型中的N还是不能太大。随着N的增大，系统复杂度仍然会快递升高，就无法体现出多元文法的优势了。</p><h2>语言模型的应用</h2><p>基于概率的语言模型，本身不是新兴的技术。它已经在机器翻译、语音识别和中文分词中得到了成功应用。近几年来，人们也开始在信息检索领域中尝试语言模型。下面我就来讲讲语言模型在信息检索和中文分词这两个方面里是如何发挥作用的。</p><h3>1.信息检索</h3><p>信息检索很关心的一个问题就是相关性，也就是说，给定一个查询，哪篇文档是更相关的呢？为了解决相关性问题，布尔模型和向量空间检索模型都是从查询的角度出发，观察查询和文档之间的相似程度，并以此来决定如何找出相关的文档。这里的“相似程度”，你可以理解为两者长得有多像。那么，语言模型如何来刻画查询和文档之间的相关度呢？</p><p>它不再使用相似度定义，而是采用了概率。一种常见的做法是计算$P(d|q)$，其中$q$表示一个查询，$d$表示一篇文档。$P(d|q)$表示用户输入查询$q$的情况下，文档$d$出现的概率是多少？如果这个概率越高，我们就认为$q$和$d$之间的相关性越高。</p><p>通过我们手头的文档集合，并不能直接获得$P(d|q)$。好在我们已经学习过了贝叶斯定理，通过这个定理，我们可以将$P(d|q)$重写如下：</p><p><img src="https://static001.geekbang.org/resource/image/de/67/de8d794df4e2758063f5ffb26546c467.png" alt=""></p><p>对于同一个查询，其出现概率$P(q)$都是相同的，同一个文档$d$的出现概率$P(d)$也是固定的。因此它们可以忽略，我们只要关注如何计算$P(q|d)$。而语言模型，为我们解决了如何计算$P(q|d)$的问题，让$k_{1}, k_{2}, …, k_{n}$表示查询q里包含的$n$个关键词。那么根据之前的链式法则公式，可以重写为这样：</p><p><img src="https://static001.geekbang.org/resource/image/d7/66/d78ba0db38a575269eff4f6cb89afa66.png" alt=""></p><p>为了提升效率，我们也使用马尔科夫假设和多元文法。假设是三元文法，那么我们可以写成这样：</p><p><img src="https://static001.geekbang.org/resource/image/e9/13/e977fb4b682e67a8693f1b76f1febe13.png" alt=""></p><p>最终，当用户输入一个查询$q$之后，对于每一篇文档$d$，我们都能获得$P(d|q)$的值。根据每篇文档所获得的$P(d|q)$这个值，由高到低对所有的文档进行排序。这就是语言模型在信息检索中的常见用法。</p><h3>2.中文分词</h3><p>和拉丁语系不同，中文存在分词的问题。如果想进行分词，你就可以实用语言模型。我举个例子给你解释一下，你就明白了。</p><p>最普遍的分词方法之一是基于常用词的词典。如果一个尚未分词的句子里发现了存在于字典里的词，我们就认为找到一个新的词，并把它切分出来。这种切分不会出现完全离谱的结果，但是无法解决某些歧义。我下面来举个例子，原句是“兵乓球拍卖完了”。我在读的时候，会有所停顿，你就能理解分词应该如何进行。可是，仅仅从书面来看，至少有以下几种分词方式：</p><pre><code>第一种，兵乓|球|拍卖|完了\n第二种，兵乓球|拍卖|完了\n第三种，兵乓|球拍|卖完|了\n第四种，兵乓|球拍|卖|完了\n</code></pre><p>上面分词的例子，从字面来看都是合理的，所以这种歧义无法通过这句话本身来解决。那么这种情况下，语言模型能为我们做什么呢？我们知道，语言模型是基于大量的语料来统计的，所以我们可以使用这个模型来估算，哪种情况更合理。</p><p>假设整个文档集合是D，要分词的句子是$s$，分词结果为$w_{1}$, … $w_{n}$，那么我们可以求$P(s)$的概率为：</p><p><img src="https://static001.geekbang.org/resource/image/c7/34/c74b222e54b6c2a9a6385a988896f334.png" alt=""></p><p>请注意，在信息检索中，我们关心的是每篇文章产生一个句子（也就是查询）的概率，而这里可以是整个文档集合D产生一个句子的概率。</p><p>根据链式法则和三元文法模型，那么上面的式子可以重写为：</p><p><img src="https://static001.geekbang.org/resource/image/d4/be/d4cfe338d5aed842cd1b366008a551be.png" alt=""></p><p>也就是说，语言模型可以帮我们估计某种分词结果，在文档集合中出现的概率。但是由于不同的分词方法，会导致$w_{1}$到$w_{n}$的不同，因此就会产生不同的$P(s)$。接下来，我们只要取最大的$P(s)$，并假设这种分词方式是最合理的，就可以在一定程度上解决歧义。我们可以使用这个公式来求解：</p><p><img src="https://static001.geekbang.org/resource/image/1c/dc/1cfeaeb018f38f86c448b57b61525adc.png" alt=""></p><p>其中，$W_{i}$表示第$i$种分词方法。</p><p>回到“兵乓球拍卖完了”这句话，如果文档集合都是讲述的有关体育用品的销售，而不是拍卖行，那么“兵乓|球拍|卖完|了”这种分词的可能性应该更高。</p><h2>小结</h2><p>这一节，我介绍了基于概率论的语言模型，以及它在信息检索和中文分词领域中的应用。这一节的公式比较多，你刚开始看可能觉得有点犯晕。不用急，我给你梳理了几个要点，你只要掌握这几个要点，依次再进行细节学习，就会事半功倍。</p><p>第一，使用联合概率，条件概率和边缘概率的“三角”关系，进行相互推导。链式法则就是很好的体现。</p><p>第二，使用马尔科夫假设，把受较多随机变量影响的条件概率，简化为受较少随机变量影响的条件概率，甚至是边缘概率。</p><p>第三，使用贝叶斯定理，通过先验概率推导后验概率。在信息检索中，给定查询的情况下推导文档的概率，就需要用到这个定理。</p><p>如果你记住了这几点，那么不仅能很快的理解本篇的内容，还能根据实际需求，设计出满足自己需要的语言模型。</p><h2>思考题</h2><p>在中文分词的时候，我们也可以考虑文章的分类。比如，这样一句话“使用纯净水源浇灌的大米”，正确的切分应该是：</p><pre><code>使用|纯净|水源|浇灌|的|大米\n</code></pre><p>如果我们知道这句描述来自于“大米”类商品，而不是“纯净水”类商品，那么就不会错误地切分为：</p><pre><code>使用|纯净水|源|浇灌|的|大米\n</code></pre><p>想想看，如何对我介绍的语言模型加以改进，把分类信息也包含进去？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title:
          "24 | 语言模型：如何使用链式法则和马尔科夫假设简化概率模型？",
      },
      {
        title:
          "25 | 马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？",
        herf: "https://time.geekbang.org/column/article/81374",
        id: "81374",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我们介绍了基于概率的语言模型。概率语言模型的研究对象其实是一个词的序列，以及这个词序列出现的概率有多大。那语言模型是不是也可以用于估算其他序列出现的概率呢？答案是肯定的。</p><p>通过上一节我们知道，语言模型中有个重点：马尔科夫假设及对应的多元文法模型。如果我们把这一点进一步泛化，就能引出马尔科夫模型。也就是说，只要序列的每个状态之间存在转移的概率，那么我们就可以使用马尔科夫模型。有时候情况会更复杂，不仅每个状态之间的转移是按照一定概率进行的，就连每个状态本身也是按照一定概率分布出现的，那么还需要用到隐马尔科夫模型。</p><p>今天这一节，我们就来学习马尔科夫模型、隐马尔科夫模型，以及它们在PageRank和语音识别中的应用。</p><h2>马尔科夫模型</h2><p>在介绍语言模型的时候，我们提到了马尔科夫假设，这个假设是说，每个词出现的概率和之前的一个或若干个词有关。我们换个角度思考就是，<strong>每个词按照一定的概率转移到下一个词</strong>。怎么个转移呢？我来解释一下。</p><p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是<strong>马尔科夫模型</strong>（Markov Model）。</p><!-- [[[read_end]]] --><p>前面讲多元文法的时候，我提到了二元文法、三元文法。对于二元文法来说，某个词出现的概率只和前一个词有关。对应的，在马尔科夫模型中，如果一个状态出现的概率只和前一个状态有关，那么我们称它为<strong>一阶马尔科夫模型</strong>或者<strong>马尔科夫链</strong>。对应于三元、四元甚至更多元的文法，我们也有二阶、三阶等马尔科夫模型。</p><p>我们先从最简单的<strong>马尔科夫模型-马尔科夫链</strong>开始看。我画了一张示意图，方便你理解马尔科夫链中各个状态的转移过程。</p><p><img src="https://static001.geekbang.org/resource/image/90/b9/90537ae6b49b65b154d2084e6e8385b9.jpg" alt=""></p><p>在这张图中，你可以看到，从状态A到B的概率是0.1，从状态B到状态C的概率是0.2等等。我们也可以使用状态转移表来表示这张图。</p><p><img src="https://static001.geekbang.org/resource/image/10/44/108c8b522bd4ff6d1793230260c2c644.png" alt=""></p><p>我们可以根据某个应用的需要，把上述状态转移表具体化。例如，对于语言模型中的二元文法模型，我这里列出了一个示意表。</p><p><img src="https://static001.geekbang.org/resource/image/90/f4/90796185dff6955b48cb300ea11839f4.png" alt=""></p><p>当然，除了二元文法模型，马尔科夫链还有很多应用的场景。</p><p>Google公司最引以为傲的PageRank链接分析算法，它的核心思想就是基于马尔科夫链。这个算法假设了一个“随机冲浪者”模型，冲浪者从某张网页出发，根据Web图中的链接关系随机访问。在每个步骤中，冲浪者都会从当前网页的链出网页中随机选取一张作为下一步访问的目标。在整个Web图中，绝大部分网页节点都会有链入和链出。那么冲浪者就可以永不停歇地冲浪，持续在图中走下去。</p><p>在随机访问的过程中，越是被频繁访问的链接，越是重要。可以看出，每个节点的PageRank值取决于Web图的链接结构。假如一个页面节点有很多的链入链接，或者是链入的网页有较高的被访问率，那么它也将会有更高的被访问概率。</p><p>那么，PageRank的公式和马尔科夫链有什么关系呢？我先给你看一张Web的拓扑图。</p><p><img src="https://static001.geekbang.org/resource/image/84/bf/842598a61f0edc622552544603dbe9bf.jpg" alt=""></p><p>其中A、B、C等结点分别代表了页面，而结点之间的有向边代表了页面之间的超链接。看了这张图中，你是不是觉得Web拓扑图和马尔科夫链的模型图基本上是一致的？我们可以假设每张网页就是一个状态，而网页之间的链接表明了状态转移的方向。这样，我们很自然地就可以使用马尔科夫链来刻画“随机冲浪者”。</p><p>另外，在最基本的PageRank算法中，我们可以假设每张网页的出度是$n$，那么从这张网页转移到任何下一张相连网页的概率都是$\\frac{1}{n}$，因此这个转移的概率只和当前页面有关，满足一阶马尔科夫模型的假设。我在之前的拓扑结构中添加了转移的概率。</p><p><img src="https://static001.geekbang.org/resource/image/ea/5d/ea12a997c4dff97a31991021860d0c5d.jpg" alt=""></p><p>PageRank在标准的马尔科夫链上，引入了随机的跳转操作，也就是假设冲浪者不按照Web图的拓扑结构走下去，只是随机挑选了一张网页进行跳转。这样的处理是类比人们打开一张新网页的行为，也是符合实际情况的，避免了信息孤岛的形成。最终，根据马尔科夫链的状态转移和随机跳转，可以得到如下的PageRank公式。</p><p><img src="https://static001.geekbang.org/resource/image/9a/b2/9afb3366f6b4d4c9aeeebc7e59e96bb2.png" alt=""></p><p>其中，$p_{i}$表示第$i$张网页，$M_{i}$是$p_{i}$的入链接集合，$p_{j}$是$M_{i}$集合中的第$j$张网页。$PR_{(p_{j})}$表示网页$p_{j}$的PageRank得分，$L_{(p_{j})}$表示网页$p_{j}$的出链接数量，$\\frac{1}{L_{(p_{j})}}$就表示从网页$p_{j}$跳转到$p_{i}$的概率。$α$是用户不进行随机跳转的概率，$N$表示所有网页的数量。</p><p>从最简单的马尔科夫链，到多阶的马尔科夫模型，它们都可以刻画基于马尔科夫假设的随机过程，例如概率语言模型中的多元文法和PageRank这类链接分析算法。但是，这些模型都是假设每个状态对我们都是已知的，比如在概率语言模型中，一个状态对应了单词“上学”，另一个状态对应了单词“书包”。可是，有没有可能某些状态我们是未知的呢？下面我们就来详细说说这种情况。</p><h2>隐马尔科夫模型</h2><p>在某些现实的应用场景中，我们是无法确定马尔科夫过程中某个状态的取值的。这种情况下，最经典的案例就是语音识别。使用概率对语音进行识别的过程，和语言模型类似，因此我们可以把每个等待识别的词对应为马尔科夫过程中的一个状态。不过，语音识别所面临的困难更大。为什么呢？你先看看下面这个句子。这个句子里全都是拼音，你能看出它表示什么意思吗？</p><pre><code>ni(三声) zhi(一声) dao(四声) wo(三声) zai(四声) deng(三声) ni(三声) ma(一声)\n</code></pre><p>中国有句古话说得好，“白纸黑字”，写在文档里的文字对于计算机是确定的，“嘛”“吗”  “妈”不会弄错。可是，如果你说一句“你知道我在等你吗”，听众可能一直弄不明白为什么要等别人的妈妈，除非你给他们看到文字版的内容，证明最后一个字是口字旁的“吗”。另外，再加上各种地方的口音、唱歌的发音或者不标准的拼读，情况就更糟糕了。</p><p>计算机只知道某个词的发音，而不知道它具体怎么写，对于这种情况，我们就认为计算机只能观测到每个状态的部分信息，而另外一些信息被“隐藏”了起来。这个时候，我们就需要用隐马尔科夫模型来解决这种问题。隐马尔科夫模型有两层，一层是我们可以观测到的数据，称为“输出层”，另一层则是我们无法直接观测到的状态，称为“隐藏状态层”。我画了一张图方便你理解。</p><p><img src="https://static001.geekbang.org/resource/image/77/75/77593998432b6290808a80c63b830f75.jpg" alt=""></p><p>其中，$x_{1}，x_{2}，x_{3}$等等属于隐藏状态层，$a_{12}$表示了从状态$x_{1}$到$x_{2}$的转移概率，$a_{23}$表示了从状态$x_{2}$到$x_{3}$的转移概率。这一层和普通的马尔科夫模型是一致的，可惜在隐马尔科夫模型中我们无法通过数据直接观测到这一层。我们所能看到的是，$y_{1}，y_{2}，y_{3}$等等代表的“输出层”。另外，$b_{11}$表示了从状态$x_{1}$到$y_{1}$的输出概率，$b_{22}$表示了从状态$x_{2}$到$y_{2}$的输出概率，$b_{33}$表示了从状态$x_{3}$到$y_{3}$的输出概率等等。</p><p>那么在这个两层模型示例中，“隐藏状态层”产生“输出层”的概率是多少呢？这是一系列条件概率决定的，具体的公式我列在这里。</p><p><img src="https://static001.geekbang.org/resource/image/80/7a/80bd25ad15e9d852cbea8b4ef1f4a67a.png" alt=""></p><p>如果你觉得这个两层的模型不太好理解，我来给你说个浅显易懂的例子。假设正在进行普通话语音识别，计算机接受了一个词组的发音。我在下面列出了它的拼音。</p><pre><code>xiang(四声)mu(四声) kai(一声)fa(一声) shi(四声)jian(四声)\n</code></pre><p>假设根据我们手头上的语料数据，这个词组有多种可能，我列出两种。</p><h3>第一种情况</h3><p><img src="https://static001.geekbang.org/resource/image/f7/88/f7df10338a0fda0fbecc9046fc6ea388.jpg" alt=""></p><p>第一种情况下，三个确定的状态是“项目”“开发”和“时间”这三个词。从“项目”转移到“开发”的概率是0.25，从“开发”转移到“时间”的概率是0.3。从“项目”输出“xiang（三声）mu（四声）”的概率是0.1，输出”xiang（四声）mu（四声）”的概率是0.8，输出“xiang（四声）mu（一声）”的概率是0.1，“开发”和“时间”也有类似的输出概率。</p><p>这个时候你可能会奇怪，“项目”的普通话发音就是“xiang（四声）mu（四声）”，为什么还会输出其他的发音呢？这是因为，前面说的这些概率都是通过历史语料的数据统计而来。在进行语音识别的时候，我们会通过不同地区、不同性别、不同年龄等等的人群，采集发音的样本。如此一来，影响这个发音的因素就很多了，比如方言、口音、误读等等。当然，在正常情况下，大部分的发音还是标准的，所以“项目”这个词输出到“xiang（四声）mu（四声）”的概率是最高的。</p><p>好，有了这些概率的分布，我们来看看“项目开发时间”这个词组最后生成的概率是多少。在两层模型的条件概率公式中，我代入了具体的概率值并使用了如下的推导：</p><p><img src="https://static001.geekbang.org/resource/image/7f/f4/7fd2cf482bbd849ff0dfb64d90e3a9f4.png" alt=""></p><h3>第二种情况</h3><p><img src="https://static001.geekbang.org/resource/image/d9/01/d9e15463a4a6d6e227f614da19d2c601.jpg" alt=""></p><p>在第二种的可能性中，三个确定的状态是“橡木”“开发”和“事件”这三个词。从“橡木”转移到"开发"的概率是0.015，从“开发”转移到“事件”的概率是0.05。从“橡木”输出“xiang（一声）mu（四声）”的概率是0.2，输出“xiang（四声）mu（四声）”的概率是0.8，“开发”和“事件”也有类似的输出概率。和第一种情况类似，我们可以计算“橡木开发事件”这个词组最后生成的概率是多少，我用下面这个公式来推导：</p><p><img src="https://static001.geekbang.org/resource/image/c9/07/c91f4ed6837cd11e6231c237a2ab9707.png" alt=""></p><p>最后比较第一种和第二种情况产生的概率，分别是P(项目)x0.0027和P(橡木)x0.000459。假设P(项目)和P(橡木)相等，那么“项目开发时间”这个词组的概率更高。所以“xiang（四声）mu（四声）kai（一声）fa（一声）shi（四声）jian（四声）”这组发音，计算机会识别为“项目开发时间”。从中我们可以看出，尽管“事件”这个词产生“shi（四声）jian（四声）”这个发音的可能性更高，但是“橡木开发事件”这个词组出现的概率极低，因此最终计算机还是选择了“项目开发时间”，隐藏的状态层起到了关键的作用。</p><h2>总结</h2><p>马尔科夫模型考虑了n个状态之间的转移及其对应的关系。这个状态是比较抽象的含义，在不同的应用领域代表不同的含义。在概率语言模型中，状态表示不同的词，状态之间的转移就代表了词按照一定的先后顺序出现。在PageRank这种链接分析中，状态表示不同的网页，状态之间的转移就代表了人们在不同网页之间的跳转。</p><p>在马尔科夫模型中，我们知道了每种状态及其之间转移的概率，然后求解序列出现的概率。然而，有些现实的场景更为复杂，比如说我们观测到的不是状态本身，而是状态按照一定概率分布所产生的输出。针对这种情况，隐马尔科夫模型提出了一种两层的模型，同时考虑了状态之间转移的概率和状态产生输出的概率，为语音识别、手写识别、机器翻译等提供了可行的解决方案。</p><p>隐马尔科夫模型需要回答的最主要问题是：给定一个模型和某个特定的输出序列，如何找到最可能产生这个输出的状态序列？在本节中，我使用了“项目开发时间”这个例子展示隐马尔科夫模型是如何工作的。不过这个例子很简单，我只比较了两种可能性。但是，实际中可能性是非常多的，如果我们使用穷举法，那么复杂度一定很高。</p><p>我们可以把两层的模型看作图结构。其中，状态和输出是结点，转移和输出关系是边，相应的概率是边的权重，这个时候我们就可以对Dijkstra算法稍加修改，来找出权重乘积最大的最优路径，提升查找的效率。我们还可以利用状态序列之间存在的先后关系，使用基于动态规划的维特比（Viterbi）算法来找出最优路径。</p><h2>思考题</h2><p>机器翻译会使用大量的语料，自动学习不同语言之间词和词的匹配。如果在机器翻译中使用隐马尔科夫进行建模，你认为“隐藏状态层”表示的是什么？“输出层”表示的又是什么？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title:
          "25 | 马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？",
      },
      {
        title: "26 | 信息熵：如何通过几个问题，测出你对应的武侠人物？",
        herf: "https://time.geekbang.org/column/article/81673",
        id: "81673",
        content:
          '<p>你好，我是黄申。</p><p>之前和你聊了概率在朴素贝叶斯分类算法中的应用。其实，概率在很多像信息论这样的应用数学领域都有广泛的应用。信息论最初就是运用概率和统计的方法，来研究信息传递的。最近几十年，人们逐步开始使用信息论的概念和思想，来描述机器学习领域中的概率分布，并衡量概率分布之间的相似性。随之而来的是，人们发明了不少相关的机器学习算法。所以接下来的几节，我来介绍一些基于信息论知识的内容。</p><p>信息论的概念比较枯燥，为了让你更轻松地学习，让我从一个生动的案例开始。最近我在朋友圈看到一个小游戏，叫“测一测你是金庸笔下的哪个人物？”。玩这个游戏的步骤是，先做几道题，然后根据你的答案，生成对应的结果。下面是我几位朋友答题之后得到的结果。</p><p><img src="https://static001.geekbang.org/resource/image/55/f1/55ea8faffde5fd7450518903b9d3f3f1.jpeg" alt=""></p><p>这种测试挺好玩的，而且好像有很多类似的，比如测星座啊、测运势啊等等。那你知道这种心理或者性格测试的题目是怎么设计的吗？</p><p>通常，这种心理测试会有一个题库，包含了许多小题目，也就是从不同的方面，来测试人的性格。不过，针对特定的测试目标，我们可能没必要让被测者回答所有的问题。那么，问卷设计者应该如何选择合适的题目，才能在读者回答尽量少的问题的同时，相对准确地测出自己是什么“性格”呢？这里，我们就需要引入基于概率分布的信息熵的概念，来解决这个问题。</p><!-- [[[read_end]]] --><h2>什么是信息熵？</h2><p>我还是拿刚刚那个“测测你是哪个武侠人物”的小游戏举例子。我设计了一个测试题，你可以看看下面这个图表。这个表里一共有10个人物。每个人物都有性别、智商、情商、侠义和个性共5个属性。相应地，我会设计5道题目分别测试这5个属性所占的比例。最后，将测出的5个属性和答案中的武侠人物对照，就可以找到最接近的答案，也就是被测者对应的武侠人物。</p><p><img src="https://static001.geekbang.org/resource/image/40/93/40a23d486077a05edd6dd7f308fb1193.png" alt=""></p><p>这个过程非常简单，你应该很容易就能理解。在这个设计过程中，起决定性作用的环节其实就是，如何设计这5道题目。比如，题目的先后顺序会不会直接影响要回答问题的数量？每个问题在人物划分上，是否有着不同的区分能力？这些都是信息熵要解决的问题。</p><p>我们先来看，这里的<strong>区分能力</strong>指的是什么呢？每一个问题都会将被测试者划分为不同的人物分组。如果某个问题将属于不同人物分组的被测者，尽可能地划分到了相应的分组，那么我们认为这个问题的<strong>区分能力较强。<strong>相反，如果某个问题无法将属于不同人物分组的被测者划分开来，那么我们认为这个问题的</strong>区分能力较弱</strong>。为了帮你进一步理解，我们先来比较一下“性别”和“智商”这两个属性。</p><p><img src="https://static001.geekbang.org/resource/image/8d/f3/8d79a177252ded1ca2bacc392e3471f3.png" alt=""><img src="https://static001.geekbang.org/resource/image/ca/0b/caf124bd2df93a642b2e83404562d60b.png" alt=""></p><p>首先，性别属性将武侠人物平均地划分为一半一半，也就是说“男”和“女”出现的先验概率是各50%。如果我们假设被测试的人群，其男女性别的概率分布也是50%和50%，那么关于性别的测试题，就能将被测者的群体大致等分。</p><p>我们再来看智商属性。我们也将武侠人物划分为2个小集合，不过“智商高”的先验概率是80%，而“智商中等”的先验概率只有20%。同样，我们假设被测试的人群，其智商的概率分布也是类似地，那么经过关于智商的测试题之后，仍然有80%左右的不同人物还是属于同一个集合，并没有被区分开来。因此，我们可以认为关于“智商”的测试题，在对人物进行分组这个问题上，其能力要弱于“性别”的测试题。</p><p>上述这些是不是都很简单？这些都是我们按照感觉，或者说经验来划分的。现在，我们试着用两个科学的度量指标，<strong>信息熵</strong>（Entropy）和<strong>信息增益</strong>（Information Gain），来衡量每道题目的区分能力。</p><p>首先，怎么来理解信息熵呢？信息熵，我们通常简称为熵，其实就是用来刻画给定集合的<strong>纯净度</strong>的一个指标。你可能要问了，那纯净度是啥呢？我举个例子给你解释一下。比如说，一个集合里的元素全部是属于同一个分组，这个时候就表示最纯净，我们就说熵为0；如果这个集合里的元素是来自不同的分组，那么熵是大于0的值。其具体的计算公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/f9/c0/f9da465b8601bb84b97022afd88cbac0.png" alt=""></p><p>其中，$n$表示集合中分组的数量，$p_{i}$表示属于第$i$个分组的元素在集合中出现的概率。</p><p>你可能要问了，这个公式是怎么来的呢？想要解释这个，我们还要从<strong>信息量</strong>说起。熵的公式是用来计算某个随机变量的信息量之期望，而信息量是信息论中的一个度量，简单来说就是，当我们观察到某个随机变量的具体值时，接收到了多少信息。而我们接收到的信息量跟发生事件的概率有关。事情发生的概率越大，产生的信息量越小；事情发生的概率越小，产生的信息量越大。</p><p>因此，我们想要设计一个能够描述信息量的函数，就要同时考虑到下面这三个特点：</p><ul>\n<li>\n<p>信息量应该为正数；</p>\n</li>\n<li>\n<p>一个事件的信息量和它发生的概率成反比；</p>\n</li>\n<li>\n<p>$H(x)$与$P(x)$的对数有关。其中$H(x)$表示$x$的信息量，$P(x)$表示$x$出现的概率。假设有两个不相关的事件$x$和$y$，我们观察到这两个事件同时发生时获得的信息量，应该等于这两个事件各自发生时获得的信息量之和，用公式表达出来就是$H(x,y)=H(x)+H(y)$。之前我们说过，如果$x，y$是两个不相关的事件，那么就有$P(x,y)=P(x)*P(y)$。</p>\n</li>\n</ul><p>依照上述这三点，我们可以设计出信息量公式：$H(x)=-log(P(x), 2)$。函数log的使用是体现了$H(x)$和$P(x)$的对数关系（我们可以使用其他大于1的数字作为对数的底，我这里使用2只是约定俗成。而最开始的负号是为了保证信息量为正）。这个公式可以量化随机变量某种取值时，所产生的信息量。最后，加上计算随机变量不同可能性所产生的信息量之期望，我们就得到了熵的公式。</p><p>从集合和分组的角度来说，如果一个集合里的元素趋向于落在同一分组里，那么告诉你某个元素属于哪个分组的信息量就越小，整个集合的熵也越小，换句话说，整个集合就越“纯净”。相反，如果一个集合里的元素趋向于分散在不同分组里，那么告诉你某个元素属于哪个分组的信息量就越大，整个集合的熵也越大，换句话说，整个集合就越“混乱”。</p><p>为了帮你理解运用，这里我再举几个例子帮助你更好地消化这个公式。我们首先来看一个集合，它只包含了来自A组的元素。</p><p><img src="https://static001.geekbang.org/resource/image/f4/5e/f44a38aaf3b1685bd8532618dcd0b75e.png" alt=""></p><p>那么集合中分组的数量$n$为1，A分组的元素在集合中出现的概率为100%，所以这个集合的熵为-100%*log(100%, 2) = 0。</p><p>我们再来看另一个集合，它只包含了来自A组和B组的元素，其中A、B两组元素数量一样多，各占一半。</p><p><img src="https://static001.geekbang.org/resource/image/9f/6d/9f05be8a2b461f376d8e22356c9df06d.png" alt=""></p><p>那么集合中分组的数量$n$为2，A和B分组的元素在集合中出现的概率各为50%，所以这个集合的熵为2*(-50%*log(50%, 2)) = 1，高于刚才那个集合。</p><p>从上述两个集合的对比可以看出，一个集合中所包含的分组越多、元素在这些分组里分布得越均匀，熵值也越大。而熵值表示了纯净的程度，或者从相反的角度来说，是混乱的程度。</p><p>好了，你已经知道单个集合的熵是如何计算的了。那么，如果将一个集合划分成多个更小的集合之后，又该如何根据这些小集合，来计算整体的熵呢？之前我们提到了信息量和熵具有加和的性质，所以对于包含多个集合的更大集合，它的信息量期望值是可以通过每个小集合的信息量期望值来推算的。具体来说，我们可以使用如下公式：</p><p><img src="https://static001.geekbang.org/resource/image/cd/d3/cd8f5873383759df7782b37f125bb1d3.png" alt=""></p><p>其中，$T$表示一种划分，$P_{v}$表示划分后其中某个小集合，$Entropy(P_{v})$表示某个小集合的熵， 而$\\frac{|Pv|} {|P|}$ 表示某个小集合出现的概率。所以这个公式其实就表示，<strong>对于多个小集合而言，其整体的熵等于各个小集合之熵的加权平均</strong>。而每个小集合的权重是其在整体中出现的概率。</p><p>我用个例子进一步解释这个公式。假设A、B、C三个集合是一个大的整体，我们现在将C组的元素和A、B组分开。</p><p><img src="https://static001.geekbang.org/resource/image/9e/a3/9e2c0629e7ae441eb8b6cb234bb613a3.png" alt=""></p><p>根据之前单个集合的熵计算，A和B组元素所组成的小集合，它的熵是1。而C组没有和其他组混合，所形成的小集合其熵为0。在计算前两个小集合的整体熵时，A组和B组形成的集合出现的概率为$\\frac{2}{3}$，而C组形成的集合出现概率为$\\frac{1}{3}$，所有整体熵$=\\frac{2}{3} * 1 + \\frac{1}{3} * 0 = 0.67$。</p><h2>什么是信息增益？</h2><p>如果我们将划分前后的整体熵做个对比，你会发现划分后的整体熵要小于划分之前的整体熵。这是因为每次划分，都可能将不同分组的元素区分开来，降低划分后每个小集合的混乱程度，也就是降低它们的熵。我们将划分后整体熵的下降，称为<strong>信息增益</strong>（Information Gain）。如果划分后整体熵下降的越多，信息增益就越大。我列出公式便于你的理解。</p><p><img src="https://static001.geekbang.org/resource/image/72/79/7268dcacc996164ba51a499db45de679.png" alt=""></p><p>其中T表示当前选择的特征，$Entropy§$表示选择特征$T$之前的熵，$Entropy(P_{v})$表示特征$T$取值为$v$分组的熵。减号后面的部分表示选择T做决策之后，各种取值加权平均后整体的熵。</p><p>$Gain(P,T)$表示两个熵值之差，越大表示信息增益越多，应该选择这维特征$T$。</p><p>我们把这个概念放到咱们的小游戏里就是，如果一个测试问题能够将来自不同分组的人物尽量的分开，也就是该划分对应的信息增益越高，那么我们就认为其区分能力越高，提供的信息含量也越多。好，说到这里，让我们从游戏的最开始出发，比较一下有关性别和智商的两个测试题。</p><p>在提出任何问题之前，我们无法知道被测者属于哪位武侠人物，因此所有被测者属于同一个集合。假设被测者的概率分布和这10位武侠人物的先验概率分布相同，那么被测者集合的熵为10*(-1 * 0.1 * log(0.1, 2))=3.32。</p><p>通过性别的测试问题对人物进行划分后，我们得到了两个更小的集合，每个小集合都包含5种不同的人物分组，因此每个小集合的熵是(-1 * 5 * 0.2 * log(0.2, 2)) = 2.32，两个小集合的整体熵是0.5 * 2.32 + 0.5 * 2.32 = 2.32。因此使用性别的测试题后，信息增益是3.32 - 2.32 = 1。</p><p>而通过智商的测试问题对人物分组后，我们也得到了两个小集合，一个包含了8种人物，另一个包含了2种人物。包含8种人物的小集合其熵是(-1* 8 * 0.125 * log(0.125, 2)) = 3，包含2种人物的小集合其熵是(-1* 2 * 0.5 * log(0.5, 2)) = 1。两个小集合的整体熵是0.8 * 3 + 0.2 * 1 = 2.6。因此使用智商的测试题后，信息增益是3.32 - 2.6 = 0.72，低于基于性别的测试。所以，我们可以得出结论，有关性别的测试题比有关智商的测试题更具有区分能力。</p><p>信息增益和信息熵是紧密相关的。如果说信息熵衡量了某个状态下，每个分组的纯净程度或者说混乱程度，那么信息增益就是比较了不同状态下，信息熵的差异程度。</p><h2>总结</h2><p>这一讲中，我们从一个有趣的人物性格测试开始，探讨了如何高效率地进行问卷调查。其中主要包含了两个要点：信息熵和信息增益。熵的计算是基于集合内各组元素分布的概率来进行的。而信息增益是集合划分前后整体熵的差值。对某个集合进行划分，都会将其中元素细分到更小的集合，而每个细分的集合纯净度就会提高，整体熵就会下降，其中下降的部分就是信息增益。</p><p>了解信息熵和信息增益的定义之后，我们可以用它们来安排测试问题的先后顺序。其核心的思路是，利用信息增益找出区分力最强的测试题。如果一道测试题可以将来自不同分组的元素分隔开来，那么就说它是有区分力的。如果分隔后，每个细分的集合其熵越趋近于0，那么我们说这个测试题的区分力越强。</p><h2>思考题</h2><p>假设一个集合包含了64个元素，而每个元素的分类都互不相同，那么这个集合的信息熵是多少？仔细观察一下你所计算的结果，和二进制有没有什么联系？</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p>',
        article_title: "26 | 信息熵：如何通过几个问题，测出你对应的武侠人物？",
      },
      {
        title: "27 | 决策树：信息增益、增益比率和基尼指数的运用",
        herf: "https://time.geekbang.org/column/article/81941",
        id: "81941",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我通过问卷调查的案例，给你解释了信息熵和信息增益的概念。被测者们每次回答一道问题，就会被细分到不同的集合，每个细分的集合纯净度就会提高，而熵就会下降。在测试结束的时候，如果所有被测者都被分配到了相应的武侠人物名下，那么每个人物分组都是最纯净的，熵值都为0。于是，测试问卷的过程就转化为“如何将熵从3.32下降到0”的过程。</p><p>由于每道问题的区分能力不同，而我们对问题的选择会影响熵下降的幅度。这个幅度就是信息增益。如果问卷题的顺序选择得好，我们可以更快速地完成对用户性格的判定。这一节我们就继续这个话题，看看如何获得一个更简短的问卷设计，把这个核心思想推广到更为普遍的决策树分类算法中。</p><h2>如何通过信息熵挑选合适的问题？</h2><p>为了实现一个更简短的问卷，你也许很自然地就想到，每次选择问题的时候，我们可以选择信息增益最高的问题，这样熵值下降得就最快。这的确是个很好的方法。我们来试一试。</p><p>我们现在开始选择第一个问题。首先，依次计算“性别”“智商”“情商”“侠义”和“个性”对人物进行划分后的信息增益。我们得到如下结果：</p><p><img src="https://static001.geekbang.org/resource/image/9f/11/9f135e031841f15012ed997a1dd30a11.png" alt=""></p><p>显然，第一步我们会选择“侠义”，之后用户就会被细分为3组。</p><p><img src="https://static001.geekbang.org/resource/image/7c/42/7cd2a03c7b5fd5f6b94e69c89b70c142.png" alt=""><img src="https://static001.geekbang.org/resource/image/a1/b8/a12483f003569c79899c143d28c332b8.png" alt=""><img src="https://static001.geekbang.org/resource/image/09/10/0957e7645a48a21e9409886963270b10.png" alt=""></p><p>针对第一组，我们继续选择在当前这组中，区分力最强、也是就信息增益最高的问题。根据计算的结果我们应该选择有关“性别”的问题，然后进一步地细分。后续的步骤依次类推，直到所有人物都被分开，对于第二组和第三组我们也进行同样地操作。整个过程稍微有点复杂，为了帮你理解，我把它画成了一个图。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/9d/1c/9db1ccd4fd4aa2cd03d74f02811abb1c.png" alt=""></p><p>从这个图可以看出来，对于每种人物的判断，我们至多需要问3个问题，没有必要问全5个问题。比如，对于人物J和C，我们只需要问2个问题。假设读者属于10种武侠人物的概率是均等的，那么我们就可以利用之前介绍的知识，来计算读者需要回答的问题数量之期望值。每种人物出现的概率是0.1，8种人物需要问3个问题，2种人物需要问2个问题，那么回答问题数的期望值是0.8 * 3 + 0.2 * 2 = 2.8（题）。</p><p>如果我们每次不选熵值最高的问题，而选择熵值最低的问题呢？</p><p>我计算了一下，最差的情况下，我们要问完全部5个问题，才能确定被测者所对应的武侠人物。而且问4个问题的情况也不少，回答问题数的期望值会在4到5之间，明显要多于基于最高熵来选择题目的方法。当然，如果测试的目标和问题很多，基于熵的问题选择其运算量就会比较大，我们就可以通过编程来自动化整个过程，最终达到优化问卷设计的目的。</p><p>好了，现在我们总结一下，如何才能进行高效的问卷调查。最核心的思想是，根据当前的概率分布，挑选在当前阶段区分能力更强的那些问题。具体的步骤有三个。</p><p>第一步，根据分组中的人物类型，为每个集合计算信息熵，并通过全部集合的熵值加权平均，获得整个数据集的熵。注意，一开始集合只有一个，并且包含了所有的武侠人物。</p><p>第二步，根据信息增益，计算每个问卷题的区分能力。挑选区分能力最强的题目，并对每个集合进行更细的划分。</p><p>第三步，有了新的划分之后，回到第一步，重复第一和第二步，直到没有更多的问卷题，或者所有的人物类型都已经被区分开来。这一步也体现了递归的思想。</p><p>其实，上述这个过程就体现了训练<strong>决策树</strong>（Decision Tree）的基本思想。决策树学习属于归纳推理算法之一，适用于分类问题。在前面介绍朴素贝叶斯的时候，我说过，分类算法主要包括了建立模型和分类新数据两个阶段。决定问卷题出现顺序的这个过程，其实就是建立决策树模型的过程。</p><p>你可以看到，整个构建出来的图就是一个树状结构，这也是“决策树”这个名字的由来。而根据用户对每个问题的答案，从决策树的根节点走到叶子节点，最后来判断其属于何种人物类型，这个过程就是分类新数据的过程。</p><p>让我们把问卷案例泛化一下，将武侠人物的类型变为机器学习中的训练样本，将问卷中的题目变为机器学习中的特征，那么问卷调查的步骤就可以泛化为决策树构建树的步骤。</p><p>第一步，根据集合中的样本分类，为每个集合计算信息熵，并通过全部集合的熵值加权平均，获得整个数据集的熵。注意，一开始集合只有一个，并且包含了所有的样本。</p><p>第二步，根据信息增益，计算每个特征的区分能力。挑选区分能力最强的特征，并对每个集合进行更细的划分。</p><p>第三步，有了新的划分之后，回到第一步，重复第一步和第二步，直到没有更多的特征，或者所有的样本都已经被分好类。</p><p>有点需要注意的是，问卷案例中的每类武侠人物。都只有一个样本，而在泛化的机器学习问题中，每个类型对应了多个样本。也就是说，我们可以有很多个郭靖，而且每个人的属性并不完全一致，但是它们的分类都是“郭靖”。正是因为这个原因，决策树通常都只能把整体的熵降低到一个比较低的值，而无法完全降到0。这也意味着，训练得到的决策树模型，常常无法完全准确地划分训练样本，只能求到一个近似的解。</p><h2>几种决策树算法的异同</h2><p>随着机器学习的快速发展，人们也提出了不少优化版的决策树。采用信息增益来构建决策树的算法被称为<a href="https://zh.wikipedia.org/wiki/ID3%E7%AE%97%E6%B3%95"><strong>ID3</strong></a>（Iterative Dichotomiser 3，迭代二叉树3代）。但是这个算法有一个缺点，它一般会优先考虑具有较多取值的特征，因为取值多的特征会有相对较大的信息增益。这是为什么呢？</p><p>你仔细观察一下信息熵的定义，就能发现背后的原因。更多的取值会把数据样本划分为更多更小的分组，这样熵就会大幅降低，信息增益就会大幅上升。但是这样构建出来的树，很容易导致机器学习中的过拟合现象，不利于决策树对新数据的预测。为了克服这个问题，人们又提出了一个改进版，<a href="https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95">C4.5算法</a>。</p><p>这个算法使用<strong>信息增益率</strong>（Information Gain Ratio）来替代信息增益，作为选择特征的标准，并降低决策树过拟合的程度。信息增益率通过引入一个被称作<strong>分裂信息</strong>（Split Information）的项来惩罚取值较多的特征，我把相应的公式给你列出来了。</p><p><img src="https://static001.geekbang.org/resource/image/1d/a2/1d2d93ed55bfe09f256a9b72ca6c88a2.png" alt=""></p><p>其中，训练数据集$P$通过属性$T$的属性值，划分为$n$个子数据集，$|Pi|$表示第$i$个子数据集中样本的数量，$|P|$表示划分之前数据集中样本总数量。 这个公式看上去和熵很类似，其实并不相同。</p><p>熵计算的时候考虑的是，集合内数据是否属于同一个类，因此即使集合数量很多，但是集合内的数据如果都是来自相同的分类（或分组），那么熵还是会很低。而这里的分裂信息是不同的，它只考虑子集的数量。如果某个特征取值很多，那么相对应的子集数量就越多，最终分裂信息的值就会越大。正是因为如此，人们可以使用分裂信息来惩罚取值很多的特征。具体的计算公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/01/c4/01f28b759dae3e5fa7139535984eb6c4.png" alt=""></p><p>其中$Gain(P,T)$是数据集$P$使用特征$T$之后的信息增益，$GainRatio(P,T)$是数据集$P$使用特征$T$之后的信息增益率。</p><p>另一种常见的决策树<strong>是CART算法</strong>（Classification and Regression Trees，分类与回归树）。这种算法和ID3、C4.5相比，主要有两处不同：</p><ul>\n<li>\n<p>在分类时，CART不再采用信息增益或信息增益率，而是采用基尼指数（Gini）来选择最好的特征并进行数据的划分；</p>\n</li>\n<li>\n<p>在ID3和C4.5决策树中，算法根据特征的属性值划分数据，可能会划分出多个组。而CART算法采用了二叉树，每次把数据切成两份，分别进入左子树、右子树。</p>\n</li>\n</ul><p>当然，CART算法和ID3、C4.5也有类似的地方。首先，CART中每一次迭代都会降低基尼指数，这类似于ID3、C4.5降低信息熵的过程。另外，基尼指数描述的也是纯度，与信息熵的含义相似。我们可以用下面这个公式来计算每个集合的纯度。</p><p><img src="https://static001.geekbang.org/resource/image/99/69/99ac2d02888b882c6a411316b037d369.png" alt=""></p><p>其中，$n$为集合$P$中所包含的不同分组（或分类）数量。如果集合$P$中所包含的不同分组越多，那么这个集合的基尼指数越高，纯度越低。</p><p>然后，我们需要计算整个数据集的基尼指数。</p><p><img src="https://static001.geekbang.org/resource/image/de/3f/de267e07a31038e848d4396a45ccf23f.png" alt=""></p><p>其中，$m$为全集使用特征$T$划分后，所形成的子集数量。$P_{j}$为第$j$个集合。</p><p>无论是何种决策树算法，来自信息论的几个重要概念：信息熵、信息增益、信息增益率、基尼指数都起到了重要的作用。如果你能很好的学习并运用这些概念，那么决策树这种类型的算法就不难理解了。</p><h2>总结</h2><p>通过这两节的介绍，我想你对信息熵、信息增益、基尼指数等信息论的概念，以及基于这些概念的决策树分类算法应该有了一定了解。决策树算法的优势在于，容易理解和实现。此外，对于通过样本训练所得的树结构，其每个结点都是基于某个数据特征的判定，对于我们的阅读和解释来说都是很方便的。</p><p>当然，决策树也有不足。之前我已经提到，这类算法受训练样本的影响很大，比较容易过拟合。在预测阶段，如果新的数据和原来的训练样本差异较大，那么分类效果就会比较差。为此人们也提出了一些优化方案，比如剪枝和随机森林。如果感兴趣，你可以自己去研究一下。</p><h2>思考题</h2><p>刚刚我提到了，如果每次都选择使得信息增益最小的问题，那么构建出来的答题路径就相对冗长。你可以自己动手计算一下用户要回答问题数的期望。</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。如果你有朋友对决策树感兴趣，你可以点击“请朋友读”，把今天的内容分享给他，说不定就帮他解决一个问题。</span></p>',
        article_title: "27 | 决策树：信息增益、增益比率和基尼指数的运用",
      },
      {
        title: "28 | 熵、信息增益和卡方：如何寻找关键特征？",
        herf: "https://time.geekbang.org/column/article/82296",
        id: "82296",
        content:
          '<p>你好，我是黄申。今天我们来说说特征选择。</p><p>我们已经讨论过信息熵和信息增益在决策树算法中的重要作用。其实，它们还可以运用在机器学习的其他领域，比如特征选择。你可能对“特征选择”这个名词不太熟悉，没有关系，我先花点时间，给你介绍一下什么是特征选择，以及机器学习为什么需要这个步骤。</p><h2>什么是特征选择？</h2><p>在编程领域中，机器学习已经有了十分广泛的应用，它主要包括监督式学习（Supervised Learning）和非监督式的学习（Unsupervised Learning）。监督式学习，是指通过训练资料学习并建立一个模型，并依此模型推测新的实例，主要包括分类（Classification）和回归（Regression）。</p><p>无论是在监督学习还是非监督学习中，我们都可以使用特征选择。不过，我今天要聊的特征选择，会聚焦在监督式学习中的特征处理方法。因此，为了说清楚特征选择是什么，以及为什么要进行这个步骤，我们先来看看监督式机器学习的主要步骤。</p><p>机器学习的步骤主要包括数据的准备、特征工程、模型拟合、离线和在线测试。测试过程也许会产生新的数据，用于进一步提升模型。在这些处理中，特征工程是非常重要的一步。</p><p>“特征”（Feature），是机器学习非常常用的术语，它其实就是可用于模型拟合的各种数据。前面讲朴素贝叶斯分类时，我解释了如何把现实世界中水果的各类特征转化为计算机所能理解的数据，这个过程其实就是最初级的特征工程。当然，特征工程远不止原始特征到计算机数据的转化，还包括特征选择、缺失值的填补和异常值的去除等等。这其中非常重要的一步就是特征选择。</p><!-- [[[read_end]]] --><p>越来越多的数据类型和维度的出现，会加大机器学习的难度，并影响最终的准确度。针对这种情形，特征选择尝试发掘和预定义任务相关的特征，同时过滤不必要的噪音特征。它主要包括特征子集的产生、搜索和评估。我们可以使用穷举法来找到最优的结果，但是如果特征有$N$个，那么复杂度会达到$O(2^{N})$。所以穷举法并不适合特征数量庞大的问题，比如我们之前讲过的文本分类。</p><p>因此，在这个领域诞生了一类基于分类标签的选择方法，它们通过信息论的一些统计度量，看特征和类标签的关联程度有多大。这里我还是使用文本分类的案例，来展示如何基于信息论，来进行特征选择。</p><h2>利用信息熵进行特征选择</h2><p>我们之前讲过如何为文本数据提取特征。对于一篇自然语言的文章，我们主要使用词包（Bag of Words）模型和分词，把完整的文章切分成多个单词或词组，而它们就表示了文章的关键属性，也就是用于机器学习的特征。</p><p>你会发现有些文本预处理的步骤已经在做特征选择的事情了，比如“停用词”。它会直接过滤一些不影响或基本不影响文章语义的词，这就是在减少噪音特征。不过，我之前也提到了，停用词的使用过于简单粗暴，可能会产生适得其反的效果。例如在进行用户观点分类时，“good”和“bad”这样的停用词反而成为了关键。不仅不能过滤，反而要加大它们的权重。</p><p>那么，我们怎么能知道哪些特征是更重要的呢？对于分类问题，我们更关心的是如何正确地把一篇文章划分到正确的分类中。一个好的特征选择，应该可以把那些对分类有价值的信息提取出来，而过滤掉那些对分类没有什么价值的信息。既然如此，我们能不能充分利用分类标签来进行挑选呢？答案是肯定的。前两节，我描述了信息熵和信息增益的工作原理。这里，我就可以使用它们来进行特征选择。</p><p>首先，我们来看这个问题，什么是对分类有价值的特征？</p><p>如果一个特征，经常只在某个或少数几个分类中出现，而很少在其他分类中出现，那么说明这个特征具有较强的区分力，它的出现很可能预示着整个数据属于某个分类的概率很高或很低。</p><p>这个时候，对于一个特征，我们可以看看包含这个特征的数据，是不是只属于少数几个类。举个例子，出现“电影”这个词的文章，经常出现在“娱乐”这个分类中，而很少出现在“军事”“政治”等其他分类中。</p><p>是否属于少数几个类这一点，可以使用信息熵来衡量。我用$Df_{i}$来表示所有出现特征$f_{i}$的数据集合，这个集合一共包含了$n$个分类$C$，而$c_{j}$表示这$n$个分类中的第$j$个。然后我们就可以根据$Df_{i}$中分类$C$的分布，来计算熵。我们用这个公式来计算：</p><p><img src="https://static001.geekbang.org/resource/image/4f/6e/4f316dd9824e5522a71a8de54102796e.png" alt=""></p><p>如果熵值很低，说明包含这个特征的数据只出现在少数分类中，对于分类的判断有价值。计算出每个特征所对应的数据集之熵，我们就可以按照熵值由低到高对特征进行排序，挑选出排列靠前的特征。</p><p>当然，这个做法只考虑了单个特征出现时，对应数据的分类情况，而并没有考虑整个数据集的分类情况。比如，虽然出现“电影”这个词的文章，经常出现在“娱乐”这个分类中，很少出现在其他分类中，但是可能整个样本数据中，“娱乐”这个分类本来就已经占绝大多数，所以“电影”可能并非一个很有信息含量的特征。</p><p>为了改进这一点，我们可以借用决策树中信息增益的概念。我们把单个特征f是不是出现作为一个决策条件，将数据集分为$Df_{i}$ 和$D\\bar{f_{i}}$ ，$Df_{i}$表示出现了这个特征的数据，而$D\\bar{f_{i}}$表示没有出现这个特征的数据。那么使用特征$f_{i}$进行数据划分之后，我们就能得到基于两个新数据集的熵，然后和没有划分之前的熵进行比较，得出信息增益。</p><p><img src="https://static001.geekbang.org/resource/image/a6/34/a6a9e6ce3eab1fa755488f8c82c1ac34.png" alt=""></p><p>如果基于某个特征的划分，所产生的信息增益越大，说明这个特征对于分类的判断越有价值。所以，我们可以为计算基于每个特征的划分，所产生的信息增益，然后按照增益值由高到低对特征进行排序，挑选出排列靠前的特征。</p><h2>利用卡方检验进行特征选择</h2><p>在统计学中，我们使用卡方检验来检验两个变量是否相互独立。把它运用到特征选择，我们就可以检验特征与分类这两个变量是否独立。如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。反之，如果两者有较强的相关性，那么特征对于分类来说就是有信息量的，是个好的特征。为了检验独立性，卡方检验考虑了四种情况的概率：$P(f_{i},c_{j})$  、$P(\\bar{f_{i}}  ,\\bar{c_{j}})$、$P(f_{i},\\bar{c_{j}})$和$P(\\bar{f_{i}},c_{j})$。</p><p>在这四种概率中，$P(f_{i},c_{j})$和$P(\\bar{f_{i}}  ,\\bar{c_{j}})$表示特征$f_{i}$和分类$c_{j}$是正相关的。如果$P(f_{i},c_{j})$很高，表示特征fi的出现意味着属于分类$c_{j}$的概率更高；如果$P(\\bar{f_{i}}  ,\\bar{c_{j}})$很高，表示特征$f_{i}$不出现意味着不属于分类$c_{j}$的概率更高。</p><p>类似地，$P(f_{i},\\bar{c_{j}})$和$P(\\bar{f_{i}},c_{j})$表示特征$f_{i}$和分类$c_{j}$是负相关的。如果$P(f_{i},\\bar{c_{j}})$很高，表示特征$f_{i}$的出现意味着不属于分类$c_{j}$的概率更高；如果$P(\\bar{f_{i}},c_{j})$很高，表示特征$f_{i}$不出现意味着属于分类$c_{j}$的概率更高。</p><p>如果特征和分类的相关性很高，要么是正向相关值远远大于负向相关值，要么是负向相关值远远大于正向相关值。如果特征和分类相关性很低，那么正向相关值和负向相关的值就会很接近。卡方检验就是利用了正向相关和负向相关的特性。</p><p><img src="https://static001.geekbang.org/resource/image/9e/3d/9ec2338131ede3bd92b5abdc798ad33d.png" alt=""></p><p>其中，$N$表示数据的总个数。通过这个公式，你可以看到，如果一个特征和分类的相关性很高，无论是正向相关还是负向相关，那么正向相关和负向相关的差值就很大，最终计算的值就很高。最后，我们就可以按照卡方检验的值由高到低对特征进行排序，挑选出排列靠前的特征。</p><h2>总结</h2><p>在之前水果的案例中，可用的特征并不是很多，每种特征都是有价值的。对于文本分类，每种单词或词组都是特征，再加上多元文法，特征的数量会成倍的增加。过多的特征会影响模型分析的速度和准确度。</p><p>对于监督式学习而言，我们没有必要进行$O(2^{N})$这种数量级的特征子集搜索，而是直接考虑特征和分类标签直接的关系。这个时候信息论等统计度量就可以帮上忙了，它们可以衡量特征和分类之间的关联程度，从而判断哪些特征对于分类来说更重要。</p><p>无论是使用何种统计度量，我们都可以计算相应的数值、排序、并得到排名靠前的若干特征。从文本分类的角度来说，我们只会挑选对分类最有价值的那些单词或词组，而去除其他不重要的那些词。如果特征选择得当，我们既可以减少模型存储的空间，还可以提升分类的准确度。当然，过度的减少特征最终会导致准确度的下降，所以对于不同的数据集要结合实验，要把握一个合理的度。</p><h2>思考题</h2><p>在之前介绍决策树的时候，我除了解释信息增益，还阐述了基尼指数的概念。既然信息增益可用于特征选择，那么基尼指数是不是也可以呢？你可以试着写出相应的公式。</p><p><span class="orange">欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "28 | 熵、信息增益和卡方：如何寻找关键特征？",
      },
      {
        title: "29 | 归一化和标准化：各种特征如何综合才是最合理的？",
        herf: "https://time.geekbang.org/column/article/82661",
        id: "82661",
        content:
          '<p>你好，我是黄申，今天我来说说特征值的变换。</p><p>上一节我讲了如何在众多的特征中，选取更有价值的特征，以提升模型的效率。特征选择是特征工程中的重要步骤，但不是全部。今天，我来说说特征工程中的另一块内容，数值变换。也就是说，我们可以使用统计中的数据分布，对连续型的数值特征进行转换，让多个特征的结合更有效。具体怎么理解呢？我下面就来详细讲一讲。</p><h2>为什么需要特征变换？</h2><p>我们在很多机器学习算法中都会使用特征变换。我使用其中一种算法线性回归作为例子，来解释为什么要进行数值型特征的变换。</p><p>我们之前介绍的监督式学习会根据某个样本的一系列特征，最后判定它应该属于哪个分类，并给出一个离散的分类标签。除此之外，还有一类监督式学习算法，会根据一系列的特征输入，给出连续的预测值。</p><p>举个例子，房地产市场可以根据销售的历史数据，预估待售楼盘在未来的销售情况。如果只是预估卖得“好”还是“不好”，那么这个粒度明显就太粗了。如果我们能做到预估这些房屋的售价，那么这个事情就变得有价值了。想要达成这个预测目的的过程，就需要最基本的<strong>因变量连续回归分析</strong>。</p><p>因变量连续回归的训练和预测，和分类的相应流程大体类似，不过具体采用的技术有一些不同。它采用的是研究一个或多个随机变量$y_{1}$，$y_{2}$，…，$y_{i}$与另一些变量$x_{1}$，$x_{2}$，…，$x_{k}$之间关系的统计方法，又称<strong>多重回归分析</strong>。</p><!-- [[[read_end]]] --><p>我们将$y_{1}$，$y_{2}$，…，$y_{i}$称为因变量，$x_{1}$，$x_{2}$，…，$x_{k}$称为自变量。通常情况下，因变量的值可以分解为两部分，一部分是受自变量影响的，即表示为自变量相关的函数，其中函数形式已知，可能是线性也可能是非线性函数，但包含一些未知参数；另一部分是由于其他未被考虑的因素和随机性的影响，即随机误差。</p><p>如果因变量和自变量为线性关系时，就称为<strong>线性回归模型</strong>；如果因变量和自变量为非线性关系，则称为<strong>非线性回归分析模型</strong>。今天我们要说的是回归中常用的多元线性回归，它的基本形式是：</p><p><img src="https://static001.geekbang.org/resource/image/13/70/1350fcaad0a241fae13896bf85fa4d70.png" alt=""></p><p>其中，$x_{1}$，$x_{2}$，…，$x_{n}$是自变量，$y$是因变量，$ε$是随机误差，通常假定随机误差的均值为0。而w0是截距，$w_{1}$，$w_{2}$，…，$w_{n}$是每个自变量的系数，表示每个自变量对最终结果的影响是正面还是负面，以及影响的程度。如果某个系数大于0，表示对应的自变量对结果是正面影响，这个自变量越大，结果就越大。否则就是负面影响，这个自变量越大，结果就越小。而系数的绝对值表示了影响程度的大小，如果绝对值趋于0，表示基本没有影响。</p><p>线性回归也是统计概率中常用的算法。不过它的实现通常会涉及很多线性代数的知识，所以下一个模块的时候，我会再详细介绍这个算法。这一节，你只需要知道线性回归所要达到的目标，以及怎么使用它就可以了。</p><p>线性回归和其他算法相比，有很强的可解释性。我们可以通过回归后为每个自变量确定的系数，来判哪些自变量对最终的因变量影响更大。可是，在正式开始线性回归分析之前，还有一个问题，那就是不同字段的数据没有可比性。</p><p>比如，房屋的面积和建造的年份，它们分别代表了不同的含义，也有不一样的取值范围。在线性回归中，如果直接将没有可比性的数字型特征线性加和，那么模型最终的解释肯定会受影响。</p><p>这里我用Boston Housing数据集对房价数据进行回归分析，这个数据来自70年代美国波斯顿周边地区的房价，是用于机器学习的经典数据集，你可以在Kaggle的网站（<a href="https://www.kaggle.com/c/boston-housing#description">https://www.kaggle.com/c/boston-housing#description</a>）下载到它。这个数据一共有14个特征或者说自变量，而有1个目标值或者说因变量。</p><p>这里，我只使用其中的train.csv。使用一小段Python代码，我们就能很快的得到一个线性回归的结果。</p><pre><code>import pandas as pd\nfrom sklearn.linear_model import LinearRegression\n\n\ndf = pd.read_csv(&quot;/Users/shenhuang/Data/boston-housing/train.csv&quot;)       #读取Boston Housing中的train.csv\ndf_features = df.drop([\'medv\'], axis=1)     #Dataframe中除了最后一列，其余列都是特征，或者说自变量\ndf_targets = df[\'medv\']         #Dataframe最后一列是目标变量，或者说因变量\n\n\nregression = LinearRegression().fit(df_features, df_targets)        #使用特征和目标数据，拟合线性回归模型\nprint(regression.score(df_features, df_targets))    #拟合程度的好坏\nprint(regression.coef_)            #各个特征所对应的系\n</code></pre><p>使用上述代码之前，请确保你已经按照了Python中的sklearn和pandas包。运行这段代码，你可以得到如下的结果：</p><pre><code>0.735578647853312\n[-4.54789253e-03 -5.17062363e-02  4.93344687e-02  5.34084254e-02\n  3.78011391e+00 -1.54106687e+01  3.87910457e+00 -9.51042267e-03\n -1.60411361e+00  3.61780090e-01 -1.14966409e-02 -8.48538613e-01\n  1.18853164e-02 -6.01842329e-01]\n</code></pre><p>因为不是所有的数据都是可以使用线性回归模型来表示，所以我们需要使用regression.score函数，来看拟合的程度。如果完美拟合，这个函数就会输出1；如果拟合效果很差，这个函数的输出可能就是一个负数。</p><p>这里regression.score函数的输出大约为0.74，接近于1.0。它表示这个数据集使用线性模型拟合的效果还是不错的。如果你还是不理解，不用担心，具体的我们会在线性代数部分详细解答。这里你可以简单的理解为，0.74仅仅表示我们可以使用线性回归来解决Boston Housing这个问题。</p><p>这里，你更需要关注的是每个特征所对应的权重，因为它们可以帮助我们解释哪个特征对最终房价的中位值有更大的影响。参看train.csv中的数据，你会发现最主要的两个正相关特征是nox（系数为3.78011391e+00）和age（系数为3.87910457e+00）。其中nox表示空气污染浓度，age表示老房子占比，也就是说空气污染越多、房龄越高，房价中位数越高，这好像不太合乎常理。我们再来看看最主要的负相关特征rm（系数为-1.54106687e+01），也就是房间数量。房间数量越多，房价中位数越低，也不合理。</p><p>造成这些现象最重要的原因是，不同类型的特征值没有转换到同一个可比较的范围内，所以线性回归后所得到的系数不具有可比性，因此我们无法直接对这些权重加以解释。</p><h2>两种常见的特征变换方法</h2><p>该怎么解决这个问题呢？我们就需要对特征值进行转换。今天我介绍两种最常见的变换方法：归一化和标准化。</p><h3>归一化</h3><p>我们先来看最常用的方法，<strong>归一化</strong>（Normalization）。它其实就是获取原始数据的最大值和最小值，然后把原始值线性变换到[0,1]之间，具体的变换函数为：</p><p><img src="https://static001.geekbang.org/resource/image/0f/1e/0ff408fa0e7a547d2a874a76e39cc31e.png" alt=""></p><p>其中$x$是原始值，$max$为样本数据的最大值，$min$为样本数据的最小值，$x’$是变换后的值。这种方法有个不足最大值与最小值非常容易受噪音数据的影响。</p><p>这里面需要注意的是，“归一化”这个词在不同的领域的含义可能不同。这里我们特指基于最大和最小值的变换。</p><p>接下来，我们来看看在Python中如何实现归一化，以及归一化对回归后系数的影响。</p><pre><code>from sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import MinMaxScaler\n\n\nminMaxScaler = MinMaxScaler()       #基于min和max值的归一化\n\n\ndf_normalized = minMaxScaler.fit_transform(df)  #对原始数据进行归一化，包括特征值和目标变量\ndf_features_normalized = df_normalized[:, 0:-1] #获取归一化之后的特征值\ndf_targets_normalized = df_normalized[:, -1]    #获取归一化之后的目标值\n\n\n#再次进行线性回归\nregression_normalized = LinearRegression().fit(df_features_normalized, df_targets_normalized)\nprint(regression_normalized.score(df_features_normalized, df_targets_normalized))\nprint(regression_normalized.coef\n</code></pre><p>其中，df还是之前加载的dataframe。运行这段代码，你可以得到如下结果：</p><pre><code>0.7355786478533118\n[-0.05103746 -0.08448544  0.10963215  0.03204506  0.08400253 -0.16643522\n  0.4451488  -0.01986622 -0.34152292  0.18490982 -0.13361651 -0.16216516\n  0.10390408 -0.48468369]\n</code></pre><p>你可以看到，表示拟合程度的分数没有变，但是每个特征对应的系数或者说权重，发生了比较大的变化。仔细观察一下，你会发现，这次最主要的正相关特征是age（0.4451488）和tax（0.18490982），也就是老房子占比和房产税的税率，其中至少房产税的税率是比较合理的，因为高房价的地区普遍税率也比较高。而最主要的负相关特征是rad（-0.34152292）和lstat（-0.48468369），rad表示高速交通的便利程度，它的值越大表示离高速越远，房价中位数越低。而lstat表示低收入人群的占比，这个值越大房价中位数越低，这两点都是合理的。</p><h3>标准化</h3><p>另一种常见的方法是基于正态分布的z分数（z-score）标准化（Standardization）。该方法假设数据呈现标准正态分布。</p><p>什么是标准正态分布呢？我们之前介绍过，正态分布是连续随机变量概率分布的一种。在现实生活中，大量随机现象的数据分布都近似于正态分布。</p><p>我这里再快速回顾一下这种分布的特点。</p><p>它以经过平均数的垂线为轴，左右对称展开，中间点最高，然后逐渐向两侧下降，分布曲线和x轴组成的面积为1，表示不同事件出现的概率和为1。平均数和标准差是正态分布的关键参数，它们会决定分布的具体形态。而标准正态分布是正态分布的一种，平均数为0，标准差为1。</p><p>理解了什么是标准正态分布，我们来看看z分数这个方法是如何运作的。实际上，z分数标准化是利用标准正态分布的特点，计算一个给定分数距离平均数有多少个标准差。它的具体转换公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/af/01/af7092087da728c5c36819cf2ae68f01.png" alt=""></p><p>其中$x$为原始值，$u$为均值，$σ$为标准差，$x’$是变换后的值。</p><p>经过z分数的转换，高于平均数的分数会得到一个正的标准分，而低于平均数的分数会得到一个负的标准分数。更重要的是，转换后的数据是符合标准正态分布的。你通过理论或者具体的数值来推导一下，就会发现转换后的数据均值为0，标准差为1。</p><p>和归一化相比，z分数这样的标准化不容易受到噪音数据的影响，并且保留了各维特征对目标函数的影响权重。</p><p>下面我们来看看，在Python中如何实现标准化，以及标准化对回归后系数的影响。</p><pre><code>standardScaler = StandardScaler()    #基于Z分数的标准化\n\n\nstandardScaler.fit(df)\ndf_standardized = standardScaler.transform(df)  #对原始数据进行标准化，包括特征值和目标变量\n\n\ndf_features_standardized = df_standardized[:, 0:-1] #获取标准化之后的特征值\ndf_targets_standardized = df_standardized[:, -1]    #获取标准化之后的特征值\n\n\n#再次进行线性回归\nregression_standardized = LinearRegression().fit(df_features_standardized, df_targets_standardized)\nprint(regression_standardized.score(df_features_standardized, df_targets_standardized))\nprint(regression_standardized.coef\n</code></pre><p>其中，df还是之前加载的dataframe。运行这段代码，这次你得到的结果如下：</p><pre><code>0.7355786478533118\n[-0.07330367 -0.04144107  0.12194378  0.04074345  0.09805446 -0.19311408\n  0.29767387 -0.02916672 -0.34642803  0.34477088 -0.21410757 -0.19904179\n  0.11218058 -0.46369483]\n</code></pre><p>表示拟合程度的分数任然没有变。再次对比不同特征所对应的系数，你会发现这次最主要的正相关特征还是age（0.29767387）和tax（0.34477088），但是相比之前，明显房产税的税率占了更高的权重，更加合理。而最主要的负相关特征还是rad（-0.34152292）和lstat（-0.48468369），这两点都是合理的。</p><h2>总结</h2><p>今天我介绍了在机器学习领域里，如何使用统计里的数据分布来进行特征值的转换。这里，我帮你梳理了几个要点，便于你的记忆。</p><p>第一点，为什么有时候需要转换特征值？因为不同类型的特征取值范围不同，分布也不同，相互之间没有可比性。因此在线性回归中，通过这些原始值分析得到的权重，并不能代表每个特征实际的重要性。</p><p>第二点，如何使用归一化进行特征值转换？这里的归一化是指使用特征取值范围中的最大值和最小值，把原始值转换为0到1之间的值。这样处理的好处在于简单易行，便于理解。不过，它的缺点也很明显，由于只考虑了最大最小值，因此很容易受到异常数据点的干扰。</p><p>第三点，如何使用标准化进行转换？经过标准化处理之后，每种特征的取值都会变成一个标准正态分布，以0为均值，1为标准差。和归一化相比，标准化使用了数据是正态分布的假设，不容易受到过大或过小值的干扰。</p><p>掌握了上面几个点，你就能很好的理解这一节的内容了。在实际的数据分析或者是统计建模的项目中，对于数值型的特征要保持敏感，看到它们的时候都要考虑一下，是不是需要进行特征值的转换？这样就能避免由于多种特征的不同分布而产生的误导性结论。</p><h2>思考题</h2><p>今天我们使用了三种方式处理Boston Housing的数据，并训练出三种线性回归的模型。请尝试使用这些模型的predict方法，对test.csv数据进行预测，看看每种模型的预测效果。（提示：如果你在train.csv上使用了某种特征值的转换，那么相应的test.csv数据也需要经过同样的处理。）</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你也可以把今天的内容分享给你的好友，和他一起在实战中重新理解数学。</p>',
        article_title: "29 | 归一化和标准化：各种特征如何综合才是最合理的？",
      },
      {
        title:
          "30 | 统计意义（上）：如何通过显著性检验，判断你的A/B测试结果是不是巧合？",
        herf: "https://time.geekbang.org/column/article/82919",
        id: "82919",
        content:
          '<p>你好，我是黄申，今天我们来聊聊统计意义和显著性检验。</p><p>之前我们已经讨论了几种不同的机器学习算法，包括朴素贝叶斯分类、概率语言模型、决策树等等。不同的方法和算法会产生不同的效果。在很多实际应用中，我们希望能够量化这种效果，并依据相关的数据进行决策。</p><p>为了使这种量化尽可能准确、客观，现在的互联网公司通常是根据用户的在线行为来评估算法，并比较同类算法的表现，以此来选择相应的算法。在线测试有一个很大的挑战，那就是如何排除非测试因素的干扰。</p><p><img src="https://static001.geekbang.org/resource/image/a9/8a/a9e5a362fabdaf3d591a7cfb33ff308a.png" alt=""></p><p>从图中可以看出，自2016年1月12日开始，转化率曲线的趋势发生了明显的变化。假如说这天恰好上线了一个新版的技术方案A，那么转化率上涨一定是新方案导致的吗？不一定吧？很有可能，1月12日有个大型的促销，使得价格有大幅下降，或者有个和大型企业的合作引入了很多优质顾客等，原因有非常多。如果我们取消12日上线的技术方案A，然后用虚线表示在这种情况下的转化率曲线，这个时候得到了另一张图。</p><p><img src="https://static001.geekbang.org/resource/image/0f/92/0ffe01ec3c4c75764bc94577ff07d492.png" alt=""></p><p>从图中可以发现，不用方案A，反而获得了更好的转化率表现，所以，简单地使用在线测试的结果往往会导致错误的结论，我们需要一个更健壮的测试方法，A/B测试。</p><p>A/B测试，简单来说，就是为同一个目标制定两个或多个方案，让一部分用户使用A方案，另一部分用户使用B方案，记录下每个部分用户的使用情况，看哪个方案产生的结果更好。这也意味着，通过A/B测试的方式，我们可以拿到使用多个不同方法之后所产生的多组结果，用于对比。</p><!-- [[[read_end]]] --><p>问题来了，假设我们手头上有几组不同的结果，每组对应一个方案，包含了最近30天以来每天的转化率，如何判断哪个方案的效果更好呢？你可能会想，对每一组的30个数值取平均数，看看谁的均值大不就好了？但是，这真的就够了吗？</p><p>假设有两组结果需要比较，每一组都有5个数据，而且这两组都符合正态分布。我用一张图画一下这两个正态分布之间的关系。</p><p><img src="https://static001.geekbang.org/resource/image/4c/e3/4c50716807e2eb5178bb37052b9c48e3.png" alt=""></p><p>从这张图可以看出，左边的正态分布A均值μ1比较小，右侧的正态分布B均值μ2比较大。可是，如果我们无法观测到A和B这两个分布的全部，而只根据这两个分布的采样数据来做判断，会发生什么情况？我们很有可能会得出错误的结论。</p><p><img src="https://static001.geekbang.org/resource/image/51/29/511dc74701343b3b546af00004d91929.png" alt=""></p><p>比如说，在这张图的采样中，红色的点表示B的采样，它们都是来自B分布的左侧，而蓝色的点表示A的采样，它们都是来自A分布的右侧。如果我们仅仅根据这两组采样数据的均值来判断，很可能会得出“B分布的均值小于A分布均值”这样的错误结论。</p><p>A/B测试面临的就是这样的问题。我们所得到的在线测试结果，实际上只是一种采样。所以我们不能简单地根据每个组的平均值，来判断哪个组更优。那有没有更科学的办法呢？在统计学中，有一套成熟的系统和对应的方法，今天我们就来讲讲这种方法。</p><p>为了让你能够充分理解这个，我先介绍几个基本概念，显著性差异、统计假设检验和显著性检验、以及P值。</p><h2>显著性差异</h2><p>从刚刚那两张正态分布图，我们可以分析得出，两组数据之间的差异可能由两个原因引起。</p><p>第一，两个分布之间的差异。假设A分布的均值小于B分布，而两者的方差一致，那么A分布随机产生的数据有更高的概率小于B分布随机产生的数据。第二，采样引起的差异，也就是说采样数据不能完全体现整体的数据分布。我在之前的图中，用来自A、B两组的10个数据展示了采样所导致的误差。</p><p>如果差异是第一个原因导致的，在统计学中我们就认为这两组“有显著性差异”。如果差异是第二种原因导致的，我们就认为这两组“无显著性差异”。可以看出来，<strong>显著性差异</strong>（Significant Difference），其实就是研究多组数据之间的差异，是由于不同的数据分布导致的呢，还是由于采样的误差导致的呢？通常，我们也把“具有显著性差异”，称为“差异具有统计意义”或者“差异具有显著性”。</p><p>这里你还需要注意“差异具有显著性”和“具有显著差异”的区别。如前所说，“差异具有显著性“表示不同的组很可能来自不同的数据分布，也就是说多个组的数据来自同一分布的可能性非常小。而“具有显著差异”，是指差异的幅度很大，比如相差100倍。</p><p>不过，差异的显著性和显著差异没有必然联系。举两个例子，比如说，两个不同的数据分布，它们的均值分别是1和1.2，这两个均值相差的绝对值很小，也就是没有显著差异，但是由于它们源自不同的数据分布，所以差异是具有显著性的。再比如说，来自同一个数据分布的两个采样，它们的均值分别是1和100，具有显著的差异，但是差异没有显著性。</p><h2>统计假设检验和显著性检验</h2><p>统计假设检验是指事先对随机变量的参数或总体分布做出一个假设，然后利用样本信息来判断这个假设是否合理。在统计学上，我们称这种假设为<strong>虚无假设</strong>（Null Hypothesis），也叫原假设或零假设，通常记作<strong>H0</strong>。而和虚无假设对立的假设，我们称为<strong>对立假设</strong>（Alternative Hypothesis），通常记作<strong>H1</strong>。也就是说，如果证明虚无假设不成立，那么就可以推出对立假设成立。</p><p>统计假设检验的具体步骤是，先认为原假设成立，计算其会导致什么结果。若在单次实验中产生了小概率的事件，则拒绝原假设H0，并接受对立假设H1。若不会产生小概率的事件，则不能拒绝原假设H0，从而接受它。因此，统计学中的假设是否成立，并不像逻辑数学中的绝对“真”或“假”，而是需要从概率的角度出发来看。</p><p>那么，问题来了，多少才算是“小概率”呢？按照业界的约定俗成，通常我们把概率不超过0.05的事件称为“小概率事件”。当然，根据具体的应用，偶尔也会取0.1或0.01等。在假设检验中，我们把这个概率记为α，并称它为显著性水平。</p><p>显著性检验是统计假设检验的一种，顾名思义，它可以帮助我们判断多组数据之间的差异，是采样导致的“偶然”，还是由于不同的数据分布导致的“必然“。当然，这里的“偶然”和“必然”都是相对的，和显著性水平α有关。显著性检验的假设是，多个数据分布之间没有差异。如果样本发生的概率小于显著性水平α，证明小概率事件发生了，所以拒绝原假设，也就是说认为多个分布之间有差异。否则呢，接受原假设，认为多个分布之间没有差异。换句话说，显著性水平α即为拒绝原假设的标准。</p><h2>P值</h2><p>既然已经定义了显著性检验和显著性水平，那么我们如何为多组数据计算它们之间差异的显著性呢？我们可以使用P值（P-value）。P值中的P代表Probability，就是当H0假设为真时，样本出现的概率，或者换句话说，其实就是我们所观测到的样本数据符合原假设H0的可能性有多大。</p><p>如果P值很小，说明观测值与假设H0的期望值有很大的偏离，H0发生的概率很小，我们有理由拒绝原假设，并接受对立假设。P值越小，表明结果越显著，我们越有信心拒绝原假设。反之，说明观测值与假设H0的期望值很接近，我们没有理由拒绝H0。</p><p>在显著性检验中，原假设认为多个分组内的数据来自同一个数据分布，如果P值足够小，我们就可以拒绝原假设，认为多个分组内的数据来自不同的数据分布，它们之间存在显著性的差异。所以说，只要能计算出P值，我们就能把P值和显著性水平α进行比较，从而决定是否接受原假设。</p><h2>总结</h2><p>今天我从互联网公司常见的A/B测试实验入手，给你讲解了一个更科学的方法来比较不同算法的效果，它就是统计学里的差异显著性检验。这个方法包含了一些你平时可能不太接触的概念，你首先需要理解显著性差异、统计假设检验和P值。其中最为重要的就是显著性差异的概念，因为这是差异显著性检验区别于简单的平均值方法的关键。</p><p>为了便于你的记忆，我这里再用一个形象的比喻来带你复习一遍。</p><p>儿子考了90分，我问他：“你比班上平均分高多少？”如果他回答：“我不太确定，我只看到了周围几个人的分数，我猜大概高出了10分吧”，那么说明他对“自己分数比平均分高出10分”这个假设信心不足，结论有较大的概率是错误的，所以即使可能高了10分，我也高兴不起来。</p><p>如果他回答：“老师说了，班级平均分是88分，我比平均分高出了2分”，那我就很开心了，因为老师掌握了全局的信息，她说的话让儿子对“自己分数比平均分高出2分”的假设是非常有信心的。即使只高出了2分，但是结论有很大的概率是正确的。</p><p>理解了概念之后，我们就要进入实战环节了。其实显著性检验的具体方法有很多，例如方差分析（F检验）、t检验、卡方检验等等。不同的方法计算P值的方法也不同，在下一节，我会用A/B测试的案例来详细解释。</p><h2>思考题</h2><p>在对比两组数据的差异时，如果不断增加采样次数，也就是样本的数量，使用平均值和使用显著性检验这两者的结论，会不会逐渐变得一致？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title:
          "30 | 统计意义（上）：如何通过显著性检验，判断你的A/B测试结果是不是巧合？",
      },
      {
        title:
          "31 | 统计意义（下）：如何通过显著性检验，判断你的A/B测试结果是不是巧合？",
        herf: "https://time.geekbang.org/column/article/83200",
        id: "83200",
        content:
          '<p>你好，我是黄申，今天我们接着来聊显著性检验。</p><p>上一节，我介绍了差异显著性检验的概念，它是指从统计的角度来说，差异的产生有多大的概率、是不是足够可信。这点和数值差异的大小是有区别的。既然我们不能通过差异的大小来推断差异是否可信，那么有没有什么方法，可以帮助我们检验不同数据分布之间，是否存在显著差异呢？具体的方法有不少，比如方差分析（F检验）、t检验、卡方检验等等。我这里以方差分析为例，来讲这个方法是如何帮助我们解决AB测试中的问题。</p><h2>方差分析</h2><p><strong>方差分析</strong>（Analysis of Variance, ANOVA），也叫<strong>F检验</strong>。这种方法可以检验两组或者多组样本的均值是否具备显著性差异。它有四个前提假设，分别是：</p><ul>\n<li>\n<p>随机性：样本是随机采样的；</p>\n</li>\n<li>\n<p>独立性：来自不同组的样本是相互独立的；</p>\n</li>\n<li>\n<p>正态分布性：组内样本都来自一个正态分布；</p>\n</li>\n<li>\n<p>方差齐性：不同组的方差相等或相近。</p>\n</li>\n</ul><p>根据第三个前提，我们假设数据是正态分布，那么分布就有两个参数，一个是平均数，一个是方差。如果我们仅仅知道两个分组的平均值，但并不知道它们的方差相差多大，那么我们所得出的两个分布是否有显著差异的结论就不可靠了。</p><p>为了突出重点，我们先假设咱们的数据都符合上述四个前提，然后我来详细讲解一下方差分析的主要思想。最后，我会通过Python语言来验证各个假设和最终的F检验结果。</p><!-- [[[read_end]]] --><p>这里，我使用之前提到的A/B测试案例，通过方差分析来检验多种算法所产生的用户转化率有没有显著性差异。我们把“转化率”称为“因变量”，把“算法”称为“因素”。这里我们只有算法一个因素，所以所进行的方差分析是单因素方差分析。在方差分析中，因素的取值是离散型的，我们称不同的算法取值为“水平”。如果我们比较算法a和b，那么a和b就是算法这个因素的两个水平。</p><p>我们假设只有两种算法a和b参与了A/B测试。为了检验这些算法导致的转化率，是不是存在显著的差异，我们进行一个为期10天的测试，每天都为每种算法获取一个转化率。具体的数据我列在下面这张表格中。</p><p><img src="https://static001.geekbang.org/resource/image/f3/92/f349be3fe72cba0460f0868605413592.png" alt=""></p><p>我使用$Y_{ij}$来表示这种表格中的数据，$i$表示第$i$次采样（或第$i$天），$j$表示第$j$种水平（或第$j$种算法）。以上面这张表格为例，$Y_{51}=0.34$。</p><p>如果我们把每种算法导致的转化率看作一个数据分布，那么方差分析要解决的问题就是：这两个转化率分布的均值，是不是相等。如果我把两种数据分布的均值记做μ1和μ2，那么原假设H0就是μ1=μ2。而对立假设H1就是μ1 &lt;&gt; μ2。</p><p>之前我们提到，差异是不是显著性，关键要看这个差异是采样的偶然性引起的，还是分布本身引起的。方差分析的核心思想也是围绕这个展开的，因此它计算了三个数值：SST、SSM和SSE。SST表示所有采样数据的<strong>因变量方差</strong>（Total Sum of Squares），我把它的计算公式列在这里。</p><p><img src="https://static001.geekbang.org/resource/image/fd/ad/fd07b019affee5b704308fffd71cb0ad.png" alt=""></p><p>在这个公式中， $Y_{ij}$如前所说，表示了第$i$天第$j$种算法所导致的转化率。而$\\overline{\\overline Y}$表示了10天里，2种算法全部20个数据的平均值。SSM表示数据分布所引起的方差，我们称它为<strong>模型平方和</strong>（Sum Of Squares for Model），它的计算公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/d9/13/d926ab132444cec5e367b9ee535f7f13.png" alt=""></p><p>在这个公式中，$n_{j}$为水平$j$下的观测数量，在我们的案例中为10。$\\overline Y_{j}$为第$j$个水平的平均值，在案例中为算法a或算法b在这10天的平均值。$\\overline Y_{j}-\\overline{\\overline Y}$表示的是某个算法的采样均值和所有采样均值之间的差异，$n_{j}$是相应的权重。我们这里的两个算法都被测试了10天，所以权重相同。根据我们的案例，SSM是0.00018。SSE表示采样引起的方差，我们称它为<strong>误差平方和</strong>（Sum of Squaress for Error）。它的计算公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/84/2f/842aad0e8d589da4fe66d8e0473bc22f.png" alt=""></p><p>根据我们的案例，SSE是0.01652。我们刚刚介绍的三个统计量，SST、SSM和SSE这三者的关系其实是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/23/88/239c3e46ab61cbf12046507d2188a488.png" alt=""></p><p>你可以把这三者的公式代入，自己证明一下等式是否成立。由此可以看出，SST是由SSM和SSE构成的。如果在SST中，SSM的占比更大，那么说明因素对因变量的差异具有显著的影响；如果SSE的占比更大，那么说明采样误差对因变量的差异具有更显著的影响。我们使用这两部分的比例来衡量显著性，并把这个比例称为F值。具体公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/a6/74/a667bf48f002c85be85c604dd12bce74.png" alt=""></p><p>在这个公式中，s是水平的个数，n为所有样本的总数量，s-1为分布的自由度，n-s为误差的自由度。你可能对自由度这个概念比较陌生，这里我稍微解释一下。</p><p><strong>自由度</strong>（degree of freedom），英文缩写是df，它是指采样中能够自由变化的数据个数。对于一组包含n个数据的采样来说，如果方差是一个固定值，那么只有n-1个数据可以自由变化，最后一个数的取值是给定的方差和其他n-1个数据决定的，而不由它自己随意变化，所以自由度就是n-1。这也是为什么在计算一组数的方差时，我们在下面这个公式中使用的除数是n-1，而不是n。</p><p>回到方差分析，对于SSM来说，如果SSM是固定的，那么对于s个水平来说，只能有s-1个组数据自由变化，而最后一组数据必须固定，所以对应于SSM的自由度为s-1。对于SSE来说，如果SSE是固定的，那么对于n个采样、s个水平数据来说，只有n-s个数据是可以自由变化的。因为每个水平中，都要有一个数据需要保证该组的平均值$\\overline Y_{j}$而无法自由变化。</p><p>在我们的案例中，s为不同算法的个数，也就是水平的个数s为2，采样数据的个数n为20，所以分布的自由度为2-1=1，误差的自由度为20-2=18。</p><p>在我们的案例中，F=(0.00018/(2-1))/(0.01652/(20-2))=0.196125908。有了F值，我们需要根据F检验值的临界表来查找对应的P值。我列出了这张表的常见内容，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/4c/42/4ca490378b2816d293b47c26a56ad642.png" alt=""></p><p>通过这张表以及n和m的值，我们可以找到，在显著性水平α为0.05的时候，F值的临界值。如果大于这个临界值，那么F检验的P值就会小于显著性水平α，证明差异具有显著性。</p><p>在咱们的案例中，n=20，m=s-1=1，所以对应的F值为4.414。而我们计算得到的F值为0.196，远远小于4.414，因此说明差异没有显著性。虽然算法a所导致的平均转化率要比算法b的相对高出约2%（要注意，2%的相对提升在转化率中已经算很高了），但是由于差异没有显著性，所以这个提升的偶然性很大，并不意味着算法a比算法b更好。</p><p>如果需要，你可以在网上相关的统计资料里查找到完整的F检验临界值表。</p><h2>使用Python代码进行验证</h2><p>除了手动的计算，我们还可以用一些Python的代码来验证手动计算是不是准确。</p><p>首先，我们要确保自己安装了Python的扩展包statsmodels。如果没有安装，你可以在命令行中输入下面这行：</p><pre><code>pip install -U statsmodels\n</code></pre><p>我们可以把下列数据输入一个oneway.csv文件。</p><pre><code>algo,ratio\na,0.29\na,0.36\na,0.32\na,0.29\na,0.34\na,0.24\na,0.27\na,0.29\na,0.31\na,0.27\nb,0.29\nb,0.33\nb,0.31\nb,0.30\nb,0.31\nb,0.26\nb,0.25\nb,0.30\nb,0.28\nb,0.29\n</code></pre><p>安装完了statsmodels，并建立了数据文件oneway.csv，我们就可以运行下面这段Python代码来进行F检验了。</p><pre><code>import pandas as pd\nfrom statsmodels.formula.api import ols\nfrom statsmodels.stats.anova import anova_lm\nimport scipy.stats as ss\n\n\n# 读取数据，d1对应于算法a，d2对应于算法b\ndf = pd.read_csv(&quot;/Users/shenhuang/Data/oneway.csv&quot;) #设置为你自己的文件路径\nd1 = df[df[\'algo\'] == \'a\'][\'ratio\']\nd2 = df[df[\'algo\'] == \'b\'][\'ratio\']\n\n\n# 检测两个水平的正态性\nprint(ss.normaltest(d1))\nprint(ss.normaltest(d2))\n\n\n# 检测两个水平的方差齐性\nargs = [d1, d2]\nprint(ss.levene(*args))\n\n\n# F检验的第一种方法\nprint(ss.f_oneway(*args))\n\n\n# F检验的第二种方法\nmodel = ols(\'ratio ~ algo\', df).fit()\nanovat = anova_lm(model)\nprint(ano\n</code></pre><p>我们假设用于A/B测试的两个算法是相互独立且随机的，所以这里只检测了正态分布性和方差齐性。</p><p>其中，ss.normaltest分别测试了两个水平的正态分布性，两次结果如下：</p><pre><code>NormaltestResult(statistic=0.16280747339563784, pvalue=0.9218214431590781)\nNormaltestResult(statistic=0.4189199849120419, pvalue=0.8110220857858036)\n</code></pre><p>ss.normaltest的原假设是数据符合正态分布，两次检验P值都是远远大于0.05的，所以原假设成立，这两者都符合正态分布。</p><p>而ss.levene分析了两者的方差齐性，同样P值都是远远大于0.05，因此符合方差齐的前提。</p><pre><code>LeveneResult(statistic=0.7944827586206901, pvalue=0.38450823419725666)\n</code></pre><p>ss.f_oneway和anova_lm都可以进行F检验。ss.f_oneway给出的结果比较简洁。</p><pre><code>F_onewayResult(statistic=0.19612590799031476, pvalue=0.663142430745588)\n</code></pre><p>而anova_lm提供了更多的信息，但是两种F检验函数都证明了我们之前的手动推算结果是正确的。</p><pre><code>            df   sum_sq   mean_sq         F    PR(&gt;F)\nalgo       1.0  0.00018  0.000180  0.196126  0.663142\nResidual  18.0  0.01652  0.000918       NaN       NaN\n</code></pre><h2>总结</h2><p>方差分析可以帮助我们检测差异的显著性，它分析的内容是受一个或多个因素影响的因变量在不同水平分组的差异。不过单因素的方差分析要求因变量属于正态分布总体，并具有方差齐性。如果因变量的分布明显的是非正态，或者方差的差异很显著，那么我们就不能直接使用这种方法。对于方差不齐的情况，我们可以选择适当的函数，例如对数、倒数等等，对原始数据进行转换，直到方差齐性变得显著，或者剔除明显属于“均值±标准差”之外的数据。</p><p>当然，对于非正态分布的数据，我们也可以使用非参数的分析。非参数检验是在总体的方差知道很少的情况下，利用样本数据对总体分布形态等进行推断的方法。名字中的“非参数”的由来，就是因为这种检验方法在推断过程中不涉及有关总体分布的参数，而只是进行分布位置、分布形状之间的比较，因此不受总体分布的限定，适用范围比较广。常见的非参数检验包括二项分布检验、K-S检验、卡方检验等等。</p><h2>思考题</h2><p>请尝试使用Python语言实现你自己的方差分析函数，然后通过测试数据来比较你实现的函数和Python扩展包里的函数（例如statsmodels.stats.anova.anova_lm或scipy.stats.f_oneway）。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title:
          "31 | 统计意义（下）：如何通过显著性检验，判断你的A/B测试结果是不是巧合？",
      },
      {
        title: "32 | 概率统计篇答疑和总结：为什么会有欠拟合和过拟合？",
        herf: "https://time.geekbang.org/column/article/83593",
        id: "83593",
        content:
          '<p>你好，我是黄申。</p><p>在概率统计这个模块中，我们讲了很多监督式机器学习相关的概念。你可能对朴素贝叶斯、决策树、线性回归这类监督式算法中的一些概念还是不太清楚。比如说，为什么要使用大量的文档集合或者语料库来训练一个朴素贝叶斯模型呢？这个过程最后得到的结果是什么？为什么训练后的结果可以用于预测新的数据？这里面其实涉及了很多模型拟合的知识。</p><p>为了帮助你更好地理解这些内容，今天我就来说说监督式学习中几个很重要的概念：拟合、欠拟合和过拟合，以及如何处理欠拟合和过拟合。</p><h2>拟合、欠拟合和过拟合</h2><p>每种学习模型都有自己的假设和参数。虽然朴素贝叶斯和决策树都属于分类算法，但是它们各自的假设和参数都不相同。朴素贝叶斯的假设是贝叶斯定理和变量之间的独立性，而决策树的假设是集合的纯净程度或者混乱程度。我们这里所说的参数，是指根据模型假设和训练样本推导出来的数据，例如朴素贝叶斯中的参数是各种先验概率和条件概率，而决策树的参数是各个树结点以及结点上的决策条件。</p><p>了解了什么是模型的假设和参数，我们来看看什么是模型的<strong>拟合</strong>（Model Fitting）。在监督式学习中，我们经常提到“训练一个模型”，其实更学术的说法应该是“拟合一个模型”。</p><!-- [[[read_end]]] --><p>拟合模型其实就是指通过模型的假设和训练样本，推导出具体参数的过程。有了这些参数，我们就能对新的数据进行预测。这样说有些抽象，我画了张一元回归的图来帮助你理解。假设我们的数据点分布在一个二维空间。</p><p><img src="https://static001.geekbang.org/resource/image/e3/97/e3e14adcdd0b0ffee6f75a4077c4d997.png" alt=""></p><p>其中黑色的点表示训练数据所对应的点，x轴表示唯一的自变量，y轴表示因变量。根据这些训练数据，拟合回归模型之后，所得到的模型结果是一条黑色的曲线。</p><p><img src="https://static001.geekbang.org/resource/image/89/18/89f0c825e42edfe114d7170dc8695618.png" alt=""></p><p>有了这条曲线，我们就能根据测试数据的x轴取值（如图中的x’）来获取y轴的取值（如图中的y’），也就是根据自变量的值来获取因变量的值，达到预测的效果。这种情况就是<strong>适度拟合</strong>（right fitting）。</p><p>可是，有的时候拟合得到的模型过于简单，和训练样本之间的误差非常大，这种情况就是<strong>欠拟合</strong>（Under Fitting）。比如下面这根黑色的曲线，和第一根曲线相比，它离数据点的距离更大。这种拟合模型和训练样本之间的差异，我们就称为<strong>偏差</strong>（Bias）。</p><p><img src="https://static001.geekbang.org/resource/image/71/b5/71b543dad1c6626cda01e57af80137b5.png" alt=""></p><p>欠拟合说明模型还不能很好地表示训练样本，所以在测试样本上的表现通常也不好。例如图中预测的值y’’和测试数据x’对应的真实值y’相差很大。</p><p>相对于欠拟合，另一种情况是，拟合得到的模型非常精细和复杂，和训练样本之间的误差非常小，我们称这种情况为<strong>过拟合</strong>（Over Fitting）。比如下面这根黑色的曲线，和第一根曲线相比，离数据点的距离更近，也就是说偏差更小。</p><p><img src="https://static001.geekbang.org/resource/image/c4/a6/c4b5efe5ea3878edfe0ebc183d85f5a6.png" alt=""></p><p>初学者通常都会觉得过拟合很好，其实并不是这样。过拟合的模型虽然在训练样本中表现得非常优越，但是在测试样本中可能表现不理想。为什么会这样呢？这主要是因为，有的时候，训练样本和测试样本不太一致。</p><p>比如，用于训练的数据都是苹果和甜橙，但是用于测试的数据都是西瓜。在上图中，测试数据x’所对应的y值应该是y’，而不是预测的y’’。这种训练样本和测试样本之间存在的差异，我们称为<strong>方差</strong>（Variance）。在过拟合的时候，我们认为模型缺乏泛化的能力，无法很好地处理新的数据。</p><p>类似地，我以二维空间里的分类为例，展示了适度拟合、欠拟合和过度拟合的情况。仍然假设训练数据的点分布在一个二维空间，我们需要拟合出一个用于区分两个类的分界线。我分别用三张图展示了这三种情况下的分界线。</p><p>首先，第一张是适度拟合的情况。</p><p><img src="https://static001.geekbang.org/resource/image/79/f3/79fae3f45a2f3637057aac2ce027ebf3.png" alt=""></p><p>这张图中，蓝色的点表示分类1的训练数据点，红色的点表示分类2的训练数据点。在适度拟合的时候，分界线比较好的区分了蓝色和红色的点。</p><p>在欠拟合的时候，模型过于简单，分界线区分训练样本中蓝色和红色点的能力比较弱，存在比较多的错误分类。</p><p><img src="https://static001.geekbang.org/resource/image/e6/6c/e6d0aec1c5386d0f5c9f5849d3c2766c.png" alt=""></p><p>在过拟合的时候，模型过于复杂，分界线区分训练样本中蓝色和红色点的能力近乎完美，基本上没有错误的分类。但是，如果测试样本和这个训练样本不太一样，那么这个模型就会产生比较大的误差。</p><p><img src="https://static001.geekbang.org/resource/image/d8/41/d823f53d598cb5f3285546a6b881aa41.png" alt=""></p><p>在常见的监督式学习过程中，适度拟合、欠拟合和过拟合，这三种状态是逐步演变的。我也用一张图来解释这个过程。</p><p><img src="https://static001.geekbang.org/resource/image/f4/1b/f44c549733d640a4e80eb7c1048ccb1b.png" alt=""></p><p>在这个图中，x轴表示模型的复杂程度，y轴表示预测的误差。蓝色曲线表示模型在训练样本上的表现，它和x轴之间的距离表示了偏差。而红色曲线表示模型在测试样本上的表现，它和蓝色曲线之间的距离表示了方差。</p><p>从图的左侧往右侧看，模型的复杂度由简单逐渐复杂。越复杂的模型，越近似训练样本，所以偏差就不断下降。可是，由于过于近似训练样本，模型和测试样本的差距就会加大，因此在模型复杂度达到一定程度之后，在训练样本上的预测误差反而会开始增加，这样就会导致训练和测试样本之间的方差不断增大。</p><p>在这个图中，最左边是高偏差、低方差，就是我们所说的欠拟合，最右边是低偏差、高方差，就是我们所说的过拟合。在靠近中间的位置，我们希望能找到一个偏差和方差都比较均衡的区域，也就是适度拟合的情况。</p><h2>如何处理欠拟合和过拟合？</h2><p>解释了什么是模型拟合、欠拟合和过拟合，我们下面来说说，有哪些常见的处理过拟合和欠拟合的方法。</p><p>想要解决一个问题，我们先要搞清楚产生这个问题的原因。<strong>欠拟合问题，产生的主要原因是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大</strong>。因此，我们就可以增加特征维度，让输入的训练样本具有更强的表达能力。</p><p>之前讲解朴素贝叶斯的时候，我提到“任何两个变量是相互独立的假设”，这种假设和马尔科夫假设中的一元文法的作用一致，是为了降低数据稀疏程度、节省计算资源所采取的措施。可是，这种假设在现实中往往不成立，所以朴素贝叶斯模型的表达能力是非常有限的。当我们拥有足够的计算资源，而且希望建模效果更好的时候，我们就需要更加精细、更加复杂的模型，朴素贝叶斯可能就不再适用了。</p><p>比如，在最近非常火的电影《流浪地球》中，计算机系统莫斯拥有全人类文明的数字资料库。假设我们手头也有一个庞大的资料库，也有莫斯那么强大的计算能力，那么使用一元文法来处理数据就有点大材小用了。我们完全可以放弃朴素贝叶斯中关于变量独立性的假设，而使用二元、三元甚至更大的N元文法来处理这些数据。这就是典型的通过增加更多的特征，来提升模型的复杂度，让它从欠拟合阶段往适度拟合阶段靠拢。</p><p>相对应的，<strong>过拟合问题产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符合训练样本，但是无法适应测试样本或者说新的数据</strong>。所以我们可以减少特征的维度。之前在介绍决策树的时候，我提到了这类算法比较容易过拟合，可以使用剪枝和随机森林来缓解这个问题。</p><p>剪枝，顾名思义，就是删掉决策树中一些不是很重要的结点及对应的边，这其实就是在减少特征对模型的影响。虽然去掉一些结点和边之后，决策树对训练样本的区分能力变弱，但是可以更好地应对新数据的变化，具有更好的泛化能力。至于去掉哪些结点和边，我们可以使用前面介绍的特征选择方法来进行。</p><p>随机森林的构建过程更为复杂一些。“森林”表示有很多决策树，可是训练样本就一套，那这些树都是怎么来的呢？随机森林算法采用了统计里常用的可重复采样法，每次从全部n个样本中取出m个（m&lt;n），然后构建一个决策树。重复这种采样并构建决策树的过程若干次，我们就能获得多个决策树。对于新的数据，每个决策树都会有自己的判断结果，我们取大多数决策树的意见作为最终结果。由于每次采样都是不完整的训练集合，而且有一定的随机性，所以每个决策树的过拟合程度都会降低。</p><p>从另一个角度来看，过拟合表示模型太复杂，而相对的训练数据量太少。因此我们也可以增加训练样本的数据量，并尽量保持训练数据和测试数据分布的一致性。如果我们手头上有大量的训练数据，则可以使用交叉验证（Cross Validation）的划分方式来保持训练数据和测试数据的一致性。其核心思想是在每一轮中，拿出大部分数据实例进行建模，然后用建立的模型对留下的小部分实例进行预测，最终对本次预测结果进行评估。这个过程反复进行若干轮，直到所有的标注样本都被预测了一次而且仅一次。如果模型所接受的数据总是在变化，那么我们就需要定期更新训练样本，重新拟合模型。</p><h2>总结</h2><p>第二模块中，我介绍了很多概率统计中常用的概念。随机变量和它的概率分布体现了事物发生的不确定性。而条件概率、联合概率和边缘概率体现了多个随机变量之间的关系以及是不是相互独立，通过这三者的关系，我们可以推导出贝叶斯定理。在贝叶斯定理和变量独立性假设的基础之上，我讲了朴素贝叶斯算法中的公式推导，以及如何使用先验概率来预测后验概率。由于朴素贝叶斯假定多个变量之间相互独立，因此特别适合特征维度很多、特征向量和矩阵很稀疏的场景。基于词包方法的文本分类就是个非常典型的例子。</p><p>文本分类涉及了词与词之间相互独立的假设，然后延伸出多元文法，而多元文法也广泛应用在概率语言模型中。语言模型是马尔科夫模型的一种，而隐马尔科夫模型在马尔科夫模型的基础之上，提出了两层的结构，解决了我们无法直接观测到转移状态的问题。</p><p>由概率知识派生而来的信息论，也能帮助我们设计机器学习的算法，比如决策树和特征选择。统计中的数据分布可以让特征值转换更合理，而假设检验可以告诉我们哪些结论是更可靠的。</p><p>由于很多监督式学习都是基于概率统计的，所以我使用了一些学习算法来进行讲解。你会发现，概率和统计可以帮助这些算法学习训练样本中的特征，并可以对新的数据进行预测，这就是模型拟合的过程。</p><h2>思考题</h2><p>学习完了概率和统计模块，你觉得自己最大的收获和感触是什么？</p><p>欢迎留言和我分享。你可以把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "32 | 概率统计篇答疑和总结：为什么会有欠拟合和过拟合？",
      },
    ],
  },
  {
    chapterTitle: "线性代数篇 (13讲)",
    children: [
      {
        title: "33 | 线性代数：线性代数到底都讲了些什么？",
        herf: "https://time.geekbang.org/column/article/83948",
        id: "83948",
        content:
          '<p>你好，我是黄申。</p><p>通过第二模块的学习，我想你对概率统计在编程领域，特别是机器学习算法中的应用，已经有了一定理解。概率统计关注的是随机变量及其概率分布，以及如何通过观测数据来推断这些分布。可是，在解决很多问题的时候，我们不仅要关心单个变量之间的关系，还要进一步研究多个变量之间的关系，最典型的例子就是基于多个特征的信息检索和机器学习。</p><p>在信息检索中，我们需要考虑多个关键词特征对最终相关性的影响，而在机器学习中，无论是监督式还是非监督式学习，我们都需要考虑多个特征对模型拟合的影响。在研究多个变量之间关系的时候，线性代数成为了解决这类问题的有力工具。</p><p>另一方面，在我们日常生活和工作中，很多问题都可以线性化，小到计算两个地点之间的距离，大到计算互联网中全部网页的PageRank。所以，为了使用编程来解决相应的问题，我们也必须掌握一些必要的线性代数基础知识。因此，我会从线性代数的基本概念出发，结合信息检索和机器学习领域的知识，详细讲解线性代数的运用。</p><p>关于线性代数，究竟都需要掌握哪些方面的知识呢？我们今天就来看一看，让你对之后一段时间所要学习的知识有个大体的了解。</p><h2>向量和向量空间</h2><p>我们之前所谈到的变量都属于<strong>标量</strong>（Scalar）。它只是一个单独的数字，而且不能表示方向。从计算机数据结构的角度来看，标量就是编程中最基本的变量。这个很好理解，你可以回想一下刚开始学习编程时接触到的标量类型的变量。</p><!-- [[[read_end]]] --><p>和标量对应的概念，就是线性代数中最常用、也最重要的概念，<strong>向量</strong>（Vector），也可以叫作矢量。它代表一组数字，并且这些数字是有序排列的。我们用数据结构的视角来看，向量可以用数组或者链表来表达。</p><p>后面的文章里，我会用加粗的小写字母表示一个向量，例如$x$，而$x_{1}，x_{2}，x_{3}，…，x_{n}$等等，来表示向量中的每个元素，这里面的n就是向量的维。</p><p><img src="https://static001.geekbang.org/resource/image/0e/82/0e03179f68d39d5a26ad18acd4bbda82.png" alt=""></p><p>向量和标量最大的区别在于，向量除了拥有数值的大小，还拥有方向。向量或者矢量中的“向”和“矢”这两个字，都表明它们是有方向的。你可能会问，为什么这一串数字能表示方向呢？</p><p>这是因为，如果我们把某个向量中的元素看作坐标轴上的坐标，那么这个向量就可以看作空间中的一个点。以原点为起点，以向量代表的点为终点，就能形成一条有向直线。而这样的处理其实已经给向量赋予了代数的含义，使得计算的过程中更加直观。在后面讨论向量空间、向量夹角、矩阵特征值等概念的时候，我会进一步展示给你看。</p><p>由于一个向量包含了很多个元素，因此我们自然地就可以把它运用在机器学习的领域。上一个模块，我讲过如何把自然界里物体的属性，转换为能够用数字表达的特征。由于特征有很多维，因此我们可以使用向量来表示某个物体的特征。其中，向量的每个元素就代表一维特征，而元素的值代表了相应特征的值，我们称这类向量为<strong>特征向量</strong>（Feature Vector）。</p><p>需要注意的是，这个特征向量和<strong>矩阵的特征向量</strong>（Eigenvector）是两码事。那么矩阵的特征向量是什么意思呢？矩阵的几何意义是坐标的变换。如果一个矩阵存在特征向量和特征值，那么这个矩阵的特征向量就表示了它在空间中最主要的运动方向。如果你对这几个概念还不太理解，也不用担心，在介绍矩阵的时候，我会详细说说什么是矩阵的特征向量。</p><h2>向量的运算</h2><p>标量和向量之间可以进行运算，比如标量和向量相加或者相乘时，我们直接把标量和向量中的每个元素相加或者相乘就行了，这个很好理解。可是，向量和向量之间的加法或乘法应该如何进行呢？我们需要先定义向量空间。向量空间理论上的定义比较繁琐，不过二维或者三维的坐标空间可以很好地帮助你来理解。这些空间主要有几个特性：</p><ul>\n<li>\n<p>空间由无穷多个的位置点组成；</p>\n</li>\n<li>\n<p>这些点之间存在相对的关系；</p>\n</li>\n<li>\n<p>可以在空间中定义任意两点之间的长度，以及任意两个向量之间的角度；</p>\n</li>\n<li>\n<p>这个空间的点可以进行移动。</p>\n</li>\n</ul><p>有了这些特点，我们就可以定义向量之间的加法、乘法（或点乘）、距离和夹角等等。</p><p>两个向量之间的加法，首先它们需要维度相同，然后是对应的元素相加。</p><p><img src="https://static001.geekbang.org/resource/image/ce/0b/ceff73e9e2f4f8bc3bc8d72e5cc9d80b.png" alt=""></p><p>所以说，向量的加法实际上就是把几何问题转化成了代数问题，然后用代数的方法实现了几何的运算。我下面画了一张图，来解释二维空间里，两个向量的相加，看完你就能理解了。</p><p><img src="https://static001.geekbang.org/resource/image/bf/9e/bf3780041ecb702bd3ae130aa4b4119e.png" alt=""></p><p>在这张图中，有两个向量x和y，它们的长度分别是x’和y’，它们的相加结果是x+y，这个结果所对应的点相当于x向量沿着y向量的方向移动y’，或者是y向量沿着x向量的方向移动x’。</p><p>向量之间的乘法默认是点乘，向量x和y的点乘是这么定义的：</p><p><img src="https://static001.geekbang.org/resource/image/90/b2/907f5f302897d2ca31444d6f2144cdb2.png" alt=""></p><p>点乘的作用是把相乘的两个向量转换成了标量，它有具体的几何含义。我们会用点乘来计算向量的长度以及两个向量间的夹角，所以一般情况下我们会默认向量间的乘法是点乘。至于向量之间的夹角和距离，它们在向量空间模型（Vector Space Model）中发挥了重要的作用。信息检索和机器学习等领域充分利用了向量空间模型，计算不同对象之间的相似程度。在之后的专栏里，我会通过向量空间模型，详细介绍向量点乘，以及向量间夹角和距离的计算。</p><h2>矩阵的运算</h2><p>矩阵由多个长度相等的向量组成，其中的每列或者每行就是一个向量。因此，我们把向量延伸一下就能得到矩阵（Matrix）。</p><p>从数据结构的角度看，向量是一维数组，那矩阵就是一个二维数组。如果二维数组里绝大多数元素都是0或者不存在的值，那么我们就称这个矩阵很稀疏（Sparse）。对于稀疏矩阵，我们可以使用哈希表的链地址法来表示。所以，矩阵中的每个元素有两个索引。</p><p>我用加粗的斜体大写字母表示一个矩阵，例如$X$，而$X_{12}，X_{22}，…，X_{nm}$等等，表示矩阵中的每个元素，而这里面的n和m分别表示矩阵的行维数和列维数。</p><p>我们换个角度来看，向量其实也是一种特殊的矩阵。如果一个矩阵是n × m维，那么一个n × 1的矩阵也可以称作一个n维列向量；而一个1 × m矩阵也称为一个m维行向量。</p><p>同样，我们也可以定义标量和矩阵之间的加法和乘法，我们只需要把标量和矩阵中的每个元素相加或相乘就可以了。剩下的问题就是，矩阵和矩阵之间是如何进行加法和乘法的呢？矩阵加法比较简单，只要保证参与操作的两个矩阵具有相同的行维度和列维度，我们就可以把对应的元素两两相加。而乘法略微繁琐一些，如果写成公式就是这种形式：</p><p><img src="https://static001.geekbang.org/resource/image/64/85/6466b4df93b4dc7bfd7d73ca258f0185.png" alt=""></p><p>其中，矩阵$Z$为矩阵$X$和$Y$的乘积，$X$是形状为i x k的矩阵，而$Y$是形状为k × j的矩阵。$X$的列数k必须和$Y$的行数k相等，两者才可以进行这样的乘法。</p><p>我们可以把这个过程看作矩阵$X$的行向量和矩阵$Y$的列向量两两进行点乘，我这里画了张图，你理解了这张图就不难记住这个公式了。</p><p><img src="https://static001.geekbang.org/resource/image/d7/cf/d718c22f06c9250028867c74e5daedcf.png" alt=""></p><p>两个矩阵中对应元素进行相乘，这种操作也是存在的，我们称它为元素<strong>对应乘积</strong>，或者Hadamard乘积。但是这种乘法咱们用得比较少，所以你只要知道有这个概念就可以了。</p><p>除了加法和乘法，矩阵还有一些其他重要的操作，包括转置、求逆矩阵、求特征值和求奇异值等等。</p><p><strong>转置</strong>（Transposition）是指矩阵内的元素行索引和纵索引互换，例如$X_{ij}$就变为$X_{ji}$，相应的，矩阵的形状由转置前的n × m变为转置后的m × n。从几何的角度来说，矩阵的转置就是原矩阵以对角线为轴进行翻转后的结果。下面这张图展示了矩阵$X$转置之后的矩阵$X’$：</p><p><img src="https://static001.geekbang.org/resource/image/a0/c1/a024d2504f9a6351b5b815ff251a7bc1.png" alt=""></p><p>除了转置矩阵，另一个重要的概念是逆矩阵。为了理解逆矩阵或矩阵逆（Matrix Inversion），我们首先要理解单位矩阵（Identity Matrix）。单位矩阵中，所有沿主对角线的元素都是1，而其他位置的所有元素都是0。通常我们只考虑单位矩阵为方阵的情况，也就是行数和列数相等，我们把它记做$I_{n}$，$n$表示维数。我这里给出一个$I_{5}$的示例。</p><p><img src="https://static001.geekbang.org/resource/image/56/00/56451a7a823444abc5791f4bc7ea6800.png" alt=""></p><p>如果有矩阵$X$，我们把它的逆矩阵记做$X^{-1}$，两者相乘的结果是单位矩阵，写成公式就是这种形式：</p><p><img src="https://static001.geekbang.org/resource/image/51/65/51adb30f4c592f3a10f2490f75913f65.png" alt=""></p><p>特征值和奇异值的概念以及求解比较复杂了，从大体上来理解，它们可以帮助我们找到矩阵最主要的特点。通过这些操作，我们就可以在机器学习算法中降低特征向量的维度，达到特征选择和变换的目的。我会在后面的专栏，结合案例给你详细讲解。</p><h2>总结</h2><p>相对于概率统计，线性代数中的基本概念和知识点可能没有那么多。但是对于刚入门的初学者，这些内容理解起来会比较费力。在这一节里，我进行了大致的梳理，帮助你学习。</p><p>标量和向量的区别，标量只是单独的一个数，而向量是一组数。矩阵是向量的扩展，就是一个二维数组。我们可以使用哈希表的链地址法表示稀疏矩阵。</p><p>标量和向量或矩阵的加法、乘法比较简单，就是把这个标量和向量或矩阵中所有的元素轮流进行相加或相乘。向量之间的加法和矩阵之间的加法，是把两者对应的元素相加。向量之间的相乘分为叉乘和点乘，我在专栏里默认向量乘法为点乘。而矩阵的乘法默认为左矩阵的行向量和右矩阵的列向量两两点乘。</p><p>说到这里，你可能还是不太理解线性代数对于编程有什么用处。在这个模块之后的内容中，我会详细介绍向量空间模型、线性方程组、矩阵求特征值和奇异值分解等，在信息检索和机器学习领域中，有怎样的应用场景。</p><h2>思考题</h2><p>之前你对线性代数的认识是什么样的呢？对这块内容，你觉得最难的是什么？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "33 | 线性代数：线性代数到底都讲了些什么？",
      },
      {
        title: "34 | 向量空间模型：如何让计算机理解现实事物之间的关系？",
        herf: "https://time.geekbang.org/column/article/84292",
        id: "84292",
        content:
          '<p>你好，我是黄申。</p><p>之前我们讲过如何让计算机理解现实世界中的事物，方法是把事物的各种特性转为机器所能理解的数据字段。而这些数据字段，在机器学习里通常被称为特征。有了特征，我们不仅可以刻画事物本身，还能刻画不同事物之间的关系。</p><p>上一个模块我们只是了解了监督式学习，重点考察了特征和分类标签之间的关系。但是在信息检索和非监督式学习中，我们更关注的是不同事物之间的相似程度。这就需要用到线性代数中的向量空间模型了。</p><p>提到向量空间模型，你可能对其中的概念有点陌生，所以我会从向量空间的基本概念开始说起，讲到向量空间模型的相关知识，最后再讲讲它是如何应用在不同的编程中的。</p><h2>什么是向量空间？</h2><p>上一节，我讲到了向量和向量空间的一些基本概念。为了帮助你更好地理解向量空间模型，我这里给出向量和向量空间的严格定义。</p><p>首先假设有一个数的集合$F$，它满足“$F$中任意两个数的加减乘除法（除数不为零）的结果仍然在这个$F$中”，我们就可以称$F$为一个“域”。我们处理的数据通常都是实数，所以这里我只考虑实数域。而如果域$F$里的元素都为实数，那么$F$就是实数域。</p><!-- [[[read_end]]] --><p>如果$x_{1}，x_{2}，……，x_{n}∈F$，那么$F$上的$n$维向量就是：</p><p><img src="https://static001.geekbang.org/resource/image/d9/8b/d93900b041abe4a77690635691662e8b.png" alt=""></p><p>或者写成转置的形式：</p><p><img src="https://static001.geekbang.org/resource/image/96/db/961ed40b59d1c2664d688a9b10ab96db.png" alt=""></p><p>向量中第$i$个元素，也称为第$i$个分量。$F_{n}$是由$F$上所有$n$维向量构成的集合。</p><p>我们已经介绍过向量之间的加法，以及标量和向量的乘法。这里我们使用这两个操作来定义向量空间。</p><p>假设$V$是$F_{n}$的非零子集，如果对任意的向量$x$、向量$y∈V$，都有$(x+y)∈V$，我们称为$V$对向量的加法封闭；对任意的标量$k∈V$，向量$x∈V$，都有$kx$属于$V$，我们称$V$对标量与向量的乘法封闭。</p><p>如果$V$满足向量的加法和乘法封闭性，我们就称$V$是$F$上的向量空间。向量空间除了满足这两个封闭性，还满足基本运算法则，比如交换律、结合律、分配律等等。这里介绍的定义和法则有点多，不过你可以不用都死记硬背下来。只要用的时候，知道有这些东西就可以了。</p><h2>向量空间的几个重要概念</h2><p>有了刚才的铺垫，接下来我们来看几个重要的概念：向量的长度、向量之间的距离和夹角。</p><h3>向量之间的距离</h3><p>有了向量空间，我们就可以定义向量之间的各种距离。我们之前说过，可以把一个向量想象为n维空间中的一个点。而向量空间中两个向量的距离，就是这两个向量所对应的点之间的距离。距离通常都是大于0的，这里我介绍几种常用的距离，包括曼哈顿距离、欧氏距离、切比雪夫距离和闵可夫斯基距离。</p><ul>\n<li><strong>曼哈顿距离</strong>（Manhattan Distance）</li>\n</ul><p>这个距离度量的名字由来非常有趣。你可以想象一下，在美国人口稠密的曼哈顿地区，从一个十字路口开车到另外一个十字路口，驾驶距离是多少呢？当然不是两点之间的直线距离，因为你无法穿越挡在其中的高楼大厦。你只能驾车绕过这些建筑物，实际的驾驶距离就叫作曼哈顿距离。由于这些建筑物的排列都是规整划一的，形成了一个个的街区，所以我们也可以形象地称把它为“城市街区”距离。我这里画了张图方便你理解这种距离。</p><p><img src="https://static001.geekbang.org/resource/image/3c/f2/3c07f6da33999ebc41e53be90ba35af2.png" alt=""></p><p>从图中可以看出，从A点到B点有多条路径，但是无论哪条，曼哈顿距离都是一样的。</p><p>在二维空间中，两个点（实际上就是二维向量）$x(x_{1},x_{2})$与$y(y_{1},y_{2})$间的曼哈顿距离是：</p><p><img src="https://static001.geekbang.org/resource/image/9b/c0/9bb6b5eb558d5582456d19be80b300c0.png" alt=""></p><p>推广到$n$维空间，曼哈顿距离的计算公式为：</p><p><img src="https://static001.geekbang.org/resource/image/f8/e9/f81a89126f0a8adb7bb578fef17409e9.png" alt=""></p><p>其中$n$表示向量维度，$x_{i}$表示第一个向量的第$i$维元素的值，$y_{i}$表示第二个向量的第$i$维元素的值。</p><ul>\n<li><strong>欧氏距离</strong>（Euclidean Distance）</li>\n</ul><p>欧氏距离，其实就是欧几里得距离。欧氏距离是一个常用的距离定义，指在n维空间中两个点之间的真实距离，在二维空间中，两个点$x(x_{1},x_{2})$与$y(y_{1},y_{2})$间的欧氏距离是：</p><p><img src="https://static001.geekbang.org/resource/image/51/29/5182e68ae521212464a0c8a1dd26d829.png" alt=""></p><p>推广到n维空间，欧氏距离的计算公式为：</p><p><img src="https://static001.geekbang.org/resource/image/3b/2b/3b4b64fec423d02bb6b511ee37c4412b.png" alt=""></p><ul>\n<li><strong>切比雪夫距离</strong>（Chebyshev Distance）</li>\n</ul><p>切比雪夫其实是在模拟国际象棋里国王的走法。国王可以走临近8个格子里的任何一个，那么国王从格子$(x_{1},x_{2})$走到格子$(y_{1},y_{2})$最少需要多少步呢？其实就是二维空间里的切比雪夫距离。</p><p>一开始，为了走尽量少的步数，国王走的一定是斜线，所以横轴和纵轴方向都会减1，直到国王的位置和目标位置在某个轴上没有差距，这个时候就改为沿另一个轴每次减1。所以，国王走的最少格子数是$|x_{1}-y_{1}|$和$|x_{2}-y_{2}|$这两者的较大者。所以，在二维空间中，两个点$x(x_{1},x_{2})$与$y(y_{1},y_{2})$间的切比雪夫距离是：</p><p><img src="https://static001.geekbang.org/resource/image/19/85/196f8f04a75ad0c48f0f425a6e13aa85.png" alt=""></p><p></p><p>推广到n维空间，切比雪夫距离的计算公式为：</p><p><img src="https://static001.geekbang.org/resource/image/ba/f6/ba2ddcb9a07dfe8bff595abf1fa68bf6.png" alt=""></p><p>上述三种距离，都可以用一种通用的形式表示，那就是闵可夫斯基距离，也叫闵氏距离。在二维空间中，两个点$x(x_{1},x_{2})$与$y(y_{1},y_{2})$间的闵氏距离是：</p><p><img src="https://static001.geekbang.org/resource/image/0f/db/0fdcaa63c585cb2b530f03e69dcab1db.png" alt=""></p><p>两个$n$维变量$x(x_{1},x_{2},…,x_{n})$与$y(y_{1},y_{2},…,y_{n})$间的闵氏距离的定义为：</p><p><img src="https://static001.geekbang.org/resource/image/6f/8f/6f201ca2a097b7763ae4bfbf545e9c8f.png" alt=""></p><p>其中$p$是一个变参数，尝试不同的p取值，你就会发现：</p><ul>\n<li>\n<p>当$p=1$时，就是曼哈顿距离；</p>\n</li>\n<li>\n<p>当$p=2$时，就是欧氏距离；</p>\n</li>\n<li>\n<p>当$p$趋近于无穷大的时候，就是切比雪夫距离。这是因为当$p$趋近于无穷大的时候，最大的$|x_{i}-y_{i}|$会占到全部的权重。</p>\n</li>\n</ul><p>距离可以描述不同向量在向量空间中的差异，所以可以用于描述向量所代表的事物之差异（或相似）程度。</p><h3>向量的长度</h3><p>有了向量距离的定义，向量的长度就很容易理解了。向量的长度，也叫向量的模，是向量所对应的点到空间原点的距离。通常我们使用欧氏距离来表示向量的长度。</p><p>当然，我们也可以使用其他类型的距离。说到这里，我也提一下“范数”的概念。范数满足非负性、齐次性、和三角不等式。你可以不用深究这三点的含义，不过你需要知道范数常常被用来衡量某个向量空间中向量的大小或者长度。</p><p>$L_{1}$范数$||x||$ ，它是为$x$向量各个元素绝对值之和，对应于向量$x$和原点之间的曼哈顿距离。</p><p>$L_{2}$范数$||x||_{2}$ ，它是$x$向量各个元素平方和的$\\frac{1}{2}$次方，对应于向量$x$和原点之间的欧氏距离。</p><p>$L_{p}$范数$||x||_{p}$ ，为$x$向量各个元素绝对值$p$次方和的1/p次方，对应于向量$x$和原点之间的闵氏距离。</p><p>$L_{∞}$范数$||x||_{∞}$ ，为$x$向量各个元素绝对值最大那个元素的绝对值，对应于向量$x$和原点之间的切比雪夫距离。</p><p>所以，在讨论向量的长度时，我们需要弄清楚是L几范数。</p><h3>向量之间的夹角</h3><p>在理解了向量间的距离和向量的长度之后，我们就可以引出向量夹角的余弦，它计算了空间中两个向量所形成夹角的余弦值，具体的计算公式我列在了下面：</p><p><img src="https://static001.geekbang.org/resource/image/47/58/47a3eb754bc98caab86dc554b4cf7558.png" alt=""></p><p>从公式可以看出，分子是两个向量的点乘，而分母是两者长度（或L2范数）的乘积，而L2范数可以使用向量点乘自身的转置来实现。夹角余弦的取值范围在[-1,1]，当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。值越大，说明夹角越小，两点相距就越近；值越小，说明夹角越大，两点相距就越远。</p><h2>向量空间模型</h2><p>理解了向量间距离和夹角余弦这两个概念，你再来看<strong>向量空间模型</strong>（Vector Space Model）就不难了。</p><p>向量空间模型假设所有的对象都可以转化为向量，然后使用向量间的距离（通常是欧氏距离）或者是向量间的夹角余弦来表示两个对象之间的相似程度。我使用下图来展示空间中向量之间的距离和夹角。</p><p><img src="https://static001.geekbang.org/resource/image/2b/ec/2b2fb28b3bfb8fc43831469f537068ec.png" alt=""></p><p>由于夹角余弦的取值范围已经在-1到1之间，而且越大表示越相似，所以可以直接作为相似度的取值。相对于夹角余弦，欧氏距离ED的取值范围可能很大，而且和相似度呈现反比关系，所以通常要进行1/(ED+1)这种归一化。</p><p>当ED为0的时候，变化后的值就是1，表示相似度为1，完全相同。当ED趋向于无穷大的时候，变化后的值就是0，表示相似度为0，完全不同。所以，这个变化后的值，取值范围是0到1之间，而且和相似度呈现正比关系。</p><p>早在上世纪的70年代，人们把向量空间模型运用于信息检索领域。由于向量空间可以很形象地表示数据点之间的相似程度，因此现在我们也常常把这个模型运用在基于相似度的一些机器学习算法中，例如K近邻（KNN）分类、K均值（K-Means)聚类等等。</p><h2>总结</h2><p>为了让计算机理解现实世界中的事物，我们会把事物的特点转换成为数据，并使用多维度的特征来表示某个具体的对象。多个维度的特征很容易构成向量，因此我们就可以充分利用向量和向量空间，来刻画事物以及它们之间的关系。</p><p>我们可以在向量空间中定义多种类型的向量长度和向量间距离，用于衡量向量之间的差异或者说相似程度。此外，夹角余弦也是常用的相似度衡量指标。和距离相比，夹角余弦的取值已经控制在[-1, 1]的范围内，不会因为异常点所产生的过大距离而受到干扰。</p><p>向量空间模型充分利用了空间中向量的距离和夹角特性，来描述文档和查询之间的相似程度，或者说相关性。虽然向量空间模型来自信息检索领域，但是也被用广泛运用在机器学习领域中。在接下来的文章里，我会结合具体的案例，分别来说说如何在这些领域使用向量空间模型。</p><h2>思考题</h2><p>假设在三维空间中有两个点，它们的坐标分别是(3, -1, 8)和(-2, 3, -6)，请计算这两个点之间的欧氏距离和夹角余弦。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title:
          "34 | 向量空间模型：如何让计算机理解现实事物之间的关系？",
      },
      {
        title: "35 | 文本检索：如何让计算机处理自然语言？",
        herf: "https://time.geekbang.org/column/article/84575",
        id: "84575",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我详细解释了向量空间和向量空间模型。你也许觉得理论上的内容还是过于抽象，不太好理解。别急，今天我就来具体演示一下如何使用这个模型。由于学者们最初是在信息检索领域使用这个模型的，所以我会结合文本信息检索领域的知识，阐述如何在这个领域使用向量空间模型。</p><h2>什么是信息检索？</h2><p>首先，我们先来看一下，什么是信息检索，以及最基本的排序模型有哪些。这样，你就能理解为什么我们需要使用向量空间模型了。</p><p>现在的信息检索技术已经相当成熟，并影响我们日常生活的方方面面。搜索引擎就是这项技术的最佳体现，人们输入一个查询，然后系统就能返回相关的信息。</p><p>笼统地说，<strong>信息检索就是让计算机根据用户信息需求，从大规模、非结构化的数据中，找出相关的资料。</strong>这里的“非结构化”其实是针对经典的关系型数据库（Relation Database）而言的，比如DB2、Oracle DB、MySQL等等。</p><p>数据库里的记录都有严格的字段定义（Schema），是“结构化”数据的典型代表。相反，“非结构化”没有这种严格的定义，互联网世界里所存储的海量文本就是“非结构化“数据的典型代表。因为这些文章如果没有经过我们的分析，对于其描述的主题、写作日期、作者等信息，我们是一无所知的。自然，我们也就无法将其中的内容和已经定义好的数据库字段进行匹配，所以这也是数据库在处理非结构化数据时非常乏力的原因。这时候就需要采用信息检索的技术来帮助我们。</p><!-- [[[read_end]]] --><p>在信息检索中，相关性是个永恒的话题。“这篇文章是否和体育相关？”当被问及这个问题，我们要大致看一下文章的内容，才能做出正确的判断。可是，迄今为止，计算机尚无法真正懂得人类的语言，它们该如何判定呢？好在科学家们设计了很多模型，帮助计算机处理基于文本的相关性。</p><p>最简单的模型是布尔模型，它借助了逻辑（布尔）代数的基本思想。如果我想看一篇文章是否关于体育，最简单的方法莫过于看看其中是否提到和体育相关的关键词，比如“足球”“NBA”“奥运会”等等。如果有，就相当于返回值为“真”，我就认为这篇文章就是相关的。如果没有，就相当于返回值为“假”，我就认为这篇文章不相关。这就是布尔模型的核心思想。</p><p>这里我列出了要求全部关键词都出现的查询条件。</p><p><img src="https://static001.geekbang.org/resource/image/81/3d/8105ba571514b27e93b500462090603d.png" alt=""></p><p>当然，我们可以根据具体的需求，在查询条件中加入“OR”，允许进行部分关键词的匹配。</p><p>和布尔模型相比，向量空间模型更为复杂，也更为合理。如我之前介绍的，此模型的重点是将文档转换为向量，然后比较向量之间的距离或者相似程度。在转换的时候，我们通常会使用词包（Bag Of Word）的方式，忽略了单词在文章中出现的顺序，简化计算复杂度。类似地，这个模型也会把用户输入的查询转换为向量。如此一来，相关性问题就转化为计算查询向量和文档向量之间的距离或者相似度了。距离越小或者说相似度越高，那么我们就认为相关度越高。</p><p>相对于标准的布尔数学模型，向量空间模型的主要优势在于，允许文档和查询之间的部分匹配</p><p>连续的相似程度、以及基于这些的的排序。结果不再局限于布尔模型的“真”“假”值。此外，单词或词组的权重可以不再是二元的，而是可以使用例如<a href="https://zh.wikipedia.org/wiki/Tf-idf">tf-idf</a>（term frequency–inverse document frequency）的机制。</p><p>上面我简要地说明了为什么在信息检索领域，向量空间模型相比布尔模型更具优势。接下来，我来详细讲解如何在一个文档集合上，使用向量空间模型，查找和给定查询相关的文档。</p><h2>信息检索中的向量空间模型</h2><p>整个方法从大体上来说，可以分为四个主要步骤。</p><p>第一步，把文档集合都转换成向量的形式。</p><p>第二步，把用户输入的查询转换成向量的形式，然后把这个查询的向量和所有文档的向量，进行比对，计算出基于距离或者夹角余弦的相似度。</p><p>第三步，根据查询和每个文档的相似度，找出相似度最高的文档，认为它们是和指定查询最相关的。</p><p>第四步，评估查询结果的相关性。</p><p>这一节，我主要侧重讲解和向量空间模型最相关的前两步。</p><h3>把文档转为特征向量</h3><p>任何向量都有两个主要的构成要素：维度和取值。这里的维度表示向量有多少维分量、每个分量的含义是什么，而取值表示每个分量的数值是多少。而原始的文本和向量差别很大，我们需要经过若干预处理的步骤。</p><p>我们首先来看看如何为文本创建向量的维度。简单地说，我们要把文章中唯一的单词或者词组，作为向量的一个维度。</p><p>在概率统计的模块中，我说过如何基于词包（Bag of Word）的方式来预处理文本，包括针对中文等语系的分词操作、针对英文等拉丁语系的词干（Stemming）和归一化（Normalization）处理，以及所有语言都会碰到的停用词（Stopword）、同义词和扩展词处理。完成了前面这些预处理，我们就可以获得每篇文档出现的单词和词组。而通过对所有文档中的单词和词组进行去重，我们就可以构建整个文档集合的词典（Vocabulary）。向量空间模型把词典中的每个词条作为向量的一个维度。</p><p>有了向量的维度，我们再来考虑每个维度需要取什么值。最简单的方法是用“1”表示这个词条出现在文档中，“0”表示没有出现。不过这种方法没有考虑每个词的权重。有些词经常出现，它更能表达文章的主要思想，对于计算机的分析能起到更大的作用。对于这点，有两种常见的改进方法，分别是使用词频和词频x逆文档频率来实现的。</p><p>我们先来看基于词频的方法。假设我们有一个文档集合c，d表示c中的一个文档，t表示一个单词，那么我们使用tf表示词频（Term Frequency），也就是一个词t在文档d中出现的次数。这种方法的假设是，如果某个词在文档中的tf越高，那么这个词对于这个文档来说就越重要。</p><p>另一种改进方法，不仅考虑了tf，还考虑了idf。这里idf表示逆文档频率（Inverse Document Frequency）。</p><p>首先，df表示文档频率（Document Frequency），也就是文档集合c中出现某个词t的文档数量。一般的假设是，某个词t在文档集合c中，出现在越多的文档中，那么其重要性越低，反之则越高。刚开始可能感觉有点困惑，但是仔细想想不难理解。</p><p>在讨论体育的文档集合中，“体育”一词可能会出现在上万篇文章中，它的出现并不能使得某篇文档变得和“体育”这个主题更相关。相反，如果只有3篇文章讨论到中国足球，那么这3篇文章和中国足球的相关性就远远高于其他文章。“中国足球”这个词组在文档集合中就应该拥有更高的权重，用户检索“中国足球”时，这3篇文档应该排在更前面。所以，我们通常用df的反比例指标idf来表示这种重要程度，基本公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/3e/58/3e72f94ec09ad6f73f0428141811d658.png" alt=""></p><p>其中N是整个文档集合中文章数量，log是为了确保idf分值不要远远高于tf而埋没tf的贡献。这样一来，单词t的df越低，其idf越高，t的重要性越高。那么综合起来，tf-idf的基本公式表示如下：</p><p><img src="https://static001.geekbang.org/resource/image/86/78/86a0881bc6518898640bb368f78be878.png" alt=""></p><p>一旦完成了从原始文档到向量的转换，我们就可以接受用户的查询（Query）。</p><h3>查询和文档的匹配</h3><p>在计算查询和文档的相似度之前，我们还需要把查询转换成向量。由于用户的查询也是由自然语言组成，所以这个转换的流程和文档的转换流程是基本一致的。不过，查询也有它的特殊性，因此需要注意下面几个问题。</p><p>第一，查询和文档长度不一致。人们输入的查询通常都很短，甚至都不是一个句子，而只是几个关键词。这种情况下，你可能会觉得两个向量的维度不同，无法计算它们之间的距离或夹角余弦。对于这种情况，我们可以使用文档字典中所有的词条来构建向量。如果某维分量所对应的词条出现在文档或者查询中，就取1、tf或tf-idf值，如果没有就取0。这样，文档向量和查询向量的维度就相同了，只是查询向量更稀疏、拥有多维度的0。</p><p>第二，查询里出现了文档集合里没有的词。简单的做法是直接去除这维分量，也可以使用相对于其他维度来说极小的一个数值，这和分类中的平滑技术类似。</p><p>第三，查询里词条的idf该如何计算。如果我们使用tf-idf机制来计算向量中每个维度的取值，那么就要考虑这个问题。由于查询本身并不存在文档集合的概念，所以也就不存在df和idf。对于这种情况，我们可以借用文档集合里对应词条的idf。</p><p>把查询转换成向量之后，我们就可以把这个查询的向量和所有文档的向量依次对比，看看查询和哪些文档更相似。我们可以结合上一节所说的，计算向量之间的距离或者夹角余弦。由于夹角余弦不用进行归一化，所以这种方法更为流行。需要注意的是，信息检索里，夹角余弦的取值范围通常是[0,1]，而不再是[-1,1]。这是因为在进行文本处理的时候，我们根据单词的出现与否，设置0、1/tf/tf-idf，因此向量每个分量的取值都是正的。</p><p>在概率统计模块中，我介绍过特征选择和特征值的转换。由于文本向量往往是非常稀疏的，我们也可能需要对转换后的文档和查询向量，进行这两项操作。</p><h3>排序和评估</h3><p>完成了前两步，后面的排序和评估就很直观了。我们按照和输入查询的相似程度，对所有文档进行相似度由高到低的排序，然后取出前面的若干个文档，作为相关的信息返回。当然，这里你需要注意，这里所说的“相关性”是从向量空间模型的角度出发，不代表所返回的信息一定满足用户的需求。因此，我们还需要设计各种离线或者在线的评估，来衡量向量空间模型的效果。由于这些内容不是线性代数的关注点，我就不展开了。如果你有兴趣，可以自己去研究一下。</p><h2>总结</h2><p>今天我从文本的信息检索出发，介绍如何使用向量空间模型。在使用这个模型之前，很重要的处理步骤，就是要把原始数据转换成向量。这里所说的数据类型是文本，所以我们要进行分词等操作，然后构建文档的字典，并使用字典的词条来构建向量。如果是其他类型的数据，我们则需要提取相应的特征，并利用这些特征来构建向量。</p><p>如果我们把查询也转换成向量，那么就可以计算查询向量和文档向量之间的相似度。通过这种相似度，我们就能对所有的文档进行排序，找出向量空间模型认为“最相关”的文章。</p><p>不过，我今天介绍的计算相似度并排序的过程，只是最基本的实现，而这种实现并没有考虑效率的问题。我们这里可以简单分析一下时间复杂度。</p><p>假设查询的平均长度（或词条数量）远远小于文档的平均长度，我们把查询的平均长度记做m，那么对于每次计算查询向量和文档向量的相似度，时间复杂度都是O(m)。假设文档集中文档的数量平均是n，那么根据时间复杂度的四则运算法则，把查询和所有文档比较的时间复杂度是O(m*n)。</p><p>其实，在第17讲我曾经提到过了倒排索引的案例，我们可以把倒排索引和向量空间模型相结合。倒排索引可以快速找到包含查询词的候选文档，这样就避免了不必要的向量计算。更多具体的内容，我会在之后的实战模块为你详细讲解。</p><h2>思考题</h2><p>假设你使用了tf-idf的机制来构造向量，那么当文档集合中新增了文档之后，你是不是只需要为新增文档构建向量？原有文档的向量是否需要更新？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "35 | 文本检索：如何让计算机处理自然语言？",
      },
      {
        title: "36 | 文本聚类：如何过滤冗余的新闻？",
        herf: "https://time.geekbang.org/column/article/84949",
        id: "84949",
        content:
          "<p>你好，我是黄申。</p><p>前两节，我讲了向量空间模型，以及如何在信息检索领域中运用向量空间模型。向量空间模型提供了衡量向量之间的距离或者相似度的机制，而这种机制可以衡量查询和被查询数据之间的相似程度，而对于文本检索来说，查询和文档之间的相似程度可作为文档的相关性。</p><p>实际上，除了文档的相关性，距离或者相似度还可以用在机器学习的算法中。今天，我们就来聊聊如何在聚类算法中使用向量空间模型，并最终实现过滤重复文章。</p><h2>聚类算法</h2><p>在概率统计模块中，我们介绍了分类（Classification/Categorization）和回归（Regression）这两种监督式学习（Supervised Learning）。监督式学习通过训练资料学习并建立一个模型，并依此模型对新的实例进行预测。</p><p>不过，在实际场景中，我们常常会遇到另一种更为复杂的情况。这时候不存在任何关于样本的先验知识，而是需要机器在没人指导的情形下，去将很多东西进行归类。由于缺乏训练样本，这种学习被称为“非监督学习”（Unsupervised Learning），也就是我们通常所说的聚类（Clustering）。在这种学习体系中，系统必须通过一种有效的方法发现样本的内在相似性，并把数据对象以群组（Cluster）的形式进行划分。</p><!-- [[[read_end]]] --><p>谈到相似性，你可能已经想到了利用特征向量和向量空间模型，这确实是可行的方法。不过，为了让你全面了解在整个非监督式学习中，如何运用向量空间，让我先从一个具体的聚类算法开始。</p><p>这个算法的名称是K均值（K-Means）聚类算法，它让我们可以在一个任意多的数据上，得到一个事先定好群组数量（K）的聚类结果。这种算法的中心思想是：尽量最大化总的群组内相似度，同时尽量最小化群组之间的相似度。群组内或群组间的相似度，是通过各个成员和群组质心相比较来确定的。想法很简单，但是在样本数量达到一定规模后，希望通过排列组合所有的群组划分，来找到最大总群组内的相似度几乎是不可能的。于是人们提出如下的求近似解的方法。</p><ol>\n<li>\n<p>从N个数据对象中随机选取k个对象作为质心，这里每个群组的质心定义是，群组内所有成员对象的平均值。因为是第一轮，所以第i个群组的质心就是第i个对象，而且这时候我们只有这一个组员。</p>\n</li>\n<li>\n<p>对剩余的对象，测量它和每个质心的相似度，并把它归到最近的质心所属的群组。这里我们可以说距离，也可以说相似度，只是两者呈现反比关系。</p>\n</li>\n<li>\n<p>重新计算已经得到的各个群组的质心。这里质心的计算是关键，如果使用特征向量来表示的数据对象，那么最基本的方法是取群组内成员的特征向量，将它们的平均值作为质心的向量表示。</p>\n</li>\n<li>\n<p>迭代上面的第2步和第3步，直至新的质心与原质心相等或相差之值小于指定阈值，算法结束。</p>\n</li>\n</ol><p>我以二维空间为例子，画张图来展示一下数据对象聚类的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/0e/5642c36e8780997ee36ed53380ae880e.png\" alt=\"\"></p><p>在这张图中，( a )、( b )、( c )三步分别展示了质心和群组逐步调整的过称。我们一一来看。(a)步骤是选择初始质心，质心用不同颜色的x表示；( b )步骤开始进行聚类，把点分配到最近的质心所在的组；( c )步骤重新计算每个群组的质心，你会发现x的位置发生了改变。之后就是如此重复，进入下一轮聚类。</p><p>总的来说，K均值算法是通过不断迭代、调整K个聚类质心的算法。而质心或者群组的中心点，是通过求群组所包含的成员之平均值来计算的。</p><h2>使用向量空间进行聚类</h2><p>明白了K均值聚类算法的核心思想，再来理解向量空间模型在其中的运用就不难了。我还是以文本聚类为例，讲讲如何使用向量空间模型和聚类算法，去除重复的新闻。</p><p>我们在看新闻的时候，一般都希望不断看到新的内容。可是，由于现在的报道渠道非常丰富，经常会出现热点新闻霸占版面的情况。假如我们不想总是看到重复的新闻，应该怎么办呢？有一种做法就是对新闻进行聚类，那么内容非常类似的文章就会被聚到同一个分组，然后对每个分组我们只选择1到2篇显示就够了。</p><p>基本思路确定后，我们可以把整个方法分为三个主要步骤。</p><p>第一步，把文档集合都转换成向量的形式。这块我上一节讲过了，你要是不记得了，可以自己回去复习一下。</p><p>第二步，使用K均值算法对文档集合进行聚类。这个算法的关键是如何确定数据对象和分组质心之间的相似度。针对这点，我们有两个点需要关注。</p><ul>\n<li>\n<p>使用向量空间中的距离或者夹角余弦度量，计算两个向量的相似度。</p>\n</li>\n<li>\n<p>计算质心的向量。K均值里，质心是分组里成员的平均值。所以，我们需要求分组里所有文档向量的平均值。求法非常直观，就是分别为每维分量求平均值，我把具体的计算公式列在这里：</p>\n</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/7f/43/7f47f218d42e6d33b4af132c6d536543.png\" alt=\"\"></p><p>其中，$x_{i}$表示向量的第i个分量，$x_{ij}$表示第j格向量的第$i$个分量，而$j=1,2,…,n$表示属于某个分组的所有向量。</p><p>第三步，在每个分类中，选出和质心最接近的几篇文章作为代表。而其他的文章作为冗余的内容过滤掉。</p><p>下面，我使用Python里的sklearn库，来展示使用欧氏距离的K均值算法。</p><h2>Python中的K均值算法</h2><p>在尝试下面的代码之前，你需要看看自己的机器上是不是已经安装了scikit-learn。Scikit-learn是Python常用的机器学习库，它提供了大量的机器学习算法的实现和相关的文档，甚至还内置了一些公开数据集，是我们实践机器学习算法的好帮手。</p><p>首先，我使用sklearn库中的CountVectorizer，对一个测试的文档集合构建特征，也就是词典。这个测试集合有7句话，2句关于篮球，2句关于电影，还有3句关于游戏。具体代码如下：</p><pre><code>from sklearn.feature_extraction.text import CountVectorizer\n\n#模拟文档集合\ncorpus = ['I like great basketball game',\n          'This video game is the best action game I have ever played',\n          'I really really like basketball',\n          'How about this movie? Is the plot great?',\n          'Do you like RPG game?',\n          'You can try this FPS game',\n          'The movie is really great, so great! I enjoy the plot']\n\n#把文本中的词语转换为词典和相应的向量\nvectorizer = CountVectorizer()\nvectors = vectorizer.fit_transform(corpus)\n\n#输出所有的词条（所有维度的特征）\nprint('所有的词条（所有维度的特征）')\nprint(vectorizer.get_feature_names())\nprint('\\n')\n\n#输出(文章ID, 词条ID) 词频\nprint('(文章ID, 词条ID) 词频')\nprint(vectors)\nprint('\\n')\n</code></pre><p>从运行的结果中，你可以看到，整个词典里包含了哪些词，以及每个词在每个文档里的词频。</p><p>这里，我们希望使用比词频tf更好的tf-idf机制，TfidfTransformer可以帮助我们做到这点，代码和注释如下：</p><pre><code>from sklearn.feature_extraction.text import TfidfTransformer\n\n#构建tfidf的值\ntransformer = TfidfTransformer()\ntfidf = transformer.fit_transform(vectorizer.fit_transform(corpus))\n\n# 输出每个文档的向量\ntfidf_array = tfidf.toarray()\nwords = vectorizer.get_feature_names()\n\nfor i in range(len(tfidf_array)):\n    print (&quot;*********第&quot;, i + 1, &quot;个文档中，所有词语的tf-idf*********&quot;)\n    # 输出向量中每个维度的取值\n    for j in range(len(words)):\n        print(words[j], ' ', tfidf_array[i][j])\n    print('\\n')\n</code></pre><p>运行的结果展示了每个文档中，每个词的tfidf权重，你可以自己手动验算一下。</p><p>最后，我们就可以进行K均值聚类了。由于有篮球、电影和游戏3个类别，我选择的K是3，并在KMeans的构造函数中设置n_clusters为3。</p><pre><code>from sklearn.cluster import KMeans\n\n#进行聚类，在我这个版本里默认使用的是欧氏距离\nclusters = KMeans(n_clusters=3)\ns = clusters.fit(tfidf_array)\n\n#输出所有质心点，可以看到质心点的向量是组内成员向量的平均值\nprint('所有质心点的向量')\nprint(clusters.cluster_centers_)\nprint('\\n')\n\n#输出每个文档所属的分组\nprint('每个文档所属的分组')\nprint(clusters.labels_)\n\n#输出每个分组内的文档\ndict = {}\nfor i in range(len(clusters.labels_)):\n    label = clusters.labels_[i]\n    if label not in dict.keys():\n        dict[label] = []\n        dict[label].append(corpus[i])\n    else:\n        dict[label].append(corpus[i])\nprint(dict)\n</code></pre><p>为了帮助你的理解，我输出了每个群组的质心，也就是其中成员向量的平均值。最后，我也输出了3个群组中所包含的句子。在我机器上的运行结果显示，系统可以把属于3个话题的句子区分开来。如下所示：</p><pre><code>{2: ['I like great basketball game', 'I really really like basketball'], 0: ['This video game is the best action game I have ever played', 'Do you like RPG game?', 'You can try this FPS game'], 1: ['How about this movie? Is the plot great?', 'The movie is really great, so great! I enjoy the plot']}\n</code></pre><p>不过，由于KMeans具体的实现可能不一样，而且初始质心的选择也有一定随机性，所以你看到的结果可能稍有不同。</p><h2>总结</h2><p>这一节，我介绍了如何在机器学习的聚类算法中，使用向量空间模型。在聚类中，数据对象之间的相似度时很关键的。如果我们把样本转换为向量，然后使用向量空间中的距离或者夹角余弦，就很自然的能获得这种相似度，所以向量空间模型和聚类算法可以很容易的结合在一起。</p><p>为了给你加深印象，我介绍了一个具体的K均值算法，以及向量空间模型在其中所起到的作用，并通过Python的sklearn代码演示了几个关键的步骤。</p><p>向量空间模型和K均值算法的结合，虽然简单易懂，但是一开始怎样选择这个群组的数量，是个关键问题。我今天演示的测试数据很小，而且主题划分的也非常明显。所以我选择聚类的数量为3。</p><p>可是在实际项目中，对于一个新的数据集合，选择多少比较合适呢？如果这个K值取得太大，群组可能切分太细，每个之间区别不大。如果K值取得太小，群组的粒度又太粗，造成群组内差异比较明显。对非监督式的学习来说，这个参数确实难以得到准确预估。我们可以事先在一个较小的数据集合上进行尝试，然后根据结果和应用场景确定一个经验值。</p><h2>思考题</h2><p>今天我使用的是sklearn里的KMeans包，它使用了向量间的欧氏距离来进行聚类。你可以尝试实现自己的K均值聚类，并使用向量间的夹角余弦作为相似度的度量。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>",
        article_title: "36 | 文本聚类：如何过滤冗余的新闻？",
      },
      {
        title: "37 | 矩阵（上）：如何使用矩阵操作进行PageRank计算？",
        herf: "https://time.geekbang.org/column/article/85194",
        id: "85194",
        content:
          '<p>你好，我是黄申。今天我来说说矩阵。</p><p>前面我说过，矩阵由多个长度相等的向量组成，其中的每列或者每行就是一个向量。从数据结构的角度来看，我们可以把向量看作一维数组，把矩阵看作二维数组。</p><p>具有了二维数组的特性，矩阵就可以表达二元关系了，例如图中结点的邻接关系，或者是用户对物品的评分关系。而通过矩阵上的各种运算操作，我们就可以挖掘这些二元关系，在不同的应用场景下达到不同的目的。今天我就从图的邻接矩阵出发，展示如何使用矩阵计算来实现PageRank算法。</p><h2>回顾PageRank链接分析算法</h2><p>在讲马尔科夫模型的时候，我已经介绍了PageRank链接分析算法。所以，在展示这个算法和矩阵操作的关系之前，我们快速回顾一下它的核心思想。</p><p>PageRank是基于马尔科夫链的。它假设了一个“随机冲浪者”模型，冲浪者从某张网页出发，根据Web图中的链接关系随机访问。在每个步骤中，冲浪者都会从当前网页的链出网页中，随机选取一张作为下一步访问的目标。此外，PageRank还引入了随机的跳转操作，这意味着冲浪者不是按Web图的拓扑结构走下去，只是随机挑选了一张网页进行跳转。</p><p>基于之前的假设，PageRank的公式定义如下：</p><p><img src="https://static001.geekbang.org/resource/image/55/6d/553f1e841d71ac34db7161cb9974e56d.png" alt=""></p><p>其中，$p_{i}$表示第$i$张网页，$M_{i}$是$p_{i}$的入链接集合，$p_{j}$是$M_{i}$集合中的第$j$张网页。$PR_{(p_{j})}$表示网页$p_{j}$的PageRank得分，$L_{(p_{j})}$表示网页$p_{j}$的出链接数量，$\\frac{1}{L_{(p_{j})}}$就表示从网页$p_{j}$跳转到$p_{i}$的概率。$α$是用户不进行随机跳转的概率，$N$表示所有网页的数量。</p><!-- [[[read_end]]] --><p>PageRank的计算是采样迭代法实现的：一开始所有网页结点的初始PageRank值都可以设置为某个相同的数，例如1，然后我们通过上面这个公式，得到每个结点新的PageRank值。每当一张网页的PageRank发生了改变，它也会影响它的出链接所指向的网页，因此我们可以再次使用这个公式，循环地修正每个网页结点的值。由于这是一个马尔科夫过程，所以我们能从理论上证明，所有网页的PageRank最终会达到一个稳定的数值。整个证明过程很复杂，这里我们只需要知道这个迭代计算的过程就行了。</p><h2>简化PageRank公式</h2><p>那么，这个计算公式和矩阵操作又有什么联系呢？为了把问题简化，我们暂时不考虑随机跳转的情况，而只考虑用户按照网页间链接进行随机冲浪。那么PageRank的公式就简化为：</p><p><img src="https://static001.geekbang.org/resource/image/b6/05/b6f8fc1f6e8b144e3d9e6a0d99da1c05.png" alt=""></p><p>这个公式只包含了原公式中的$Σ\\frac{PR_{(p_{j})}}{L_{(p_{j})})}$部分。我们再来对比看看矩阵点乘的计算公式。</p><p><img src="https://static001.geekbang.org/resource/image/5b/fc/5bb501ed32b7f9882fd71baf3d4f92fc.png" alt=""></p><p>以上两个公式在形式上是基本一致的。因此，我们可以把$Σ\\frac{PR_{(p_{j})}}{L_{(p_{j})})}$的计算，分解为两个矩阵的点乘。一个矩阵是当前每张网页的PageRank得分，另一个矩阵就是邻接矩阵。所谓邻接矩阵，其实就是表示图结点相邻关系的矩阵。</p><p>假设$x_{i,j}$是矩阵中第$i$行、第$j$列的元素，那么我们就可以使用$x_{i,j}$表示从结点$i$到结点$j$的连接，放到PageRank的应用场景，$x_{i,j}$就表示网页$p_{i}$到网页$p_{j}$的链接。最原始的邻接矩阵所包含的元素是0或1，0表示没有链接，而1表示有链接。</p><p>考虑到PageRank里乘积是$\\frac{1}{L_{(p_{j})}}$，我们可以对邻接矩阵的每一行进行归一化，用原始的值（0或1）除以$L_{(p_{j})}$，而$L_{(p_{j})}$表示有某张网页$p_{j}$的出链接，正好是矩阵中$p_{j}$这一行的和。所以，我们可以对原始的邻接矩阵，进行基于行的归一化，这样就能得到每个元素为$\\frac{1}{L_{(p_{j})}}$的矩阵，其中$j$表示矩阵的第$j$行。注意，这里的归一化是指让所有元素加起来的和为1。</p><p>为了方便你理解，我用下面这个拓扑图作为例子给你详细解释。</p><p><img src="https://static001.geekbang.org/resource/image/df/27/df77f2aa727b5c8dba6a5276e5a25627.png" alt=""></p><p>基于上面这个图，原始矩阵为：</p><p><img src="https://static001.geekbang.org/resource/image/08/09/08cb860669c99a1a8cdb0666373c6e09.png" alt=""></p><p>其中第i行、第j列的元素值表示从结点i到j是不是存在链接。如果是，那么这个值为1；否则就为0。</p><p>按照每一行的和，分别对每一行进行归一化之后的矩阵就变为：</p><p><img src="https://static001.geekbang.org/resource/image/b1/f5/b16cace172cb8e3ff7a4981cc53504f5.png" alt=""></p><p>有了上述这个邻接矩阵，我们就可以开始最简单的PageRank计算。PageRank的计算是采样迭代法实现的。这里我把初始值都设为1，并把第一次计算的结果列在这里。</p><p><img src="https://static001.geekbang.org/resource/image/fb/0c/fbc67543c3113496bfcf4e39bf375c0c.png" alt=""></p><p>好了，我们已经成功迈出了第一步，但是还需要考虑随机跳转的可能性。</p><h2>考虑随机跳转</h2><p>经过上面的步骤，我们已经求得$Σ\\frac{PR_{(p_{j})}}{L_{(p_{j})})}$部分。不过，PageRank引入了随机跳转的机制。这一部分其实也是可以通过矩阵的点乘来实现的。我们把$Σ\\frac{PR_{(p_{j})}}{L_{(p_{j})})}$部分用$A$表示，那么完整的PageRank公式就可以表示为：</p><center>$PR_{(P_{i})}=αA+\\frac{1-α}{N}$</center><p></p><p></p><p>于是，我们可以把上述公式分解为如下两个矩阵的点乘：</p><p><img src="https://static001.geekbang.org/resource/image/ea/af/eaf0b4fb41e70cc39dc534a457c2a9af.png" alt=""></p><p>我们仍然使用前面的例子，来看看经过随机跳转之后，PageRank值变成了多少。这里$α$取0.9。</p><p><img src="https://static001.geekbang.org/resource/image/83/71/831c5970c794231fec8bca1a38e58271.png" alt=""></p><p>我们前面提到，PageRank算法需要迭代式计算。为了避免计算后的数值越来越大甚至溢出，我们可以进行归一化处理，保证所有结点的数值之和为1。经过这个处理之后，我们得到第一轮的PageRank数值，也就是下面这个行向量：</p><p>[0.37027027 0.24864865 0.37027027 0.00540541 0.00540541]</p><p>接下来，我们只需要再重复之前的步骤，直到每个结点的值趋于稳定就可以了。</p><h2>使用Python进行实现</h2><p>说到这里，我已经把如何把整个PageRank的计算，转换成多个矩阵的点乘这个过程讲完了。这样一来，我们就可以利用Python等科学计算语言提供的库，来完成基于PageRank的链接分析。为了展示具体的代码，我以之前的拓扑图为例，给你详细讲述每一步。</p><p>首先，我们要进行一些初始化工作，包括设置结点数量、确定随机跳转概率的$α$、代表拓扑图的邻接矩阵以及存放所有结点PageRank值的数组。下面是一段示例代码，在代码中我提供了注释供你参考。</p><pre><code>import numpy as np\n\n# 设置确定随机跳转概率的alpha、网页结点数\nalpha = 0.9\nN = 5\n\n# 初始化随机跳转概率的矩阵\njump = np.full([2,1], [[alpha], [1-alpha]], dtype=float)\n\n# 邻接矩阵的构建\nadj = np.full([N,N], [[0,0,1,0,0],[1,0,1,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,1,0,0,0]], dtype=float)\n\n# 对邻接矩阵进行归一化\nrow_sums = adj.sum(axis=1)      # 对每一行求和\nrow_sums[row_sums == 0] = 0.1   # 防止由于分母出现0而导致的Nan\nadj = adj / row_sums[:, np.newaxis] # 除以每行之和的归一化\n\n# 初始的PageRank值，通常是设置所有值为1.0\npr = np.full([1,N], 1, dtype=float)\n</code></pre><p>之后，我们就能采用迭代法来计算PageRank值。一般我们通过比较每个结点最近两次计算的值是否足够接近，来确定数值是不是已经稳定，以及是不是需要结束迭代。这里为简便起见，我使用了固定次数的循环来实现。如果你的拓扑图比较复杂，需要更多次迭代，我把示例代码和注释列在这里。</p><pre><code># PageRank算法本身是采样迭代方式进行的，当最终的取值趋于稳定后结束。\nfor i in range(0, 20):\n\n    # 进行点乘，计算Σ(PR(pj)/L(pj))\n    pr = np.dot(pr, adj)\n\n    # 转置保存Σ(PR(pj)/L(pj))结果的矩阵，并增加长度为N的列向量，其中每个元素的值为1/N，便于下一步的点乘。\n    pr_jump = np.full([N, 2], [[0, 1/N]])\n    pr_jump[:,:-1] = pr.transpose()\n\n    # 进行点乘，计算α(Σ(PR(pj)/L(pj))) + (1-α)/N)\n    pr = np.dot(pr_jump, jump)\n\n    # 归一化PageRank得分\n    pr = pr.transpose()\n    pr = pr / pr.sum()\n\n    print(&quot;round&quot;, i + 1, pr)\n</code></pre><p>如果成功运行了上述两段代码，你就能看到每个结点最终获得的PageRank分数是多少。</p><p>Python中还有一些很不错的库，提供了直接构建拓扑图和计算PageRank的功能，例如networkx（<a href="https://networkx.github.io/">https://networkx.github.io/</a>）。你可以尝试使用这种库，构建样例拓扑图并计算每个结点的PageRank得分，最后和上述代码所计算的PageRank得分进行比较，验证一下上述代码的结果是不是合理。</p><h2>总结</h2><p>我们可以把向量看作一维数组，把矩阵看作二维数组。矩阵的点乘，是由若干个向量的点乘组成的，所以我们可以通过矩阵的点乘操作，挖掘多组向量两两之间的关系。</p><p>今天我们讲了矩阵的点乘操作在PageRank算法中的应用。通过表示网页的邻接二元关系，我们可以使用矩阵来计算PageRank的得分。在这个应用场景下，矩阵点乘体现了多个马尔科夫过程中的状态转移。</p><p>矩阵点乘和其他运算操作，还可以运用在很多其他的领域。例如，我在上一节介绍K均值聚类算法时，就提到了需要计算某个数据点向量、其他数据点向量之间的距离或者相似度，以及使用多个数据点向量的平均值来获得质心点的向量，这些都可以通过矩阵操作来完成。</p><p>另外，在协同过滤的推荐中，我们可以使用矩阵点乘，来实现多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。下一节，我会使用矩阵来表示用户和物品的二元关系，并通过矩阵来计算协同过滤的结果。</p><h2>思考题</h2><p>在介绍PageRank算法时，我提到了它的计算是一个迭代的过程。这一节我使用了固定次数的循环来实现这一点。请尝试使用计算前后两次PageRank数值的差，来判断是否需要结束迭代。（提示：你可以使用矩阵元素对应的减法，以及在第3讲和加餐2中提到的相对误差。）</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "37 | 矩阵（上）：如何使用矩阵操作进行PageRank计算？",
      },
      {
        title: "38 | 矩阵（下）：如何使用矩阵操作进行协同过滤推荐？",
        herf: "https://time.geekbang.org/column/article/85562",
        id: "85562",
        content:
          '<p>你好，我是黄申。今天我们来聊聊矩阵操作和推荐算法的关系。</p><p>我这里说的推荐，是指为用户提供可靠的建议、并协助用户挑选物品的一种技术。一个好的推荐系统需要建立在海量数据挖掘基础之上，并根据用户所处的情景和兴趣特点，向用户推荐可能感兴趣的信息和商品。</p><p>协同过滤（Collaborative Filtering）是经典的推荐算法之一，它充分利用了用户和物品之间已知的关系，为用户提供新的推荐内容。我会从这种二元关系出发，给你讲讲如何使用矩阵计算，来实现协同过滤推荐算法。</p><h2>用矩阵实现推荐系统的核心思想</h2><p>矩阵中的二维关系，除了可以表达图的邻接关系，还可以表达推荐系统中用户和物品的关系。如果你不懂推荐系统，不用急，我这里先给你简单讲讲它的核心思想。</p><p>简单地理解就是，推荐系统会根据用户所处的场景和个人喜好，推荐他们可能感兴趣的信息和商品。比如，你在阅读一部电影的影评时，系统给你推荐了其他“你可能也感兴趣的电影”。可以看出来，推荐系统中至少有2个重要的角色：用户和物品。用户是系统的使用者，物品就是将要被推荐的候选对象。</p><p>例如，亚马逊网站的顾客就是用户，网站所销售的商品就是物品。需要注意的是，除了用户角色都是现实中的自然人，某些场景下被推荐的物品可能也是现实中的自然人。例如，一个招聘网站会给企业雇主推荐合适的人才，这时候应聘者承担的是物品角色。</p><!-- [[[read_end]]] --><p>而一个好的推荐算法，需要充分挖掘用户和物品之间的关系。我们可以通过矩阵来表示这种二元关系。我这里有一个例子，我们用矩阵$X$来表示用户对物品喜好程度。</p><p><img src="https://static001.geekbang.org/resource/image/e5/13/e58feab91a926fae9201fbf49f749113.png" alt=""></p><p>其中第$i$行是第$i$个用户的数据，而第j列是用户对第j格物品的喜好程度。我们用$x_{i,j}$表示这个数值。这里的喜好程度可以是用户购买商品的次数、对书籍的评分等等。</p><p>假设我们用一个0到1之间的小数表示。有了这种矩阵，我们就可以通过矩阵的操作，充分挖掘用户和物品之间的关系。下面，我会使用经典的协同过滤算法，来讲解矩阵在其中的运用。</p><p>在此之前，我们先来看什么是协同过滤。你可以把它理解为最直观的“口口相传”。假设我们愿意接受他人的建议，尤其是很多人都向你建议的时候。其主要思路就是利用已有用户群过去的行为或意见，预测当前用户最可能喜欢哪些东西。根据推荐依据和传播的路径，又可以进一步细分为基于用户的过滤和基于物品的过滤。</p><h2>基于用户的过滤</h2><p>首先，我们来看基于用户的协同过滤。它是指给定一个用户访问（我们假设有访问就表示有兴趣）物品的数据集合，找出和当前用户历史行为有相似偏好的其他用户，将这些用户组成“近邻”，对于当前用户没有访问过的物品，利用其近邻的访问记录来预测。我画了一张图方便你理解。</p><p><img src="https://static001.geekbang.org/resource/image/25/b5/25cde6fc74cd86892b41ce66de4be4b5.png" alt=""></p><p>根据这张图的访问关系来看，用户A访问了物品A和C，用户B访问了物品B，用户C访问了物品A，C和D。我们计算出来，用户C是A的近邻，而B不是。因此系统会更多地向用户A推荐用户C访问的物品D。</p><p>理解了这个算法的基本概念，我们来看看如何使用公式来表述它。假设有m个用户，n个物品，那么我们就能使用一个m×n维的矩阵$X$来表示用户对物品喜好的二元关系。基于这个二元关系，我们可以列出下面这两个公式：</p><p><img src="https://static001.geekbang.org/resource/image/1b/de/1bb5c0d0f0d77e7e77b2dbdc56ae27de.png" alt=""></p><p>其中，第一个公式比较容易理解，它的核心思想是计算用户和用户之间的相似度。完成了这一步我们就能找到给定用户的“近邻”。</p><p>我们可以使用向量空间模型中的距离或者是夹角余弦来处理，在这里我使用了夹角余弦，其中$us_{i1}$,$i2$表示用户$i1$和$i2$的相似度，而$X_{i1}$,表示矩阵中第$i1$行的行向量，$X_{i2}$,表示矩阵中第$i2$行的行向量。分子是两个表示用户的行向量之点乘，而分母是这两个行向量$L2$范数的乘积。</p><p>第二个公式利用第一个公式所计算的用户间相似度，以及用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。其中$p_{i,j}$表示第$i$用户对第$j$个物品的喜好度，$us_{i,k}$表示用户$i$和$k$之间的相似度，$x_{k,j}$表示用户$k$对物品$j$的喜好度。注意这里最终需要除以$Σus_{i,k}$，是为了进行归一化。</p><p>从这个公式可以看出，如果$us_{i,k}$越大，$x_{k,j}$对最终$p_{i,j}$的影响越大，反之如果$us_{i,k}$越小，$x_{k,j}$对最终$p_{i,j}$的影响越小，充分体现了“基于相似用户”的推荐。</p><p>如果你无法理解如何把这两个公式对应为矩阵操作，没关系，我下面会通过之前介绍的喜好度矩阵$X$的示例，把这两个公式逐步拆解，并对应到矩阵上的操作，你一看就能明白了。</p><p>首先，我们来看第一个关于夹角余弦的公式。</p><p><img src="https://static001.geekbang.org/resource/image/3c/2b/3c04082d6f87f9268eceb65cb624892b.png" alt=""></p><p>在介绍向量空间模型的时候，我提到夹角余弦可以通过向量的点乘来实现。这对矩阵同样适用，我们可以采用矩阵点乘自身的转置来实现，也就是$XX’$。矩阵$X$的每一行是某个用户的行向量，每个分量表示用户对某个物品的喜好程度。而矩阵$X’$的每一列是某个用户的列向量，每个分量表示用户对某个物品的喜好程度。</p><p>我们假设$XX’$的结果为矩阵$Y$，那么$y_{i,j}$就表示用户$i$和用户$j$这两者喜好度向量的点乘结果，它就是夹角余弦公式中的分子。如果$i$等于$j$，那么这个计算值也是夹角余弦公式分母的一部分。从矩阵的角度来看，$Y$中任何一个元素都可能用于夹角余弦公式的分子，而对角线上的值会用于夹角余弦公式的分母。这里我们仍然使用之前的喜好度矩阵示例，来计算矩阵$Y$和矩阵$US$。</p><p>首先我们来看$Y$的计算。</p><p><img src="https://static001.geekbang.org/resource/image/79/2b/79e7065dade1b1a4d38639bb9d2cea2b.png" alt=""></p><p>然后我们使用$Y$来计算$US$。我用下面这张图表示矩阵中的元素和夹角余弦计算的对应关系。</p><p><img src="https://static001.geekbang.org/resource/image/9d/42/9ddfe8b7874d9d708fa367ccca967942.png" alt=""></p><p>明白了上面这个对应关系，我们就可以利用矩阵$Y$，获得任意两个用户之间的相似度，并得到一个m×m维的相似度矩阵$US$。矩阵$US$中$us_{i,j}$的取值为第$i$个用户与第$j$个用户的相似度。这个矩阵是一个沿对角线对称的矩阵。根据夹角余弦的定义，$us_{i,j}$和$us_{j,i}$是相等的。通过示例的矩阵$Y$，我们可以计算矩阵$US$。我把相应的结果列在了下方。</p><p><img src="https://static001.geekbang.org/resource/image/1e/1e/1e02d4f61487b6e5fd6178ef8e143b1e.png" alt=""></p><p>接下来，我们再来看第二个公式。</p><p><img src="https://static001.geekbang.org/resource/image/80/6b/80fc4fd72d8f4f114cd0fa7f868f576b.png" alt=""></p><p>从矩阵的角度来看，现在我们已经得到用户相似度矩阵$US$，再加上用户对物品的喜好度矩阵$X$，现在需要计算任意用户对任意物品的喜好度推荐矩阵$P$。</p><p>为了实现上面这个公式的分子部分，我们可以使用$US$和$X$的点乘。我们假设点乘后的结果矩阵为$USP$。这里我列出了根据示例计算得到的矩阵$USP$。</p><p><img src="https://static001.geekbang.org/resource/image/65/1f/65ff214ce18ccc12193bf17cd1ec201f.png" alt=""></p><p>分母部分可以使用$US$矩阵的按行求和来实现。我们假设按行求和的矩阵为$USR$。根据示例计算就可以得到$USR$。</p><p><img src="https://static001.geekbang.org/resource/image/28/0e/28c5469d3fcacda96604f66dfc883a0e.png" alt=""></p><p>最终，我们使用$USP$和*$USR$的元素对应除法，就可以求得矩阵$P$。</p><p><img src="https://static001.geekbang.org/resource/image/eb/c8/eba06795db612c7be96118b9fa93cfc8.png" alt=""></p><p>既然已经有$X$这个喜好度矩阵了，为什么还要计算$P$这个喜好度矩阵呢？实际上，$X$是已知的、有限的喜好度。例如用户已经看过的、购买过的、或评过分的物品。而$P$是我们使用推荐算法预测出来的喜好度。</p><p>即使一个用户对某个物品从未看过、买过、或评过分，我们依然可以通过矩阵$P$，知道这位用户对这个物品大致的喜好程度，从而根据这个预估的分数进行物品的推荐，这也是协同过滤的基本思想。从根据示例计算的结果也可以看出这点，在原始矩阵$X$中第1个用户对第3个物品的喜好度为0。可是在最终的喜好度推荐矩阵P中，第1个用户对第3个物品的喜好度为0.278，已经明显大于0了，因此我们就可以把物品3推荐给用户1。</p><p>上面这种基于用户的协同过滤有个问题，那就是没有考虑到用户的喜好程度是不是具有可比性。假设用户的喜好是根据对商品的评分来决定的，有些用户比较宽容，给所有的商品都打了很高的分，而有些用户比较严苛，给所有商品的打分都很低。分数没有可比性，这就会影响相似用户查找的效果，最终影响推荐结果。这个时候我们可以采用之前介绍的特征值变化，对于原始的喜好度矩阵，按照用户的维度对用户所有的喜好度进行归一化或者标准化处理，然后再进行基于用户的协同过滤。</p><h2>基于物品的过滤</h2><p>基于物品的协同过滤是指利用物品相似度，而不是用户间的相似度来计算预测值。我同样用图来帮助你理解。</p><p><img src="https://static001.geekbang.org/resource/image/5b/00/5be6626c3c5bf8a6dcdb0c29f032c500.png" alt=""></p><p>在这张图中，物品A和C因为都被用户A和B同时访问，因此它们被认为相似度更高。当用户C访问过物品A后，系统会更多地向用户推荐物品C，而不是其他物品。</p><p>基于物品的协同过滤同样有两个公式，你可以看一下。</p><p><img src="https://static001.geekbang.org/resource/image/d7/21/d7d584a2b1f85463c5028fffb76cce21.png" alt=""></p><p>如果你弄明白了基于用户的过滤，那么这两个公式也就不难理解了。第一个公式的核心思想是计算物品和物品之间的相似度，在这里我仍然使用夹角余弦。其中$is_{j1}$,$j2$表示物品$j1$和$j2$的相似度，而$X_{j1}$表示了$X$中第$j1$列的列向量，而$X_{j2}$表示了$X$中第$j2$列的列向量。分子是两个表示物品的列向量之点乘，而分母是这两个列向量$L2$范数的乘积。</p><p>第二个公式利用第一个公式所计算的物品间相似度，和用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。其中$p_{i,j}$表示第$i$用户对第$j$个物品的喜好度，$x_{i,k}$表示用户$i$对物品$k$的喜好度，$is_{k,j}$表示物品$k$和$j$之间的相似度，注意这里除以$Σis_{k,j}$是为了进行归一化。从这个公式可以看出，如果$is_{k,j}$越大，$x_{i,k}$对最终$p_{i,j}$的影响越大，反之如果$is_{k,j}$越小，$x_{i,k}$对最终$p_{i,j}$的影响越小，充分体现了“基于相似物品”的推荐。</p><p>类似地，用户喜好程度的不一致性，同样会影响相似物品查找的效果，并最终影响推荐结果。我们也需要对于原始的喜好度矩阵，按照用户的维度对用户的所有喜好度，进行归一化或者标准化处理。</p><h2>总结</h2><p>今天我首先简要地介绍了推荐系统的概念和主要思想。为了给用户提供可靠的结果，推荐系统需要充分挖掘历史数据中，用户和物品之间的关系。协同过滤的推荐算法就很好地体现了这一点。</p><p>一旦涉及用户和物品的这种二元关系，矩阵就有用武之地了。我通过矩阵来表示用户和物品的关系，并通过矩阵计算来获得协同过滤的结果。协同过滤分为基于用户的过滤和基于物品的过滤两种，它们的核心思想都是相同的，因此矩阵操作也是类似的。在这两个应用场景下，矩阵点乘体现了多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。</p><p>当然，基于用户和物品间关系的推荐算法有很多，对矩阵的操作也远远不止点乘、按行求和、元素对应乘除法。我后面会介绍如何使用矩阵的主成分分析或奇异值分解，来进行物品的推荐。</p><h2>思考题</h2><p>我在介绍推荐算法时，提到了基于物品的协同过滤。请参照基于用户的协同过滤，写出相应的矩阵操作步骤。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title: "38 | 矩阵（下）：如何使用矩阵操作进行协同过滤推荐？",
      },
      {
        title: "39 | 线性回归（上）：如何使用高斯消元求解线性方程组？",
        herf: "https://time.geekbang.org/column/article/86014",
        id: "86014",
        content:
          '<p>你好，我是黄申。</p><p>之前我使用Boston Housing的数据，阐述了如何使用多元线性回归。可是，计算机系统究竟是如何根据观测到的数据，来拟合线性回归模型呢？这两节，我就从最简单的线性方程组出发，来说说如何求解线性回归的问题。</p><p>在第29讲中，我讲过机器学习中两类很重要的方法：回归分析以及线性回归。回归分析属于监督式学习算法，主要研究一个或多个随机变量$y_1$，$y_2$，…，$y_i$与另一些变量$x_{1}$，$x_{2}$，…，$x_{k}$之间的关系。其中，我们将$y_{1}，y_{2}、…，y_{i}$称为因变量，$x_1，x_2，…，x_k$称为自变量。按照不同的维度，我们可以把回归分为三种。</p><ul>\n<li>\n<p>按照自变量数量，当自变量$x$的个数大于1时就是多元回归。</p>\n</li>\n<li>\n<p>按照因变量数量，当因变量$y$个数大于1时就是多重回归。</p>\n</li>\n<li>\n<p>按照模型种类，如果因变量和自变量为线性关系时，就是线性回归模型；如果因变量和自变量为非线性关系时时，就是非线性回归分析模型。</p>\n</li>\n</ul><!-- [[[read_end]]] --><h2>高斯消元法</h2><p>对于回归分析来说，最简单的情形是只有一个自变量和一个因变量，且它们大体上是有线性关系的，这就是一元线性回归。对应的模型很简单，就是$Y=a+bX+ε$。这里的$X$是自变量，$Y$是因变量，$a$是截距，b是自变量的系数。前面这些你估计都很熟悉，最后还有个$ε$，这表示随机误差，只不过我们通常假定随机误差的均值为$0$。进一步来说，如果我们暂时不考虑a和ε，把它扩展为多元的形式，那么就可以得到类似下面这种形式的方程：</p><p>$b_1·x_1+b_2·x_2+...+b_{n-1}·x_{n-1} +b_n·x_n=y$</p><p>假设我们有多个这样的方程，就能构成线性方程组，我这里列出一个例子。</p><p>$2x_1+x_2+x_3=0$<br>\n$4x_1+2x_2+x_3=56$<br>\n$2x_1-x_2+4x_3=4$</p><p>对于上面这个方程组，如果存在至少一组$x_1、x_2$和$x_3$使得三个方程都成立，那么就叫方程有解；如果没有，那么我们就说方程无解。如果方程有解，那么解可能是唯一，也可能是多个。我们通常关心的是，方程组是不是有解，以及$x_1$一直到$x_n$分别是多少。</p><p>为了实现这个目的，人们想了很多方法来求解方程组，这些方法看起来多种多样，其实主要就是两大类，直接法和迭代法。</p><p>直接法就是通过有限次的算术运算，计算精确解。而迭代法，我们在第3讲就提到过，它是一种不断用变量的旧值递推新值的过程。我们可以用迭代法不断地逼近方程的精确解。</p><p>这里，我就从上面这个方程组的例子出发，阐述最常见的高斯消元法，以及如何使用矩阵操作来实现它。</p><p>高斯消元法主要分为两步，<strong>消元</strong>（Forward Elimination）和<strong>回代</strong>（Back Substitution）。所谓消元，就是要减少某些方程中元的数量。如果某个方程中的元只剩一个了$x_m$了，那么这个自变量$x_m$的解就能知道了。所谓的回代，就是把已知的解$x_m$代入到方程式中，求出其他未知的解。</p><p>我们先从消元开始，来看这个方程组。</p><p>$2x_1+x_2+x_3=0$<br>\n$4x_1+2x_2+x_3=56$<br>\n$2x_1-x_2+4x_3=4$</p><p>首先保持第一个方程不变，然后消除第二个和第三个方程中的$x_1$。对于第二个方程，方法是让第二个方程式减去第一个方程式的两倍，方程的左侧为：</p><p>$(4x_1+2x_2+x_3)-2(2x_1+x_2+x_3)=-x_3$</p><p>方程的右侧变为：</p><p>$56-2·0=56$</p><p>所以第二个方程变为：</p><p>$-x_3=56$</p><p>这样三个方程式就变为：</p><p>$2x_1+x_2+x_3=0$<br>\n$-x_3=56$<br>\n$2x_1-x_2+4x_3=4$</p><p>对于第三个方程同样如此，我们需要去掉其中的$x_1$。方法是让第三个方程减去第一个方程，之后三个方程式变为：</p><p>$2x_1+x_2+x_3=0$<br>\n$-x_3=56$<br>\n$-2x_2+3x_3=4$</p><p>至此，我们使用第一个方程式作为参照，消除了第二个和第三个方程式中的$x_1$，我们称这里的第一个方程式为“主元行”。</p><p>接下来，我们要把第二个方程式作为“主元行”，来消除第三个方程中的$x_2$。你应该能发现，第二个方程中的$x_2$已经没有了，失去了参照，这个时候我们需要把第二个方程和第三个方程互换，变为：</p><p>$2x_1+x_2+x_3=0$<br>\n$-2x_2+3x_3=4$<br>\n$-x_3=56$</p><p>到了这个时候，由于第三个方程以及没有$x_2$了，所以无需再消元。如果还有$x_2$，那么就需要参照第二个方程式来消除第三个方程中的$x_2$。</p><p>观察一下现在的方程组，第一个方程有3个自变量，第二个方程有2个自变量，第三个方程只有1个自变量。这个时候，我们就可以从第三个方程开始，开始回代的过程了。通过第三个方程，显然我们可以得到$x_3=-56$，然后把这个值代入第二个方程，就可以得到$x_2 = -86$。最后把$x_2$和$x_3$的值代入第一个方程式，我们可以得到$x_1=71$。</p><h2>使用矩阵实现高斯消元法</h2><p>如果方程和元的数量很小，那么高斯消元法并不难理解。可是如果方程和元的数量很多，整个过程就变得比较繁琐了。实际上，我们可以把高斯消元法转为矩阵的操作，便于自己的理解和记忆。</p><p>为了进行矩阵操作，首先我们要把方程中的系数$b_i$转成矩阵，我们把这个矩阵记作$B$。对于上面的方程组示例，系数矩阵为：</p><p><img src="https://static001.geekbang.org/resource/image/f5/27/f503789bf7c86ed71833714ef2ec7d27.png" alt=""></p><p>那么，最终我们通过消元，把系数矩阵B变为：</p><p><img src="https://static001.geekbang.org/resource/image/4b/83/4b22614e3ee87cc6f05e83f149577583.png" alt=""></p><p>从此可以看出，消元的过程就是把原始的系数矩阵变为上三角矩阵。这里的上三角矩阵表示，矩阵中只有主对角线以及主对角线以上的三角部分里有数字。我们用$U$表示上三角矩阵。</p><p>而回代呢，我们最终得到的结果是：</p><p>$x_1=71$<br>\n$x_2=-86$<br>\n$x_3=-56$</p><p>我们可以把这几个结果看作：</p><p>$1·x_1+0·x_2+0·x_3=71$<br>\n$0·x_1+1·x_2+0·x_3=-86$<br>\n$0·x_1+0·x_2+1·x_3=-56$</p><p>再把系数写成矩阵的形式，就是：</p><p><img src="https://static001.geekbang.org/resource/image/30/cc/30000d4fa09611c433b1bf4c830f5dcc.png" alt=""></p><p>发现没？这其实就是单位矩阵。所以说，回代的过程是把上三角矩阵变为单位矩阵的过程。</p><p>为了便于后面的回代计算，我们也可以把方程式等号右边的值加入到系数矩阵，我们称这个新的矩阵为<strong>增广矩阵</strong>，我把这个矩阵记为$A$。</p><p>好，现在让我们来观察一下这个增广矩阵$A$。</p><p><img src="https://static001.geekbang.org/resource/image/22/eb/22fedea5f06d766d4ff2cfa7319ddceb.png" alt=""></p><p>对于这个矩阵，我们的最终目标是，把除了最后一列之外的部分，变成单位矩阵，而此时最后一列中的每个值，就是每个自变量所对应的解了。</p><p>之前我已经讲过矩阵相乘在向量空间模型、PageRank算法和协同过滤推荐中的应用。这里，我们同样可以使用这种操作来进行消元。为了方便你理解，我们可以遵循之前消元的步骤一步步来看。</p><p>还记得这个方程组消元的第一步吗？对，首先保持第一个方程不变，然后消除第二个和第三个方程中的$x_1$。这就意味着要把$A_{2,1}$和$A_{3,1}$变为$0$。</p><p>对于第一个方程式，如果要保持它不变，我们可以让向量$[1, 0, 0]$左乘$A$。对于第二个方程，具体操作是让第二个方程式减去第一个方程式的两倍，达到消除$x_1$的目的。我们可以让向量$[-2, 1, 0]$左乘$A$。对于第三个方程式，具体操作是让第三个方程式减去第一个方程式，达到消除$x_1$的目的。我们可以让向量$[-1, 0, 1]$左乘$A$。我们使用这三个行向量组成一个矩阵$E1$。</p><p><img src="https://static001.geekbang.org/resource/image/a1/e0/a1d1ed2a3d2fad6612419778cefb71e0.png" alt=""></p><p>因此，我们可是用下面这个矩阵$E1$和$A$的点乘，来实现消除第二个和第三个方程式中$x_1$的目的。</p><p><img src="https://static001.geekbang.org/resource/image/51/4e/51740abc1698f91b5baac900b42b8d4e.png" alt=""></p><p>你会发现，由于使用了增广矩阵，矩阵中最右边的一列，也就是方程等号右边的数值也会随之发生改变。</p><p>下一步是消除第三个方程中的$x_2$。依照之前的经验，我们要把第二个方程式作为“主元行”，来消除第三个方程中的$x_2$。可是第二个方程中的$x_2$已经没有了，失去了参照，这个时候我们需要把第二个方程和第三个方程互换。这种互换的操作如何使用矩阵来实现呢？其实不难，例如使用下面这个矩阵$E2$左乘增广矩阵$A$。</p><p><img src="https://static001.geekbang.org/resource/image/7a/c3/7a5989f252595581c5a0e47107269bc3.png" alt=""></p><p>上面这个矩阵第一行$[1 0 0]$的意思就是我们只取第一行的方程，而第二行$[0 0 1]$的意思是只取第三个方程，而第三行$[0 1 0]$表示只取第二个方程。</p><p>我们先让$E1$左乘$A$，然后再让$E2$左乘$E1A$的结果，就能得到消元后的系数矩阵。</p><p><img src="https://static001.geekbang.org/resource/image/de/00/decf0462a60b9dcb7defd521d4b19500.png" alt=""></p><p>我们把$E1$点乘$E2$的结果记作$E3$，并把$E3$称为消元矩阵。</p><p><img src="https://static001.geekbang.org/resource/image/2e/df/2ea3b5f4e5eed00d635e208c1f7b0cdf.png" alt=""><img src="https://static001.geekbang.org/resource/image/0b/86/0b2a2499dc78c7dd8f32db062ce3b586.png" alt=""></p><p>对于目前的结果矩阵来说，除了最后一列，它已经变成了一个上三角矩阵，也就是说消元步骤完成。接下来，我们要使得最后一列之外的部分变成一个单位矩阵，就能得到最终的方程组解。和消元不同的是，我们将从最后一行开始。对于最后一个方程，我们只需要把所有系数取反就行了，所以会使用下面这个矩阵$S1$实现。</p><p><img src="https://static001.geekbang.org/resource/image/2a/bc/2a502f387af1227ff309faf921268ebc.png" alt=""><img src="https://static001.geekbang.org/resource/image/12/46/1266ac238659c01af69bbf37d4335f46.png" alt=""></p><p>接下来要去掉第二个方程中的$x_3$，我们要把第二个方程减去3倍的第三个方程，然后除以-2。首先是减去3倍的第三个方程。</p><p><img src="https://static001.geekbang.org/resource/image/bf/e0/bfd6bce21ada11993249d3d9728cf6e0.png" alt=""></p><p>然后把第二个方程除以-2。</p><p><img src="https://static001.geekbang.org/resource/image/31/ca/31e6d5d4e71cb304eee7e3b78b0c9bca.png" alt=""></p><p>最后，对于第一个方程，我们要把第一个方程减去第二个和第三个方程，最后除以2，我把这几步合并了，并列在下方。</p><p><img src="https://static001.geekbang.org/resource/image/24/1b/249f6c4cf7b5ff373f23ac3e1167ae1b.png" alt=""></p><p>最终，结果矩阵的最后一列就是方程组的解。我们把回代部分的矩阵，都点乘起来。</p><p><img src="https://static001.geekbang.org/resource/image/ba/c1/ba81f9fed08ce1c10f6dbc98196602c1.png" alt=""></p><p>而消元矩阵$E3$为：</p><p><img src="https://static001.geekbang.org/resource/image/0b/86/0b2a2499dc78c7dd8f32db062ce3b586.png" alt=""></p><p>我们可以让矩阵$S$左乘矩阵$E3$，就会得到下面的结果。</p><p><img src="https://static001.geekbang.org/resource/image/8d/b0/8da5e9b9ac5ca050c10bee764067bab0.png" alt=""></p><p>我们把这个矩阵记作$SE$，把乘以最初的系数矩阵$B$，就得到了一个单位矩阵。根据逆矩阵的定义，$SE$就是$B$的逆矩阵。换个角度来思考，使用消元法进行线性方程组求解的过程，就是在找系数矩阵的逆矩阵的过程。</p><h2>总结</h2><p>今天我们一起探讨了求解线性方程组最常见的方法之一，高斯消元法。这个方法主要包含了消元和回代两个步骤。这些步骤都可以使用矩阵的操作来进行。从矩阵的角度来说，消元就是把系数矩阵变为上三角矩阵，而回代是把这个上三角矩阵变为单位矩阵。我们可以直接把用于消元和回代的矩阵，用于由系数和因变量值组成的增广矩阵，并获得最终的方程解。</p><p>线性方程组的概念，也是线性回归分析的基础。在线性回归时，我们也能获得由很多观测数据值所组成的方程组。但是，在进行线性回归分析时，方程组的处理方式和普通的方程组求解有一些不同。其中有两个最主要的区别。</p><p>第一个区别是，在线性回归分析中，样本数据会告诉我们自变量和因变量的值，要求的是系数。而在线性方程组中，我们已知系数和因变量的值，要求的是自变量的值。</p><p>第二个区别是，在线性回归分析中，方程的数量要远远大于自变量的数量，而且我们不要求每个方程式都是完全成立。这里，不要求完全成立的意思是，拟合出来的因变量值可以和样本数据给定的因变量值存在差异，也就允许模型拟合存在误差。模型拟合的概念我在上一模块的总结篇中重点讲解了，所以你应该能理解，模型的拟合不可能100%完美，这和我们求解线性方程组精确解的概念是不同的。</p><p>正是因为这两点差异，我们无法直接使用消元法来求解线性回归。下一节，我会来详细解释，如何使用最小二乘法来解决线性回归的问题。</p><h2>思考题</h2><p>请分别写出下面这个方程组的消元矩阵和回代矩阵，并求出最终的解。</p><p>$x_1-2x_2+x_3-4x_4=4$<br>\n$x_2-x_3+x_4=-3$<br>\n$x_1+3x_2+x_4=1$<br>\n$-7x_2+3x_3+x_4=-3$</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title: "39 | 线性回归（上）：如何使用高斯消元求解线性方程组？",
      },
      {
        title: "40 | 线性回归（中）：如何使用最小二乘法进行直线拟合？",
        herf: "https://time.geekbang.org/column/article/86326",
        id: "86326",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我提到了，求解线性回归和普通的线性方程组最大的不同在于误差ε。在求解线性方程组的时候，我们并不考虑误差的存在，因此存在无解的可能。而线性回归允许误差ε的存在，我们要做的就是尽量把ε最小化，并控制在一定范围之内。这样我们就可以求方程的近似解。而这种近似解对于海量的大数据分析来说是非常重要的。</p><p>但是现实中的数据一定存在由于各种各样原因所导致的误差，因此即使自变量和因变量之间存在线性关系，也基本上不可能完美符合这种线性关系。总的来说，线性回归分析并不一定需要100%精确，而误差ε的存在可以帮助我们降低对精度的要求。通常，多元线性回归会写作：</p><p>$y=b_0+b_1·x_1+b_2·x_2+…+$<br>\n$b_{n-1}·x_{n-1}+b_n·x_n+ε$</p><p>这里的$x_1，x_2，…，x_n$是自变量，$y$是因变量，$b_0$是截距，$b_1$，$b_2$，…，$b_n$是自变量的系数，$ε$是随机误差。</p><!-- [[[read_end]]] --><p>在线性回归中，为了实现最小化$ε$的目标，我们可以使用最小二乘法进行直线的拟合。最小二乘法通过最小化误差的平方和，来寻找和观测数据匹配的最佳函数。由于这些内容有些抽象，下面我会结合一些例子来解释最小二乘法的核心思想，以及如何使用这种方法进行求解。</p><h2>使用观测值拟合</h2><p>在详细阐述最小二乘法之前，我们先来回顾一下第32讲介绍的模型拟合。在监督式学习中，拟合模型其实是指通过模型的假设和训练样本，推导出具体参数的过程。有了这些参数，我们就能对新的数据进行预测。而在线性回归中，我们需要找到观测数据之间的线性关系。</p><p>假设我们有两个观测数据，对应于二维空间中的两个点，这两个点可以确定唯一的一条直线，两者呈现线性关系。你可以参考下面这张图。</p><p><img src="https://static001.geekbang.org/resource/image/0d/96/0dc299d455a9010bf4c64f8d12248e96.png" alt=""></p><p>之后，我们又加入了一个点。这个点不在原来的那条直线上。</p><p><img src="https://static001.geekbang.org/resource/image/51/7c/51d4747efbae8c38eb1cc8ebc41c5e7c.png" alt=""></p><p>这个时候，从线性方程的角度来看，就不存在精确解了。因为没有哪条直线能同时穿过这三个点。这张图片也体现了线性回归分析和求解线性方程组是不一样的，线性回归并不需要求精确解。</p><p>如果我们加入更多的观察点，就更是如此了。比如下面这张图。</p><p><img src="https://static001.geekbang.org/resource/image/c4/2e/c499346f631f1decd062335a45f41f2e.png" alt=""></p><p>从上图中你应该可以看出，这根直线不是完全精准地穿过这些点，而只是经过了其中两个，大部分点和这根直线有一定距离。这个时候，线性回归就有用武之地了。</p><p>由于我们假设ε的存在，因此在线性回归中，我们允许某条直线只穿过其中少量的点。不过，既然我们允许这种情况发生，那么就存在无穷多这样的直线。比如下面我随便画了几条，都是可以的。</p><p><img src="https://static001.geekbang.org/resource/image/e5/e6/e5bae0f3a457f75f20f16c02512dcbe6.png" alt=""></p><p>当然，我们从直觉出发，一定不会选取那些远离这些点的直线，而是会选取尽可能靠近这些点的那些线。比如下面这张图里展示的这两条。</p><p><img src="https://static001.geekbang.org/resource/image/f1/f3/f17c54e4d9018d3a9f58e9711e2f00f3.png" alt=""></p><p>好了，即然这样，我们就需要定义哪根线是最优的，以及在给出了最优的定义之后，如何能求解出这条最优的直线呢？最小二乘法可以回答这两个问题，下面我们具体来看。</p><h2>最小二乘法</h2><p>最小二乘法的主要思想就是求解未知参数，使得理论值与观测值之差（即误差，或者说残差）的平方和达到最小。我们可以使用下面这个公式来描述。</p><p><img src="https://static001.geekbang.org/resource/image/82/f8/82c94c629f2cb09dff9a8014186b84f8.png" alt=""></p><p>其中，$y_i$表示来自数据样本的观测值，而$y$^是假设的函数的理论值，$ε$就是我们之前提到的误差，在机器学习中也常被称为损失函数，它是观测值和真实值之差的平方和。最小二乘法里的“二乘”就是指的平方操作。有了这个公式，我们的目标就很清楚了，就是要发现使ε最小化时候的参数。</p><p>那么最小二乘法是如何利用最小化$ε$的这个条件来求解的呢？让我们从矩阵的角度出发来理解整个过程。</p><p>有了上面的定义之后，我们就可以写出最小二乘问题的矩阵形式。</p><p>$min||XB-Y||_{2}^{2}$</p><p>其中$B$为系数矩阵，$X$为自变量矩阵，$Y$为因变量矩阵。换句话说，我们要在向量空间中，找到一个$B$，使向量$XB$与$Y$之间欧氏距离的平方数最小的$B$。</p><p>结合之前所讲的矩阵点乘知识，我们把上述式子改写为：</p><p>$||XB-Y||_{2}^{2}=tr((XB-Y)’(XB-Y))$</p><p>其中$(XB-Y)’$表示矩阵$(XB-Y)$的转置。而$tr()$函数表示取对角线上所有元素的和，对于某个矩阵$A$来说，$tr(A)$的值计算如下：</p><p><img src="https://static001.geekbang.org/resource/image/ca/35/ca47283036c28ac72e281fb21a105735.png" alt=""></p><p>进一步，根据矩阵的运算法则，我们有：</p><p>$tr((XB-Y)’(XB-Y))$<br>\n$=tr(B’X’-Y’)(XB-Y)$<br>\n$=tr(B’X’XB-B’X’Y-Y’XB+Y’Y)$</p><p>因此我们可以得到：</p><p>$||XB-Y||_{2}^{2}$<br>\n$=tr((XB-Y)’(XB-Y))$<br>\n$=tr(B’X’-Y’)(XB-Y)$<br>\n$=tr(B’X’XB-B’X’Y-Y’XB+Y’Y)$</p><p>我们知道，求最极值问题直接对应的就是导数为0，因此我对上述的矩阵形式进行求导，得到如下的式子：</p><p>$\\frac{d||XB-Y||_{2}^{2}}{dB}$<br>\n$=\\frac{d(tr(B’X’XB-B’X’Y-Y’XB+Y’Y))}{dB}$<br>\n$=X’XB+X’XB-X’Y-X’Y$<br>\n$=2X’XB-2X’Y$</p><p>如果要$||XB-Y||_{2}^{2}$最小，就要满足两个条件。</p><p>第一个条件是$\\frac{d||XB-Y||_{2}^{2}}{dB}$为0，也就是$2X’XB-2X’Y=0$。</p><p>第二个条件是$\\frac{d(2X’XB-2X’Y)}{dB}&gt;0$。</p><p>由于$\\frac{d(2X’XB-2X’Y)}{dB}=2X’X&gt;0$，所以，第二个条件是满足的。只要$2X’XB=2X’Y$。</p><p>我们就能获得$ε$的最小值。从这个条件出发，我们就能求出矩阵$B$：</p><p>$2X’XB=2X’Y$<br>\n$X’XB=X’Y$<br>\n$(X’X)^{-1}X’XB=(X’X)^{-1}X’Y$<br>\n$IB=(X’X)^{-1}X’Y$<br>\n$B=(X’X)^{-1}X’Y$</p><p>其中$I$为单位矩阵。而$(X’X)^{-1}$表示$X’X$的逆矩阵。所以，最终系数矩阵为：</p><p>$B=(X’X)^{-1}X’Y$</p><h2>补充证明和解释</h2><p>为了保持推导的连贯性，在上述的推导过程中，我跳过了几个步骤的证明。下面我会给出详细的解释，供你更深入的学习和研究。</p><h3>步骤a：</h3><p>$(XB)’=B’X’$</p><h3>证明：</h3><p>对于$XB$中的每个元素$xb_{i,j}$，有：</p><p><img src="https://static001.geekbang.org/resource/image/5f/1d/5fb0b4cae0208e738c50f158b3ecd31d.png" alt=""></p><p>而对于$(XB)’$中的每个元素$xb’_{i,j}$，有：</p><p><img src="https://static001.geekbang.org/resource/image/27/99/27ecb20e94b05529217503a16cfe2399.png" alt=""></p><p>对于$B’$中的每个元素有：</p><p>$b’<em>{i,k}=b</em>{k,i}$</p><p>$X’$中的每个元素有：</p><p>$x’<em>{k,j}=x</em>{j,k}$</p><p>那么，对于$B’X’$中的每个元素$b’x’_{i,j}$，就有：</p><p><img src="https://static001.geekbang.org/resource/image/73/be/736be0c61a9234300bd1c9394e90fdbe.png" alt=""></p><p>所以有$(XB)’ = B’X’$。</p><h3>步骤b：</h3><p>$(XB-Y)’=B’X’-Y’$</p><h3>证明：</h3><p>和步骤a类似，对于$XB-Y$中的每个元素 $xb-y’_{i,j}$有：</p><h3>步骤c：</h3><p>$\\frac{d(tr(B’X’Y))}{dB}=X’Y$</p><h3>证明：</h3><p><img src="https://static001.geekbang.org/resource/image/bd/57/bd0d66ab7fee4a37a0fac13b677d7f57.png" alt=""></p><p>同理，可以证明：</p><p>$\\frac{d(tr(Y’XB))}{dB}=(Y’X)’=X’Y$</p><h3>步骤d：</h3><p>$\\frac{d(tr(B’X’XB))}{dB}=2X’XB$</p><h3>证明：</h3><p>$\\frac{d(tr(B’X’XB))}{dB}$<br>\n$=\\frac{d(tr(B’(X’XB)))}{dB}+\\frac{d(tr((B’X’X)B))}{dB}$<br>\n$=(X’XB)+(B’X’X)’$<br>\n$=X’XB+X’XB$<br>\n$=2X’XB$</p><h3>步骤e：</h3><p>常量对于变量求导为0，例如：</p><p>$\\frac{d(Y’Y)}{dB}=0$</p><p>好了，弄明白了这些细节上的证明，你就能更好地理解最小二乘法中的推导步骤。不过，你可能还是会奇怪，为什么最终要对矩阵求导数来求ε的最小值。最后，我们就聊聊如何使用求导获取极小值。</p><p>极值是一个函数的极大值或极小值。如果一个函数在一点的某个邻域内每个地方都有确定的值，而以该点所对应的值是最大（小）的，那么这函数在该点的值就是一个极大（小）值。而函数的极值可以通过它的一阶和二阶导数来确定。</p><p>对于一元可微函数$f(x)$，它在某点$x_0$有极值的充分必要条件是$f(x)$在$x_0$的邻域上一阶可导，在$x_0$处二阶可导，且一阶导数$f’(x_0)=0$，二阶导数$f’’(x_0)≠0$。其中$f’$和$f’’$分别表示一阶导数和二阶导数。</p><p>在一阶导数$f’(x0)=0$的情况下，如果$f’’(x0)&lt;0$，则$f$在$x_0$取得极大值；如果$f’’(x0)&gt;0$，则$f$在$x_0$取得极小值。这就是为什么在求矩阵$B$的时候，我们要求$2X’XB-2X’Y$为$0$，并且$2X’XB-2X’Y$的导数要大于$0$，这样我们才能确保求得极小值。</p><h2>总结</h2><p>今天我们探讨了为什么简单的线性方程组无法满足线性函数拟合的需求，最主要的原因就是现实的观测数据往往不是精确的线性关系，存在一定的误差。我们所要做的就是，在允许一定范围的误差前提下，找到一种线性关系，尽量的满足观察数据，使得我们所定义的误差最小。</p><p>最小二乘法通过向量空间的欧氏距离之平方，定义了预测值和真实值之间的误差。在给定自变量和因变量的观测值之后，最小二乘法可以帮助我们推导出所有自变量的系数，并最小化误差。我使用矩阵的形式，为你推导了整个过程。</p><p>不过，到目前为止，我们都只是从理论上理解最小二乘法，可能你还没有太深的感触。下一节，我会通过一个具体的例子来逐步进行演算，并使用Python代码对最终的结果进行验证。</p><h2>思考题</h2><p>还记得在29讲的线性回归案例吗？我们使用了Boston Housing的数据，拟合出了十多个自变量的系数。请使用这些系数，计算train.csv中所有样本因变量预测值和真实值之间的误差。你可以使用Python代码来实现一下。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "40 | 线性回归（中）：如何使用最小二乘法进行直线拟合？",
      },
      {
        title: "41 | 线性回归（下）：如何使用最小二乘法进行效果验证？",
        herf: "https://time.geekbang.org/column/article/86766",
        id: "86766",
        content:
          '<p>你好，我是黄申。</p><p>上一节我们已经解释了最小二乘法的核心思想和具体推导过程。今天我们就用实际的数据操练一下，这样你的印象就会更加深刻。我会使用几个具体的例子，演示一下如何使用最小二乘法的结论，通过观测到的自变量和因变量值，来推算系数，并使用这个系数来进行新的预测。</p><h2>基于最小二乘法的求解</h2><p>假想我们手头上有一个数据集，里面有3条数据记录。每条数据记录有2维特征，也就是2个自变量，和1个因变量。</p><p><img src="https://static001.geekbang.org/resource/image/94/b4/9427dc10b0745cb5680e911e0d0d15b4.png" alt=""></p><p>如果我们假设这些自变量和因变量都是线性的关系，那么我们就可以使用如下这种线性方程，来表示数据集中的样本：</p><p>$b_1·0+b_2·1=1.5$<br>\n$b_1·1-b_2·1=-0.5$<br>\n$b_1·2+b_2·8=14$</p><p>也就是说，我们通过观察数据已知了自变量$x_1$、$x_2$和因变量$y$的值，而要求解的是$b_1$和$b_2$这两个系数。如果我们能求出$b_1$和$b_2$，那么在处理新数据的时候，就能根据新的自变量$x_1$和$x_2$的取值，来预测$y$的值。</p><!-- [[[read_end]]] --><p>可是我们说过，由实际项目中的数据集所构成的这类方程组，在绝大多数情况下，都没有精确解。所以这个时候我们没法使用之前介绍的高斯消元法，而是要考虑最小二乘法。根据上一节的结论，我们知道对于系数矩阵$B$，有：</p><p>$B=(X’X)^{-1}X’Y$</p><p>既然有了这个公式，要求$B$就不难了，让我们从最基本的几个矩阵开始。</p><p><img src="https://static001.geekbang.org/resource/image/f2/9d/f2f70be34564a2e64071cd623d0e3f9d.png" alt=""></p><p>矩阵$(X’X)^{-1}$的求解稍微繁琐一点。逆矩阵的求法我还没讲解过，之前我们说过线性方程组之中，高斯消元和回代的过程，就是把系数矩阵变为单位矩阵的过程。我们可以利用这点，来求解$X^{-1}$。我们把原始的系数矩阵$X$列在左边，然后把单位矩阵列在右边，像$[X | I]$这种形式，</p><p>其中$I$表示单位矩阵。</p><p>然后我们对左侧的矩阵进行高斯消元和回代，把左边矩阵X变为单位矩阵。同时，我们也把这个相应的矩阵操作运用在右侧。这样当左侧变为单位矩阵之后，那么右侧的矩阵就是原始矩阵$X$的逆矩阵$X^{-1}$，具体证明如下：</p><p>$[X | I]$<br>\n$[X^{-1}X | X^{-1}I]$<br>\n$[I | X^{-1}I]$<br>\n$[I | X^{-1}]$</p><p>好了，给定下面的$X’X$矩阵之后，我们使用上述方法来求$(X’X)^{-1}$ 。我把具体的推导过程列在了这里。</p><p><img src="https://static001.geekbang.org/resource/image/1a/ad/1a6f3815a9895fc80f54124a1dae7cad.png" alt=""></p><p>求出$(X’X)^{-1}$之后，我们就可以使用$B=(X’X)^{-1}X’Y$来计算矩阵B。</p><p><img src="https://static001.geekbang.org/resource/image/fe/3d/fe4c0b674649e5a18b5992c71316253d.png" alt=""></p><p>最终，我们求出系数矩阵为$[1 1.5]$，也就是说$b_1 = 1$, $b_2 = 1.5$。实际上，这两个数值是精确解。我们用高斯消元也是能获得同样结果的。接下来，让我稍微修改一下$y$值，让这个方程组没有精确解。</p><p>$b_1·0+b_2·1=1.4$<br>\n$b_1·1-b_2·1=-0.48$<br>\n$b_1·2+b_2·8=13.2$</p><p>你可以尝试高斯消元法对这个方程组求解，你会发现只要两个方程就能求出解，但是无论是哪两个方程求出的解，都无法满足第三个方程。</p><p>那么通过最小二乘法，我们能不能求导一个近似解，保证_ε_足够小呢？下面，让我们遵循之前求解$(X’X)^{-1}X’Y$的过程，来计算$B$。</p><p><img src="https://static001.geekbang.org/resource/image/f3/10/f3653f2fd1220936834777b62cced310.png" alt=""></p><p>计算完毕之后，你会发现两个系数的值分别变为$b_1 = 0.938, b_2 = 1.415$。由于这不是精确解，所以让我们看看有了这系数矩阵$B$之后，原有的观测数据中，真实值和预测值的差别。</p><p>首先我们通过系数矩阵$B$和自变量矩阵$X$计算出来预测值。</p><p><img src="https://static001.geekbang.org/resource/image/a3/7a/a3cf56dc09e8e53304060a418ea9707a.png" alt=""></p><p>然后是样本数据中的观测值。这里我们假设这些值是真实值。</p><p><img src="https://static001.geekbang.org/resource/image/a6/d9/a693f3f03a81c01d7f34e615ce473cd9.png" alt=""></p><p>根据误差$ε$的定义，我们可以得到：</p><p><img src="https://static001.geekbang.org/resource/image/94/20/947a02d7580305c8f3a6e19d64dbf120.png" alt=""></p><p>说到这里，你可能会怀疑，通过最小二乘法所求得的系数$b_1 = 0.949$和$b_2 = 1.415$，是不是能让$ε$最小呢？这里，我们随机的修改一下这两个系数，变为$b_1 = 0.95$和$b_2 = 1.42$，然后我们再次计算预测的$y$值和$ε$。</p><p><img src="https://static001.geekbang.org/resource/image/36/0e/36d8fb93ae5967f2e75cabd4da43890e.png" alt=""></p><p>很明显，0.064是大于之前的0.0158。</p><p>这两次计算预测值_y_的过程，其实也是我们使用线性回归，对新的数据进行预测的过程。简短地总结一下，线性回归模型根据大量的训练样本，推算出系数矩阵$B$，然后根据新数据的自变量$X$向量或者矩阵，计算出因变量的值，作为新数据的预测。</p><h2>Python代码实现</h2><p>这一部分，我们使用Python的代码，来验证一下之前的推算结果是不是正确，并看看最小二乘法和Python sklearn库中的线性回归，这两种结果的对比。</p><p>首先，我们使用Python numpy库中的矩阵操作来实现最小二乘法。主要的函数操作涉及矩阵的转置、点乘和求逆。具体的代码和注释我列在了下方。</p><pre><code>from numpy import *\n\nx = mat([[0,1],[1,-1],[2,8]])\ny = mat([[1.4],[-0.48],[13.2]])\n\n# 分别求出矩阵X\'、X\'X、(X\'X)的逆\n# 注意，这里的I表示逆矩阵而不是单位矩阵\nprint(&quot;X矩阵的转置X\'：\\n&quot;, x.transpose())\nprint(&quot;\\nX\'点乘X：\\n&quot;, x.transpose().dot(x))\nprint(&quot;\\nX\'X矩阵的逆\\n&quot;, (x.transpose().dot(x)).I)\n\nprint(&quot;\\nX\'X矩阵的逆点乘X\'\\n&quot;, (x.transpose().dot(x)).I.dot(x.transpose()))\nprint(&quot;\\n系数矩阵B：\\n&quot;, (x.transpose().dot(x)).I.dot(x.transpose()).dot(y))\n</code></pre><p>通过上述代码，你可以看到每一步的结果，以及最终的矩阵$B$。你可以把输出结果和之前手动推算的结果进行对比，看看是不是一致。</p><p>除此之外，我们还可把最小二乘法的线性拟合结果和sklearn库中的LinearRegression().fit()函数的结果相比较，具体的代码和注释我也放在了这里。</p><pre><code>import pandas as pd\nfrom sklearn.linear_model import LinearRegression\n\ndf = pd.read_csv(&quot;/Users/shenhuang/Data/test.csv&quot;)\ndf_features = df.drop([\'y\'], axis=1)     #Dataframe中除了最后一列，其余列都是特征，或者说自变量\ndf_targets = df[\'y\']                     #Dataframe最后一列是目标变量，或者说因变量\n\nprint(df_features, df_targets)\nregression = LinearRegression().fit(df_features, df_targets)        #使用特征和目标数据，拟合线性回归模型\nprint(regression.score(df_features, df_targets))        #拟合程度的好坏\nprint(regression.intercept_)\nprint(regression.coef_)            #各个特征所对应的系数\n</code></pre><p>其中，test.csv文件的内容我也列在了这里。</p><p>$x_1,x_2,y$<br>\n$0,1,1.4$<br>\n$1,-1,-0.48$<br>\n$2,8,13.2$</p><p>这样写是为了方便我们使用pandas读取csv文件并加载为dataframe。</p><p>在最终的结果中，1.0表示拟合程度非常好，而-0.014545454545452863表示一个截距，[0.94909091 1.41454545]表示系数$b_1$和$b_2$的值。这个结果和我们最小二乘法的结果有所差别，主要原因是LinearRegression().fit()默认考虑了有线性函数存在截距的情况。那么我们使用最小二乘法是不是也可以考虑有截距的情况呢？答案是肯定的，不过我们首先要略微修改一下方程组和矩阵$X$。如果我们假设有截距存在，那么线性回归方程就要改写为：</p><p>$b_0+b_1·x_1+b_2·x_2+…+b_{n-1}·x_{n-1}+b_n·x_n=y$</p><p>其中，$b_0$表示截距，而我们这里的方程组用例就要改写为：</p><p>$b_0+b_1·0+b_2·1=1.4$<br>\n$b_0+b_1·1-b_2·1=-0.48$<br>\n$b_0+b_1·2+b_2·8=13.2$</p><p>而矩阵$X$要改写为：</p><p><img src="https://static001.geekbang.org/resource/image/41/fb/417cf726043be38e7cf0a46a9eea3bfb.png" alt=""></p><p>然后我们再执行下面这段代码。</p><pre><code>from numpy import *\n\nx = mat([[1,0,1],[1,1,-1],[1,2,8]])\ny = mat([[1.4],[-0.48],[13.2]])\n\nprint(&quot;\\n系数矩阵B：\\n&quot;, (x.transpose().dot(x)).I.dot(x.transpose()).dot(y))\n</code></pre><p>你就会得到：</p><pre><code> 系数矩阵B：\n     [[-0.01454545]\n     [ 0.94909091]\n     [ 1.41454545]]\n\n</code></pre><p>这个结果和LinearRegression().fit()的结果就一致了。</p><p>需要注意的是，使用线性回归的时候，我们都有一个前提假设，那就是数据的自变量和因变量之间现线性关系。如果不是线性关系，那么使用线性模型来拟合的效果一定不好。比如，之前在解释欠拟合的时候，我用过下面这个例子。</p><p><img src="https://static001.geekbang.org/resource/image/0b/a5/0b9f8c88a846626c74a803ee645bc1a5.png" alt=""></p><p>上面这张图的数据分布并没有表达线性关系，所以我们需要对原始的数据进行非线性的变换，或者是使用非线性的模型来拟合。</p><p>那么，我们如何判断一个数据集是不是能用线性模型表示呢？在线性回归中，我们可以使用决定系数R2。这个统计指标使用了回归平方和与总平方和之比，是反映模型拟合度的重要指标。它的取值在0到1之间，越接近于1表示拟合的程度越好、数据分布越接近线性关系。随着自变量个数的增加，R2将不断增大，因此我们还需要考虑方程所包含的自变量个数对R2的影响，这个时候可使用校正的决定系数Rc2。所以，在使用各种科学计算库进行线性回归时，你需要关注R2或者Rc2，来看看是不是一个好的线性拟合。在之前的代码实践中，我们提到的regression.score函数，其实就是返回了线性回归的R2。</p><h2>总结</h2><p>今天我们使用了具体的案例来推导最小二乘法的计算过程，并用Python代码进行了验证。通过最近3节的讲解，相信你对线性方程组求精确解、求近似解、以及如何在线性回归中运用这些方法，有了更加深入的理解。</p><p>实际上，从广义上来说，最小二乘法不仅可以用于线性回归，还可以用于非线性的回归。其主要思想还是要确保误差ε最小，但是由于现在的函数是非线性的，所以不能使用求多元方程求解的办法来得到参数估计值，而需要采用迭代的优化算法来求解，比如梯度下降法、随机梯度下降法和牛顿法。</p><h2>思考题</h2><p>我这里给出一个新的方程组，请通过最小二乘法推算出系数的近似解，并使用你熟悉的语言进行验证。</p><p>$b_1+b_2·3+b_3·(-7)=-7.5$<br>\n$b_1·2+b_2·5+b_3·4=5.2$<br>\n$b_1·(-3)+b_2·(-7)+b_3·(-2)=-7.5$<br>\n$b_1·1+b_2·4+b_3·(-12)=-15$</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "41 | 线性回归（下）：如何使用最小二乘法进行效果验证？",
      },
      {
        title: "42 | PCA主成分分析（上）：如何利用协方差矩阵来降维？",
        herf: "https://time.geekbang.org/column/article/87097",
        id: "87097",
        content:
          '<p>你好，我是黄申。</p><p>在概率统计模块，我详细讲解了如何使用各种统计指标来进行特征的选择，降低用于监督式学习的特征之维度。接下来的几节，我会阐述两种针对数值型特征，更为通用的降维方法，它们是<strong>主成分分析PCA</strong>（Principal Component Analysis）和<strong>奇异值分解SVD</strong>（Singular Value Decomposition）。这两种方法是从矩阵分析的角度出发，找出数据分布之间的关系，从而达到降低维度的目的，因此并不需要监督式学习中样本标签和特征之间的关系。</p><h2>PCA分析法的主要步骤</h2><p>我们先从主成分分析PCA开始看。</p><p>在解释这个方法之前，我先带你快速回顾一下什么是特征的降维。在机器学习领域中，我们要进行大量的特征工程，把物品的特征转换成计算机所能处理的各种数据。通常，我们增加物品的特征，就有可能提升机器学习的效果。可是，随着特征数量不断的增加，特征向量的维度也会不断上升。这不仅会加大机器学习的难度，还会影响最终的准确度。针对这种情形，我们需要过滤掉一些不重要的特征，或者是把某些相关的特征合并起来，最终达到在减少特征维度的同时，尽量保留原始数据所包含的信息。</p><p>了解了这些，我们再来看今天要讲解的PCA方法。它的主要步骤其实并不复杂，我一说你就能明白，但是为什么要这么做，你可能并不理解。咱们学习一个概念或者方法，不仅要知道它是什么，还要明白是怎么来的，这样你就能知其然，知其所以然，明白背后的逻辑，达到灵活运用。因此，我先从它的运算步骤入手，给你讲清楚每一步，然后再解释方法背后的核心思想。</p><!-- [[[read_end]]] --><p>和线性回归的案例一样，我们使用一个矩阵来表示数据集。我们假设数据集中有m个样本、n维特征，而这些特征都是数值型的，那么这个集合可以按照如下的方式来展示。</p><p><img src="https://static001.geekbang.org/resource/image/10/e2/10cf8973fd0f94e778c808bdda2881e2.png" alt=""></p><p>那么这个样本集的矩阵形式就是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/fb/20/fb10462182f9cc58b389771316f40720.png" alt=""></p><p>这个矩阵是m×n维的，其中每一行表示一个样本，而每一列表示一维特征。让我们把这个矩阵称作样本矩阵，现在，我们的问题是，能不能通过某种方法，找到一种变换，可以降低这个矩阵的列数，也就是特征的维数，并且尽可能的保留原始数据中有用的信息？</p><p>针对这个问题，PCA分析法提出了一种可行的解决方案。它包括了下面这样几个主要的步骤：</p><ol>\n<li>\n<p>标准化样本矩阵中的原始数据；</p>\n</li>\n<li>\n<p>获取标准化数据的协方差矩阵；</p>\n</li>\n<li>\n<p>计算协方差矩阵的特征值和特征向量；</p>\n</li>\n<li>\n<p>依照特征值的大小，挑选主要的特征向量；</p>\n</li>\n<li>\n<p>生成新的特征。</p>\n</li>\n</ol><p>下面，我们一步步来看。</p><h3>1.标准化原始数据</h3><p>之前我们已经介绍过特征标准化，这里我们需要进行同样的处理，才能让每维特征的重要性具有可比性。为了便于你回顾，我把标准化的公式列在了这里。</p><p>$x’=\\frac{x-μ}{σ}$</p><p>其中$x$为原始值，$u$为均值，$σ$为标准差，$x’$是变换后的值。需要注意的是，这里标准化的数据是针对同一种特征，也是在同一个特征维度之内。不同维度的特征不能放在一起进行标准化。</p><h3>2.获取协方差矩阵</h3><p>首先，我们来看一下什么是协方差（Covariance），以及协方差矩阵。协方差是用于衡量两个变量的总体误差。假设两个变量分别是$x$和$y$，而它们的采样数量都是$m$，那么协方差的计算公式就是如下这种形式：</p><p><img src="https://static001.geekbang.org/resource/image/27/c2/2732d3255408c3bb4e01f6c2bd4499c2.png" alt=""></p><p>其中$x_k$表示变量$x$的第$k$个采样数据，$\\bar{x}$表示这$k$个采样的平均值。而当两个变量是相同时，协方差就变成了方差。</p><p>那么，这里的协方差矩阵又是什么呢？我们刚刚提到了样本矩阵，假设$X_{,1}$表示样本矩阵$X$的第$1$列，$X_{,2}$表示样本矩阵$X$的第$2$列，依次类推。而$cov(X_{,1},X_{,1})$表示第1列向量和自己的协方差，而$cov(X_{,1},X_{,2})$表示第1列向量和第2列向量之间的协方差。结合之前协方差的定义，我们可以得知：</p><p><img src="https://static001.geekbang.org/resource/image/a3/a0/a3664cc303c7473df6dae33c6a0fbca0.png" alt=""></p><p>其中，$x_{k,i}$表示矩阵中第$k$行，第$i$列的元素。 $\\bar{X_{,i}}$表示第$i$列的平均值。</p><p>有了这些符号表示，我们就可以生成下面这种协方差矩阵。</p><p><img src="https://static001.geekbang.org/resource/image/ff/6c/ffe746718b2dde0a76051066326d226c.png" alt=""></p><p>从协方差的定义可以看出，$cov(X_{,i},X_{,j})=cov(X_{,j},X_{,i})$，所以$COV$是个对称矩阵。另外，我们刚刚提到，对于$cov(X_{,i},X_{,j})$，如果$i=j$，那么$cov(X_{,i},X_{,j})$也就是$X_{,j}$这组数的方差。所以这个对称矩阵的主对角线上的值就是各维特征的方差。</p><h3>3.计算协方差矩阵的特征值和特征向量</h3><p>需要注意的是，这里所说的矩阵的特征向量，和机器学习中的特征向量（Feature Vector）完全是两回事。矩阵的特征值和特征向量是线性代数中两个非常重要的概念。对于一个矩阵$X$，如果能找到向量$v$和标量$λ$，使得下面这个式子成立。</p><p>$Xv=λv$</p><p>那么，我们就说$v$是矩阵$X$的特征向量，而$λ$是矩阵$X$的特征值。矩阵的特征向量和特征值可能不止一个。说到这里，你可能会好奇，特征向量和特征值表示什么意思呢？我们为什么要关心这两个概念呢？简单的来说，我们可以把向量$v$左乘一个矩阵$X$看做对$v$进行旋转或拉伸，而这种旋转和拉伸都是由于左乘矩阵$X$后，所产生的“运动”所导致的。特征向量$v$表示了矩阵$X$运动的方向，特征值$λ$表示了运动的幅度，这两者结合就能描述左乘矩阵$X$所带来的效果，因此被看作矩阵的“特征”。在PCA中的主成分，就是指特征向量，而对应的特征值的大小，就表示这个特征向量或者说主成分的重要程度。特征值越大，重要程度越高，我们要优先现在这个主成分，并利用这个主成分对原始数据进行变换。</p><p>如果你还是有些困惑，我会在下面一节，讲解更多的细节。现在，让我们先来看看给定一个矩阵，如何计算它的特征值和特征向量，并完成PCA分析的剩余步骤。我在下面列出了计算特征值的推导过程：</p><p>$Xv=λv$<br>\n$Xv-λv=0$<br>\n$Xv-λIv=0$<br>\n$(X-λI)v=0$</p><p>其中I是单位矩阵。对于上面推导中的最后一步，我们需要计算矩阵的行列式。</p><p><img src="https://static001.geekbang.org/resource/image/37/d0/373722f933c8a6afc97052c5f3686ed0.png" alt=""></p><p>$(x_{1,1}-λ)(x_{2,2}-λ)…(x_{n,n}-λ)+x_{1,2}x_{2,3}…x_{n-1,n}x_{n,1}+…)-(x_{n,1}x_{n-1,2}…x_{2,n-1}x_{1,n})=0$</p><p>最后，通过解这个方程式，我们就能求得各种λ的解，而这些解就是特征值。计算完特征值，我们可以把不同的λ值代入$λE-A$，来获取特征向量。</p><p><img src="https://static001.geekbang.org/resource/image/17/cb/1776be34cd7d73453a33e7259abbe0cb.png" alt=""></p><h3>4.挑选主要的特征向量，转换原始数据</h3><p>假设我们获得了k个特征值和对应的特征向量，那么我们就有：</p><p>$Xv_1=λ_1v_1$<br>\n$Xv_2=λ_2v_2$<br>\n$…$<br>\n$Xv_k=λ_kv_k$</p><p>按照所对应的λ数值的大小，对这k组的v排序。排名靠前的v就是最重要的特征向量。</p><p>假设我们只取前k1个最重要的特征，那么我们使用这k1个特征向量，组成一个n×k1维的矩阵D。</p><p>把包含原始数据的m×n维矩阵X左乘矩阵D，就能重新获得一个m×k1维的矩阵，达到了降维的目的。</p><p>有的时候，我们无法确定k1取多少合适。一种常见的做法是，看前k1个特征值的和占所有特征值总和的百分比。假设一共有10个特征值，总和是100，最大的特征值是80，那么第一大特征值占整个特征值之和的80%，我们认为它能表示80%的信息量，还不够多。那我们就继续看第二大的特征值，它是15，前两个特征值之和有95，占比达到了95%，如果我们认为足够了，那么就可以只选前两大特征值，把原始数据的特征维度从10维降到2维。</p><h2>小结</h2><p>这一节，我首先简要地重温了为什么有时候需要进行特征的降维和基于分类标签的特征选择。随后，我引出了和特征选择不同的另一种方法，基于矩阵操作的PCA主成分分析。这种方法的几个主要步骤包括，标准化原始数据、获得不同特征的协方差矩阵、计算协方差矩阵的特征值和特征向量、选择最重要的主成分，以及通过所选择的主成分来转换原始的数据集。</p><p>要理解PCA分析法是有一定难度的，主要是因为两点原因：第一，计算的步骤有些复杂。第二，这个方法的核心思路有些抽象。这两点可能会让刚刚接触PCA的学习者，感到无从下手。</p><p>为了帮助你更好的理解，下一节，我会使用一个示例的矩阵进行详细的推算，并用两种Python代码进行结果的验证。除此之外，我还会分析几个要点，包括PCA为什么使用协方差矩阵？这个矩阵的特征值和特征向量又表示什么？为什么特征值最大的主成分涵盖最多的信息量？明白了这些，你就能深入理解为什么PCA分析法要有这些步骤，以及每一步都代表什么含义。</p><h2>思考题</h2><p>给定这样一个矩阵：</p><p><img src="https://static001.geekbang.org/resource/image/96/9f/962b0abb078974d1d964627e43081f9f.png" alt=""></p><p>假设这个矩阵的每一列表示一个特征的维度，每一行表示一个样本。请完成</p><ol>\n<li>\n<p>按照列（也就是同一个特征维度）进行标准化。</p>\n</li>\n<li>\n<p>生成这个矩阵的协方差矩阵。</p>\n</li>\n</ol><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "42 | PCA主成分分析（上）：如何利用协方差矩阵来降维？",
      },
      {
        title:
          "43 | PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？",
        herf: "https://time.geekbang.org/column/article/87337",
        id: "87337",
        content:
          '<p>你好，我是黄申，今天我们继续来聊PCA主成分分析的下半部分。</p><p>上一节，我们讲解了一种特征降维的方法：PCA主成分分析。这个方法主要是利用不同维度特征之间的协方差，构造一个协方差矩阵，然后获取这个矩阵的特征值和特征向量。根据特征值的大小，我们可以选取那些更为重要的特征向量，或者说主成分。最终，根据这些主成分，我们就可以对原始的数据矩阵进行降维。</p><p>PCA方法的操作步骤有些繁琐，并且背后的理论支持也不是很直观，因此对于初学者来说并不好理解。考虑到这些，我今天会使用一个具体的矩阵示例，详细讲解每一步操作的过程和结果，并辅以基于Python的核心代码进行分析验证。除此之外，我还会从多个角度出发，分析PCA方法背后的理论，帮助你进一步的理解和记忆。</p><h2>基于Python的案例分析</h2><p>这么说可能有一些抽象，让我使用一个具体的案例来帮你理解。假设我们有一个样本集合，包含了3个样本，每个样本有3维特征$x_1$，$x_2$和$x_3$。</p><p><img src="https://static001.geekbang.org/resource/image/96/9f/962b0abb078974d1d964627e43081f9f.png" alt=""></p><p>在标准化的时候，需要注意的是，我们的分母都使用m而不是m-1，这是为了和之后Python中sklearn库的默认实现保持一致。</p><!-- [[[read_end]]] --><p>首先需要获取标准化之后的数据。</p><p>第一维特征的数据是1，2，-3。平均值是0，方差是</p><p>$\\sqrt{\\frac{1+4+9}{3}}≈2.16$</p><p>标准化之后第一维特征的数据是1/2.16=0.463，2/2.16=0.926，-3/2.16=-1.389。以此类推，我们可以获得第二个维度和第三个维度标准化之后的数据。</p><p>当然，全部手动计算工作量不小，这时可以让计算机做它擅长的事情：重复性计算。下面的Python代码展示了如何对样本矩阵的数据进行标准化。</p><pre><code>from numpy import *\nfrom numpy import linalg as LA\nfrom sklearn.preprocessing import scale\n\n# 原始数据，包含了3个样本和3个特征，每一行表示一个样本，每一列表示一维特征\nx = mat([[1,3,-7],[2,5,-14],[-3,-7,2]])\n\n# 矩阵按列进行标准化\nx_s = scale(x, with_mean=True, with_std=True, axis=0)\nprint(&quot;标准化后的矩阵：&quot;, x_s)\n</code></pre><p>其中，scale函数使用了axis=0，表示对列进行标准化，因为目前的矩阵排列中，每一列代表一个特征维度，这点需要注意。如果矩阵排列中每一行代表一个特征维度，那么可以使用axis=1对行进行标准化。</p><p>最终标准化之后的矩阵是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/94/2e/94b28f8127ced76a795e8ef1a38a532e.png" alt=""></p><p>接下来是协方差的计算。对于第1维向量的方差，有</p><p>$\\frac{0.463^2 +0.926^2+(-1.389^2)}{2}≈1.5$</p><p>第1维和第2维向量之间的协方差是</p><p>$\\frac{0.463×0.508+0.926×0.889+(-1.389)×(-1.397)}{2}≈1.5$</p><p>以此类推，我们就可以获得完整的协方差矩阵。同样的，为了减少推算的工作量，我们可以使用Python代码获得协方差矩阵。</p><pre><code># 计算协方差矩阵，注意这里需要先进行转置，因为这里的函数是看行与行之间的协方差\nx_cov = cov(x_s.transpose())\n# 输出协方差矩阵\nprint(&quot;协方差矩阵：\\n&quot;, x_cov, &quot;\\n&quot;)\n</code></pre><p>和sklearn中的标准化函数scale有所不同，numpy中的协方差函数cov除以的是(m-1)，而不是m。最终完整的协方差矩阵是：</p><p><img src="https://static001.geekbang.org/resource/image/58/31/585248158037b17596803624dd708d31.png" alt=""></p><p>然后，我们要求解协方差矩阵的特征值和特征向量。</p><p><img src="https://static001.geekbang.org/resource/image/d7/38/d7344d083edfddad1cf64e8faf52f038.png" alt=""></p><p>最后化简为：</p><p>$-λ^3+4.5λ^2=0.343λ=0$<br>\n$λ(0.0777-λ)(λ-4.4223)=0$</p><p>所以$λ$有3个近似解，分别是0、0.0777和4.4223。</p><p>特征向量的求解过程如果手动推算比较繁琐，我们还是利用Python语言直接求出特征值和对应的特征向量。</p><pre><code># 求协方差矩阵的特征值和特征向量\neigVals,eigVects = LA.eig(x_cov)\nprint(&quot;协方差矩阵的特征值：&quot;, eigVals)\nprint(&quot;协方差的特征向量（主成分）：\\n&quot;, eigVects, &quot;\\n&quot;)\n</code></pre><p>我们可以得到三个特征值及它们对应的特征向量。</p><p><img src="https://static001.geekbang.org/resource/image/ad/94/ad822f51bc6d1f741717d2abe6f3b694.png" alt=""></p><p>需要注意，Python代码输出的特征向量是列向量，而我表格中列出的是行向量。</p><p>我使用下面的这段代码，找出特征值最大的特征向量，也就是最重要的主成分，然后利用这个主成分，对原始的样本矩阵进行变换。</p><pre><code># 找到最大的特征值，及其对应的特征向量\nmax_eigVal = -1\nmax_eigVal_index = -1\n\nfor i in range(0, eigVals.size):\n    if (eigVals[i] &gt; max_eigVal):\n        max_eigVal = eigVals[i]\n        max_eigVal_index = i\n\n    eigVect_with_max_eigVal = eigVects[:,max_eigVal_index]\n\n# 输出最大的特征值及其对应的特征向量，也就是第一个主成分\nprint(&quot;最大的特征值：&quot;, max_eigVal)\nprint(&quot;最大特征值所对应的特征向量：&quot;, eigVect_with_max_eigVal)\n\n# 输出变换后的数据矩阵。注意，这里的三个值是表示三个样本，而特征从3维变为1维了。\nprint(&quot;变换后的数据矩阵：&quot;, x_s.dot(eigVect_with_max_eigVal), &quot;\\n&quot;)\n</code></pre><p>很明显，最大的特征值是4.422311507725755，对应的特征向量是[-0.58077228 -0.57896098 0.57228292]。变换后的样本矩阵是：</p><p><img src="https://static001.geekbang.org/resource/image/48/ce/486d7bd7918b92fc7a1ef3798ecfd2ce.png" alt=""><br>\n它从原来的3个特征维度降维1个特征维度了。</p><p>Python的sklearn库也实现了PCA，我们可以通过下面的代码来尝试一下。</p><pre><code>from sklearn.decomposition import PCA\n\n# 挑选前2个主成分\npca = PCA(n_components=2)\n\n# 进行PCA分析\npca.fit(x_s)\n\n# 输出变换后的数据矩阵。注意，这里的三个值是表示三个样本，而特征从3维变为1维了。\nprint(&quot;方差（特征值）: &quot;, pca.explained_variance_)\nprint(&quot;主成分（特征向量）&quot;, pca.components_)\nprint(&quot;变换后的样本矩阵：&quot;, pca.transform(x_s))\nprint(&quot;信息量: &quot;, pca.explained_variance_ratio_)\n</code></pre><p>这段代码中，我把输出的主成分设置为2，也就是说挑出前2个最重要的主成分。相应的，变化后的样本矩阵有2个特征维度。</p><p><img src="https://static001.geekbang.org/resource/image/11/5f/11271b41ece4f3cfc27a6aee14e4f05f.png" alt=""></p><p>除了输出主成分和变换后的矩阵，sklearn的PCA分析还提供了信息量的数据。</p><pre><code>信息量:  [0.98273589 0.01726411]\n</code></pre><p>它是各个主成分的方差所占的比例，表示第一个主成分包含了原始样本矩阵中的98.27%的信息，而第二个主成分包含了原始样本矩阵中的1.73%的信息，可想而知，最后一个主成分提供的信息量基本为0了，我们可以忽略不计了。如果我们觉得95%以上的信息量就足够了，那么就可以只保留第一个主成分，把原始的样本矩阵的特征维度降到1维。</p><p>当然，学习的更高境界，不是仅仅“知其然”，还要做到“知其所以然”。即使现在你对PCA的操作步骤了如指掌，可能还是有不少疑惑，比如，为什么我们要使用协方差矩阵？这个矩阵的特征值和特征向量又表示什么？为什么选择特征值最大的主成分，就能涵盖最多的信息量呢？不用着急，接下来，我会给你做出更透彻的解释，让你不仅明白如何进行PCA分析，同时还明白为什么要这么做。</p><h2>PCA背后的核心思想</h2><h3>为什么要使用协方差矩阵？</h3><p>首先要回答的第一个问题是，为什么我们要使用样本数据中，各个维度之间的协方差，来构建一个新的协方差矩阵？要弄清楚这一点，首先要回到PCA最终的目标：降维。降维就是要去除那些表达信息量少，或者冗余的维度。</p><p>我们首先来看如何定义维度的信息量大小。这里我们认为样本在某个特征上的差异就越大，那么这个特征包含的信息量就越大，就越重要。相反，信息量就越小，需要被过滤掉。很自然，我们就能想到使用某维特征的方差来定义样本在这个特征维度上的差异。</p><p>另一方面，我们要看如何发现冗余的信息。如果两种特征是有很高的相关性，那我们可以从一个维度的值推算出另一个维度的值，所表达的信息就是重复的。在概率和统计模块，我介绍过多个变量间的相关性，而在实际运用中，我们可以使用皮尔森（Pearson）相关系数，来描述两个变量之间的线性相关程度。这个系数的取值范围是$[-1,1]$，绝对值越大，说明相关性越高，正数表示正相关，负数表示负相关。</p><p>我使用下面这张图，来表示正相关和负相关的涵义。左侧$X$曲线和$Y$曲线有非常近似的变化趋势，当$X$上升$Y$往往也是上升的，$X$下降$Y$往往也下降，这表示两者有较强的正相关性。右侧$X$和$Y$两者相反，当$X$上升的时候，$Y$往往是下降的，$X$下降的时候，$Y$往往是上升，这表示两者有较强的负相关性。</p><p><img src="https://static001.geekbang.org/resource/image/1f/cf/1fb2ca1b83f4d01c9b1e4cd7bc6ef7cf.png" alt=""></p><p>皮尔森系数计算公式如下：</p><p><img src="https://static001.geekbang.org/resource/image/75/17/75f30694d8ef651299d322361848a117.png" alt=""></p><p>其中$n$表示向量维度，$x_{k,i}$和$x_{k,j}$分别为两个特征维度$i$和$j$在第$k$个采样上的数值。 $\\bar{x_{,i}}$和$\\bar{x_{,j}}$分别表示两个特征维度上所有样本的均值，$σx$和$σy$分别表示两个特征维度上所有样本的标准差。</p><p>我把皮尔森系数的公式稍加变化，你来观察一下皮尔森系数和协方差之间的关系。</p><p><img src="https://static001.geekbang.org/resource/image/52/51/52128104b8b2cacbffd8c2ef720cba51.png" alt=""></p><p>你看，变换后的分子不就是协方差吗？而分母类似于标准化数据中的分母。所以在本质上，皮尔森相关系数和数据标准化后的协方差是一致的。</p><p>考虑到协方差既可以衡量信息量的大小，也可以衡量不同维度之间的相关性，因此我们就使用各个维度之间的协方差所构成的矩阵，作为PCA分析的对象。就如前面说讲述的，这个协方差矩阵主对角线上的元素是各维度上的方差，也就体现了信息量，而其他元素是两两维度间的协方差，也就体现了相关性。</p><p>既然协方差矩阵提供了我们所需要的方差和相关性，那么下一步，我们就要考虑对这个矩阵进行怎样的操作了。</p><h3>为什么要计算协方差矩阵的特征值和特征向量？</h3><p>关于这点，我们可以从两个角度来理解。</p><p>第一个角度是对角矩阵。所谓对角矩阵，就是说只有矩阵主对角线之上的元素有非0值，而其他元素的值都为0。我们刚刚解释了协方差矩阵的主对角线上，都是表示信息量的方差，而其他元素都是表示相关性的协方差。既然我们希望尽可能保留大信息量的维度，而去除相关的维度，那么就意味着我们希望对协方差进行对角化，尽可能地使得矩阵只有主对角线上有非0元素。</p><p>假如我们确实可以把矩阵尽可能的对角化，那么对角化之后的矩阵，它的主对角线上元素就是、或者接近矩阵的特征值，而特征值本身又表示了转换后的方差，也就是信息量。而此时，对应的各个特征向量之间是基本正交的，也就是相关性极低甚至没有相关性。</p><p>第二个角度是特征值和特征向量的几何意义。在向量空间中，对某个向量左乘一个矩阵，实际上是对这个向量进行了一次变换。在这个变换的过程中，被左乘的向量主要发生旋转和伸缩这两种变化。如果左乘矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就称为这个矩阵的特征向量，而伸缩的比例就是特征值。换句话来说，某个矩阵的特征向量表示了这个矩阵在空间中的变换方向，这些方向都是趋于正交的，而特征值表示每个方向上伸缩的比例。</p><p>如果一个特征值很大，那么说明在对应的特征向量所表示的方向上，伸缩幅度很大。这也是为什么，我们需要使用原始的数据去左乘这个特征向量，来获取降维后的新数据。因为这样做可以帮助我们找到一个方向，让它最大程度地包含原有的信息。需要注意的是，这个新的方向，往往不代表原始的特征，而是多个原始特征的组合和缩放。</p><h2>小结</h2><p>这两节，我详细讲解了PCA主成分分析法，它是一种针对数值型特征、较为通用的降维方法。和特征选择不同，它并不需要监督式学习中的样本标签，而是从不同维度特征之间的关系出发，进行了一系列的操作和分析。主要步骤包括，标准化原始的数据矩阵、构建协方差矩阵、计算这种协方差矩阵的特征值和特征向量、挑选较大特征值所对应的特征向量、进行原始特征数据的转换。如果排名靠前的特征向量，或者说主成分，已经包括了足够的信息量，那么我们就可以通过选择较少的主成分，对原始的样本矩阵进行转换，从而达到降维的目的。</p><p>PCA方法一开始不是很好理解，其主要的原因之一是它背后的核心思想并不是很直观。为此，我详细解释了为什么PCA会从标准化和协方差入手来构建协方差矩阵。对于同类的特征来说，标准化之后的协方差就是方差，表示了这一维特征所包含的信息量。而对于不同类的特征来说，标准化之后的协方差体现了这两维特征的相关性。鉴于这两个特性，我们需要求解协方差矩阵的特征值和特征向量。如果你弄清楚了这几个关键点，那么PCA方法也就不难理解了。</p><h2>思考题</h2><p>到目前为止，我们讲解了两种特征降维的方法。第一，在监督式学习中，基于分类标签的特征选择；第二，基于特征协方差矩阵的PCA主成分分析。请尝试从你自己的理解，来说说这两种降维方法各自的优缺点。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title:
          "43 | PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？",
      },
      {
        title: "44 | 奇异值分解：如何挖掘潜在的语义关系？",
        herf: "https://time.geekbang.org/column/article/87657",
        id: "87657",
        content:
          '<p>你好，我是黄申。</p><p>今天，我们来聊另一种降维的方法，<strong>SVD奇异值分解</strong>（Singular Value Decomposition）。它的核心思路和PCA不同。PCA是通过分析不同维度特征之间的协方差，找到包含最多信息量的特征向量，从而实现降维。而SVD这种方法试图通过样本矩阵本身的分解，找到一些“潜在的因素”，然后通过把原始的特征维度映射到较少的潜在因素之上，达到降维的目的。</p><p>这个方法的思想和步骤有些复杂，它的核心是矩阵分解，首先，让我们从方阵的矩阵分解开始。</p><h2>方阵的特征分解</h2><p>在解释方阵的分解时，我们会用到两个你可能不太熟悉的概念：方阵和酉矩阵。为了让你更顺畅的理解整个分解的过程，我先给你解释下这两个概念。</p><p><strong>方阵</strong>（Square Matrix）是一种特殊的矩阵，它的行数和列数相等。如果一个矩阵的行数和列数都是n，那么我们把它称作n阶方阵。</p><p>如果一个矩阵和其转置矩阵相乘得到的是单位矩阵，那么它就是一个<strong>酉矩阵</strong>（Unitary Matrix）。</p><p>$X’X=I$</p><p>其中X’表示X的转置，I表示单位矩阵。换句话说，矩阵X为酉矩阵的充分必要条件是X的转置矩阵和X的逆矩阵相等。</p><p>$X’=X^{-1}$</p><!-- [[[read_end]]] --><p>理解这两个概念之后，让我们来观察矩阵的特征值和特征向量。前两节我们介绍了，对于一个n×n维的矩阵$X$，$n$维向量$v$，标量$λ$，如果有$Xv=λv$。</p><p>那么我们就说$λ$是$X$的特征值，$v$是$X$的特征向量，并对应于特征值$λ$。</p><p>之前我们说过特征向量表示了矩阵变化的方向，而特征值表示了变化的幅度。实际上，通过特征值和特征矩阵，我们还可以把矩阵X进行<strong>特征分解</strong>（Eigendecomposition）。这里矩阵的特征分解，是指把矩阵分解为由其特征值和特征向量表示的矩阵之积的方法。如果我们求出了矩阵$X$的$k$个特征值$λ1，λ2，…，λn$，以及这$n$个特征值所对应的特征向量$v1，v2，…，vn$，那么就有$XV=VΣ$。</p><p>其中，$V$是这$n$个特征向量所张成的n×n维矩阵，而Σ为这n个特征值为主对角线的n×n维矩阵。进一步推导，我们可以得到：</p><p>$XVV^{-1}=VΣV^{-1}$<br>\n$XI=VΣV^{-1}$<br>\n$X=VΣV^{-1}$</p><p>如果我们会把$V$的这$n$个特征向量进行标准化处理，那么对于每个特征向量$V_i$，就有$||V_i||_2=1$，而这表示$V’_iV_i=1$，此时V的n个特征向量为标准正交基，满足$V’V=I$ ， 也就是说V为酉矩阵，有$V’=V^{-1}$ 。这样一来，我们就可以把特征分解表达式写作$X=VΣV’$。</p><p>我们以介绍PCA分析时所用的矩阵为例，验证矩阵的特征分解。当时，我们有一个：</p><p><img src="https://static001.geekbang.org/resource/image/33/0e/3384840ca067f7d9564de1ff74130e0e.png" alt=""></p><p>下面我们需要证明$X=VΣV’$成立，我把推算的过程写在下面了。</p><p><img src="https://static001.geekbang.org/resource/image/83/14/83a16135267b7c38c26fccc0d8a41314.png" alt=""></p><p>讲到这里，相信你对矩阵的特征分解有了一定程度的认识。可是，矩阵$X$必须为对称方阵才能进行有实数解的特征分解。那么如果$X$不是方阵，那么应该如何进行矩阵的分解呢？这个时候就需要用到奇异值分解SVD了。</p><h2>矩阵的奇异值分解</h2><p>SVD分解和特征分解相比，在形式上是类似的。假设矩阵$X$是一个m×n维的矩阵，那么$X$的SVD为$X=UΣV’$。</p><p>不同的地方在于，SVD并不要求要分解的矩阵为方阵，所以这里的$U$和$V’$并不是互为逆矩阵。其中$U$是一个m×m维的矩阵，$V$是一个n×n维的矩阵。而$Σ$是一个m×n维的矩阵，对于$Σ$来说，只有主对角线之上的元素可以为非$0$，其他元素都是$0$，而主对角线上的每个元素就称为<strong>奇异值</strong>。$U$和$V$都是酉矩阵，即满足$U’U=I,V’V=I$。</p><p>现在问题来了，我们应该如何求出，用于SVD分解的$U,Σ和V$这三个矩阵呢？之所以不能使用有实数解的特征分解，是因为此时矩阵X不是对称的方阵。我们可以把$X$的转置$X’$和$X$做矩阵乘法，得到一个n×n维的对称方阵$X’X$。这个时候，我们就能对$X’X$这个对称方阵进行特征分解了，得到的特征值和特征向量满足$(XX’)v_i=λ_iv_i$。</p><p>这样一来，我们就得到了矩阵$X’X$的$n$个特征值和对应的$n$个特征向量$v$。通过$X’X$的所有特征向量构造一个n×n维的矩阵$V$，这就是上述SVD公式里面的$V$矩阵了。通常我们把$V$中的每个特征向量叫作$X$的<strong>右奇异向量</strong>。</p><p>同样的道理，如果我们把X和X’做矩阵乘法，那么会得到一个m×m维的方阵XX’。由于XX’也是方阵，因此我们同样可以对它进行特征分解，得到的特征值和特征向量满足$(XX’)u_i=λ_iu_i$。</p><p>类似地，我们得到了矩阵$XX’$的m个特征值和对应的m个特征向量$u$。通过XX’的所有特征向量构造一个m×m的矩阵$U$。这就是上述SVD公式里面的$U$矩阵了。通常，我们把U中的每个特征向量叫作X的<strong>左奇异向量</strong>。</p><p>现在，包含左右奇异向量的$U$和$V$都求解出来了，只剩下奇异值矩阵$Σ$了。之前我提到，$Σ$除了对角线上是奇异值之外，其他位置的元素都是$0$，所以我们只需要求出每个奇异值$σ$就可以了。这个解可以通过下面的公式推导求得：</p><p>$X=UΣV’$<br>\n$XV=UΣV’V$</p><p>由于$V$是酉矩阵，所以$V’V=I$，就有：</p><p>$XV=UΣI$<br>\n$XV=UΣ$<br>\n$Xv_i=σ_iu_i$<br>\n$σ_i=\\frac{Xv_i}{u_i}$</p><p>其中$v_i$和$u_i$都是列向量。一旦我们求出了每个奇异值$σ$，那么就能得到奇异值矩阵$Σ$。</p><p>通过上述几个步骤，我们就能把一个mxn维的实数矩阵，分解成$X=UΣV’$的形式。说到这里，你可能会疑惑，把矩阵分解成这个形式有什么用呢？实际上，在不同的应用中，这种分解表示了不同的含义。下面，我会使用潜在语义分析的案例，带你看看，在发掘语义关系的时候，SVD分解起到了怎样的关键作用。</p><h2>潜在语义分析和SVD</h2><p>在讲向量空间模型的时候，我解释了文档和词条所组成的矩阵。对于一个大的文档集合，我们首先要构造字典，然后根据字典构造每篇文档的向量，最后通过所有文档的向量构造矩阵。矩阵的行和列分别表示文档和词条。基于这个矩阵、向量空间中的距离、余弦夹角等度量，我们就可以进行基于相似度的信息检索或文档聚类。</p><p>不过，最简单的向量空间模型采用的是精确的词条匹配，它没有办法处理词条形态的变化、同义词、近义词等情况。我们需要使用拉丁语系的取词根（Stemming）操作，并手动建立同义词、近义词词典。这些处理方式都需要人类的语义知识，也非常依赖人工的干预。另外，有些词语并不是同义词或者近义词，但是相互之间也是有语义关系的。例如“学生”“老师”“学校”“课程”等等。</p><p>那么，我们有没有什么模型，可以自动地挖掘在语义层面的信息呢？当然，目前的计算机还没有办法真正理解人类的自然语言，它们需要通过大量的数据，来找到词语之间的关系。下面我们就来看看<strong>潜在语义分析LSA</strong>（Latent Semantic Analysis）或者叫潜在语义索引LSI（Latent Semantic Index）这种方法，是如何做到这点的。</p><p>和一般的向量空间模型有所不同，LSA通过词条和文档所组成的矩阵，发掘词和词之间的语义关系，并过滤掉原始向量空间中存在的一些“噪音”，最终提高信息检索和机器学习算法的精确度。LSA主要包括以下这些步骤。</p><p>第一步，分析文档集合，建立表示文档和词条关系的矩阵。</p><p>第二步，对文档-词条矩阵进行SVD奇异值分解。在LSA的应用场景下，分解之后所得到的奇异值σ对应了一个语义上的“概念”，而$σ$值的大小表示这个概念在整个文档集合中的重要程度。$U$中的左奇异值向量表示了每个文档和这些语义“概念”的关系强弱，$V$中的右奇异值向量表示每个词条和这些语义“概念”的关系强弱。所以说，SVD分解把原来的词条-文档关系，转换成了词条-语义概念-文档关系。</p><p>我画了一张图帮助你理解这个过程。</p><p><img src="https://static001.geekbang.org/resource/image/95/c1/95c4ef346ab87eafcfa6e7236dc0cdc1.png" alt=""></p><p>在这种图中，我们有一个7×5维的矩阵$X$，表示7个文档和5个单词。经过SVD分解之后，我们得到了两个主要的语义概念，一个概念描述了计算机领域，另一个概念描述了医学领域。矩阵U描述文档和这两个概念之间的关系，而矩阵$V’$描述了各个词语和这两个概念之间的关系。如果要对文档进行检索，我们可以使用$U$这个降维之后的矩阵，找到哪些文档和计算机领域相关。同样，对于聚类算法，我们也可以使用U来判断哪些文档属于同一个类。</p><p>第三步，对SVD分解后的矩阵进行降维，这个操作和PCA主成分分析的降维操作是类似的。</p><p>第四步，使用降维后的矩阵重新构建概念-文档矩阵，新矩阵中的元素不再表示词条是不是出现在文档中，而是表示某个概念是不是出现在文档中。</p><p>总的来说，LSA的分解，不仅可以帮助我们找到词条之间的语义关系，还可以降低向量空间的维度。在这个基础之上在运行其他的信息检索或者机器学习算法，就更加有效。</p><h2>总结</h2><p>之前介绍的PCA主成分分析，要求矩阵必须是对称的方阵，因此只适用于刻画特征之间关系的协方差矩阵。但是，有的时候我们需要挖掘的是样本和特征之间的关系，例如文档和词条。这个时候矩阵并不是对称的方阵，因此无法直接使用PCA分析。</p><p>为此，SVD奇异值分解提供了一种可行的方案。它巧妙地运用了矩阵X和自己的转置相乘，生成了两种对称的方阵，并通过这两者的特征分解，获得了SVD中的左奇异向量所组成的矩阵U和右奇异向量所组成的矩阵V，并最终推导出奇异值矩阵Σ。这样，SVD就可以对原始的数据矩阵进行分解，并运用最终的奇异向量进行降维。</p><p>我们可以把SVD运用在很多场合中，在不同的应用场景下，$U，V$和$Σ$代表了不同的含义。例如，在LSA分析中，通过对词条和文档矩阵的SVD分解，我们可以利用Σ获得代表潜在语义的一些概念。而矩阵$U$表示了这些概念和文档之间的关系，矩阵$V$表示了这些概念和单个词语之间的关系。</p><h2>思考题</h2><p>请使用你自己熟悉的语言实现SVD分解。（提示：如果使用Python等科学计算语言，你可以参考本节所讲述的矩阵分解步骤，也可以使用一些现成的科学计算库。）</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title: "44 | 奇异值分解：如何挖掘潜在的语义关系？",
      },
      {
        title: "45 | 线性代数篇答疑和总结：矩阵乘法的几何意义是什么？",
        herf: "https://time.geekbang.org/column/article/88078",
        id: "88078",
        content:
          "<p>你好，我是黄申。今天是线性代数的答疑和总结。</p><p>在这个模块中，我们讲了不少向量、矩阵、线性方程相关的内容。看到大家在留言区的问题，今天我重点说说矩阵乘法的几何意义，以及为什么SVD中$X'X$的特征向量组成了$V$矩阵，而$XX'$的特征向量组成了$U$矩阵。最后，我会对整个线性代数的模块做一个总结。</p><h2>矩阵乘法的几何意义</h2><p>首先，我们来说说矩阵乘法所代表的几何意义。</p><p>在阐述PCA主成分分析的时候，我们聊过为什么这个方法要研究协方差矩阵的特征值和特征向量。其中，我提到对某个向量左乘一个矩阵，实际上是对这个向量进行了一次变换。某个矩阵的特征向量表示了这个矩阵在空间中的变换方向，这些方向都是正交或者趋于正交的，而特征值表示每个方向上伸缩的比例。今天，我会继续深入这个话题，结合实例，给出更详细地解释。</p><p>多维的向量空间很难理解，所以我们还是从最简单的二维空间开始。首先，我们需要明白什么是二维空间中的正交向量。正交向量的定义非常简单，只要两个向量的点乘结果为0，那么它们就是正交的。在酉矩阵之中，矩阵和矩阵的转置相乘为单位矩阵，只有向量自己点乘自己值为1，而不同向量之间点乘值为0，所以不同的向量之间是正交的。</p><!-- [[[read_end]]] --><p>理解了正交向量之后，我们来定义一个二维空间，这个空间的横坐标为$x$，纵坐标为$y$，空间中的一个点坐标为$(1,2)$，对于这个点，我们可以把从原点到它的直线投影到$x$轴和$y$轴，这个直线在$x$轴上投影的长度为1，在y轴上投影的长度为2。我使用下图来表示。</p><p><img src=\"https://static001.geekbang.org/resource/image/67/af/67b0b2634a6c53339b41579bf34f80af.png\" alt=\"\"></p><p>对于这个点，我们使用一个矩阵$X_1$左乘这个点的坐标，你可以看看会发生什么。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/ba/423463beaff43e69429cc6b4f17910ba.png\" alt=\"\"></p><p>我们把结果转成坐标系里的点，它的坐标是$(3, 4)$，把从原点到$(1,2)$的直线，和从原点到$(3,4)$的直线进行比较，你会发现直线发生了旋转，而且长度也发生了变化，这就是矩阵左乘所对应的几何意义。我们还可以对这个矩阵$X_1$分析一下，看看它到底表示了什么含义，以及为什么它会导致直线的旋转和长度发生变化。</p><p>之前我讲过，要看一个矩阵的特征，需要分析它的特征向量和特征值。由于矩阵$X_1$是一个对角矩阵，所以特征值很容易求解，分别是3和2。而对应的特征向量是$[1, 0]$和$[0, 1]$。在二维坐标中，坐标[1, 0]实际上表示的是$x$轴的方向，而[0, 1]实际上表示的是$y$轴的方向。特征值3对应特征向量[1, 0]就表明在$x$轴方向拉伸为原来的3倍，特征值2对应特征向量[0, 1]就表明在$y$轴方向拉伸2倍。所以，矩阵$X_1$的左乘，就表示把原有向量在$x$轴上拉伸为原来的3倍，而在$y$轴上拉伸为原来的2倍。我用下面这张图来展示。</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/80/8e42e5eace66c585d78dfa32226ec780.png\" alt=\"\"></p><p>我们还可以从另一个角度来验证这点，把从原点到$(3, 4)$的直线进行分解，我们会发现这个直线在$x$轴上投影的长度为3，为原来的3倍，而在$y$轴上投影的长度为4，为原来的2倍。</p><p>当然，矩阵的特征向量不一定是$x$轴和$y$轴，它们可以是二维空间中任何相互正交的向量。下面，我们再来看一个稍微复杂一点的例子。这次我们从两个正交的向量开始。</p><p><img src=\"https://static001.geekbang.org/resource/image/32/f3/32bfec48931dcc52354db9624a0d9bf3.png\" alt=\"\"></p><p>我使用下面这张图展示了这两个向量在空间的方向。</p><p><img src=\"https://static001.geekbang.org/resource/image/07/04/0795164dbc78540fc5c0fc56713ae504.png\" alt=\"\"></p><p>然后我用这两个向量构建一个矩阵$V$。</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/de/9a02adc8acb0d8f0b40bdc85eaea9cde.png\" alt=\"\"></p><p>之所以使用这样一个例子，是因为$V$是一个酉矩阵，也就是说$VV'=I$，所以我们可以使用它，外加一个特征值组成的对角矩阵$Σ$，来构建另一个用于测试的矩阵$X_2$。我在SVD的那一讲，介绍过对称方阵可以进行特征值分解，所以我们可以通过$V$和$Σ$，获得一个对称方阵$X_2=VΣV'$。</p><p>我们假设两个特征值分别是0.5和2，所以有：</p><p><img src=\"https://static001.geekbang.org/resource/image/26/6f/2606792083d27b6333428d03918e606f.png\" alt=\"\"></p><p>根据我们之间的解释，如果让这个矩阵$X_2$左乘任何一个向量，就是让向量沿$[\\frac{1}{\\sqrt{2}}    \\frac{1}{\\sqrt{2}}]$方向压缩一半，而在$[\\frac{1}{\\sqrt{2}}    \\frac{-1}{\\sqrt{2}}]$方向增加两倍。为了验证这一点，我们让$X_2$左乘向量$(1, 2)$，获得新向量：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/e3/2dd3d37508be334af83f9d6ec2a17fe3.png\" alt=\"\"></p><p>把这个新的坐标$(-0.25, 1.75)$和原坐标$(1,2)$都放到二维坐标系中，并让它们分别在$[\\frac{1}{\\sqrt{2}}    \\frac{1}{\\sqrt{2}}]$和$[\\frac{1}{\\sqrt{2}}    \\frac{-1}{\\sqrt{2}}]$这两个方向进行投影，然后比较一下投影的长度，你就会发现伸缩的变化了。我使用下面这张图来帮你理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/be/a0/be3adac33d5359d8962ffa55f42ba6a0.png\" alt=\"\"></p><p>弄清楚了矩阵左乘向量的几何意义，那么矩阵左乘矩阵的几何意义也就不难理解了。假设我们让矩阵$X$左乘矩阵$Y$，那么可以把右矩阵$Y$看作一堆列向量的集合，而左乘矩阵$X$就是对每个$Y$中的列向量进行变换。另外，如果二维空间理解了，那么三维、四维直到$n$维空间就可以以此类推了。</p><h2>SVD分解中的$U$和$V$矩阵</h2><p>在讲解SVD奇异值分解的时候，我们解释了$X'X$的特征向量组成了SVD中的$V$矩阵，而$XX'$的特征向量组成了SVD中的$U$矩阵。不过，我们还没有证明这两点。今天我来说说如何证明它们。首先，我们来看看$V$矩阵的证明。</p><p>$X=UΣV'$<br>\n$X'=VΣ'U'$<br>\n$X'X=(VΣ'U)(UΣV')=VΣ'(U'U)Σ'V'=VΣ^2V')$</p><p>其中，$(UΣV')'=VΣ'U'$的证明，我们在最小二乘法的讲解过程中证明过。另外，$U$是酉矩阵，所以$U'U=I$。$Σ$是对角矩阵，所以$Σ'Σ=Σ2$，而且$Σ2$仍然是对角矩阵。</p><p>由于$Σ2$是对角矩阵，所以通过$X'X=VΣ2V'$，我们可以看出$V$中的向量就是$X'X$的特征向量，而特征值是$Σ2$对角线上的值。</p><p>同理，我们也可以证明$U$中的向量就是$XX'$的特征向量。</p><p>$X=UΣV'$<br>\n$X'=VΣ'U'$<br>\n$XX'=(UΣV')(VΣ'U')=UΣ(V'V)Σ'U'=UΣ^2U')$</p><p>从这个证明的过程，我们也发现了，XX'或者X'X特征值矩阵等于奇异值矩阵的平方，也就是说我们可以通过求出X'X特征值的平方根来求奇异值。</p><h2>总结</h2><p>回答完两个问题之后，我来总结一下线性代数这个模块。</p><p>线性代数最基本的概念包括了向量、矩阵以及对应的操作。向量表示了一组数的概念，非常适合表示一个对象的多维特征，因此被广泛的运用在信息检索和机器学习的领域中。而矩阵又包含了多个向量，所以适合表示多个数据对象的集合。同时，矩阵也可以用于表达二维关系，例如网页的邻接矩阵，用户对物品的喜好程度，关键词在文档中的tf-idf等等。</p><p>由于向量和矩阵的特性，我们可以把它们运用在很多算法和模型之中。向量空间模型定义了向量之间的距离或者余弦夹角，我们可以利用这些指标来衡量数据对象之间的相似程度，并把这种相似程度用于定义查询和文档之间的相关性，或者是文档聚类时的归属关系。矩阵的运算体现了对多个向量同时进行的操作，比如最常见的左乘，就可以用在计算PageRank值，协同过滤中的用户或者物品相似度等等。</p><p>当然，矩阵的运用还不止计算数据对象之间的关系。最小二乘法的实现、PCA主成分的分析、SVD奇异值的分解也可以基于矩阵的运算。这些都可以帮助我们发现不同维度特征之间的关系，并利用这些关系找到哪些特征更为重要，选择或者创建更为重要的特征。</p><p>有的时候，线性代数涉及的公式和推导比较繁琐。在思考的过程中，我们可以把矩阵的操作简化为向量之间的操作，而把向量之间的操作简化为多个变量之间的运算。另外，我们可以多结合实际的案例，结合几何空间、动手推算，甚至可以编程实现某些关键的模块，这些都有利于理解和记忆。</p><h2>思考题</h2><p>我想听你说说，学习完了编程领域中常用的线性代数知识，你有哪些收获和心得？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>",
        article_title: "45 | 线性代数篇答疑和总结：矩阵乘法的几何意义是什么？",
      },
    ],
  },
  {
    chapterTitle: "综合应用篇 (6讲)",
    children: [
      {
        title: "46 | 缓存系统：如何通过哈希表和队列实现高效访问？",
        herf: "https://time.geekbang.org/column/article/88408",
        id: "88408",
        content:
          '<p>你好，我是黄申。</p><p>经过前三大模块的学习，我带你纵览了数学在各个计算机编程领域的重要应用。离散数学是基础数据结构和编程算法的基石，而概率统计论和线性代数，是很多信息检索和机器学习算法的核心。</p><p>因此，今天开始，我会综合性地运用之前所讲解的一些知识，设计并实现一些更有实用性的核心模块或者原型系统。通过这种基于案例的讲解，我们可以融汇贯通不同的数学知识，并打造更加高效、更加智能的计算机系统。首先，让我们从一个缓存系统入手，开始综合应用篇的学习。</p><h2>什么是缓存系统？</h2><p>缓存（Cache）是计算机系统里非常重要的发明之一，它在编程领域中有非常非常多的应用。小到电脑的中央处理器（CPU）、主板、显卡等硬件，大到大规模的互联网站点，都在广泛使用缓存来提升速度。而在网站的架构设计中，一般不会像PC电脑那样采用高速的缓存介质，而是采用普通的服务器内存。但是网站架构所使用的内存容量大得多，至少是数个吉字节 （GB）。</p><p>我们可以把缓存定义为数据交换的缓冲区。它的读取速度远远高于普通存储介质，可以帮助系统更快地运行。当某个应用需要读取数据时，会优先从缓存中查找需要的内容，如果找到了则直接获取，这个效率要比读取普通存储更高。如果缓存中没有发现需要的内容，再到普通存储中寻找。</p><!-- [[[read_end]]] --><p>理解了缓存的概念和重要性之后，我们来看下缓存设计的几个主要考量因素。</p><p>第一个因素是<strong>硬件的性能</strong>。缓存的应用场景非常广泛，因此没有绝对的条件来定义何种性能可以达到缓存的资格，我们只要确保以高速读取介质可以充当相对低速的介质的缓冲。</p><p>第二个因素是<strong>命中率</strong>。缓存之所以能提升访问速度，主要是因为能从高速介质读取，这种情况我们称为“命中”（Hit）。但是，高速介质的成本是非常昂贵的，而且一般也不支持持久化存储，因此放入数据的容量必须受到限制，只能是全局信息的一部分。那么，一定是有部分数据无法在缓存中读取，而必须要到原始的存储中查找，这种情况称之为“错过”（Missed）。</p><p>我们通常使用能够在缓存中查找到数据的次数（$|H|$），除以整体的数据访问次数（$|V|$）计算命中率。如果命中率高，系统能够频繁地获取已经在缓存中驻留的数据，速度会明显提升。</p><center>$HitRatio=\\frac{|H|}{|V|}$</center><p>接下来的问题就是，如何在缓存容量有限的情况下，尽可能的提升命中率呢？人们开始研究缓存的淘汰算法，通过某种机制将缓存中可能无用的数据剔除，然后向剔除后空余的空间中补充将来可能会访问的数据。</p><p>最基本的策略包括最少使用LFU（Least Frequently Used）策略和最久未用LRU（Least Recently Used）策略。LFU会记录每个缓存对象被使用的频率，并将使用次数最少的对象剔除。LRU会记录每个缓存对象最近使用的时间，并将使用时间点最久远的对象给剔除。很显然，我们都希望缓存的命中率越高越好。</p><p>第三个因素是<strong>更新周期</strong>。虽然缓存处理的效率非常高，但是，被访问的数据不会一成不变，对于变化速度很快的数据，我们需要将变动主动更新到缓存中，或者让原有内容失效，否则用户将读取到过时的内容。在无法及时更新数据的情况下，高命中率反而变成了坏事，轻则影响用户交互的体验，重则会导致应用逻辑的错误。</p><p>为了方便你的理解，我使用下面这张图，来展现这几个主要因素之间的关系，以及缓存系统的工作流程。</p><p><img src="https://static001.geekbang.org/resource/image/d9/5b/d92decec85a79493f9ef1f87f3add05b.png" alt=""></p><p></p><h2>如何设计一个缓存系统？</h2><p>了解这些基本概念之后，我们就可以开始设计自己的缓存系统了。今天，我重点讲解如何使用哈希表和队列，来设计一个基于最久未用LRU策略的缓存。</p><p>从缓存系统的工作流程可以看出，首先我们需要确认某个被请求的数据，是不是存在于缓存系统中。对于这个功能，哈希表是非常适合的。第2讲我讲过哈希的概念，我们可以通过哈希值计算快速定位，加快查找的速度。不论哈希表中有多少数据，读取、插入和删除操作只需要耗费接近常量的时间，也就是O (1)的时间复杂度 ，这正好满足了缓存高速运作的需求。</p><p>在第18讲，我讲了用数组和链表来构造哈希表。在很多编程语言中，哈希表的实现采用的是链地址哈希表。这种方法的主要思想是，先分配一个很大的数组空间，而数组中的每一个元素都是一个链表的头部。随后，我们就可以根据哈希函数算出的哈希值（也叫哈希的key），找到数组的某个元素及对应的链表，然后把数据添加到这个链表中。之所以要这样设计，是因为存在哈希冲突。所以，我们要尽量找到一个合理的哈希函数，减少冲突发生的机会，提升检索的效率。</p><p>接下来，我们来聊聊缓存淘汰的策略。这里我们使用LRU最久未用策略。在这种策略中，系统会根据数据最近一次的使用时间来排序，使用时间最久远的对象会被淘汰。考虑到这个特性，我们可以使用队列。我在讲解广度优先搜索策略时，谈到了队列。这是一种先进先出的数据结构，先进入队列的元素会优先得到处理。如果充分利用队列的特点，我们就很容易找到上一次使用时间最久的数据，具体的实现过程如下。</p><p>第一，根据缓存的大小，设置队列的最大值。通常的做法是使用缓存里所能存放数据记录量的上限，作为队列里结点的总数的上限，两者保持一致。</p><p>第二，每次访问一个数据后，查看是不是已经存在一个队列中的结点对应于这个数据。如果不是，创造一个对应于这个数据的队列结点，加入队列尾部。如果是，把这个数据所对应的队列结点重新放入队列的尾部。需要注意，这一点是至关重要的。因为这种操作可以保证上一次访问时间最久的数据，所对应的结点永远在队列的头部。</p><p>第三，如果队列已满，我们就需要淘汰一些缓存中的数据。由于队列里的结点和缓存中的数据记录量是一致的，所以队列里的结点数达到上限制，也就意味着缓存也已经满了。刚刚提到，由于第二点的操作，我们只需要移除队列头部的结点就可以了。</p><p>综合上述关于哈希表和队列的讨论，我们可以画出下面这张框架图。</p><p><img src="https://static001.geekbang.org/resource/image/2a/28/2a74d2c598a2aa9952b70e350c49f828.png" alt=""></p><p>从这张图可以看到，我们使用哈希表来存放需要被缓存的内容，然后使用队列来实现LRU策略。每当数据请求进来的时候，缓存系统首先检查数据记录是不是已经存在哈希表中。如果不存在，那么就返回没有查找到，不会对哈希表和队列进行任何的改变；如果已经存在，就直接从哈希表读取并返回。</p><p>与此同时，在队列中进行相应的操作，标记对应记录最后访问的次序。队列头部的结点，对应即将被淘汰的记录。如果缓存或者说队列已满，而我们又需要插入新的缓存数据，那么就需要移除队列头部的结点，以及它所对应的哈希表结点。</p><p>接下来，我们结合这张图，以请求数据记录175为例，详细看看在这个框架中，每一步是如何运作的。</p><p>这里的哈希表所使用的散列函数非常简单，是把数据的所有位数加起来，再对一个非常大的数值例如10^6求余。那么，175的哈希值就是(1+7+5)/10^6=13。通过哈希值13找到对应的链表，然后进行遍历找到记录175。这个时候我们已经完成了从缓存中获取数据。</p><p>不过，由于使用了LRU策略来淘汰旧的数据，所以还需要对保存访问状态的队列进行必要的操作。检查队列，我们发现表示175的结点已经在队列之中了，说明最近这条数据已经被访问过，所以我们要把这个结点挪到队列的最后，让它远离被淘汰的命运。</p><p>我们再来看另一个例子，假设这次需要获取的是数据记录1228，这条记录并不在缓存之中，因此除了从低速介质返回获取的记录，我们还要把这个数据记录放入缓存区，并更新保存访问状态的队列。和记录175不同的是，1228最近没有被访问过，所以我们需要在队列的末尾增加一个表示1201的结点。这个时候，队列已经满了，我们需要让队列头部的结点73出队，然后把相应的记录73从哈希表中删除，最后把记录1228插入到哈希表中作为缓存。</p><h2>总结</h2><p>当今的计算机系统中，缓存扮演着非常重要的角色，小到CPU，大到互联网站点，我们都需要使用缓存来提升系统性能。基于哈希的数据结构可以帮助我们快速的获取数据，所以非常适合运用在缓存系统之中。</p><p>不过，缓存都需要相对昂贵的硬件来实现，因此大小受到限制。所以，我们需要使用不同的策略来淘汰不经常使用的内容，取而代之一些更有可能被使用的内容，增加缓存的命中率，进而提升缓存的使用效果。为了实现这个目标，人们提出了多种淘汰的策略，包括LRU和LFU。</p><p>综合上面两点，我们提出一种结合哈希表和队列的缓存设计方案。哈希表负责快速的存储和更新被缓存的内容，而队列负责管理最近被访问的状态，并告知系统哪些数据是要被淘汰并从哈希表中移除。</p><h2>思考题</h2><p>请根据今天所讲解的设计思想，尝试编码实现一个基于LRU淘汰策略的缓存。哈希表部分可以直接使用编程语言所提供的哈希类数据结构。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title: "46 | 缓存系统：如何通过哈希表和队列实现高效访问？",
      },
      {
        title:
          "47 | 搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？",
        herf: "https://time.geekbang.org/column/article/88774",
        id: "88774",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我们充分利用了哈希表时间复杂度低的特点，设计了一个简单的缓存系统。在实际项目中，哈希表或者类似的哈希数据结构，有着更为广泛的运用。比如，搜索引擎中的倒排索引，也是基于哈希表结构来设计的。这种倒排索引可以大大提升数据对象的检索效率。</p><p>除了搜索的效率，搜索引擎另一个需要考虑的问题是相关性，也就是说，我们需要保证检索出来的信息是满足用户需求的。最简单的基于倒排索引的实现，属于一种布尔排序模型，它只考虑了单词是不是出现在文档之中，如果出现了就返回相应的文档，否则就不返回，对应于布尔模型中的真假值。在这种实现中，只要出现了相关搜索词的文档都会被检索出来，因此相关性比较差。对于这点，我们可以利用向量空间模型，来衡量文档和用户查询之间的相似程度，确保两者是相关的。不过，向量空间模型需要涉及两两之间的比较，时间复杂度比较高。</p><p>考虑到上述两点，今天，我们就以文档检索为例，参照倒排索引加向量空间模型的设计思路，设计一个简单的搜索引擎。</p><h2>搜索引擎的设计框架</h2><p>之前在讲解向量空间模型的时候，我们介绍了信息检索的基础知识，而我们平时经常使用的搜索引擎，就是一种典型的信息检索系统。在讲解如何结合倒排索引和向量空间模型之前，我们先来看，常见的文本搜索引擎都由哪些模块组成。</p><!-- [[[read_end]]] --><p>文本搜索系统的框架通常包括2个重要模块：<strong>离线的预处理</strong>和<strong>在线的查询</strong>。离线预处理也就是我们通常所说的“索引”阶段，包括数据获取、文本预处理、词典和倒排索引的构建、相关性模型的数据统计等。数据的获取和相关性模型的数据统计这两步，根据不同的应用场景，必要性和处理方式有所不同。可是，文本预处理和倒排索引构建这两个步骤，无论在何种应用场景之中都是必不可少的，所以它们是离线阶段的核心。之前我们讲过，常规的文本预处理是指针对文本进行分词、移除停用词、取词干、归一化、扩充同义词和近义词等操作。</p><p>在第17讲里，我讲解了如何使用倒排索引，把文档集转换为从关键词到文档的这种查找关系。有了这种“倒排”的关系，我们可以很高效地根据给定的单词，找到出现过这个单词的文档集合。</p><p>倒排索引是典型的牺牲空间来换取时间的方法。我们假设文章总数是k，每篇文章的单词数量是m，查询中平均的关键词数量是l，那么倒排索引可以把时间复杂度从O(k×logm)降到O(l)。但是，如果使用倒排索引，就意味着除了原始数据，我们还需要额外的存储空间来放置倒排索引。因此，如果我们的字典里，不同的词条总数为$n_1$，每个单词所对应的文章平均数为$n_2$，那么空间复杂度就是O($n_1$×$n_2$)。</p><p>在文本的离线处理完毕后，我们来看在线的文本查询。这个过程相对简单。</p><p>查询一般都会使用和离线模块一样的预处理，词典也是沿用离线处理的结果。当然，也可能会出现离线处理中未曾出现过的新词，我们一般会忽略或给予非常小的权重。在此基础上，系统根据用户输入的查询条件，在倒排索引中快速检出文档，并进行相关性的计算。</p><p>不同的相关性模型，有不同的计算方式。最简单的布尔模型只需要计算若干匹配条件的交集，向量空间模型VSM，则需要计算查询向量和待查文档向量的余弦夹角，而语言模型需要计算匹配条件的贝叶斯概率等等。</p><p>综合上述的介绍，我使用下面这张图来展示搜索引擎的框架设计。</p><p><img src="https://static001.geekbang.org/resource/image/5f/71/5fd4e7baf56b4ee938aa586289965571.png" alt=""></p><h2>倒排索引的设计</h2><p>我们之前已经把倒排索引的概念讲清楚了。不过到具体设计的时候，除了从关键词到文档这种“倒排”的关系，还有其它两个要点值得考虑：第一个是倒排索引里具体存储什么内容，第二个就是多个关键词的查询结果如何取交集。我们下面一个个来看。</p><p>首先我们来聊聊倒排索引里具体存放的内容。</p><p>从倒排索引的概念，我们很容易就想到使用哈希表、尤其是基于链式地址法的哈希表来实现倒排索引。哈希的键（key）就是文档词典的某一个词条，值（value）就是一个链表，链表是出现这个词条的所有文档之集合，而链表的每一个结点，就表示出现过这个词条的某一篇文档。这种最简单的设计能够帮助我们判断哪些文档出现过给定的词条，因此它可以用于布尔模型。但是，如果我们要实现向量空间模型，或者是基于概率的检索模型，就需要很多额外的信息，比如词频（tf）、词频-逆文档频率（tf-idf）、词条出现的条件概率等等。</p><p>另外，有些搜索引擎需要返回匹配到的信息摘要（nippet），因此还需要记住词条出现的位置。这个时候，最简单的倒排索引就无法满足我们的需求了。我们要在倒排索引中加入更多的信息。每个文档列表中，存储的不仅仅是文档的ID，还有其他额外的信息。我使用下面这张图展示了一个示例，帮助你理解这种新的设计。</p><p><img src="https://static001.geekbang.org/resource/image/b4/2d/b4efd06d8eb915d8f68a0ebc4fb6852d.png" alt=""></p><p>其中，ID字段表示文档的ID，tf字段表示词频，tfidf字段表示词频-逆文档频率，而prob表示这个词条在这篇文档中出现的条件概率。</p><p>好了，下面我们来看，如何确定出现所有多个关键词的文档。</p><p>由于倒排索引本身的特性，我们可以很快知道某一个词条对应的文档，也就是说查找出现某一个词条的所有文档是很容易的。可是，如果用户的查询包含多个关键词，那么该如何利用倒排索引，查找出现多个词条的所有文档呢？</p><p>还记得我讲解分治法时，所提到的归并排序吗？在这里，我们可以借鉴其中的合并步骤。假设有两个词条a和b，a对应的文档列表是A，b对应的文档列表是B，而A和B这两个列表中的每一个元素都包含了文档的ID。</p><p>首先，我们根据文档的ID，分别对这两个列表进行从小到大的排序，然后依次比较两个列表的文档ID，如果当前的两个ID相等，就表示这个ID所对应的文档同时包含了a和b两个关键词，所以是符合要求的，进行保留，然后两个列表都拿出下一个ID进行之后的对比。如果列表A的当前ID小于列表B的当前ID，那么表明A中的这个ID一定不符合要求，跳过它，然后拿出A中的下一个ID和B进行比较。同样，如果是列表B的第一个ID更小，那么就跳过B中的这个ID，拿出B中的下一个ID和A进行比较。依次类推，直到遍历完所有A和B中的ID。</p><p>我画了张图来进一步解释这个过程。</p><p><img src="https://static001.geekbang.org/resource/image/ba/89/ba281eeeb565405d95bedcc5a908ae89.png" alt=""></p><p>基于这种两两比较的过程，我们可以推广到比较任意多的列表。此外，在构建倒排索引的时候，我们可以事先对每个词条的文档列表进行排序，从而避免了查询时候的排序过程，达到提升搜索效率的目的。</p><h2>向量空间和倒排索引的结合</h2><p>有了倒排索引的高效查询，向量空间的实现就不难了。还记得之前我们讲解的向量空间模型吗？这个模型假设所有的对象都可以转化为向量，然后使用向量间的距离（通常是欧氏距离）或者是向量间的夹角余弦来表示两个对象之间的相似程度。</p><p>在文本搜索引擎中，我们使用向量来表示每个文档以及用户的查询，而向量的每个分量由每个词条的tf-idf构成，最终用户查询和文档之间的相似度或者说相关性，由文档向量和查询向量的夹角余弦确定。如果能获取这个查询和所有文档之间的相关性得分，那么我们就能对文档进行排序，返回最相关的那些。不过，当文档集合很大的时候，这个操作的复杂度会很高。你可以观察一下这个夹角余弦的公式。</p><p><img src="https://static001.geekbang.org/resource/image/47/58/47a3eb754bc98caab86dc554b4cf7558.png" alt=""></p><p>如果文档中词条的平均数量是n，查询中词条的平均数量是m，那么计算某个查询和某个文档之间的夹角余弦，时间复杂度是O(n×m)。如果整个被索引的文档集合有k个文档，那么计算某个查询和所有文档之间的夹角余弦，时间复杂度就变为O(n×m×k)。</p><p>实际上，很多文档并没有出现查询中的关键词条，所以计算出来的夹角余弦都是0，而这些计算都是可以完全避免的，解决方案就是倒排索引。通过倒排索引，我们挑选出那些出现过查询关键词的文档，并仅仅针对这些文档进行夹角余弦的计算，那么计算量就会大大减少。</p><p>此外，我们之前设计的倒排索引也已经保存了tf-idf这种信息，因此可以直接利用从倒排索引中取出的tf-idf值计算夹角余弦公式的分子部分。至于分母部分，它包含了用户查询向量的和文档向量的L2范数。通常，查询向量所包含的非0分量很少，L2范数计算是很快的。而每篇文档的L2范数，在文档没有更新的情况下是不变的，因此我们可以在索引阶段，就计算好并保持在额外的数据结构之中。</p><h2>小结</h2><p>目前，以搜索引擎为代表的信息检索技术已经相当成熟，无论是大型的互联网系统，还是小型的手机操作系统，都支持高效率的搜索。而搜索引擎最重要的核心就是及时性和相关性。及时性确保用户可以快速找到信息，而相关性确保所找到的信息是用户真正需要的。</p><p>在文本搜索中，倒排索引通过一种称为“索引”的过程，把文档到词条的关系，转化为词条到文档的逆关系，这样对于任何给定的关键词，我们可以很快的找到哪些文档包含这个关键词条。所以，倒排索引是搜索引擎提升及时性中非常关键的一步。倒排索引非常适合使用哈希表，特别是链地址型的哈希表来实现。</p><p>向量空间模型可以作为文本搜索的相关性模型。但是，它的计算需要把查询和所有的文档进行比较，时间复杂度太高，影响了及时性。这个时候，我们可以利用倒排索引，过滤掉绝大部分不包含查询关键词的文档。</p><h2>思考题</h2><p>请根据今天所讲解的设计思想，使用你熟悉的编程语言，来实现一个基于倒排索引和向量空间模型的文本搜索引擎。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title:
          "47 | 搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？",
      },
      {
        title:
          "48 | 搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？",
        herf: "https://time.geekbang.org/column/article/89279",
        id: "89279",
        content:
          '<p>你好，我是黄申。</p><p>上一节，我给你阐述了如何使用哈希的数据结构设计倒排索引，并使用倒排索引加速向量空间模型的计算。倒排索引提升了搜索执行的速度，而向量空间提升了搜索结果的相关性。</p><p>可是，在不同的应用场景，搜索的相关性有不同的含义。无论是布尔模型、向量空间模型、概率语言模型还是其他任何更复杂的模型，都不可能“一招鲜，吃遍天”。今天，我就结合自己曾经碰到的一个真实案例，为你讲解如何利用分类技术，改善搜索引擎返回结果的相关性。</p><p>你可能会觉得奇怪，这分类技术，不是监督式机器学习中的算法吗？它和信息检索以及搜索技术有什么关系呢？且听我慢慢说来。</p><h2>电商搜索的难题</h2><p>我曾经参与过一个电商的商品搜索项目。有段时间，用户时常反馈这么一个问题，那就是关键词搜索的结果非常不精准。比如搜索“牛奶”，会出现很多牛奶巧克力，甚至连牛奶色的连衣裙，都跑到搜索结果的前排了，用户体验非常差。但是，巧克力和连衣裙这种商品标题里确实存在“牛奶”的字样，如果简单地把“牛奶”字眼从巧克力和服饰等商品标题里去除，又会导致搜索“牛奶巧克力”或者“牛奶连衣裙”时无法展示相关的商品，这肯定也是不行的。</p><p>这种搜索不精确的情况十分普遍，还有很多其他的例子，比如搜索“橄榄油”的时候会返回热门的“橄榄油发膜”或“橄榄油护手霜”，搜索“手机”的时候会返回热门的“手机壳”和“手机贴膜”。另外，商品的品类也在持续增加，因此也无法通过人工运营来解决。</p><!-- [[[read_end]]] --><p>为了解决这个问题，首先我们来分析一下产生问题的主要原因。目前多数的搜索引擎实现，所采用都是类似向量空间模型的相关性模型。所以在进行相关性排序的时候，系统主要考虑的因素都是关键词的tf-idf、文档的长短、查询的长短等因素。这种方式非常适合普通的文本检索，在各大通用搜索引擎里也被证明是行之有效的方法之一。但是，经过我们的分析，这种方式并不适合电子商务的搜索平台，主要原因包括这样几点：</p><p>第一点，商品的标题都非常短。电商平台上的商品描述，包含的内容太多，有时还有不少广告宣传，这些不一定是针对产品特性的信息，如果进入了索引，不仅加大了系统计算的时间和空间复杂度，还会导致较低的相关性。所以，商品的标题、名称和主要的属性成为搜索索引关注的对象，而这些内容一般短小精悍，不需要考虑其长短对于相关性衡量的影响。</p><p>第二点，关键词出现的位置、词频对相关性意义不大。如上所述，正是由于商品搜索主要关注的是标题等信息浓缩的字段，因此某个关键词出现的位置、频率对于相关性的衡量影响非常小。如果考虑了这些，反而容易被别有用心的卖家利用，进行不合理的关键词搜索优化（SEO），导致最终结果的质量变差。</p><p>第三点，用户的查询普遍比较短。在电商平台上，顾客无需太多的关键词就能定位大概所需，因此查询的字数多少对于相关性衡量也没有太大意义。</p><p>因此，电商的搜索系统不能局限于关键词的词频、出现位置等基础特征，更应该从其他方面来考虑。</p><p>既然最传统的向量空间模型无法很好的解决商品的搜索，那么我们应该使用什么方法进行改进呢？回到我们之前所发现的问题，实际上主要纠结在一个“分类”的问题上。例如，顾客搜索“牛奶”字眼的时候，系统需要清楚用户是期望找到饮用的牛奶，还是牛奶味的巧克力或饼干。从这个角度出发考虑，我们很容易就考虑到了，是不是可以首先对用户的查询，进行一个基于商品目录的分类呢？如果可以，那么我们就能知道把哪些分类的商品排在前面，从而提高返回商品的相关性。</p><h2>查询的分类</h2><p>说到查询的分类，我们有两种方法可以尝试。第一种方法是在商品分类的数据上，运用朴素贝叶斯模型构建分类器。第二种方法是根据用户的搜索行为构建分类器。</p><p>在第一种方法中，商品分类数据和朴素贝叶斯模型是关键。电商平台通常会使用后台工具，让运营人员构建商品的类目，并在每个类目中发布相应的商品。这个商品的类目，就是我们分类所需的类别信息。由于这些商品属于哪个类目是经过人工干预和确认的，因此数据质量通常比较高。我们可以直接使用这些数据，构造朴素贝叶斯分类器。这里我们快速回顾一下朴素贝叶斯的公式。</p><p><img src="https://static001.geekbang.org/resource/image/92/1e/929ef79bdb208063ad744c285e51231e.png" alt=""></p><p>之前我们提到过，商品文描中噪音比较多，因此通常我们只看商品的标题和重要属性。所以，上述公式中的$f_1，f_2，……，f_k$，表示来自商品标题和属性的关键词。</p><p>相对于第一种方法，第二种方法更加巧妙。它的核心思想是观察用户在搜词后的行为，包括点击进入的详情页、把商品加入收藏或者是添加到购物车，这样我们就能知道，顾客最为关心的是哪些类目。</p><p>举个例子，当用户输入关键词“咖啡”，如果经常浏览和购买的品类是国产冲饮咖啡、进口冲饮咖啡和咖啡饮料，那么这3个分类就应该排在更前面，然后将其它虽然包含咖啡字眼，但是并不太相关的分类统统排在后面。需要注意的是，这种方法可以直接获取P(C|f)，而无需通过贝叶斯理论推导。</p><p>上述这两种方法各有优劣。第一种方法的优势在有很多的人工标注作为参考，因此不愁没有可用的数据。可是分类的结果受到商品分布的影响太大。假设服饰类商品的数量很多，而且有很多服饰都用到了“牛奶”的字眼，那么根据朴素贝叶斯分类模型的计算公式，“牛奶”这个词属于服饰分类的概率还是很高。第二种方法正好相反，它的优势在于经过用户行为的反馈，我们可以很精准地定位到每个查询所期望的分类，甚至在一定程度上解决查询季节性和个性化的问题。但是这种方法过度依赖用户的使用，面临一个“冷启动”的问题，也就说在搜索系统投入使用的初期，无法收集足够的数据。</p><p>考虑到这两个方法的特点，我们可以把它们综合起来使用，最简单的就是线性加和。</p><p>$P(C|query)=w_1·P_1(C|query)+w_2·P_2(C|query)$</p><p>其中，$P_1$和$P_2$分别表示根据第一种方法和第二种方法获得的概率，而权重$w_1$和$w_2$分别表示第一种方法和第二种方法的权重，可以根据需要设置。通常在一个搜索系统刚刚起步的时候，可以让$w_1$更大。随着用户不断的使用，我们就可以让$w_2$更大，让用户的参与使得系统更智能。</p><h2>查询分类和搜索引擎的结合</h2><p>一旦我们可以对商品查询进行更加准确地分类，那么就可以把这个和普通的搜索引擎结合起来。我使用下面的框架图来展示整个流程。</p><p><img src="https://static001.geekbang.org/resource/image/1a/bf/1ae2bca6c15f8c53937a7d825e78cdbf.png" alt=""></p><p>从这张图可以看到，我们使用商品目录打造一个初始版本的查询分类器。随着用户不断的使用这个搜索引擎，我们收集用户的行为日志，并使用这个日志改善查询的分类器，让它变得更加精准，然后再进一步优化搜索引擎的相关性。</p><p>我以Elasticsearch为例，讲一下如何利用分类的结果改变搜索的排序。</p><p>Elasticsearch是一个基于Lucene的搜索服务器，是流行的企业级搜索引擎之一，目前最新版已经更新到6.6.x。Elasticsearch是基于Lucene的架构，很多要素都是一脉相承的，例如文档和字段的概念、相关性的模型、各种模式的查询等。也正是这个原因，Elasticsearch默认的排序也采取了类似向量空间模型的方式。如果这种默认排序并不适用于商品搜索，那么我们要如何修改呢？</p><p>为了充分利用查询分类的结果，首先要达到这样的目标：对于给定的查询，所有命中的结果的得分都是相同的。至少有两种做法：修改默认的Similarity类的实现，或者是使用过滤查询（Filter Query）。</p><p>统一了基本的排序得分之后，我们就可以充分利用用户的行为数据，指导搜索引擎进行有针对性的排序改变，最终提升相关性。这里需要注意的是，由于这里排序的改变依赖于用户每次输入的关键词，因此不能在索引的阶段完成。</p><p>例如，在搜索“牛奶巧克力”的时候，理想的是将巧克力排列在前，而搜索“巧克力牛奶”的时候，理想的是将牛奶排列在前，所以不能简单地在索引阶段就利用文档提升（Document Boosting）或字段提升（Field Boosting）。</p><p>对于Elasticsearch而言，它有个强大的Boost功能，这个功能可以在查询阶段，根据某个字段的值，动态地修改命中结果的得分。假设我们有一个用户查询“米”，根据分类结果，我们知道“米”属于“大米”分类的概率为0.85，属于“饼干”和“巧克力”分类的概率都为0.03。根据这个分类数据，下面我使用了一段伪代码，展示了加入查询分类后的Elasticsearch查询。</p><pre><code>{\n  &quot;query&quot;: {\n    &quot;bool&quot;: {\n      &quot;must&quot;: {\n        &quot;match_all&quot;: {\n        }\n      },\n      &quot;should&quot;: [\n        {\n          &quot;match&quot;: {\n            &quot;category_name&quot;: {\n              &quot;query&quot;: &quot;大米&quot;,\n              &quot;boost&quot;: 0.85\n            }\n          }\n        },\n        {\n          &quot;match&quot;: {\n            &quot;category_name&quot;: {\n              &quot;query&quot;: &quot;饼干&quot;,\n              &quot;boost&quot;: 0.03\n            }\n          }\n        },\n        {\n          &quot;match&quot;: {\n            &quot;category_name&quot;: {\n              &quot;query&quot;: &quot;巧克力&quot;,\n              &quot;boost&quot;: 0.03\n            }\n          }\n        }\n      ],\n      &quot;filter&quot;: {\n        &quot;term&quot;: {&quot;listing_title&quot; : &quot;米&quot;}\n      }\n    }\n  }\n}\n</code></pre><p>其中最主要的部分是增加了should的查询，针对最主要的3个相关分类进行了boost操作。如果使用这个查询进行搜索，你就会发现属于“大米”分类的商品排到了前列，更符合用户的预期，而且这完全是在没有修改索引的前提下实现的。</p><h2>小结</h2><p>相关性模型是搜索引擎非常核心的模块，它直接影响了搜索结果是不是满足用户的需求。我们之前讲解的向量空间模型、概率语言模型等常见的模型，逐渐成为了主流的相关性模型。不过这些模型通常适用于普通的文本检索，并没有针对每个应用领域进行优化。</p><p>在电商平台上，搜索引擎是帮助用户查找商品的好帮手。可是，直接采用向量空间模型进行排序往往效果不好。这主要是因为索引的标题和属性都很短，我们无法充分利用关键词的词频、逆文档频率等信息。考虑到搜索商品的时候，商品的分类对于用户更为重要，所以我们在设计相关性排序的时候需要考虑这个信息。</p><p>为了识别用户对哪类商品更感兴趣，我们可以对用户输入的查询进行分类。用于构建分类器的数据，可以是运营人员发布的商品目录信息，也可以是用户使用之后的行为日志。我们可以根据搜索系统运行的情况，赋予它们不同的权重。</p><p>如果我们可以对查询做出更为准确的分类，那么就可以使用这个分类的结果，来对原有搜索结果进行重新排序。现在的开源搜索引擎，例如Elasticsearch，都支持动态修改排序结果，为我们结合分类器和搜索引擎提供了很大的便利。</p><h2>思考题</h2><p>通过用户行为反馈的数据，构建查询分类的时候，我们把整个查询作为了一个单词或者词组来处理。也就是说直接获取了$P(C|f)$的值。如果我们把这个查询看做多个词的组合，也就是说获取的是$P(C|f1,f2,…,fn)$，那我们可以如何改进这个基于用户行为反馈的分类模型呢？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title:
          "48 | 搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？",
      },
      {
        title: "49 | 推荐系统（上）：如何实现基于相似度的协同过滤？",
        herf: "https://time.geekbang.org/column/article/89431",
        id: "89431",
        content:
          '<p>你好，我是黄申。</p><p>个性化推荐这种技术在各大互联网站点已经普遍使用了，系统会根据用户的使用习惯，主动提出一些建议，帮助他们发现一些可能感兴趣的电影、书籍或者是商品等等。在这方面，最经典的案例应该是美国的亚马逊电子商务网站，它是全球最大的B2C电商网站之一。在公司创立之初，最为出名的就是其丰富的图书品类，以及相应的推荐技术。亚马逊的推荐销售占比可以达到整体销售的30%左右。可见，对于公司来说，推荐系统也是销售的绝好机会。因此，接下来的两节，我会使用一个经典的数据集，带你进行推荐系统核心模块的设计和实现。</p><h2>MovieLens数据集</h2><p>在开始之前，我们先来认识一个知名的数据集，MovieLens。你可以在它的<a href="http://files.grouplens.org/datasets/movielens/">主页</a>查看详细的信息。这个数据集最核心的内容是多位用户对不同电影的评分，此外，它也包括了一些电影和用户的属性信息，便于我们研究推荐结果是不是合理。因此，这个数据集经常用来做推荐系统、或者其他机器学习算法的测试集。</p><p>时至今日，这个数据集已经延伸出几个不同的版本，有不同的数据规模和更新日期。我这里使用的是一个最新的小规模数据集，包含了600位用户对于9000部电影的约10万条评分，最后更新于2018年9月。你可以在这里下载：<a href="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">http://files.grouplens.org/datasets/movielens/ml-latest-small.zip</a>。</p><!-- [[[read_end]]] --><p>解压了这个zip压缩包之后，你会看到readme文件和四个csv文件（ratings、movies、links和tags）。其中最重要的是ratings，它包含了10万条评分，每条记录有4个字段，包括userId、movieId、rating、timestamp。userId表示每位用户的id，movieId是每部电影的ID，</p><p>rating是这位用户对这部电影的评分，取值为0-5分。timestamp是时间戳。而movies包含了电影的主要属性信息，title和genres分别表示电影的标题和类型，一部电影可以属于多种类型。links和tags则包含了电影的其他属性信息。我们的实验主要使用ratings和movies里的数据。</p><h2>设计的整体思路</h2><p>有了用于实验的数据，接下来就要开始考虑如何设计这个推荐系统。我在第38期讲解了什么是协同过滤推荐算法、基于用户的协同过滤和基于物品的协同过滤。这一节我们就以协同过滤为基础，分别实现基于用户和物品的过滤。</p><p>根据协同过滤算法的核心思想，整个系统可以分为三个大的步骤。</p><p>第一步，用户评分的标准化。因为有些用户的打分比较宽松，而有些用户打分则比较挑剔。所以，我们需要使用标准化或者归一化，让不同用户的打分具有可比性，这里我会使用<strong>z分数</strong>标准化。</p><p>第二步，衡量和其他用户或者物品之间的相似度。我们这里的物品就是电影。在基于用户的过滤中，我们要找到相似的用户。在基于物品的过滤中，我们要找到相似的电影。我这里列出计算用户之间相似度$us$和物品之间相似度$is$的公式。之前我们讲过，这些都可以通过矩阵操作来实现。</p><p><img src="https://static001.geekbang.org/resource/image/8e/ec/8e002cc0e287f675221e42df5c249fec.png" alt=""><img src="https://static001.geekbang.org/resource/image/3c/2b/3c04082d6f87f9268eceb65cb624892b.png" alt=""></p><p>我们以基于用户的过滤为例。假设我们使用夹角余弦来衡量相似度，那么我们就可以采用用户评分的矩阵点乘自身的转置来计算余弦夹角。用户评分的矩阵$X$中，每一行是某位用户的行向量，每个分量表示这位用户对某部电影的打分。而矩阵$X’$的每一列是某个用户的列向量，每个分量表示用户对某部电影的打分。</p><p>我们假设$XX’$的结果为矩阵$Y$，那么$y_{i,j}$就表示用户$i$和用户$j$这两者喜好度向量的点乘结果，它就是夹角余弦公式中的分子。如果$i$等于$j$，那么这个计算值也是夹角余弦公式分母的一部分。从矩阵的角度来看，$Y$中任何一个元素都可能用于夹角余弦公式的分子，而对角线上的值会用于夹角余弦公式的分母。因此，我们可以利用$Y$来计算任何两个用户之间的相似度。</p><p>之前我们使用了一个示例讲解过对于基于用户的协同过滤，如何计算矩阵$Y$，以及如何使用$Y$来计算余弦夹角，我这里列出来给你参考。</p><p><img src="https://static001.geekbang.org/resource/image/79/2b/79e7065dade1b1a4d38639bb9d2cea2b.png" alt=""><img src="https://static001.geekbang.org/resource/image/9d/42/9ddfe8b7874d9d708fa367ccca967942.png" alt=""></p><p>第三步，根据相似的用户或物品，给出预测的得分p。</p><p><img src="https://static001.geekbang.org/resource/image/0a/29/0ace6bd5295a83ab6da8f5357a755929.png" alt=""><img src="https://static001.geekbang.org/resource/image/8e/23/8e170042ec88bdf48908ea0bdc2d7423.png" alt=""></p><p>之前我们也解释过如何使用矩阵操作来实现这一步。还是以基于用户的过滤为例。假设通过第二步，我们已经得到用户相似度矩阵$US$，$US$和评分矩阵$X$的点乘结果为矩阵$USP$。沿用前面的示例，结果就是下面这样。</p><p><img src="https://static001.geekbang.org/resource/image/65/1f/65ff214ce18ccc12193bf17cd1ec201f.png" alt=""></p><p>然后对$US$按行求和，获得矩阵$USR$。</p><p><img src="https://static001.geekbang.org/resource/image/28/0e/28c5469d3fcacda96604f66dfc883a0e.png" alt=""></p><p>最终，我们使用$USP$和$USR$的元素对应除法，就可以求得任意用户对任意电影的评分矩阵$P$。</p><p><img src="https://static001.geekbang.org/resource/image/eb/c8/eba06795db612c7be96118b9fa93cfc8.png" alt=""></p><p>有了这个设计的思路，下面我们就可以使用Python进行实践了。</p><h2>核心Python代码</h2><p>在实现上述设计的三个主要步骤之前，我们还需要把解压后的csv文件加载到数组，并转为矩阵。下面我列出了主要的步骤和注释。需要注意的是，由于这个数据集中的用户和电影ID都是从1开始而不是从0开始，所以需要减去1，才能和Python数组中的索引一致。</p><pre><code>import pandas as pd\nfrom numpy import *\n\n\n# 加载用户对电影的评分数据\ndf = pd.read_csv(&quot;/Users/shenhuang/Data/ml-latest-small/ratings.csv&quot;)\n\n\n# 获取用户的数量和电影的数量\nuser_num = df[&quot;userId&quot;].max()\nmovie_num = df[&quot;movieId&quot;].max()\n\n\n# 构造用户对电影的二元关系矩阵\nuser_rating = [[0.0] * movie_num for i in range(user_num)]\n\n\ni = 0\nfor index, row in df.iterrows():   # 获取每行的index、row\n\n\n  # 由于用户和电影的ID都是从1开始，为了和Python的索引一致，减去1\n  userId = int(row[&quot;userId&quot;]) - 1\n  movieId = int(row[&quot;movieId&quot;]) - 1\n\n\n  # 设置用户对电影的评分\n  user_rating[userId][movieId] = row[&quot;rating&quot;]\n\n\n  # 显示进度\n  i += 1\n  if i % 10000 == 0:\n    print(i)\n\n\n# 把二维数组转化为矩阵\nx = mat(user_rating)\nprint(x)\n</code></pre><p>加载了数据之后，第一步就是对矩阵中的数据，以行为维度，进行标准化。</p><pre><code># 标准化每位用户的评分数据\nfrom sklearn.preprocessing import scale\n\n\n# 对每一行的数据，进行标准化\nx_s = scale(x, with_mean=True, with_std=True, axis=1)\nprint(&quot;标准化后的矩阵：&quot;, x_s)\n</code></pre><p>第二步是计算表示用户之间相似度的矩阵US。其中，y变量保存了矩阵X左乘转置矩阵X’的结果。而利用y变量中的元素，我们很容易就可以得到不同向量之间的夹角余弦。</p><pre><code># 获取XX\'\ny = x_s.dot(x_s.transpose())\nprint(&quot;XX\'的结果是\'：&quot;, y)\n\n\n# 获得用户相似度矩阵US\nus = [[0.0] * user_num for i in range(user_num)]\nfor userId1 in range(user_num):\n    for userId2 in range(user_num):\n        # 通过矩阵Y中的元素，计算夹角余弦\n        us[userId1][userId2] = y[userId1][userId2] / sqrt((y[userId1][userId1] * y[userId2][userId2]))\n\n</code></pre><p>在最后一步中，我们就可以进行基于用户的协同过滤推荐了。需要注意的是，我们还需要使用元素对应的除法来实现归一化。</p><pre><code># 通过用户之间的相似度，计算USP矩阵\nusp = mat(us).dot(x_s)\n\n\n# 求用于归一化的分母\nusr = [0.0] * user_num\nfor userId in range(user_num):\n    usr[userId] = sum(us[userId])\n\n\n# 进行元素对应的除法，完成归一化\np = divide(usp, mat(usr).transpose())\n</code></pre><p>我们可以来看一个展示推荐效果的例子。在原始的评分数据中，我们看到ID为1的用户并没有对ID为2的电影进行评分。而在最终的矩阵P中，我们可以看系统对用户1给电影2的评分做出了较高的预测，换句话说，系统认为用户1很可能会喜好电影2。进一步研究电影的标题和类型，我们会发现用户1对《玩具总动员》（1995年）这类冒险类和动作类的题材更感兴趣，所以推荐电影2《勇敢者的游戏》（1995年）也是合理的。</p><h2>总结</h2><p>在今天的内容中，我通过一个常用的实验数据，设计并实现了最简单的基于用户的协同过滤。我们最关心的是这个数据中，用户对电影的评分。有了这种二元关系，我们就能构建矩阵，并通过矩阵的操作来发现用户或物品之间的相似度，并进行基于用户或者物品的协同过滤。对于最终的计算结果，你可以尝试分析针对不同用户的推荐，看看协同过滤推荐的效果是不是合理。</p><p>在你分析推荐结果的时候，可能会参考movie.csv这个文件中所描述的电影类型。这些电影类型都是一开始人工标注好的。那么，有没有可能在没有这种标注数据的情况下，在一定程度上自动分析哪些电影属于同一个或者近似的类型呢？如果可以，有没有可能在这种自动划分电影类型的基础之上，给出电影的推荐呢？下一节，我会通过SVD奇异值分解，来进行这个方向的尝试。</p><h2>思考题</h2><p>今天我使用Python代码实现了基于用户的协同过滤。类似地，我们也可以采用矩阵操作来实现基于物品的协同过滤，请使用你擅长的语言来实现试试。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p>',
        article_title: "49 | 推荐系统（上）：如何实现基于相似度的协同过滤？",
      },
      {
        title: "50 | 推荐系统（下）：如何通过SVD分析用户和物品的矩阵？",
        herf: "https://time.geekbang.org/column/article/89745",
        id: "89745",
        content:
          "<p>你好，我是黄申。</p><p>上一节，我们讲了如何使用矩阵操作，实现基于用户或者物品的协同过滤。实际上，推荐系统是个很大的课题，你可以尝试不同的想法。比如，对于用户给电影评分的案例，是不是可以使用SVD奇异值的分解，来分解用户评分的矩阵，并找到“潜在”的电影主题呢？如果在一定程度上实现这个目标，那么我们可以通过用户和主题，以及电影和主题之间的关系来进行推荐。今天，我们继续使用MovieLens中的一个数据集，尝试Python代码中的SVD分解，并分析一些结果所代表的含义。</p><h2>SVD回顾以及在推荐中的应用</h2><p>在实现SVD分解之前，我们先来回顾一下SVD的主要概念和步骤。如果矩阵$X$是对称的方阵，那么我们可以求得这个矩阵的特征值和特征向量，并把矩阵$X$分解为特征值和特征向量的乘积。</p><p>假设我们求出了矩阵$X$的$n$个特征值$λ_1，λ_2，…，λ_n$，以及这$n$个特征值所对应的特征向量$v_1，v_2，…，v_n$，那么矩阵$X$可以表示为：</p><!-- [[[read_end]]] --><center>$X=VΣV^{-1}$</center><p>其中，$V$是这$n$个特征向量所张成的$n×n$维矩阵，而$Σ$是这$n$个特征值为主对角线的$n×n$维矩阵。这个过程就是特征分解（Eigendecomposition）。</p><p>如果我们会把$V$的这$n$个特征向量进行标准化处理，那么对于每个特征向量$V_i$，就有$||V_{i}||_{2}=1$，而这表示$V’_iV_i=1$，此时$V$的$n$个特征向量为标准正交基，满足$V’V=I$， 也就是说，$V$为酉矩阵，有$V’=V^{-1}$ 。这样一来，我们就可以把特征分解表达式写作：</p><center>$X=VΣV'$</center><p>可是，如果矩阵$X$不是对称的方阵，那么我们不一定能得到有实数解的特征分解。但是，SVD分解可以避免这个问题。</p><p>我们可以把$X$的转置$X’$和$X$做矩阵乘法，得到一个$n×n$维的对称方阵$X’X$，并对这个对称方阵进行特征分解。分解的时候，我们得到了矩阵$X’X$的$n$个特征值和对应的$n$个特征向量$v$，其中所有的特征向量叫作$X$的右奇异向量。通过所有右奇异向量我们可以构造一个$n×n$维的矩阵$V$。</p><p>类似地，如果我们把$X$和$X’$做矩阵乘法，那么会得到一个$m×m$维的对称方阵$XX’$。由于$XX’$也是方阵，因此我们同样可以对它进行特征分解，并得到矩阵$XX’$的$m$个特征值和对应的$m$个特征向量$u$，其中所有的特征向量向叫作$X$的左奇异向量。通过所有左奇异向量我们可以构造一个$m×m$的矩阵$U$。</p><p>现在，包含左右奇异向量的$U$和$V$都求解出来了，只剩下奇异值矩阵$Σ$了。$Σ$除了对角线上是奇异值之外，其他位置的元素都是0，所以我们只需要求出每个奇异值$σ$就可以了。之前我们已经推导过，$σ$可以通过两种方式获得。第一种方式是计算下面这个式子：</p><center>$σ_i=\\frac{X_{v_{i}}}{u_{i}}$</center><p>其中$v_i$和$u_i$都是列向量。一旦我们求出了每个奇异值$σ$，那么就能得到奇异值矩阵$Σ$。</p><p>第二种方式是通过$X’X$矩阵或者$XX’$矩阵的特征值之平方根，来求奇异值。计算出每个奇异值$σ$，那么就能得到奇异值矩阵$Σ$了。</p><p>通过上述几个步骤，我们就能把一个$mxn$维的实数矩阵，分解成$X=UΣV’$的形式。那么这种分解对于推荐系统来说，又有怎样的意义呢？</p><p>之前我讲过，在潜在语义分析LSA的应用场景下，分解之后所得到的奇异值$σ$，对应一个语义上的“概念”，而$σ$值的大小表示这个概念在整个文档集合中的重要程度。$U$中的左奇异向量表示了每个文档和这些语义“概念”的关系强弱，$V$中的右奇异向量表示每个词条和这些语义“概念”的关系强弱。</p><p>最终，SVD分解把原来的“词条-文档”关系，转换成了“词条-语义概念-文档”的关系。而在推荐系统的应用场景下，对用户评分矩阵的SVD分解，能够帮助我们找到电影中潜在的“主题”，比如科幻类、动作类、浪漫类、传记类等等。</p><p>分解之后所得到的奇异值$σ$对应了一个“主题”，$σ$值的大小表示这个主题在整个电影集合中的重要程度。$U$中的左奇异向量表示了每位用户对这些“主题”的喜好程度，$V$中的右奇异向量表示每部电影和这些“主题”的关系强弱。</p><p>最终，SVD分解把原来的“用户-电影”关系，转换成了“用户-主题-电影”的关系。有了这种新的关系，即使我们没有人工标注的电影类型，同样可以使用更多基于电影主题的推荐方法，比如通过用户对电影主题的评分矩阵，进行基于用户或者电影的协同过滤。</p><p>接下来，我会使用同样一个MovieLens的数据集，一步步展示如何通过Python语言，对用户评分的矩阵进行SVD分解，并分析一些结果的示例。</p><h2>Python中的SVD实现和结果分析</h2><p>和上节的代码类似，首先我们需要加载用户对电影的评分。不过，由于非并行SVD分解的时间复杂度是3次方数量级，而空间复杂度是2次方数量级，所以对硬件资源要求很高。这里为了节省测试的时间，我增加了一些语句，只取大约十分之一的数据。</p><pre><code>import pandas as pd\nfrom numpy import *\n\n\n# 加载用户对电影的评分数据\ndf_ratings = pd.read_csv(&quot;/Users/shenhuang/Data/ml-latest-small/ratings.csv&quot;)\n\n\n# 获取用户的数量和电影的数量，这里我们只取前1/10来减小数据规模\nuser_num = int(df_ratings[&quot;userId&quot;].max() / 10)\nmovie_num = int(df_ratings[&quot;movieId&quot;].max() / 10)\n\n\n# 构造用户对电影的二元关系矩阵\nuser_rating = [[0.0] * movie_num for i in range(user_num)]\n\n\ni = 0\nfor index, row in df_ratings.iterrows():   # 获取每行的index、row\n\n\n  # 由于用户和电影的ID都是从1开始，为了和Python的索引一致，减去1\n  userId = int(row[&quot;userId&quot;]) - 1\n  movieId = int(row[&quot;movieId&quot;]) - 1\n\n\n  # 我们只取前1/10来减小数据规模\n  if (userId &gt;= user_num) or (movieId &gt;= movie_num):\n    continue\n\n\n  # 设置用户对电影的评分\n  user_rating[userId][movieId] = row[&quot;rati\n</code></pre><p>之后，二维数组转为矩阵，以及标准化矩阵的代码和之前是一致的。</p><pre><code># 把二维数组转化为矩阵\nx = mat(user_rating)\n\n\n# 标准化每位用户的评分数据\nfrom sklearn.preprocessing import scale\n\n\n# 对每一行的数据，进行标准化\nx_s = scale(x, with_mean=True, with_std=True, axis=1)\nprint(&quot;标准化后的矩阵：&quot;, x_s\n</code></pre><p>Python的numpy库，已经实现了一种SVD分解，我们只调用一个函数就行了。</p><pre><code># 进行SVD分解\nfrom numpy import linalg as LA\n\n\nu,sigma,vt = LA.svd(x_s, full_matrices=False, compute_uv=True)\nprint(&quot;U矩阵：&quot;, u)\nprint(&quot;Sigma奇异值：&quot;, sigma)\nprint(&quot;V矩阵：&quot;, vt)\n</code></pre><p>最后输出的Sigma奇异值大概是这样的：</p><pre><code>Sigma奇异值： [416.56942602 285.42546812 202.25724866 ... 79.26188177  76.35167406 74.96719708]\n</code></pre><p>最后几个奇异值不是0，说明我们没有办法完全忽略它们，不过它们相比最大的几个奇异值还是很小的，我们可以去掉这些值来求得近似的解。</p><p>为了验证一下SVD的效果，我们还可以加载电影的元信息，包括电影的标题和类型等等。我在这里使用了一个基于哈希的Python字典结构来存储电影ID到标题和类型的映射。</p><pre><code># 加载电影元信息\ndf_movies = pd.read_csv(&quot;/Users/shenhuang/Data/ml-latest-small/movies.csv&quot;)\ndict_movies = {}\n\n\nfor index, row in df_movies.iterrows():   # 获取每行的index、row\n  dict_movies[row[&quot;movieId&quot;]] = &quot;{0},{1}&quot;.format(row[&quot;title&quot;], row[&quot;genres&quot;])\nprint(dict_movies)\n</code></pre><p>我刚刚提到，分解之后所得到的奇异值$σ$对应了一个“主题”，$σ$值的大小表示这个主题在整个电影集合中的重要程度，而V中的右奇异向量表示每部电影和这些“主题”的关系强弱。所以，我们可以对分解后的每个奇异值，通过$V$中的向量，找找看哪些电影和这个奇异值所对应的主题更相关，然后看看SVD分解所求得的电影主题是不是合理。比如，我们可以使用下面的代码，来查看和向量$Vt1$,相关的电影主要有哪些。</p><pre><code># 输出和某个奇异值高度相关的电影，这些电影代表了一个主题\nprint(max(vt[1,:]))\nfor i in range(movie_num):\n    if (vt[1][i] &gt; 0.1):\n        print(i + 1, vt[1][i], dict_movies[i + 1])\n</code></pre><p>需要注意的是，向量中的电影ID和原始的电影ID差1，所以在读取dict_movies时需要使用(i + 1)。这个向量中最大的分值大约是0.173，所以我把阈值设置为0.1，并输出了所有分值大于0.1的电影，电影列表如下：</p><pre><code>0.17316444479201024\n260 0.14287410901699643 Star Wars: Episode IV - A New Hope (1977),Action|Adventure|Sci-Fi\n1196 0.1147295905497075 Star Wars: Episode V - The Empire Strikes Back (1980),Action|Adventure|Sci-Fi\n1198 0.15453176747222075 Raiders of the Lost Ark (Indiana Jones and the Raiders of the Lost Ark) (1981),Action|Adventure\n1210 0.10411193224648774 Star Wars: Episode VI - Return of the Jedi (1983),Action|Adventure|Sci-Fi\n2571 0.17316444479201024 Matrix, The (1999),Action|Sci-Fi|Thriller\n3578 0.1268370902126096 Gladiator (2000),Action|Adventure|Drama\n4993 0.12445203514448012 Lord of the Rings: The Fellowship of the Ring, The (2001),Adventure|Fantasy\n5952 0.12535012292041953 Lord of the Rings: The Two Towers, The (2002),Adventure|Fantasy\n7153 0.10972312192709989 Lord of the Rings: The Return of the King, The (2003),Action|Adventure|Drama|Fantasy\n</code></pre><p>从这个列表可以看出，这个主题是关于科幻或者奇幻类的动作冒险题材。</p><p>使用类似的代码和同样的阈值0.1，我们来看看和向量$Vt5$,相关的电影主要有哪些。</p><pre><code># 输出和某个奇异值高度相关的电影，这些电影代表了一个主题\nprint(max(vt[5,:]))\nfor i in range(movie_num):\n    if (vt[5][i] &gt; 0.1):\n        print(i + 1, vt[5][i], dict_movies[i + 1])\n</code></pre><p>电影列表如下：</p><pre><code>0.13594520920117012\n21 0.13557812349701226 Get Shorty (1995),Comedy|Crime|Thriller\n50 0.11870851441884082 Usual Suspects, The (1995),Crime|Mystery|Thriller\n62 0.11407971751480048 Mr. Holland's Opus (1995),Drama\n168 0.10295400456394468 First Knight (1995),Action|Drama|Romance\n222 0.12587492482374366 Circle of Friends (1995),Drama|Romance\n261 0.13594520920117012 Little Women (1994),Drama\n339 0.10815473505804706 While You Were Sleeping (1995),Comedy|Romance\n357 0.11108191756350501 Four Weddings and a Funeral (1994),Comedy|Romance\n527 0.1305895737838763 Schindler's List (1993),Drama|War\n595 0.11155774544755555 Beauty and the Beast (1991),Animation|Children|Fantasy|Musical|Romance|IMAX\n</code></pre><p>从这个列表可以看出，这个主题更多的是关于剧情类题材。就目前所看的两个向量来说，SVD在一定程度上区分了不同的电影主题，你也可以使用类似的方式查看更多的向量，以及对应的电影名称和类型。</p><h2>总结</h2><p>在今天的内容中，我们回顾了SVD奇异值分解的核心思想，解释了如何通过$XX’$和$X’X$这两个对称矩阵的特征分解，求得分解后的$U$矩阵、$V$矩阵和$Σ$矩阵。另外，我们也解释了在用户对电影评分的应用场景下，SVD分解后的$U$矩阵、$V$矩阵和$Σ$矩阵各自代表的意义，其中$Σ$矩阵中的奇异值表示了SVD挖掘出来的电影主题，$U$矩阵中的奇异向量表示用户对这些电影主题的评分，而$V$矩阵中的奇异向量表示了电影和这些主题的相关程度。</p><p>我们还通过Python代码，实践了这种思想在推荐算法中的运用。从结果的奇异值和奇异向量可以看出，SVD分解找到了一些MovieLens数据集上的电影主题。这样我们就可以把用户针对电影的评分转化为用户针对主题的评分。由于主题通常远远小于电影，所以SVD的分解也帮助我们实现了降低特征维度的目的。</p><p>SVD分解能够找到一些“潜在的“因素，例如语义上的概念、电影的主题等等。虽然这样操作可以降低特征维度，去掉一些噪音信息，但是由于SVD分解本身的计算量也很大，所以从单次的执行效率来看，SVD往往无法起到优化的作用。在这种情况下，我们可以考虑把它和一些监督式的学习相结合，使用一次分解的结果构建分类器，提升日后的执行效率。</p><h2>思考题</h2><p>刚才SVD分解实验中得到的$U$矩阵，是用户对不同电影主题的评分矩阵。请你使用这个$U$矩阵，进行基于用户或者基于主题（物品）的协同过滤。</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>",
        article_title: "50 | 推荐系统（下）：如何通过SVD分析用户和物品的矩阵？",
      },
      {
        title: "51 | 综合应用篇答疑和总结：如何进行个性化用户画像的设计？",
        herf: "https://time.geekbang.org/column/article/90112",
        id: "90112",
        content:
          '<p>你好，我是黄申。今天是综合应用篇的答疑和总结。</p><p>在这个模块中，我们讲述了不同数学思想在系统设计和实现中的综合运用。相对于前面几个模块，综合应用的内容更注重实践，也更加有趣。大家对这些内容也提出了很多值得思考的问题。今天，我会讲解其中一个问题，如何进行个性化用户画像的设计？。最后，我也会照例对整个应用篇进行一个总结。</p><h2>个性化用户画像的设计</h2><p>如今是个性化的时代，互联网和人工智能技术正在把这点推向极致。无论是主动搜索还是进行浏览，用户都希望看到针对自己的结果。</p><p>举个例子，A品牌的奶瓶在全网是非常畅销的，可是对于一位5岁儿子的妈妈来说，儿子早已过了喝奶瓶的阶段，所以在她输入A品牌后，返回“奶瓶”肯定不合适。同时，如果她一直在购买A品牌的儿童洗衣液，那么返回A品牌的洗衣液就更合理，顾客体验也会更好，这就是<strong>品类的个性化</strong>。</p><p>从另一个场景来看，这位妈妈没有输入A品牌，而是输入了“儿童洗衣液”，如果是A品牌的洗衣液产品排在首页，而不是她所陌生的其他品牌，用户体验也会更好，这就是<strong>品牌的个性化</strong>。</p><p>在进行个性化设计之前，最关键的问题是，如何收集和运用顾客的行为数据。</p><p>第48节，我在讲解查询分类的时候，介绍了如何利用用户的搜索行为。而实践中，用户个人的行为涉及面更为广泛，需要更多细致的分析。通常我们将相应的工程称为“用户画像”。为了让你更好地理解，这里我给出一个较为全面的设计概述。</p><!-- [[[read_end]]] --><h3>如何通过数据生成用户标签？</h3><p>开发用户画像，首先要解决的问题是：哪些用户数据可以收集，以及如何通过这些数据生成用户标签。</p><p>最基本的原始数据包括网站浏览、购物、位置、气候、设备等信息。除了这些原始的数据，我们还可以结合人工的运营，生成一些包含语义的用户标签。这里的用户标签，或者说属性标签，是一个具有语义的标签，用于描述一组用户的行为特征。例如，“美食达人”“数码玩家”“白领丽人”“理财专家”等。对于标签的定义，按照概率统计篇和线性代数篇所介绍的机器学习方法论，既可以考虑采用监督式的分类方法，也可以采用非监督式的聚类方法。</p><p>分类的好处在于，可以让人工运营向计算机系统输入更多的先验知识，也可以让标签的制定和归类更为精准。从操作的层面考虑，又可以细分为基于人工规则和基于标注数据。人工规则是指由运营人员指定分类的主要规则。</p><p>例如，运营人员指定最近1个月，至少购买过2次以上母婴产品，消费额在500元以上的为“辣妈” 标签。这里规则就相当于直接产生类似决策树的分类模型，它的优势在于具有很强的可读性，便于人们的理解和沟通。但是，如果用户的行为特征过于繁多，运营人员往往很难甄别出哪些具有代表性。这时如果仍然使用规则，那么就不容易确定规则的覆盖面或者是精准度。</p><p>另一种方法是使用标注数据，通过训练样本来构建分类器。例如，通过运营人员挑选一些有代表性的用户，对他们的特征进行人工标注，然后输入给系统。之后，让系统根据分类技术来学习，模型可以使用决策树、朴素贝叶斯NB（Naive Bayes）或支持向量机SVM（Support Vector Machine）等等。</p><p>不过，除了决策树的模型，其余模型产生的人群分组可能会缺乏可读性内容，很难向业务方解释其结果。一种缓解的办法是让系统根据数据挖掘中的特征选择技术，包括我们之前讲解的信息增益IG（Information Gain）、开方检验CHI等，来确定这组人群应该有怎样的特征，并将其作为标签。</p><p>除了分类，我们也可以使用非监督式的聚类。这种方法中，运营人员参与最少，完全利用用户之间的相似度来确定，相似度同样可以基于各种用户的特征和向量空间模型来衡量。其问题也在于结果缺乏解释性，只能通过特征选择等技术来挑选具有代表性的标签。</p><p>如果我们比较一下分类和聚类的方法，会发现分类的技术比较适合业务需求明确、运营人员充足、针对少量高端顾客的管理，其精准性可以提升VIP顾客服务的品质。而聚类更适合大规模用户群体的管理，甚至是进行在线的AB测试，其对精准性要求不高，但是数据的规模比较大，对系统的数据处理能力有一定要求。</p><p>无论是哪种方法，只要我们能获取比较准确的用户标签，那么我们就可以给出用户的画像，刻画他们的主要行为特征。下面我们来看看基于用户画像，可以进行哪些个性化的服务。首先是在搜索中增加个性化因素，相比普通的搜索，个性化的搜索可以投用户之所好，增加搜索结果的点击率、商品的购买转化率等等。具体来说，我们可以在下面这几点下功夫：</p><p>第一点，个性化的排序，根据用户经常浏览的品类和属性，对搜索结果中的项目进行个性化的排序，开头提到的5岁儿子妈妈的案例体现了这点的核心思想。</p><p>第二点，个性化的搜索词推荐。例如，一位体育迷搜索“足球”的时候，我们可以给出“足球新闻”“冠军杯”等相关搜索。而在一位彩票用户搜索“足球“的时候，我们可以给出”足球彩票“等相关搜索。</p><p>第三点，个性化的搜索下拉提示。例如，经常购买儿童洗衣液的用户，输入儿童用品的品牌后，在搜索下拉框中优先提示该品牌的儿童洗衣液。</p><p>除了搜索，个性化还可以运用在推荐系统、电子邮件营销EDM（Email Direct Marketing）、移动App的推送等等。对于推荐系统来说，在用户画像完善的前提下，我们能更准确地找到相似的用户和物品，从而进行效果更好的基于用户或基于物品的协同过滤。相对于传统的线下营销，电子邮件营销不再受限于印刷和人力成本，完全可以做到因人而异的精准化定向投放。</p><p>比如，系统根据品类、品牌、节日或时令，分为不同的主题进行推送。运营人员甚至只用制定模板和规则，然后让系统根据用户画像的特征，自动的填充模板并最终生成电子邮件的内容。另外，随着移动端逐渐占据互联网市场的主导地位，掌上设备的App推送变成了另一个重要的营销渠道。从技术层面上看，它可以采用和电子邮件营销类似的解决方案。不过，内容的运营要考虑到移动设备屏幕尺寸和交互方式的特性，并进行有针对性的优化。</p><p>有了上述这些设计理念和模块，我们需要一个整体的框架来整合它们。我在这里画了一张框架图，供你参考。</p><p><img src="https://static001.geekbang.org/resource/image/34/4f/34f550e2650e64065d0f104410ce3e4f.png" alt=""></p><p>这种架构包括行为数据的收集和分析、聚类、分类、构建画像、缓存等几个主要模块。随着数据规模的不断扩大，我们可以选择一些分布式系统来存储用户画像数据，并使用缓存系统来升数据查询的效率，为前端的搜索、推荐、EDM和App推送等应用提供服务。当然，我们还可以利用行为数据的跟踪，进一步分析这套画像系统的质量和效果，形成一个螺旋式上升的优化闭环。</p><p>综合来看，用户画像也许概念上并不复杂，可是一旦落实到技术实施，我们需要综合很多不同领域的知识。从用户标签的角度来说，可能涉及的领域包括监督式和非监督式的机器学习算法，以及相关的特征选择。从系统集成的角度来说，可能涉及的领域包括分布式、缓存、信息检索和推荐系统。这些内容我们在之前的各个模块都有介绍，今天我通过用户画像的设计进行了知识的串联。当然，我这里讲解的方案也只是一种参考，你可以结合自身的需求来进一步的设计和实现。相信经过一定量的项目实践和经验积累，你对这些内容的综合性运用会更加得心应手。</p><h2>综合应用篇总结</h2><p>在综合应用篇之前，我们分别从基础模块、概率统计模块和线性代数模块出发，详细阐述了不同编程技术背后的数学知识。在综合应用这个模块，我们又从几个非常实用的案例出发，讲解了如何结合不同的编程技术，设计并架构大型的系统，最终为商业需求提供解决方案。</p><p>如今的数据系统越来越庞大，系统设计时常常会用到缓存系统来提升记录查找的效率。对缓存系统的强烈需求也催生了很多开源的项目，例如Memcached和Redis等等，这些系统都已经相当成熟。而在这个模块，我们同时使用了哈希函数和队列，实现了一个最简单的缓存系统。哈希函数确保了查找的高效率，而队列则实现了LRU的淘汰策略。通过这两点，你就能理解缓存设计的基本原理和方法。</p><p>和缓存类似，搜索引擎的倒排索引也使用了哈希表结构来提高查询效率。当然，倒排索引的功能不仅限于数据对象的快速定位。它本身还能存放很多额外的信息，包括词频tf、tfidf、关键词出现的位置等等。在这个模块中，我展示了如何利用这些信息，实现更为复杂的相关性模型，例如向量空间模型、概率语言模型等等。另外，倒排索引可以帮助我们过滤掉完全无关的数据，大大降低这些模型的计算量。</p><p>除了基本的及时性和相关性，搜索引擎还应该按照不同应用的需求进行优化。例如，电商平台的搜索，就和通用型的搜索不一样，对于电商搜索来说，用户更加关注的是商品的品类。我讲解了如何根据商品目录和用户行为反馈，构建查询的分类器。这样，当用户进行搜索的时候，系统首先对用户输入的关键词进行分类，弄清楚用户最感兴趣的品类是哪些，然后再优化商品的排序，最终增加商品搜索结果的相关性。</p><p>和搜索引擎同样重要的是推荐引擎。有的时候，用户自己不会输入想要查询的关键词，而是喜好不断地浏览网页。这个时候推荐技术起到了很关键的作用，它可以主动地为用户提供他们可能感兴趣的内容。在这个领域，协同过滤是非常经典的算法。我通过代码的实践，给你讲解了如何通过矩阵操作实现基于用户和基于物品的过滤。除此之外，我们还探讨了如何使用SVD，对用户和物品之间的关系进行分解，帮助我们找到隐藏在用户和物品之间的潜在因素，比如电影的主题。</p><p>无论是设计搜索还是推荐系统，我们都可以加入个性化的元素，而这点往往是提升业务的关键。今天，我讲解了用户画像的原理、用户标签的设计和实现、以及如何使用用户画像来给搜索和推荐系统加入个性化。而这个整体方案涉及的技术面是相当广的，你可以结合之前的各期专栏，对每一个环节进行消化和理解。</p><h2>思考题</h2><p>对各种知识的综合应用对个人能力要求很高，却也是最重要的。我想听你说说，在平时的开发项目中，你有没有结合使用本专栏所讲的不同知识点的经历？能不能和我们说说你在这方面的心得体会？</p><p>欢迎留言和我分享，也欢迎你在留言区写下今天的学习笔记。你可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</p><p></p>',
        article_title:
          "51 | 综合应用篇答疑和总结：如何进行个性化用户画像的设计？",
      },
    ],
  },
  {
    chapterTitle: "加餐 (3讲)",
    children: [
      {
        title: "数学专栏课外加餐（一） | 我们为什么需要反码和补码？",
        herf: "https://time.geekbang.org/column/article/74296",
        id: "74296",
        content:
          '<p>你好，我是黄申。欢迎来到第一次课外加餐时间。</p><p>专栏已经更新了几讲，看到这么多人在留言区写下自己的疑惑和观点，我非常开心。很多同学在留言里提出了很多非常好的问题，所以我决定每隔一段时间，对留言里的疑问、有代表性的问题做个集中的解答，也是对我们主线内容做一个补充，希望对你有帮助。</p><h2>什么是符号位？为什么要有符号位？</h2><p>在<a href="https://time.geekbang.org/column/article/71840">第1讲</a>里，我介绍了十进制数转二进制数。这里面很多人对逻辑右移和算术右移中提到的符号位和补码有疑惑。这里面涉及了几个重要的概念，包括符号位、溢出、原码、反码和补码。我详细讲一下这几个点的来龙去脉。</p><p>首先我们来看，<strong>什么是符号位，为什么要有符号位</strong>？用一句话来概括就是，<strong>符号位是有符号二进制数中的最高位，我们需要它来表示负数。</strong></p><p>在实际的硬件系统中，计算机CPU的运算器只实现了加法器，而没有实现减法器。那么计算机如何做减法呢？我们可以通过加上一个负数来达到这个目的。比如，3-2可以看作3+(-2)。因此，负数的表示对于计算机中的二进制减法至关重要。</p><p>那么，接下来的问题就是，<strong>如何让计算机理解哪些是正数，哪些是负数呢</strong>？为此，人们把二进制数分为有符号数（signed）和无符号数（unsigned）。</p><p>如果是有符号数，那么最高位就是符号位。当符号位为0时，表示该数值为正数；当符号位为1时，表示该数值为负数。例如一个8位的有符号位二进制数10100010，最高位是1，这就表示它是一个负数。</p><!-- [[[read_end]]] --><p>如果是无符号数，那么最高位就不是符号位，而是二进制数字的一部分，例如一个8位的无符号位二进制数10100010，我们可以通过第1讲讲过的内容，换算出它所对应的十进制数是162。由于没有表示负数的符号位，所有无符号位的二进制都代表正数。</p><p>有些编程语言，比如Java，它所有和数字相关的数据类型都是有符号位的；而有些编程语言，比如C语言，它有诸如unsigned int这种无符号位的数据类型。</p><p>下面我们来看，<strong>什么是溢出？</strong></p><p>在数学的理论中，数字可以有无穷大，也有无穷小。可是，现实中的计算机系统，总有一个物理上的极限（比如说晶体管的大小和数量），因此不可能表示无穷大或者无穷小的数字。对计算机而言，无论是何种数据类型，都有一个上限和下限。</p><p>在Java中，int型是32位，它的最大值也就是上限是2^31-1（最高位是符号位，所以是2的31次方而不是32次方），最小值也就是下限是-2^31。而long型是64位，它的最大值，也就是上限是2^63-1；最小值，也就是下限是-2^63。</p><p>对于n位的数字类型，符号位是1，后面n-1位全是0，我们把这种情形表示为-2^(n-1) ，而不是2^(n-1)。一旦某个数字超过了这些限定，就会发生溢出。如果超出上限，就叫<strong>上溢出</strong>（overflow）。如果超出了下限，就叫<strong>下溢出</strong>（underflow）。</p><p>那么<strong>溢出之后会发生什么呢？</strong>我以上溢出为例来给你解释。</p><p>n位数字的最大的正值，其符号位为0，剩下的n-1位都为1，再增大一个就变为了符号位为1，剩下的n-1位都为0。而符号位是1，后面n-1位全是0，我们已经说过这表示-2^(n-1)。</p><p><img src="https://static001.geekbang.org/resource/image/10/36/10974fab2acf1ebd3cd3938387b65c36.jpg" alt=""></p><p>那么就是说，上溢出之后，又从下限开始，最大的数值加1，就变成了最小的数值，周而复始，这不就是余数和取模的概念吗？下面这个图可以帮助你的理解。</p><p><img src="https://static001.geekbang.org/resource/image/57/71/57e275c509cb477588b8c19b63df0b71.jpg" alt=""></p><p>其中右半部分的虚线表示已经溢出的区间，而为了方便你理解，我将溢出后所对应的数字也标在了虚线的区间里。由此可以看到，所以说，<strong>计算机数据的溢出，就相当于取模。</strong>而用于取模的除数就是数据类型的上限减去下限的值，再加上1，也就是(2^(n-1)-1)-(-2^(n-1))+1=2x2^(n-1)-1+1=2^n-1+1。</p><p>你可能会好奇，这个除数为什么不直接写成2^n呢？这是因为2^n已经是n+1位了，已经超出了n位所能表示的范围。</p><h2>二进制的原码、反码及补码</h2><p>理解了符号位和溢出，我接下来说说，什么是二进制的原码、反码和补码，以及我们为什么需要它们。</p><p><strong>原码</strong>就是我们看到的二进制的原始表示。对于有符号的二进制来说，原码的最高位是符号位，而其余的位用来表示该数字绝对值的二进制。所以+2的原码是000…010，-2的的原码是100.…010。</p><p>那么我们是不是可以直接使用负数的原码来进行减法计算呢？答案是否定的。我还是以3+(-2)为例。</p><p>假设我们使用Java中的32位整型来表示2，它的十进制是000…010。最低的两位是10，前面的高位都是0。如果我们使用-2的原码，也就是100…010，然后我们把3的二进制原码000…011和-2的二进制原码100…010相加，会得到100…0101。具体计算你可以看我画的这幅图。</p><p><img src="https://static001.geekbang.org/resource/image/26/6b/267986137720c8a14e45fa3bb46f736b.jpg" alt=""></p><p>二进制编码上的加减法和十进制类似，只不过，在加法中，十进制是满10才进一位，二进制加法中只要满2就进位；同样，在减法中，二进制借位后相当于2而不是10。</p><p>相加后的结果是二进制100…0101，它的最高位是1，表示负数，而最低的3位是101，表示5，所以结果就是-5的原码了，而3+(-2)应该等于1，两者不符。</p><p>如果负数的原码并不适用于减法操作，那该怎么办呢？这个问题的解答还要依赖计算机的溢出机制。</p><p>我刚刚介绍了溢出以及取模的特性，我们可以充分利用这一点，对计算机里的减法进行变换。假设有i-j，其中j为正数。如果i-j加上取模的除数，那么会形成溢出，并正好能够获得我们想要的i-j的运算结果。如果我说的还是不太好理解，你可以参考下面这张图。</p><p><img src="https://static001.geekbang.org/resource/image/d3/4f/d3788c6ecac1f8d8eee9552c7452ca4f.jpg" alt=""></p><p>我们把这个过程用表达式写出来就是i-j=(i-j)+(2^n-1+1)=i+(2^n-1-j+1)。</p><p>其中2^n-1的二进制码在不考虑符号位的情况下是n-1位的1，那么2^n-1-2的结果就是下面这样的：</p><p><img src="https://static001.geekbang.org/resource/image/41/0e/413470413ff2fe1ce02fa51f07884c0e.jpg" alt=""></p><p>从结果可以观察出来，所谓2^n-1-j相当于对正数j的二进制原码，除了符号位之外按位取反（0变1，1变0）。由于负数-j和正数j的原码，除了符号位之外都是相同的，所以，2^n-1-j也相当于对负数-j的二进制原码，除了符号位之外按位取反。我们把2^n-1-j所对应的编码称为负数-j的反码。所以，-2的反码就是1111…1101。</p><p>有了反码的定义，那么就可以得出i-j=i+(2^n-1-j+1)=i的原码+(-j的反码)+1。</p><p>如果我们把-j的反码加上1定义为-j的补码，就可以得到i-j=i的原码+(-j的补码)。</p><p>由于正数的加法无需负数的加法这样的变换，因此正数的原码、反码和补码三者都是一样的。最终，我们可以得到i-j=i的补码+(-j的补码)。</p><p>换句话说，计算机可以通过补码，正确地运算二进制减法。我们再来用3+(-2)来验证一下。正数3的补码仍然是0000…0011，-2的补码是1111…1110，两者相加，最后得到了正确的结果1的二进制。</p><p><img src="https://static001.geekbang.org/resource/image/3f/1f/3f4133ef63fd467bd389f58820c72d1f.jpg" alt=""></p><p>可见，溢出本来是计算机数据类型的一种局限性，但在负数的加法上，它倒是可以帮我们大忙。</p><p>最后，给你留一道思考题吧。理解了负数的原码、反码和补码之后，你能算算看，8位的有符号位二进制数10100010，对应的是哪个十进制数吗？</p><p>好了，关于二进制的补充内容就到这里了。<span class="orange">欢迎你继续留言给我。你也可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "数学专栏课外加餐（一） | 我们为什么需要反码和补码？",
      },
      {
        title: "数学专栏课外加餐（二） | 位操作的三个应用实例",
        herf: "https://time.geekbang.org/column/article/74717",
        id: "74717",
        content:
          '<p>你好，我是黄申。欢迎来到第二次课外加餐时间。</p><h2>位操作的应用实例</h2><p>留言里很多同学对位操作比较感兴趣，我这里通过计算机中的位操作的几个应用，来帮你理解位操作。</p><h3>1.验证奇偶数</h3><p>在<a href="https://time.geekbang.org/column/article/72163">第2节</a>里，我提到了，奇偶数其实也是余数的应用。编程中，我们也可以用位运算来判断奇偶数。</p><p>仔细观察，你会发现偶数的二进制最后一位总是0，而奇数的二进制最后一位总是1，因此对于给定的某个数字，我们可以把它的二进制和数字1的二进制进行按位“与”的操作，取得这个数字的二进制最后一位，然后再进行判断。</p><p>我这里写了一段代码，比较了使用位运算和模运算的效率，我统计了进行1亿次奇偶数判断，使用这两种方法各花了多少毫秒。如果在你的机器上两者花费的时间差不多，你可以尝试增加统计的次数。在我的机器上测试下来，同样次数的奇偶判断，使用位运算的方法耗时明显更低。</p><pre><code>public class Lesson1_append1 {\n \n public static void main(String[] args) {\n  \n  int even_cnt = 0, odd_cnt = 0;\n  long start = 0, end = 0;\n  \n  start = System.currentTimeMillis();\n  for (int i = 0; i &lt; 100000000; i++) {\n   \n   if((i &amp; 1) == 0){\n       even_cnt ++;\n   }else{\n       odd_cnt ++;\n   }\n   \n  }\n  end = System.currentTimeMillis();\n  System.out.println(end - start);\n  System.out.println(even_cnt + &quot; &quot; + odd_cnt);\n  \n  even_cnt = 0;\n  odd_cnt = 0;\n  start = 0;\n  end = 0;\n  \n  start = System.currentTimeMillis();\n  for (int i = 0; i &lt; 100000000; i++) {\n   \n   if((i % 2) == 0){\n       even_cnt ++;\n   }else{\n       odd_cnt ++;\n   }\n   \n  }\n  end = System.currentTimeMillis();\n  System.out.println(end - start);\n  System.out.println(even_cnt + &quot; &quot; + odd_cnt);\n\n }\n}\n</code></pre><h3>2.交换两个数字</h3><p>你应该知道，要想在计算机中交换两个变量的值，通常都需要一个中间变量，来临时存放被交换的值。不过，利用异或的特性，我们就可以避免这个中间变量。具体的代码如下：</p><pre><code>x = (x ^ y);\ny = x ^ y;\nx = x ^ y;\n</code></pre><p>把第一步代入第二步中, 可以得到：</p><pre><code>y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x\n</code></pre><p>把第一步和第二步的结果代入第三步中，可以得到：</p><!-- [[[read_end]]] --><pre><code>x = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y = y \n</code></pre><p>这里用到异或的两个特性，第一个是两个相等的数的异或为0，比如x^x= 0；第二个是任何一个数和0异或之后，还是这个数不变，比如0^y=y。</p><h3>3.集合操作</h3><p>集合和逻辑的概念是紧密相连的，因此集合的操作也可以通过位的逻辑操作来实现。</p><p>假设我们有两个集合{1, 3, 8}和{4, 8}。我们先把这两个集合转为两个8位的二进制数，从右往左以1到8依次来编号。</p><p>如果某个数字在集合中，相应的位置1，否则置0。那么第一个集合就可以转换为10000101，第二个集合可以转换为10001000。那么这两个二进制数的按位与就是10000000，只有第8位是1，代表了两个集合的交为{8}。而这两个二进制数的按位或就是10001101，第8位、第4位、第3位和第1位是1，代表了两个集合的并为{1, 3, 4, 8}。</p><p>说到这里，不禁让我想起Elasticsearch的BitSet。我曾经使用Elasticsearch这个开源的搜索引擎来实现电商平台的搜索。</p><p>当时为了提升查询的效率，我使用了Elasticsearch的Filter查询。我研究了一下这个Filter查询的原理，发现它并没有考虑各种文档的相关性得分，因此它可以把文档匹配关键字的情况，转换成了一个BitSet。</p><p>你可以把BitSet想成一个巨大的位数组。每一位对应了某篇文档是否和给定的关键词匹配，如果匹配，这一位就置1，否则就置0。每个关键词都可以拥有一个BitSet，用于表示哪些文档和这个关键词匹配。那么要查看同时命中多个关键词的文档有哪些，就是对多个BitSet求交集。利用上面介绍的按位与，这点是很容易实现的，而且效率相当之高。</p><h2>二分查找时的两个细节</h2><p><a href="https://time.geekbang.org/column/article/72243">第3节</a>我介绍了迭代法，并讲解了相关的代码实现。其中，有两个细节我在这里补充说明一下。</p><p>第一个是关于<strong>中间值的计算</strong>。我优化了两处代码，分别是Lesson3_2的第16行和Lesson3_3的第22行。</p><p>其中，Lesson3_2的第16行由原来的：</p><pre><code>double middle = (min + max) / 2;\n</code></pre><p>改为：</p><pre><code>double middle = min + (max - min) / 2;\n</code></pre><p>Lesson3_3的第22行由原来的：</p><pre><code>int middle = (left + right) / 2;\n</code></pre><p>改为：</p><pre><code>int middle = left + (right - left) / 2;\n</code></pre><p>这两处改动的初衷都是一样的，是为了避免溢出。在第一篇加餐中，介绍负数的加法时，我已经解释了什么是溢出。那这里为什么会发生溢出呢？我以第二处代码为例来讲解下。</p><p>从理论上来说，(left+right)/2=left+(right-left)/2。可是，我们之前说过，计算机系统有自身的局限性，无论是何种数据类型，都有一个上限或者下限。一旦某个数字超过了这些限定，就会发生溢出。</p><p>对于变量left和right而言，在定义的时候都指定了数据类型，因此不会超出范围。可是，left+right的和就不一定了。从下图可以看出，当left和right都已经很接近某个数据类型的最大值时，两者的和就会超过这个最大值，发生上溢出。这也是为什么最好不用通过(left+right)/2来求两者的中间值。</p><p><img src="https://static001.geekbang.org/resource/image/35/cc/35e891800614511659e0cbf11060b5cc.jpg" alt=""></p><p>那么为什么left + (right -left)/2就不会溢出呢？首先，right是没有超过最大值的，那么(right -left)/2自然也就没有超过范围，即使left加上了(right -left)/2，也不会超过right的值，所以运算的整个过程都不会产生溢出。</p><p>第二个是关于误差百分比和绝对误差。在Lesson3_2中有这么一行：</p><pre><code>double delta = Math.abs((square / n) - 1);\n\n</code></pre><p>这里我使用了误差的百分比，也就是误差值占输入值n的比例。其实绝对误差也是可以的，不过我在这里考虑了n的大小。比如，如果n是一个很小的正整数，比如个位数，那么误差可能要精确到0.00001。但是如果n是一个很大的数呢？比如几个亿，那么精确到0.00001可能没有多大必要，也许精确到0.1也就可以了。所以，使用误差的百分比可以避免由于不同的n，导致的迭代次数有过大差异。</p><p>由于这里n是大于1的正整数，所以可以直接拿平方值square去除以n。否则，我们要单独判断n为0的情况，并使用绝对误差。</p><h2>关于迭代法、数学归纳法和递归</h2><p>从第3节到第6节，我连续介绍了迭代法、数学归纳法、递归。这些概念之间存在相互联系，又不完全一样，很多同学对此也有一些疑惑。所以，这里我来帮你梳理一下。</p><p>迭代法和递归都是通过不断反复的步骤，计算数值或进行操作的方法。迭代一般适合正向思维，而递归一般适合逆向思维。而递归回溯的时候，也体现了正向递推的思维。它们本身都是抽象的流程，可以有不同的编程实现。</p><p>对于某些重复性的计算，数学归纳法可以从理论上证明某个结论是否成立。如果成立，它可以大大节约迭代法中数值计算部分的时间。不过，在使用数学归纳法之前，我们需要通过一些数学知识，假设命题，并证明该命题成立。</p><p>对于那些无法使用数学归纳法来证明的迭代问题，我们可以通过编程实现。这里需要注意的是，广义上来说，递归也是迭代法的一种。不过，在计算机编程中，我们所提到的迭代是一种具体的编程实现，是指使用循环来实现的正向递推，而递归是指使用函数的嵌套调用来实现的逆向递推。当然，两种实现通常是可以相互转换的。</p><p>循环的实现很容易理解，对硬件资源的开销比较小。不过，循环更适合“单线剧情”，例如计算2^n，n!，1+2+3+…+n等等。而对于存在很多“分支剧情”的复杂案例而言，使用递归调用更加合适。</p><p>利用函数的嵌套调用，递归编程可以存储很多中间变量。我们可以很轻松地跟踪不同的分支，而所有这些对程序员基本是透明的。如果这时使用循环，我们不得不自己创建并保存很多中间变量。当然，正是由于这个特性，递归比较消耗硬件资源。</p><p>递归编程本身就体现了分治的思想，这个思想还可以延伸到集群的分布式架构中。最近几年比较主流的MapReduce框架也体现了这种思想。</p><p>综合上面说的几点，你可以大致遵循这样的原则：</p><ul>\n<li>\n<p>如果一个问题可以被迭代法解决，而且是有关数值计算的，那你就看看是否可以假设命题，并优先考虑使用数学归纳法来证明；</p>\n</li>\n<li>\n<p>如果需要借助计算机，那么优先考虑是否可以使用循环来实现。如果问题本身过于复杂，再考虑函数的嵌套调用，是否可以通过递归将问题逐级简化；</p>\n</li>\n<li>\n<p>如果数据量过大，可以考虑采用分治思想的分布式系统来处理。</p>\n</li>\n</ul><p>最后，给你留一道思考题吧。</p><p>在1到n的数字中，有且只有唯一的一个数字m重复出现了，其它的数字都只出现一次。请把这个数字找出来。提示：可以充分利用异或的两个特性。</p><p>好了，前面6讲的补充内容就到这里了。<span class="orange">欢迎你留言给我。你也可以点击“请朋友读”，把今天的内容分享给你的好友，和他一起精进。</span></p><p></p>',
        article_title: "数学专栏课外加餐（二） | 位操作的三个应用实例",
      },
      {
        title: "数学专栏课外加餐（三）：程序员需要读哪些数学书？",
        herf: "https://time.geekbang.org/column/article/79048",
        id: "79048",
        content:
          '<p>你好，我是黄申。欢迎来到第三次加餐时间！之前很多同学问我能否推荐一些数学方面的书，今天我就来分享几本。</p><p>数学领域涉及的面很广，相关的书籍也很多。咱们这个专栏我从数学的三个主要方面，介绍程序员常用的数学知识，包括离散数学、概率和统计和线性代数。所以我还是围绕这个专栏的三大模块，来给你推荐相应的书籍。</p><h2>基础思想篇推荐书籍：《离散数学及其应用》</h2><p>第一模块是“基础思想篇”。这一模块，我尝试用实际项目中的案例，把不同的离散数学知识点串了起来，并加以解释。如果你对其中某些点，有更深的兴趣，可以参考Kenneth H·Rosen所著的《<strong>离散数学及其应用</strong>》，英文原名是$Discrete$ $Mathematics$ $and$ $Its$ $Applications$。</p><p><img src="https://static001.geekbang.org/resource/image/42/48/4219469a129f55f25373045081867848.jpg" alt=""></p><p>这本书是国外高校的教材，对所有离散数学的知识点介绍的比较全面。咱们讲过的同余定理、数学归纳法、递归、分治算法、排列和组合、树和树的遍历、图和最短路径、逻辑以及集合等概念，这里面都有非常详细的介绍。我看很多人对这些内容很感兴趣，可以参考这本书的相关章节，深入学习。</p><!-- [[[read_end]]] --><p>除此之外，这本书还有几个特点，我觉得非常好。</p><p>第一，介绍了不少证明的方法。计算机算法的正确性是很重要的，专栏中我在不同的地方介绍并使用了数学归纳法，在解释Dijkstra算法时也用到了反证法和分情形证明的思想。数学中用于证明的方法其实还有很多，这本书涉及了穷举证明、存在性证明等。相信这些证明方法，可以让你更好地理解，为什么有些算法是可行的，有些算法是有问题的，并帮助你在理解算法、学习算法，甚至设计算法时保证它的正确性。</p><p>第二，介绍了不少逻辑和集合相关的知识。这些我在专栏里没有涉及太多。主要是因为程序员经常接触各种条件和查询语句，对这些内容已经很熟悉了，所以我没有花太多的篇幅。如果你想知道更多关于逻辑、集合和布尔代数这些基础内容的解释，也可以看看这本书。</p><p>第三，和编程结合得非常紧密。主要体现在两个方面：第一，它介绍了一些基于伪代码的算法，也对这些算法进行了时间和空间复杂度的分析，例如常见的排序、搜索算法。第二，它介绍了不少离散数学在计算机科学中的应用场景，例如关系型数据库和SQL查询语言是如何设计的。另外，它也提供了不少课后习题，可以加深你对这些知识点的理解。所以，当你读到这本书的某些章节时，会发现，怎么和计算机的数据结构和算法这么像啊？确实，离散数学和数据结构和基础算法有着紧密的联系，加上这本书使用了不少计算机的语言、例子和应用，自然有不少共同的内容了。</p><p>专栏的第二模块是“概率统计篇”，这本书也谈到了一些离散概率的内容。在学习第二个模块的时候，你也可以搭配这本书的内容来看，相信对你会很有帮助。</p><p>当然，这本书的某些内容讲得比较深，而且有些知识点在程序员日常编码中基本上用不到。你可以结合我专栏的主题和内容，并针对自己的日常工作，挑出一些重点来学习。</p><h2>概率统计篇推荐书籍：《概率统计》</h2><p>专栏第一模块已经结束了，接下来的“概率统计篇”我会着重介绍概率统计及其在计算机领域中的主要应用。你可以预先阅读一些相关的书籍，热热身。这里我推荐另一本国外高校的教材，Morris H．DeGroot和Mark J．Schervish所著的《<strong>概率统计</strong>》，英文原名是$Probability$ $and$ $Statistics$。本书的两位作者，DeGroot和Schervish都是贝叶斯统计理论的重量级人物。</p><p><img src="https://static001.geekbang.org/resource/image/8a/76/8aa4bee1c0b435fd4dbe8bae7f955076.png" alt=""></p><p>这本书包含了概率论常用的知识点，包括了随机变量及其分布、条件概率、期望值、贝叶斯理论、马尔科夫链等等。专栏的第二模块，我也会介绍这些知识点，以及它们在计算机领域，特别是机器学习中的应用。</p><p>我们再来说这本书的几个特色。</p><p>第一，这本书通常以列举非常实用的例子开始，然后详尽地讲解理论及其扩展应用。比如，一开篇解释“概率”的时候，作者使用了抛硬币的例子，分别从“频率”“经典”和“主观”的角度来解释概率，并又阐述了“概率理论”和“概率”有何不同。这样的写法会给你很多思路上的启发，让你获得更直观的认识。文章中也不乏很多来源于各个领域的案例，比如经济学和金融学等等。</p><p>第二，对概念的解释非常详细。比如“充分统计量（sufficient statistic）”这个概念，一般的书可能两句话就解释完了，然后就是大堆的公式，但是这本书用了差不多两页的篇幅来解释它。我觉得这点对自学者而言是非常有帮助的。</p><p>第三，这本书几乎没有任何涉及计算机算法和代码的部分，哪怕是伪代码也没有。我想作者是希望完全从概率和统计本身的角度来写，而避免过多的实现细节。不过，对于这点你也不用过于担心，因为在专栏中，我会结合一些具体的机器学习算法及其应用，给你展示这些理论知识是如何运用到实践中的。</p><p>总的来说，这是一本相当不错的概率和统计方面的专业书籍。如果你预先读读这本书的内容，对概念有了理解，再看我的专栏也会更有感触。</p><h2>线性代数篇推荐书籍：《线性代数及其应用》</h2><p>如今的机器学习模型，除了基于概率和统计，还会使用线性代数的知识，本专栏的第三个模块就是“线性代数”。介绍线性代数的书籍不少，我这里推荐一本David C. Lay和Steven R. Lay合著的《<strong>线性代数及其应用</strong>》，英文原名$Linear$ $Algebra$ $and$ $Its$ $Applications$。</p><p><img src="https://static001.geekbang.org/resource/image/41/65/4103851f3c50c4f1048bbe144178c965.png" alt=""></p><p>这本书最大的特色在于：</p><p>第一，使用通俗易懂的口吻和大量的插图来阐述概念。而且在我看来，这些概念他解释得也相当清楚，比如线性方程、向量空间、特征向量、奇异值的分解等等，这些都是在机器学习算法中常用的模型或技术。</p><p>第二，写作的逻辑也相当清晰。这本书基本上都是先提出一个实际的问题，然后对这个问题进行分析，最终才进行定理式的归纳和证明。通俗易懂的同时，不乏数学的严谨性。和前面两本推荐的书一样，这本书中也结合了很多生动的案例，特别是经济学领域的。</p><p>第三，这本书还配套了一本优秀的学习指南$Linear$ $Algebra$ $and$ $Its$ $Applications$: $Study$ $Guide$。这本指南，加上原书课后的习题，对于自学的读者巩固知识很有帮助。不过我没有找到这本指南的中文翻译版。如果哪位同学有好的练习题推荐，也可以在留言区分享出来。</p><h2>入门、通识类书籍推荐</h2><p>除了上述三本重量级的专业书籍，我觉得还有几本通俗的入门书也是不错的。</p><p>一套是几位日本作家写的《<strong>程序员的数学</strong>》系列，包括《程序员的数学》《程序员的数学：概率统计》《程序员的数学：线性代数》。这套书也强调了和计算机领域紧密相连的三大模块。这几位作者使用朴实的语言，把最重要的一些概念给说明白了。相比前面三本，这套书所涵盖的内容可能没有那么全面、也没有那么深入，不过对于初学者来讲，是不错的入门书籍。</p><p><img src="https://static001.geekbang.org/resource/image/c1/69/c1cf06f722b99ee0a3efd2a530c33c69.png" alt=""></p><p>最后一本书是吴军老师的《<strong>数学之美</strong>》。这本书最大的特点是和计算机领域结合得非常紧密。所有的问题和解决方案，最后都联系到了计算机中的某个应用。可以说，作者更多的是从计算机从业者的角度出发，深入探讨了背后的数学思想和知识。除此之外，吴军老师广博的学识和深刻的见解，在这本书中也体现得淋漓尽致。这本书的写作风格对我写作这个专栏也是非常有启发的。</p><p><img src="https://static001.geekbang.org/resource/image/07/21/07a3b6e3dcbb918f3f9458c23dc32921.png" alt=""></p><p>读书在精，不在多。我选的这些书，你可能多多少少见过，但是能静下心来读完一本的人可能寥寥无几。我相信，订阅这个专栏的你，一定有颗不甘于平庸的心。你一定有你的目标和追求。开卷有益，坚持下去，学下去、读下去，相信你一定会有所收获！</p><p></p>',
        article_title: "数学专栏课外加餐（三）：程序员需要读哪些数学书？",
      },
    ],
  },
  {
    chapterTitle: "结束语 (2讲)",
    children: [
      {
        title: "结束语 | 从数学到编程，本身就是一个很长的链条",
        herf: "https://time.geekbang.org/column/article/90384",
        id: "90384",
        content:
          '<p>你好，我是黄申。不知不觉，4个多月就过去了，终于到了说再见的时候。</p><p>上周编辑对我说：“黄老师，专栏正文写完啦，要写结束语啦！”我当时第一反应是，“啥？已经写完啦？这么快！”。别看我现在“依依不舍”，回想写专栏之初，真的是一波三折。</p><p>我曾经出版过两本大数据相关的书籍，而且销量和口碑都还不错，所以刚开始的时候，我感觉写专栏应该是“得心应手”的事情。可是，试写了几篇之后，在和专栏编辑的沟通中，我逐渐意识到，写专栏和写书完全是两回事。</p><p>写书的时候，往往是作者主导，想把这本书写成什么样，给谁看，这些完全由自己说了算。但是，写专栏文章是不同的，它要有明确的受众，因此就要明确每一篇的知识点深度和密度，并把一个知识点深入浅出地说清楚，确保每个人看完之后能有所收获。</p><p>很快，我就进入了状态。可是，我又遇到了第二个“波折”。</p><p>虽然大家都知道数学和编程是紧密相关的，但是到具体的知识点的时候，就没有那么直观了。对于数学和编程之间的关系，每个人都有自己的理解。我很明白，如果无法厘清这两者的关系，很难写出一个对于程序员来说，非常实用的数学专栏。所以，在写作的同时，我反复地问自己：“数学和编程究竟是什么关系？如何把这种关系的本质通过文字和代码讲解出来？”。</p><!-- [[[read_end]]] --><p>我不断地去思考、和编辑讨论，慢慢发现，多数人对这两者关系不清楚的主要原因是，从数学的知识体系出发，一直到具体的编程应用，整个过程本身是一个很长的链条。</p><p>要把编程领域中的数学讲清楚，我们至少要经历“<strong>数学概念-数学模型-数据结构-基础算法/机器学习算法-编码实现</strong>”这几个关键步骤。</p><p>具体来说，首先你要充分理解一个数学的概念，然后是数学的模型。在这些基础之上，我们才能把它们转换成编程领域中对应的数据结构和算法，最终才能付诸于编码实现。</p><p>经历过这些深度思考，搞明白了专栏的交付目标。每天写稿、录音到深夜，对我来说，都不是什么事情了。因为写这个专栏的过程中，我也收获了很多。总的来说，这几个月的创作充满了艰辛，但是也充满了成就感。希望这个专栏能够帮到你收获知识，以及知识之外的一些对数学的认知，那就是这个专栏最大的意义和价值。</p><p>最后，感谢极客时间这个平台给了我一个机会，能够重新梳理自己这么多年的学习心得和工作经验，更要感谢订阅专栏的你，不断给我反馈和意见。专栏虽然结束了，但是学习应该是持续进行的。非常感谢你的支持，你可以继续在留言区留下的你的疑问，我也会持续不断地进行解答。</p><p>每一次结束都是另一段新旅途的开始，祝福你在工作、生活中都能取得不断的进步！</p><p><a href="http://bbn7rz69sba2z1ns.mikecrm.com/40Q6Dxa"><img src="https://static001.geekbang.org/resource/image/02/e2/02b2209b1e30a4268e38c68a0cdf61e2.jpg" alt=""></a></p><p></p>',
        article_title: "结束语 | 从数学到编程，本身就是一个很长的链条",
      },
      {
        title: "结课测试 | 这些数学知识你都掌握了吗？",
        herf: "https://time.geekbang.org/column/article/224543",
        id: "224543",
        content:
          '<p>你好，我是黄申。</p><p>到这里，《程序员的数学基础课》这门课程已经全部结束了。我给你准备了一个结课小测试，来帮助你检验自己的学习效果。</p><p>这套测试题共有 20 道题目，包括17道单选题和3道多选题，满分 100 分。</p><p>还等什么，点击下面按钮开始测试吧！</p><p><a href="http://time.geekbang.org/quiz/intro?act_id=108&amp;exam_id=228"><img src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png" alt=""></a></p><!-- [[[read_end]]] -->',
        article_title: "结课测试 | 这些数学知识你都掌握了吗？",
      },
    ],
  },
];
