exports.category = "other";
exports.title = "朱涛kotlin编程第一课";
exports.data = [
  {
    chapterTitle: "开篇词",
    children: [
      {
        title: "开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难",
        id: 472129,
        content:
          '<p>你好，我是朱涛，欢迎和我一起学习Kotlin。</p><p>作为一名Kotlin、Android领域的谷歌开发者专家，我曾经负责过陌陌创新业务的Android客户端。从2017年开始，我和我的团队成员们就一直在探索Kotlin在Android中的应用，并在Kotlin函数式编程、Kotlin DSL、Kotlin协程以及Android Jetpack方面积累了一些实践经验。我的博客“Kotlin Jetpack实战”也影响和帮助了数万名Kotlin、Android开发者。</p><p>Kotlin于我来说，就如恋人一般，令我深深地着迷。在过去的5年里，我一直在使用Kotlin进行Android研发的工作。但实际上，在使用Kotlin之前，我的主力语言是Java，那段时间，我负责过陌陌Android客户端的代码规范以及性能优化工作。在这段工作里，我见过各式各样的<strong>Java烂代码</strong>，有些烂代码是程序员主观疏忽写出来的，而还有些代码是业务本身复杂度决定的。那个时候，我就意识到了Java语言的一些缺陷。</p><ul>\n<li><strong>语法表现力差。</strong></li>\n</ul><p>比如，Java 1.8之前不支持Lambda表达式，匿名内部的写法繁琐；在函数方面，不支持高阶函数，不支持参数默认值，也不支持函数命名参数。当我们需要在Java当中实现类似需求时，不得不自己寻求其他替代方案，这就进一步提高了开发难度，降低了开发效率。</p><!-- [[[read_end]]] --><ul>\n<li><strong>可读性差，难维护。</strong></li>\n</ul><p>如果我们单独去看Java的每个语法表现力的问题，可能会觉得没什么大不了。然而，当这样的问题积少成多，并且随着工程复杂度的提升，语法表现力的问题会进一步演变成可读性问题、维护性问题。</p><p>举个例子，Java当中的Callback，如果只是一到两个Callback的嵌套，那么它还在容忍的范围内，一旦业务变得复杂，Callback嵌套超过3层，代码可读性就会急剧下降，而后的维护工作将会变成一场灾难！出现Bug，也只是迟早的问题。</p><ul>\n<li><strong>Java自身的语法设计也使它更容易出错。</strong></li>\n</ul><p>比如，Java基础类型的隐式转换，你可以直接将字符变量赋值给整型变量，而编译器也不会报错。再比如，Java的内部类会偷偷持有外部类的引用，从而在某些场景中导致内存泄漏。Java这样的语法设计就让我们程序员更容易写出Bug。</p><ul>\n<li><strong>并发编程，在Java当中也是一大难题。</strong></li>\n</ul><p>在Java当中，线程与并发以及它复杂的同步机制，它们就像是一头头难以驯服的野马，初中级Java程序员都会对其望而生畏。</p><p>以上Java的所有缺陷，最终反映到实际工作中，就会变成：<strong>前期开发效率低，中期线上问题多，后期代码难维护。</strong>其实，归根结底，都是因为Java实在是太老了。而Kotlin作为一门刚出生不久的语言，就是为了解决这些问题而生的。</p><p>在与Kotlin相伴5年的过程中，我一直在研究、探索这门语言的原理和使用技巧，也沉淀了一些实践经验和思考感悟，希望通过这门课，能给你带来一些新的有关Kotlin的认知以及使用参考，也能够让你在学习之后，可以使用Kotlin来解决工作中的实际问题。</p><h2>Kotlin为什么值得学？</h2><p>其实，不管你之前是不是有过Java的使用经验，你都需要来学习一下这门年轻的语言。我认为主要有这样三个原因。</p><p><strong>第一，极高的生产效率</strong></p><p>Kotlin具备简洁的语法和现代化的语法特性，让使用者可以用更少的时间，以更高的标准，来完成更多的工作。换句话说，也就是跟Java正好相反：前期开发效率更高，中期线上问题更少，后期代码更容易维护。</p><p>以我自身为例，在我们团队完全适应了Kotlin的开发节奏以后，线上崩溃率就大大降低了，而空指针异常也几乎没有了。另外，曾经要3人完成的工作，在使用Kotlin以后，2个人就能完成，而且还能完成得更好。</p><p>为此，不仅各个大厂的Android部门在积极转型，就连Android官方团队也都在用Kotlin写底层的源码，Kotlin相关的SDK也层出不穷。到目前为止，各个大厂的Android招聘要求里都会加上一条“要求熟悉Kotlin”或“熟悉Kotlin语言者优先”。</p><p><strong>第二，强大的兼容性</strong></p><p>Kotlin可以与Java混合编程，这一点尤为重要，不然，Kotlin的吸引力将大打折扣。因为在我们的实际工作当中，大部分情况都是在老旧工程的基础上去开发新功能的，而将整个模块甚至是程序推倒然后用Kotlin重写，其实是很不现实的。</p><p>Kotlin强大的兼容性，就让我们可以复用从前的Java代码，也能让我们以渐进的方式从Java迁移到Kotlin，而不必担心是不是要一次性重写很多代码，从而产生新的问题。</p><p><strong>第三，科技巨头加持，Kotlin的发展前景很广阔</strong></p><p>2017年，Google宣布Kotlin成为Android的官方语言后，人们对于Kotlin的关注度就一直在上升。而这也就导致，很多人听到Kotlin，都会下意识地认为它是用来写Android的。</p><p>其实，Kotlin不仅仅只是在Android领域有所建树，据我所知，<a href="https://talkingkotlin.com/qldb">Amazon</a>、<a href="https://medium.com/adobetech/streamlining-server-side-app-development-with-kotlin-be8cf9d8b61a">Adobe</a>都有将Kotlin应用到后端开发；至于Kotlin跨平台方面，国际上<a href="https://kotlinlang.org/lp/mobile/case-studies/philips">Philips</a>、<a href="https://kotlinlang.org/lp/mobile/case-studies/cash-app">Square</a>等公司也都有不错的实践，国内的携程技术团队在这方面也有不少探索和实践。随着2021年Android Jetpack Compose的发布，JetBrains在其基础上又扩展出了<a href="https://github.com/JetBrains/compose-jb">Compose-jb</a>，让Kotlin还能跨平台编写UI界面。</p><p>总而言之，对于Android开发者来说，Kotlin已是<strong>必学</strong>的编程语言；而对于其他领域的开发者来说，Kotlin也有着非常好的前景，现在入坑还来得及！</p><h2>Kotlin到底难在哪？</h2><p>那么，在看到了Kotlin有如此多的使用优势和如此广阔的发展前景之后，也有不少人都纷纷投入了Kotlin的学习大军当中，甚至很多人都是在有了Java的知识基础和使用经验之后，再去学习的Kotlin，而且他们会觉得，Kotlin的学习很简单，它跟Java的很多语法都是一样的，没啥难的嘛。</p><p>但其实，这是对Kotlin的一种误解。<strong>带着Java经验学习Kotlin，这既是一种助力，同时也是一种阻碍。</strong>在Kotlin学习的前期，Java经验可以帮我们快速掌握它的语法，但到了后期，我们脑子里的Java老一套会限制我们进一步提升。如果我们迟迟不转变自己的思维，只会在Kotlin学习之路上越跑越偏。</p><p>从我的实践经验来看，Java开发者学习Kotlin的难点，主要在于<strong>思维的转变</strong>：</p><ul>\n<li><strong>不变性思维</strong>，虽然Java当中也存在final不变性，然而，Kotlin却将这件事做到了极致：Kotlin要求我们在定义一个变量、集合的时候，就明确规定它的不变性。Kotlin这样的设计，就是希望在软件当中尽可能地消灭可变性。如果我们脑子里没有不变性思维，我们写出来的Kotlin代码将“惨不忍睹”。</li>\n<li><strong>空安全思维</strong>，Kotlin的类型系统分为可空和不可空类型，这样的设计也彻底改变了我们的编程习惯。想要处理好Kotlin的空安全问题，我们也必须完成思维的转变。</li>\n<li><strong>表达式思维</strong>，在Kotlin当中，if、else、when之类的语句，还能作为表达式来使用，这样的语法特性往往可以帮我们简化代码逻辑。</li>\n<li><strong>函数思维</strong>，在Kotlin当中，函数是一等公民。Kotlin也是一门积极拥抱函数式编程的语言，在Kotlin的一些语法设计上，总能看到一些函数式的影子。命令式编程与函数式编程，它们两者有各自的优缺点，也有各自擅长的领域。而Kotlin除了有命令式的一面，对应地，它还有函数式的一面。</li>\n<li><strong>协程思维</strong>，Java开发者在学习Kotlin协程的时候尤为痛苦，因为，在Java开发者脑子里只有“线程思维”，而对协程一无所知。想要真正地理解和掌握Kotlin的协程，我们需要从根本上改变我们脑子里的思维模型。</li>\n</ul><p>Java开发者学习Kotlin很难，那么零基础学习Kotlin会不会更简单呢？毕竟不存在旧思维束缚啊！</p><p>其实不然，零基础，也就意味着编程经验的欠缺。因此，零基础学习Kotlin最大的问题在于：<strong>容易浮于Kotlin语法表面，体会不到Kotlin设计的美感，悟不出Kotlin特性的应用场景，看不到Kotlin底层的实现原理。</strong></p><p>不过，请放心，以上所有的问题，在这门课当中，都会得到解决。</p><p>除了以上的学习难点以外，Kotlin本身的学习曲线和其他的语言不太一样，它是一门<strong>易学难精</strong>的语言。Kotlin的语法非常简洁，确实极其容易入门；但同时，它又拥有许多的新特性，不容易掌握。<strong>即使你掌握了Kotlin的一个个语法，想要写出优雅的Kotlin代码，仍然不是一件容易的事情。</strong></p><p>我凭啥这么说呢？让我从自己学习Kotlin的经历说起。</p><p><img src="https://static001.geekbang.org/resource/image/2e/d0/2ea3975d4dccc3dbab871d50eab171d0.jpg?wh=1920x1013" alt="图片"></p><p>从我的亲身经历来看，我的Kotlin学习之路大致分为三个阶段：</p><ul>\n<li><strong>第一阶段，初窥门径。</strong></li>\n</ul><p>由于Kotlin的语法非常简单，刚开始我非常自信，在学完基础语法以后，就开始试着以Java的思维写Kotlin代码，而Kotlin独有的特性，我却很少用到。渐渐地，我发现了不对劲的地方：因为我<strong>并没有发挥出Kotlin的简洁与高效的优势</strong>。同时，我内心的自信，也逐渐变成了迷茫。我终于知道，自己对Kotlin的理解还非常得浅显。</p><ul>\n<li><strong>第二阶段，登堂入室。</strong></li>\n</ul><p>这时候，难度就上来了，我开始钻研Kotlin的一些新特性的原理，并且研究它们的使用场景。在这个过程中，随着我对Kotlin的理解的深入，我也真切地感受到了Kotlin语法的美感，同时，也深深地爱上了Kotlin这门语言。这时候，我终于登堂入室了。</p><ul>\n<li><strong>第三阶段，豁然开朗。</strong></li>\n</ul><p>当我觉得自己对Kotlin已经足够了解的时候，我决定学习Kotlin的协程。这时候，我几乎绝望了。面对一堆全新的概念，我几乎毫无头绪：协程、作用域、上下文、launch、async、Channel、Flow、异常处理，我完全不知该如何入手。我一边研究协程源码、一边在工作中实践，这一路，我踩过不少坑，也引发过线上故障，磕磕碰碰之间，忽然有一天，量变产生了质变，我终于感觉豁然开朗，前方一片坦途。</p><p>现在回过头来看，当初我的Kotlin学习之路是<strong>艰难且曲折</strong>的。主要还是因为那时候，优质的Kotlin学习资源不多，且不成体系。大家都是跟着官方文档自学，而Kotlin官方文档对初学者又不那么友好，因此只能“摸着石头过河”。</p><p>由于我曲折的Kotlin学习经历，这也决定了我们这门课会力求<strong>简单易懂</strong>。比如，为了让你理解Kotlin的扩展函数的使用场景，我精心制作了普通函数与扩展函数的转换动画：</p><p><img src="https://static001.geekbang.org/resource/image/ee/43/ee2570eb0a1b10155ecf34bd7f291343.gif?wh=720x405" alt="图片"></p><p>另外，<strong>协程一直都是Kotlin学习的难点。</strong>在过去这几年的研究中，我总结出了一套“<strong>协程思维模型</strong>”。在我写协程代码的时候，我的大脑里会有一套对应的模型，来帮我模拟协程的运行过程。而这些，我也会在这门课中，以最直观的方式传授给你。</p><p>比如，下面这张图就展示了协程、线程与进程之间的关系。它能帮你在大脑里建立一个清晰、具体的协程模型。</p><p><img src="https://static001.geekbang.org/resource/image/31/9d/31f035dc1b008be1912b3e221e505f9d.gif?wh=720x405" alt="图片"></p><p>再比如说，为了让你看到协程代码背后<strong>挂起与恢复</strong>的细节，我精心制作了这个示意图。它可以让你对协程挂起函数有一个更深入的认识。</p><p><img src="https://static001.geekbang.org/resource/image/6b/2b/6b772a6ef97e6b5587690d10a8f5bb2b.gif?wh=720x405" alt="图片"></p><p>当然，动画解析只是一种讲述方式，我选这种方式，只是因为它最直观。咱们这门课程的核心理念还是：<strong>帮你快速掌握Kotlin的核心知识点，理解Kotlin的编程思想，最终可以用漂亮的Kotlin代码，来解决工作中的问题。</strong></p><h2>怎么学习Kotlin？</h2><p>Kotlin当中涵盖了很多新的语言特性，要学会这些新特性的语法其实很简单，但是要理解Kotlin设计这些新特性背后的意图，却不容易。而这，恰好就是我们需要重点关注的地方。因为，只有当我们知道Kotlin为什么要设计这些新特性，我们才能弄清楚这些特性的最佳使用场景。</p><p><img src="https://static001.geekbang.org/resource/image/f6/9d/f65548f66702b86a7aa4433aeeea319d.jpg?wh=1920x1315" alt="图片"></p><p>所以在课程中，我会尽量去揣测Kotlin设计者的思路，去对比Kotlin和Java语法的差异，然后用一些实际案例来给你讲解Kotlin新特性的使用场景。具体来看，这个课程主要分为四个部分。</p><ul>\n<li><strong>基础篇</strong></li>\n</ul><p>这个模块，我们会集中精力攻克Kotlin的核心语法，包括基础语法、面向对象、高阶函数、扩展、委托、泛型、注解和反射。并且，每学习三到四个语法，我们就会通过一个<strong>实战项目</strong>将这些知识点串联起来，从而达到学以致用的目的。</p><ul>\n<li><strong>协程篇</strong></li>\n</ul><p>协程，是Kotlin当中极其重要的特性，同时它也是Kotlin当中极其难学的特性。在这个模块，我会深入讲解协程当中的各个概念，并且会给你介绍协程的思维模型，<strong>帮助<strong><strong>你</strong></strong>完成“线程思维”到“协程思维”的转换</strong>。当然了，在这个过程中，我也会结合实战项目，让你能上手体验协程的魅力。</p><ul>\n<li><strong>源码篇</strong></li>\n</ul><p>在理解了前两个模块的内容之后，你就算是初步掌握Kotlin这门语言了。不过，我们不仅<strong>要知其然，还要知其所以然</strong>。</p><p>Kotlin官方的源代码其实是一座宝库，里面充满了Kotlin的最佳实践。通过研究Kotlin的源代码，我们可以进一步加深对Kotlin理解，同时，也可以去探究它底层的原理。比如，Kotlin协程的挂起函数到底是如何挂起的？Kotlin协程到底是如何与线程衔接的？这些问题，我都会在这个模块，用尽量简单的方式解释给你听。</p><ul>\n<li><strong>Android项目篇</strong></li>\n</ul><p>目前来说，Kotlin最主要的应用还是在Android领域。因此，在学完前面几个模块以后，我们再来看看Kotlin在Android领域到底能做什么。Kotlin凭什么能被Google指定为“官方语言”？如何使用Kotlin来提升开发效率？如何将Kotlin的特性融入到Android的架构设计中？最后，我也会带你一起来<strong>用Kotlin写一个简单的Android App</strong>。</p><p>除此之外，我还会不定期进行<strong>加餐</strong>，给你分享Kotlin在各个领域的一些知识，来进一步扩展你的Kotlin知识面。比如，Kotlin协程在后端、Android端的应用，Kotlin Multiplatform在跨平台当中的应用，以及Compose在UI领域的应用。</p><p><img src="https://static001.geekbang.org/resource/image/1a/eb/1a1a47b704fc22ec6646b43b8fd7a4eb.jpg?wh=1564x8151" alt=""></p><p>从课程安排上，相信你已经明白了：这是一个理论与实战结合的课程。因此，在学习的过程中，我希望你能够一边学习，一边跟着我完成课程配套的实战项目。另外，如果你在学习的过程中有了一些新的感悟，也欢迎你将其以博客、部落、留言评论等形式发表出来，分享给更多的人。还有一点是：如果你有不懂的地方，一定要在评论区讲出来，我们一起交流。</p><p>你可以自己立个Flag，每节课都在评论区分享思考题的思路。我相信，几个月后，你一定会有巨大的提升。</p><p>最后，希望你也可以和我一样，爱上Kotlin。</p>',
        article_title: "开篇词 | 入门Kotlin有多容易，精通Kotlin就有多难",
      },
    ],
  },
  {
    chapterTitle: "基础篇",
    children: [
      {
        title: "01 | Kotlin基础语法：正式开启学习之旅",
        id: 472154,
        content:
          '<p>你好，我是朱涛。从今天开始，我们就正式踏上Kotlin语言学习与实践的旅途了。这节课，我想先带你来学习下Kotlin的基础语法，包括变量、基础类型、函数和流程控制。这些基础语法是程序最基本的元素。</p><p>不过，如果你有使用Java的经验，可能会觉得今天的内容有点多余，毕竟Kotlin和Java的基础语法是比较相似的，它们都是基于JVM的语言。但其实不然，Kotlin作为一门新的语言，它包含了许多新的特性，由此也决定着Kotlin的代码风格。<strong>如果你不够了解Kotlin的这些新特性，你会发现自己只是换了种方式在写Java而已。</strong></p><p>并且，在具备Java语言的知识基础上，这节课的内容也可以帮你快速将已有的经验迁移过来。这样的话，针对相似的语法，你可以直接建立Kotlin与Java的对应关系，进而加深理解。当然，即使你没有其他编程经验也没关系，从头学即可，Kotlin的语法足够简洁，也非常适合作为第一门计算机语言来学习。</p><p>在课程中，我会用最通俗易懂的语言，来给你解释Kotlin的基础知识，并且会结合一些Java和Kotlin的代码案例，来帮助你直观地体会两种语言的异同点。而针对新的语法，我也会详细解释它存在的意义，以及都填补了Java的哪些短板，让你可以对Kotlin新语法的使用场景做到心中基本有数。</p><!-- [[[read_end]]] --><h2>开发环境</h2><p>在正式开始学习基础语法之前，我们还需要配置一下Kotlin语言的环境，因为直接从代码开始学能给我们带来最直观的体验。</p><p>那么要运行Kotlin代码，最快的方式，就是<strong>使用Kotlin官方的</strong><a href="https://play.kotlinlang.org/">PlayGround</a>。通过这个在线工具，我们可以非常方便地运行Kotlin代码片段。当然，这种方式用来临时测试一小段代码是没有问题的，但对于复杂的工程就有些力不从心了。</p><p>另一种方式，也是<strong>我个人比较推荐的方式，那就是安装</strong><a href="https://www.jetbrains.com/idea/download/">IntelliJ IDEA</a>。它是Kotlin官方提供的集成开发工具，也是世界上最好的IDE之一，如果你用过Android Studio，你一定会对它很熟悉，因为Android Studio就是由IntelliJ IDEA改造的。</p><p>如果你的电脑没有Java环境，在安装完最新版的IntelliJ IDEA以后，通过“File -&gt; Project Structure -&gt; SDKs”，然后点击“加号按钮”就可以选择第三方提供的OpenJDK 1.8版本进行下载了。</p><p><img src="https://static001.geekbang.org/resource/image/04/a7/04cf1b899574ceff2ecd099e41af1fa7.gif?wh=1000x770" alt="图片"></p><p>当然，这里我更推荐你可以自己手动从<a href="https://www.oracle.com/java/technologies/downloads/">Oracle官网</a>下载JDK 1.6、1.7、1.8、11这几个版本，然后再安装、配置Java多版本环境。这在实际工作中也是必备的。</p><p>需要注意的是，IntelliJ IDEA分为Ultimate付费版和Community免费版，对于我们的Kotlin学习来说，免费版完全够用。</p><p>这样，在配置好了开发环境之后，我们就可以试着一边敲代码，一边体会、思考和学习Kotlin语言中这些最基础的语法知识了。那么下面我们就来看下，在Kotlin语言中是如何定义变量的吧。</p><h2>变量</h2><p>在Java/C当中，如果我们要声明变量，我们必须要声明它的类型，后面跟着变量的名称和对应的值，然后以分号结尾。就像这样：</p><pre><code class="language-java">Integer price = 100;\n</code></pre><p>而Kotlin则不一样，我们要使用“<strong>val</strong>”或者是“<strong>var</strong>”这样的关键字作为开头，后面跟“变量名称”，接着是“变量类型”和“赋值语句”，最后是分号结尾。就像这样：</p><pre><code class="language-plain">/*\n关键字     变量类型\n ↓          ↓           */\nvar price: Int = 100;   /*\n     ↑            ↑\n   变量名        变量值   */\n</code></pre><p>不过，像Java那样每写一行代码就写一个分号，其实也挺麻烦的。所以为了省事，在Kotlin里面，我们一般会把代码末尾的分号省略，就像这样：</p><pre><code class="language-plain">var price: Int = 100\n</code></pre><p>另外，由于Kotlin支持<strong>类型推导</strong>，大部分情况下，我们的变量类型可以省略不写，就像这样：</p><pre><code class="language-plain">var price = 100 // 默认推导类型为： Int\n</code></pre><p>还有一点我们要注意，就是在Kotlin当中，我们应该尽可能避免使用var，<strong>尽可能多地去使用val</strong>。</p><pre><code class="language-plain">var price = 100\nprice = 101\n\nval i = 0\ni = 1 // 编译器报错\n</code></pre><p>原因其实很简单：</p><ul>\n<li>val声明的变量，我们叫做<strong>不可变变量</strong>，它的值在初始化以后就无法再次被修改，它相当于Java里面的final变量。</li>\n<li>var声明的变量，我们叫做<strong>可变变量</strong>，它对应Java里的普通变量。</li>\n</ul><h2>基础类型</h2><p>了解了变量类型如何声明之后，我们再来看下Kotlin中的基础类型。</p><p>基础类型，包括我们常见的数字类型、布尔类型、字符类型，以及前面这些类型组成的数组。这些类型是我们经常会遇到的概念，因此我们把它统一归为“基础类型”。</p><h3>一切都是对象</h3><p>在Java里面，基础类型分为原始类型（Primitive Types）和包装类型（Wrapper Type）。比如，整型会有对应的int和Integer，前者是原始类型，后者是包装类型。</p><pre><code class="language-java">int i = 0; // 原始类型\nInteger j = 1; // 包装类型\n</code></pre><p>Java之所以要这样做，是因为原始类型的开销小、性能高，但它不是对象，无法很好地融入到面向对象的系统中。而包装类型的开销大、性能相对较差，但它是对象，可以很好地发挥面向对象的特性。在 <a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Integer.java">JDK源码</a>当中，我们可以看到Integer作为包装类型，它是有成员变量以及成员方法的，这就是它作为对象的优势。</p><p>然而，在Kotlin语言体系当中，是没有原始类型这个概念的。这也就意味着，<strong>在Kotlin里，一切都是对象。</strong></p><p><img src="https://static001.geekbang.org/resource/image/yy/3b/yyd95b04616943878351867c4d1e063b.jpg?wh=2000x1077" alt=""></p><p>实际上，从某种程度上讲，Java的类型系统并不是完全面向对象的，因为它存在原始类型，而原始类型并不属于对象。而Kotlin则不一样，它从语言设计的层面上就规避了这个问题，类型系统则是完全面向对象的。</p><p>我们看一段代码，来更直观地感受Kotlin的独特之处：</p><pre><code class="language-plain">val i: Double = 1.toDouble()\n</code></pre><p>可以发现，由于在Kotlin中，整型数字“1”被看作是对象了，所以我们可以调用它的成员方法toDouble()，而这样的代码在Java中是无法实现的。</p><h3>空安全</h3><p>既然Kotlin中的一切都是对象，那么对象就有可能为空。也许你会想到写这样的代码：</p><pre><code class="language-plain">val i: Double = null // 编译器报错\n</code></pre><p>可事实上，以上的代码并不能通过Kotlin编译。这是因为Kotlin强制要求开发者<strong>在定义变量的时候，指定这个变量是否可能为null</strong>。对于可能为null的变量，我们需要在声明的时候，在变量类型后面加一个问号“?”：</p><pre><code class="language-plain">val i: Double = null // 编译器报错\nval j: Double? = null // 编译通过\n</code></pre><p>并且由于Kotlin对可能为空的变量类型做了强制区分，这就意味着，“可能为空的变量”无法直接赋值给“不可为空的变量”，当然，反向赋值是没有问题的。</p><pre><code class="language-plain">var i: Double = 1.0\nvar j: Double? = null\n\ni = j  // 编译器报错\nj = i  // 编译通过\n</code></pre><p>Kotlin这么设计的原因也很简单，如果我们将“可能为空的变量”直接赋值给了“不可为空的变量”，这会跟它自身的定义产生冲突。而如果我们实在有这样的需求，也不难实现，只要做个判断即可：</p><pre><code class="language-plain">var i: Double = 1.0\nval j: Double? = null\n\nif (j != null) {\n    i = j  // 编译通过\n}\n</code></pre><p>好，在了解了Kotlin和Java这两种语言的主要区别后，下面就让我们来全面认识下Kotlin的基础类型。</p><h3>数字类型</h3><p>首先，在数字类型上，Kotlin和Java几乎是一致的，包括它们对数字“字面量”的定义方式。</p><pre><code class="language-plain">val int = 1\nval long = 1234567L\nval double = 13.14\nval float = 13.14F\nval hexadecimal = 0xAF\nval binary = 0b01010101\n</code></pre><p>这里我也来给你具体介绍下：</p><ul>\n<li>整数默认会被推导为“Int”类型；</li>\n<li>Long类型，我们则需要使用“L”后缀；</li>\n<li>小数默认会被推导为“Double”，我们不需要使用“D”后缀；</li>\n<li>Float类型，我们需要使用“F”后缀；</li>\n<li>使用“0x”，来代表十六进制字面量；</li>\n<li>使用“0b”，来代表二进制字面量。</li>\n</ul><p>但是，对于数字类型的转换，Kotlin与Java的转换行为是不一样的。<strong>Java可以隐式转换数字类型，而Kotlin更推崇显式转换。</strong></p><p>举个简单的例子，在Java和C当中，我们经常直接把int类型赋值给long类型，编译器会自动为我们做类型转换，如下所示：</p><pre><code class="language-java">int i = 100;\nlong j = i;\n</code></pre><p>这段代码按照Java的编程思维方式来看，的确好像是OK的。但是你要注意，虽然Java编译器不会报错，可它仍然可能会带来问题，因为它们本质上不是一个类型，int、long、float、double这些类型之间的互相转换是存在精度问题的。尤其是当这样的代码掺杂在复杂的逻辑中时，在碰到一些边界条件的情况下，即使出现了Bug也不容易排查出来。</p><p>所以，同样的代码，在Kotlin当中是行不通的：</p><pre><code class="language-plain">val i = 100\nval j: Long = i // 编译器报错\n</code></pre><p>在Kotlin里，这样的隐式转换被抛弃了。正确的做法应该是显式调用Int类型的toLong()函数：</p><pre><code class="language-plain">val i = 100\nval j: Long = i.toLong() // 编译通过\n</code></pre><p>其实，如果我们仔细翻看Kotlin的源代码，会发现更多类似的函数，比如toByte()、toShort()、toInt()、toLong()、toFloat()、toDouble()、toChar()等等。Kotlin这样设计的优势也是显而易见的，<strong>我们代码的可读性更强了，将来也更容易维护了</strong>。</p><h3>布尔类型</h3><p>然后我们再来了解下Kotlin中布尔类型的变量，它只有两种值，分别是<strong>true<strong><strong>和</strong></strong>false</strong>。布尔类型支持一些逻辑操作，比如说：</p><ul>\n<li>“&amp;”代表“与运算”；</li>\n<li>“|”代表“或运算”；</li>\n<li>“!”代表“非运算”；</li>\n<li>“&amp;&amp;”和“||”分别代表它们对应的“短路逻辑运算”。</li>\n</ul><pre><code class="language-plain">val i = 1\nval j = 2\nval k = 3\n\nval isTrue: Boolean = i &lt; j &amp;&amp; j &lt; k\n</code></pre><h3>字符：Char</h3><p>Char用于代表单个的字符，比如<code>\'A\'</code>、<code>\'B\'</code>、<code>\'C\'</code>，字符应该用单引号括起来。</p><pre><code class="language-plain">val c: Char = \'A\'\n</code></pre><p>如果你有Java或C的使用经验，也许会写出这样的代码：</p><pre><code class="language-plain">val c: Char = \'A\'\nval i: Int = c // 编译器报错\n</code></pre><p>这个问题其实跟前面Java的数字类型隐式转换的问题类似，所以针对这种情况，我们应该调用对应的函数来做类型转换。这一点我们一定要牢记在心。</p><pre><code class="language-plain">val c: Char = \'A\'\nval i: Int = c.toInt() // 编译通过\n</code></pre><h3>字符串：String</h3><p>字符串（String），顾名思义，就是一连串的字符。和Java一样，Kotlin中的字符串也是不可变的。在大部分情况下，我们会使用双引号来表示字符串的字面量，这一点跟Java也是一样的。</p><pre><code class="language-plain">val s = "Hello Kotlin!"\n</code></pre><p>不过与此同时，Kotlin还为我们提供了非常简洁的<strong>字符串模板</strong>：</p><pre><code class="language-plain">val name = "Kotlin"\nprint("Hello $name!")\n/*            ↑\n    直接在字符串中访问变量\n*/\n// 输出结果：\nHello Kotlin!\n</code></pre><p>这样的特性，在Java当中是没有的，这是Kotlin提供的新特性。虽然说这个字符串模板功能，我们用Java也同样可以实现，但它远没有Kotlin这么简洁。在Java当中，我们必须使用两个“+”进行拼接，比如说<code>("Hello" + name + "!")</code>。这样一来，在字符串格式更复杂的情况下，代码就会很臃肿。</p><p>当然，如果我们需要在字符串当中引用更加复杂的变量，则需要使用花括号将变量括起来：</p><pre><code class="language-plain">val array = arrayOf("Java", "Kotlin")\nprint("Hello ${array.get(1)}!")\n/*            ↑\n      复杂的变量，使用${}\n*/\n// 输出结果：\nHello Kotlin!\n</code></pre><p>另外，Kotlin还新增了一个<strong>原始字符串</strong>，是用三个引号来表示的。它可以用于存放复杂的多行文本，并且它定义的时候是什么格式，最终打印也会是对应的格式。所以当我们需要复杂文本的时候，就不需要像Java那样写一堆的加号和换行符了。</p><pre><code class="language-plain">val s = """\n       当我们的字符串有复杂的格式时\n       原始字符串非常的方便\n       因为它可以做到所见即所得。 """\n\nprint(s)\n</code></pre><h3>数组</h3><p>最后，我们再来看看Kotlin中数组的一些改变。</p><p>在Kotlin当中，我们一般会使用<strong>arrayOf()</strong>来创建数组，括号当中可以用于传递数组元素进行初始化，同时，Kotlin编译器也会根据传入的参数进行类型推导。</p><pre><code class="language-plain">val arrayInt = arrayOf(1, 2, 3)\nval arrayString = arrayOf("apple", "pear")\n</code></pre><p>比如说，针对这里的arrayInt，由于我们赋值的时候传入了整数，所以它的类型会被推导为整型数组；对于arrayString，它的类型会被推导为字符串数组。</p><p>而你应该也知道，在Java当中，数组和其他集合的操作是不一样的。举个例子，如果要获取数组的长度，Java中应该使用“array.length”；但如果是获取List的大小，那么Java中则应该使用“list.size”。这主要是因为数组不属于Java集合。</p><p>不过，Kotlin在这个问题的处理上并不一样。<strong>虽然Kotlin的数组仍然不属于集合，但它的一些操作是跟集合统一的。</strong></p><pre><code class="language-plain">val array = arrayOf("apple", "pear")\nprintln("Size is ${array.size}")\nprintln("First element is ${array[0]}")\n\n// 输出结果：\nSize is 2\nFirst element is apple\n</code></pre><p>就比如说，以上代码中，我们直接使用array.size就能拿到数组的长度。</p><h2>函数声明</h2><p>好，了解了Kotlin中变量和基础类型的相关概念之后，我们再来看看它的函数是如何定义的。</p><p>在Kotlin当中，函数的声明与Java不太一样，让我们看一段简单的Kotlin代码：</p><pre><code class="language-plain">/*\n关键字    函数名          参数类型   返回值类型\n ↓        ↓                ↓       ↓      */\nfun helloFunction(name: String): String {\n    return "Hello $name !"\n}/*   ↑\n   花括号内为：函数体\n*/\n</code></pre><p>可以看到，在这段代码中：</p><ul>\n<li>使用了<strong>fun关键字</strong>来定义函数；</li>\n<li><strong>函数名称</strong>，使用的是<a href="https://zh.wikipedia.org/zh/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰命名法</a>（大部分情况下）；</li>\n<li><strong>函数参数</strong>，是以(name: String)这样的形式传递的，这代表了参数类型为String类型；</li>\n<li><strong>返回值类型</strong>，紧跟在参数的后面；</li>\n<li>最后是<strong>花括号内的函数体</strong>，它代表了整个函数的逻辑。</li>\n</ul><p>另外你可以再注意一个地方，前面代码中的helloFunction函数，它的函数体实际上只有一行代码。那么针对这种情况，我们其实就可以省略函数体的花括号，直接使用“=”来连接，将其变成一种类似变量赋值的函数形式：</p><pre><code class="language-plain">fun helloFunction(name: String): String = "Hello $name !"\n</code></pre><p>这种写法，我们称之为<strong>单一表达式函数</strong>。需要注意的是，在这种情况下，表达式当中的“return”是需要去掉的。</p><p>另外，由于Kotlin支持类型推导，我们在使用单一表达式形式的时候，返回值的类型也可以省略：</p><pre><code class="language-plain">fun helloFunction(name: String) = "Hello $name !"\n</code></pre><p>看到这里，你一定能体会到Kotlin的魅力。它的语法非常得简洁，并且是符合人类的阅读直觉的，我们读这样的代码，就跟读自然语言一样轻松。</p><p>然而，Kotlin的优势不仅仅体现在函数声明上，在函数调用的地方，它也有很多独到之处。</p><h3>函数调用</h3><p>以我们前面定义的函数为例子，如果我们想要调用它，代码的风格和Java基本一致：</p><pre><code class="language-plain">helloFunction("Kotlin")\n</code></pre><p>不过，Kotlin提供了一些新的特性，那就是<strong>命名参数</strong>。简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><pre><code class="language-plain">helloFunction(name = "Kotlin")\n</code></pre><p>让我们看一个更具体的使用场景：</p><pre><code class="language-plain">fun createUser(\n    name: String,\n    age: Int,\n    gender: Int,\n    friendCount: Int,\n    feedCount: Int,\n    likeCount: Long,\n    commentCount: Int\n) {\n    //..\n}\n</code></pre><p>这是一个包含了很多参数的函数，在Kotlin当中，针对参数较多的函数，我们一般会<strong>以纵向的方式排列</strong>，这样的代码更符合我们从上到下的阅读习惯，省去从左往右翻的麻烦。</p><p>但是，如果我们像Java那样调用createUser，代码就会非常难以阅读：</p><pre><code class="language-plain">createUser("Tom", 30, 1, 78, 2093, 10937, 3285)\n</code></pre><p>这里代码中的第一个参数，我们知道肯定是name，但是到了后面那一堆的数字，就会让人迷惑了。这样的代码不仅难懂，同时还不好维护。</p><p>但如果我们这样写呢？</p><pre><code class="language-plain">createUser(\n    name = "Tom",\n    age = 30,\n    gender = 1,\n    friendCount = 78,\n    feedCount = 2093,\n    likeCount = 10937,\n    commentCount = 3285\n)\n</code></pre><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用“=”连接，建立了两者的对应关系。对比前面Java风格的写法，这样的代码可读性更强了。如果将来你想修改likeCount这个参数，也可以轻松做到。这其实就体现出了Kotlin命名参数的<strong>可读性</strong>与<strong>易维护性</strong>两个优势。</p><p>而除了命名参数这个特性，Kotlin还支持<strong>参数默认值</strong>，这个特性在参数较多的情况下同样有很大的优势：</p><pre><code class="language-plain">fun createUser(\n    name: String,\n    age: Int,\n    gender: Int = 1,\n    friendCount: Int = 0,\n    feedCount: Int = 0,\n    likeCount: Long = 0L,\n    commentCount: Int = 0\n) {\n    //..\n}\n</code></pre><p>我们可以看到，gender、friendCount、feedCount、likeCount、commentCount这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传3个参数，剩余的4个参数没有传，但是Kotlin编译器会自动帮我们填上默认值。</p><pre><code class="language-plain">createUser(\n    name = "Tom",\n    age = 30,\n    commentCount = 3285\n)\n</code></pre><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。Kotlin这样的特性，在一些场景下就可以极大地提升我们的开发效率。</p><p>而如果是在Java当中要实现类似的事情，我们就必须手动定义“3个参数的createUser函数”，或者是使用Builder设计模式。</p><h2>流程控制</h2><p>在Kotlin当中，流程控制主要有if、when、for、 while，这些语句可以控制代码的执行流程。它们也是体现代码逻辑的关键。下面我们就来一一学习下。</p><h3>if</h3><p>if语句，在程序当中主要是用于逻辑判断。Kotlin当中的if与Java当中的基本一致：</p><pre><code class="language-plain">val i = 1\nif (i &gt; 0) {\n    print("Big")\n} else {\n    print("Small")\n}\n\n输出结果：\nBig\n</code></pre><p>可以看到，由于i大于0，所以程序会输出“Big”，这很好理解。不过Kotlin的if，并不是程序语句（Statement）那么简单，它还可以作为<strong>表达式</strong>（Expression）来使用。</p><pre><code class="language-plain">val i = 1\nval message = if (i &gt; 0) "Big" else "Small"\n\nprint(message)\n\n输出结果：\nBig\n</code></pre><p>以上的代码其实跟之前的代码差不多，它们做的是同一件事。不同的是，我们把if当作表达式在用，将if判断的结果，赋值给了一个变量。同时，Kotlin编译会根据if表达式的结果自动推导出变量“message”的类型为“String”。这种方式就使得Kotlin的代码更加简洁。</p><p>而类似的逻辑，如果要用Java来实现的话，我们就必须先在if外面定义一个变量message，然后分别在两个分支内对message赋值：</p><pre><code class="language-java">int i = 1\nString message = ""\nif (i &gt; 0) {\n    message = "Big"\n} else {\n    message = "Small"\n}\n\nprint(message)\n</code></pre><p>这样两相对比下，我们会发现Java的实现方式明显丑陋一些：<strong>不仅代码行数更多，逻辑也松散了</strong>。</p><p>另外，由于Kotlin当中明确规定了类型分为“可空类型”“不可空类型”，因此，我们会经常遇到可空的变量，并且要判断它们是否为空。我们直接来看个例子：</p><pre><code class="language-plain">fun getLength(text: String?): Int {\n  return if (text != null) text.length else 0\n}\n</code></pre><p>在这个例子当中，我们把if当作表达式，如果text不为空，我们就算出它的长度；如果它为空，长度就取0。</p><p>但是，如果你实际使用Kotlin写过代码，你会发现：在Kotlin中，类似这样的判断逻辑出现得非常频繁，如果每次都要写一个完整的if else分支，其实也很麻烦。</p><p>为此，Kotlin针对这种情况就提供了一种简写，叫做<strong>Elvis表达式</strong>。</p><pre><code class="language-plain">fun getLength(text: String?): Int {\n  return text?.length ?: 0\n}\n</code></pre><p>可以看到，通过Elvis表达式，我们就再也不必写“<code>if (xxx != null) xxx else xxx</code>”这样的赋值代码了。它在提高代码可读性的同时，还能提高我们的编码效率。</p><h3>when</h3><p>when语句，在程序当中主要也是用于逻辑判断的。当我们的代码逻辑只有两个分支的时候，我们一般会使用if/else，而在大于两个逻辑分支的情况下，我们使用when。</p><pre><code class="language-plain">val i: Int = 1\n\nwhen(i) {\n    1 -&gt; print("一")\n    2 -&gt; print("二")\n    else -&gt; print("i 不是一也不是二")\n}\n\n输出结果：\n一\n</code></pre><p>when语句有点像Java里的switch case语句，不过Kotlin的when更加强大，它同时也可以<strong>作为表达式，为变量赋值</strong>，如下所示：</p><pre><code class="language-plain">val i: Int = 1\n\nval message = when(i) {\n    1 -&gt; "一"\n    2 -&gt; "二"\n    else -&gt; "i 不是一也不是二" // 如果去掉这行，会报错\n}\n\nprint(message)\n</code></pre><p>另外，与switch不一样的是，when表达式要求它里面的逻辑分支必须是完整的。举个例子，以上的代码，如果去掉else分支，编译器将报错，原因是：i的值不仅仅只有1和2，这两个分支并没有覆盖所有的情况，所以会报错。</p><h3>循环迭代：while与for</h3><p>首先while循环，我们一般是用于重复执行某些代码，它在使用上和Java也没有什么区别：</p><pre><code class="language-plain">var i = 0\nwhile (i &lt;= 2) {\n    println(i)\n    i++\n}\n\nvar j = 0\ndo {\n    println(j)\n    j++\n} while (j &lt;= 2)\n\n输出结果：\n0\n1\n2\n0\n1\n2\n</code></pre><p>但是对于for语句，Kotlin和Java的用法就明显不一样了。</p><p>在Java当中，for也会经常被用于循环，经常被用来替代while。不过，<strong>Kotlin的for语句更多的是用于“迭代”。</strong>比如，以下代码就代表了迭代array这个数组里的所有元素，程序会依次打印出：“1、2、3”。</p><pre><code class="language-plain">val array = arrayOf(1, 2, 3)\nfor (i in array) {\n    println(i)\n}\n</code></pre><p>而除了迭代数组和集合以外，Kotlin还支持迭代一个“区间”。</p><p>首先，要定义一个区间，我们可以使用“<code>..</code>”来连接数值区间的两端，比如“<code>1..3</code>”就代表从1到3的闭区间，左闭右闭：</p><pre><code class="language-plain">val oneToThree = 1..3 // 代表 [1, 3]\n</code></pre><p>接着，我们就可以使用for语句，来对这个闭区间范围进行迭代：</p><pre><code class="language-plain">for (i in oneToThree) {\n    println(i)\n}\n\n输出结果：\n1\n2\n3\n</code></pre><p>甚至，我们还可以<strong>逆序迭代</strong>一个区间，比如：</p><pre><code class="language-plain">for (i in 6 downTo 0 step 2) {\n    println(i)\n}\n\n输出结果：\n6\n4\n2\n0\n</code></pre><p>以上代码的含义就是逆序迭代一个区间，从6到0，每次迭代的步长是2，这意味着6迭代过后，到4、2，最后到0。<strong>需要特别注意的是</strong>，逆序区间我们不能使用“<code>6..0</code>”来定义，如果用这样的方式来定义的话，代码将无法正常运行。</p><p>好了，那么到目前为止，Kotlin的变量、基础类型、函数、流程控制，我们就都已经介绍完了。掌握好这些知识点，我们就已经可以写出简单的程序了。当然，我们的Kotlin学习之路才刚刚开始，在下节课，我会带你来学习Kotlin面向对象相关的知识点。</p><h2>小结</h2><p>学完了这节课，现在我们知道虽然Kotlin和Java的语法很像，但在一些细节之处，Kotlin总会有一些新的东西。如果你仔细琢磨这些不同点，你会发现它正是大部分程序员所需要的。举个例子，作为开发者，我们都讨厌写冗余的代码，喜欢简洁易懂的代码。那么在今天学完了基础语法之后，我们可以来看看Kotlin在这方面都做了哪些改进：</p><ul>\n<li>支持类型推导；</li>\n<li>代码末尾不需要分号；</li>\n<li>字符串模板；</li>\n<li>原始字符串，支持复杂文本格式；</li>\n<li>单一表达式函数，简洁且符合直觉；</li>\n<li>函数参数支持默认值，替代Builder模式的同时，可读性还很强；</li>\n<li>if和when可以作为表达式。</li>\n</ul><p>同时，JetBrains也非常清楚开发者在什么情况下容易出错，所以，它在语言层面也做了很多改进：</p><ul>\n<li>强制区分“可为空变量类型”和“不可为空变量类型”，规避空指针异常；</li>\n<li>推崇不可变性（val），对于没有修改需求的变量，IDE会智能提示开发者将“var”改为“val”；</li>\n<li>基础类型不支持隐式类型转换，这能避免很多隐藏的问题；</li>\n<li>数组访问行为与集合统一，不会出现array.length、list.size这种恼人的情况；</li>\n<li>函数调用支持命名参数，提高可读性，在后续维护代码的时候不易出错；</li>\n<li>when表达式，强制要求逻辑分支完整，让你写出来的逻辑永远不会有漏洞。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/32/67/32ab3d37cd7f9650f4cba17736305c67.jpg?wh=1920x1983" alt="图片"></p><p>这些都是Kotlin的<strong>闪光点</strong>，也是它最珍贵的地方。</p><p>这一切，都得益于Kotlin的发明者JetBrains。作为最负盛名的IDE创造者，JetBrains能深刻捕捉到开发者的需求。它知道开发者喜欢什么、讨厌什么，它甚至知道开发者容易犯什么样的错误，从而在语言设计的层面规避错误。站在这个角度看，JetBrains能够创造出炙手可热的Kotlin语言，就一点都不奇怪了。</p><p>以上这么多的“闪光点”还仅仅只是局限于我们这节课的内容，如果放眼全局，这样的例子更是数不胜数。<strong>Kotlin对比Java的提升，如果独立去看其中的某一个点，都不足以让一个开发者心动。不过，一旦这样的改善积少成多，Kotlin的优势就会显得尤为明显。</strong>这也是很多程序员表示“Kotlin用过了就回不去”的原因。</p><h2>思考题</h2><p>虽然Kotlin在语法层面摒弃了“原始类型”，但有时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</p><p>欢迎在评论区分享你的思路，这个问题我会在第三节课给出答案，我们下节课再见。</p>',
        article_title: "01 | Kotlin基础语法：正式开启学习之旅",
      },
      {
        title: "02 | 面向对象：理解Kotlin设计者的良苦用心",
        id: 473349,
        content:
          '<p>你好，我是朱涛。这节课，我们来学习Kotlin的面向对象编程：类、接口、继承、嵌套，以及Kotlin独有的数据类和密封类。</p><p>面向对象（Object Oriented）是软件开发方法，也是计算机界应用最广的一种编程范式。它是把程序的“数据”和“方法”作为一个整体来看待，将其抽象成了一个具体的模型，从而更贴近事物的自然运行模式。它的特点是简单易懂，符合人类的思维模式。</p><p>在“面向对象”的概念上，虽然Kotlin和Java之间有一定的语法差异，但底层的思想是没有变的。比如Java和Kotlin当中，都有类、接口、继承、嵌套、枚举的概念，唯一区别就在于这些概念在两种语言中的具体语法不同。<strong>我们需要做的，仅仅只是为我们脑海里已经熟知的概念，再增加一种语法规则而已。</strong></p><p>而如果你没有Java基础也没关系，今天这节课要学习的内容，几乎是所有编程语言都需要掌握的概念。在掌握了Kotlin面向对象的编程思想后，如果你再去学习其他编程语言，你也照样可以快速迁移这些知识点。</p><p>当然，Kotlin作为一门新的语言，它也创造了一些新的东西，比如数据类、密封类、密封接口等。这些Kotlin的新概念，会是我们需要着重学习的对象。<strong>实际上，也正是因为Kotlin的这些独有概念，使得它形成了一种独特的编程风格和编程思想。</strong></p><!-- [[[read_end]]] --><p>那么，在学习这节课的时候，我想请你注意一点，就是如果你已经有了Java、C的编程经验，一定要有意识地跳出从前的编程习惯，尝试去理解Kotlin的编程思想。只有这样，你才能写出地道的Kotlin代码，而不仅仅只是用Kotlin语法翻译Java/C代码。</p><h2>怎么写出有Kotlin特点的类？</h2><p>Kotlin当中的“类”，我们可以将其理解为对某种事物的“抽象模型”。比如说，我们可以在Kotlin当中定义一个类，它叫做Person。</p><pre><code class="language-plain">class Person(val name: String, var age: Int)\n</code></pre><p>计算机的世界里当然没有“人”的概念，但是这并不妨碍我们在代码当中定义一个人的“抽象模型”。上面的Person类当中，有一个属性，叫做“name”，每个人都会有名字，而名字也是属于人的一部分。这也很好理解，对吧。</p><p>不过，如果你以Java的角度来分析上面的代码的话，会发现它并没有表面上那么简单。如果我们将其翻译成等价的Java代码，它会变成很多行代码：</p><pre><code class="language-java">public class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 属性 name 没有 setter\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre><p>那么，把Kotlin和Java的代码对比着来看，我们很快就会发现，Kotlin当中，Person类的<strong>name是用val修饰的</strong>，这意味着，它在初始化以后将无法被修改。这个逻辑对应到Java当中，就是该变量只有getter没有setter。而Kotlin当中，Person类的<strong>age是var修饰的</strong>，意味着它是可以被随意修改的。这个逻辑对应到Java当中，就是该变量既有getter也有setter。</p><p>这下你应该就明白了，<strong>Kotlin定义的类，在默认情况下是public的</strong>，编译器会帮我们生成“构造函数”，对于类当中的属性，Kotlin编译器也会根据实际情况，自动生成getter和setter。</p><p>到这里，我们不得不感叹Kotlin语言的简洁性。Kotlin里简单到不能再简单的一行代码，在Java中却要写这么一大串。要注意，这里的差距并不仅仅是我们程序员敲代码的时间，还包括后续我们迭代维护的时间，或者说是读代码的时间。Kotlin一行代码，我们轻松就能理解了，而对应的Java则完全不一样。并且，这还只是一个最简单的案例，真实的程序比这复杂千万倍。</p><h3>自定义属性getter</h3><p>我们继续来看前面的Person类的例子。如果这时候，我们希望它增加一个功能，就是根据年龄的大小自动判断是不是成年人，也就是age≥18。</p><p>如果按照我们从前的Java思维，一定会习以为常地写出下面这样的代码，也就是为Person类增加一个新的方法：isAdult()。</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    fun isAdult(): Boolean {\n        return age &gt;= 18 \n    }\n}\n</code></pre><p>又或者，我们可以充分发挥Kotlin的简洁语法特性，将isAdult()写得更加清爽一些：</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    fun isAdult() = age &gt;= 18 \n}\n</code></pre><p>代码写成这样，已经算不错了。然而，我们还可以用另一种更符合直觉的写法，那就是将isAdult()定义成Person的属性。具体的做法，就是借助Kotlin属性的<strong>自定义getter</strong>。</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    val isAdult\n        get() = age &gt;= 18\n//        ↑\n//    这就是isAdult属性的getter方法\n}\n</code></pre><p>所谓getter，就是<strong>获取属性值的方法</strong>。我们通过自定义这个get()方法，就可以改变返回值的规则。比如，这里的年龄大于等于18，就是成年人，这个规则就是通过自定义来实现的。</p><p>以上的isAdult属性，我们省略了它的类型，因为编译器会自动推导它的类型是Boolean（布尔）类型。另外，由于get()方法内部只有一行代码，我们使用了函数的“单一表达式”写法，直接用等号连接即可。</p><p>而如果get()方法内部的逻辑比较复杂，我们仍然可以像正常函数那样，带上花括号：</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    val isAdult: Boolean\n        get() {\n            // do something else\n            return age &gt;= 18\n        }\n}\n</code></pre><p>不过需要注意的是，在这种情况下，编译器的自动类型推导就会失效了，所以我们要为isAdult属性增加明确的类型：Boolean。</p><p>看到这里，也许你会觉得奇怪：判断一个人是否为成年人，我们只需要判断age这个属性即可，<strong>为什么还要引入一个新的属性isAdult呢？</strong>这不是凭空多占用了一个变量的内存吗？这么做是否有必要？</p><p>实际上，这里涉及到Java到Kotlin的一种思想转变。让我们来详细分解上面的问题：</p><ul>\n<li>首先，<strong>从语法的角度</strong>上来说，是否为成年人，本来就是属于人身上的一种属性。我们在代码当中将其定义为属性，更符合直觉。而如果我们要给Person增加一个行为，比如walk，那么这种情况下定义一个新的方法就是非常合适的。</li>\n<li>其次，<strong>从实现层面</strong>来看，我们确实定义了一个新的属性isAdult，但是Kotlin编译器能够分析出，我们这个属性实际是根据age来做逻辑判断的。在这种情况下，Kotlin编译器可以在JVM层面，将其优化为一个方法。</li>\n<li>通过以上两点，我们就成功在语法层面有了一个isAdult属性；但是<strong>在实现层面，isAdult仍然还是个方法</strong>。这也就意味着，isAdult本身不会占用内存，它的性能和我们用Java写的方法是一样的。而这在Java当中是无法实现的。</li>\n</ul><p>所以，当你使用Kotlin来编写代码的时候，一定要注意其中引入的Kotlin属性的含义，并且理解它的底层实现逻辑。只有这样，你才能真正发挥Kotlin简洁语法的优势，而不必束缚在Java或者C的代码撰写思维里。</p><p>对了，也许你会突发奇想，想要将上面的代码进一步简化，比如写成这样：</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    val isAdult = age &gt;= 18\n}\n</code></pre><p>但实际上，这种代码是无法正常工作的。由于它牵涉到Kotlin的原理，你可以在学完下一节“Kotlin原理”之后，再回过头来看看这段代码为什么有问题。</p><h3>自定义属性setter</h3><p>我们继续来看前面的Person案例，假设这时候我们又来了一个新的需求，希望在age被修改的时候，能够做一些日志统计工作。如果是Java，那我们直接在setAge()方法当中加入一些逻辑就行了。</p><p>可是在Kotlin当中，我们要怎么办呢？答案也很容易想到，<strong>自定义setter</strong>。</p><pre><code class="language-plain">class Person(val name: String) {\n    var age: Int = 0\n//  这就是age属性的setter\n//       ↓\n        set(value: Int) {\n            log(value)\n            field = value\n        }\n    // 省略\n}\n</code></pre><p>所谓setter，就是<strong>可以对属性赋值的方法</strong>。当我们想要改变属性的赋值逻辑时，我们就可以通过自定义来实现了。需要注意的是，以上代码当中的value，就是set方法传入的参数。而set()方法当中的field则是代表了age，这是Kotlin编译器为我们提供的字段。field = value，这一行代码就表示我们实现了对age的赋值操作。</p><p>有的时候，我们不希望属性的set方法在外部访问，那么我们可以给set方法加上可见性修饰符，比如这里，我们可以给set方法加上private，限制它仅可以在类的内部访问：</p><pre><code class="language-plain">class Person(val name: String) {\n    var age: Int = 0\n        private set(value: Int) {\n            log(value)\n            field = value\n        }\n    // 省略\n}\n</code></pre><p>在了解了Kotlin中类的定义以后，我们再来看一种特殊的类：抽象类。</p><h2>抽象类与继承</h2><p>前面我们所创建的类，比如Person，它是具体的、已经定型的类，我们可以直接用它来创建对象。而抽象类，则不是具体的类，它没有完全定型，我们也不能直接用它来创建对象。</p><p>在Kotlin当中，抽象类的定义和Java几乎一样，也就是在关键字“class”“fun”的前面加上abstract关键字即可。这里我们继续上面的例子，把Person定义成抽象类，然后为它添加一个抽象方法：</p><pre><code class="language-plain">abstract class Person(val name: String) {\n    abstract fun walk()\n    // 省略\n}\n</code></pre><p>这样一来，如果我们要创建Person类，就必须要使用匿名内部类的方式，或者使用Person的子类来创建变量。而这，就需要用到<strong>类的继承</strong>了。</p><p>从概念上讲，Kotlin的继承和Java的并没有区别，它们只是在语法上有一点点不一样。Java当中我们是使用extends表示继承，而Kotlin当中我们则使用冒号来表示继承。</p><pre><code class="language-java">//                      Java 的继承\n//                           ↓\npublic class MainActivity extends Activity {\n    @Override\n    void onCreate(){ ... }\n}\n\n//              Kotlin 的继承\n//                 ↓\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate() { ... }\n}\n</code></pre><p>除了继承的语法不太一样，重写的表达方式也不太一样。Java当中是使用@Override注解，而Kotlin当中直接将其定义为了<strong>override关键字</strong>。而除了抽象类以外，正常的类其实也是可以被继承的。不过，我们必须对这个类<strong>标记为open</strong>。如果一个类不是抽象类，并且没有用open修饰的话，它是无法被继承的。</p><pre><code class="language-plain">class Person() {\n    fun walk()\n}\n\n// 报错\nclass Boy: Person() {\n}\n</code></pre><p>根据以上代码我们可以看到，Person不是抽象类，同时它也没有被open修饰。Boy这个类尝试继承Person，会导致编译器报错。所以，我们必须为Person这个类加上open关键字：</p><pre><code class="language-plain">open class Person() {\n    open fun walk()\n}\n\nclass Boy: Person() {\n    // 省略重写逻辑\n}\n</code></pre><p>所以，Kotlin的类，默认是不允许继承的，除非这个类明确被open关键字修饰了。另外，对于被open修饰的普通类，它内部的方法和属性，默认也是不允许重写的，除非它们也被open修饰了：</p><pre><code class="language-plain">open class Person() {\n    val canWalk: Boolean = false\n    fun walk()\n}\n\nclass Boy: Person() {\n    // 报错\n    override val canWalk: Boolean = true\n    // 报错\n    override fun walk() {\n    }\n}\n</code></pre><p>可以看到，由于Person类当中的canWalk属性以及walk()方法，它们都没有使用open修饰，在这种情况下，即使Person可以被继承，但在继承之后的Boy类当中，我们是无法重写canWalk属性、walk()方法的。</p><p>也就是说，<strong>在继承的行为上面，Kotlin和Java完全相反。</strong>Java当中，一个类如果没有被final明确修饰的话，它默认就是可以被继承的。而这同时也就导致了，在Java当中“继承”被过度使用。对于这一点，经典书籍<a href="https://book.douban.com/subject/1103015">《Effective Java》</a>也有提到过。</p><p>所以，<strong>Java的继承是默认开放的，Kotlin的继承是默认封闭的</strong>。Kotlin的这个设计非常好，这样就不会出现Java中“继承被滥用”的情况。</p><p>好，下面，我们再来看看另一种常见的面向对象的编程方式，那就是“实现”。</p><h2>接口和实现</h2><p>Kotlin当中的接口（interface），和Java也是大同小异的，它们都是通过<strong>interface</strong>这个关键字来定义的。</p><pre><code class="language-plain">interface Behavior {\n    fun walk()\n}\n\nclass Person(val name: String): Behavior {\n    override fun walk() {\n        // walk\n    }\n    // ...\n}\n</code></pre><p>可以看到在以上的代码中，我们定义了一个新的接口Behavior，它里面有一个需要被实现的方法walk，然后我们在Person类当中实现了这个接口。</p><p>而在这里，我们又会发现Kotlin和Java不同的小细节：<strong>Kotlin的继承和接口实现语法是一样的。</strong>多么得贴心！</p><p>Kotlin的接口，跟Java最大的差异就在于，接口的方法可以有默认实现，同时，它也可以有属性。比如，我们来看看下面这段代码：</p><pre><code class="language-plain">interface Behavior {\n    // 接口内的可以有属性\n    val canWalk: Boolean\n\n    // 接口方法的默认实现\n    fun walk() {\n        if (canWalk) {\n            // do something\n        }\n    }\n}\n\nclass Person(val name: String): Behavior {\n    // 重写接口的属性\n    override val canWalk: Boolean\n        get() = true\n}\n</code></pre><p>可以看到，我们在Behavior接口当中增加了一个属性canWalk，代表是否可以行走。与此同时，我们在接口方法当中，为walk()方法提供了默认实现，这个实现的逻辑也很简单，如果canWalk为true，才执行walk内部的具体行为。</p><p>需要特别注意的是，由于walk已经有了默认的实现，所以我们在Person类当中就可以不必实现walk方法了。而Kotlin的这一设计，就让“接口”和“抽象类”之间的界限越来越模糊了。</p><p>换句话说，Kotlin当中的接口，被设计得更加强大了，<strong>它拥有了部分抽象类才有的特性，同时还可以灵活使用接口组合的特性</strong>。</p><p>另外你还需要知道一点，就是虽然在Java 1.8版本当中，接口也引入了类似的特性，但由于Kotlin是完全兼容Java 1.6版本的。因此为了实现这个特性，Kotlin编译器在背后做了一些转换。这也就意味着，它是有一定局限性的。而具体的局限体现在哪里呢？这个我先不多讲，你可以自己回去思考思考。</p><h2>嵌套</h2><p>Java当中，最常见的嵌套类分为两种：非静态内部类、静态内部类。Kotlin当中也有一样的概念。</p><pre><code class="language-plain">class A {\n    class B {\n    }\n}\n</code></pre><p>以上代码中，B类，就是A类里面的嵌套类，这非常容易理解。不过我们需要注意的是，这种写法的嵌套类，我们无法在B类当中访问A类的属性和成员方法。</p><pre><code>class A {\n    val name: String = &quot;&quot;\n    fun foo() = 1\n\n\n    class B {\n        val a = name   // 报错\n        val b = foo()  // 报错\n    }\n}\n</code></pre><p>可以看到，当我们尝试在B类当中访问A类的成员时，编译器会报错。如果你有Java基础，应该马上就能反应过来：这种写法就对应了Java当中的静态内部类！</p><pre><code>// 等价的Java代码如下：\npublic class A() {\n    public String name = &quot;&quot;;\n    public int foo() { return 1; }\n\n\n    public static class B {\n        String a = name)   // 报错\n        int b = foo()      // 报错\n    }\n}\n</code></pre><p>所以，Kotlin当中的普通嵌套类，它的本质是静态的。相应地，如果想在Kotlin当中定义一个普通的内部类，我们需要在嵌套类的前面加上<strong>inner关键字</strong>。</p><pre><code>class A {\n    val name: String = &quot;&quot;\n    fun foo() = 1\n// 增加了一个关键字\n//    ↓\n    inner class B {\n        val a = name   // 通过\n        val b = foo()  // 通过\n    }\n}\n</code></pre><p>inner关键字，代表了B类是A类内部的类，这种情况下，我们在B类的内部是可以访问A类的成员属性和方法的。</p><p>Kotlin的这种设计非常巧妙。如果你熟悉Java开发，你会知道，Java当中的嵌套类，如果没有static关键字的话，它就是一个内部类，这样的内部类是会持有外部类的引用的。可是，这样的设计在Java当中会非常容易出现内存泄漏！而大部分Java开发者之所以会犯这样的错误，往往只是因为忘记加“static”关键字了。这是一个Java开发者默认情况下就容易犯的错。</p><p>Kotlin则反其道而行之，在默认情况下，<strong>嵌套类变成了静态内部类</strong>，而这种情况下的嵌套类是不会持有外部类引用的。只有当我们真正需要访问外部类成员的时候，我们才会加上inner关键字。这样一来，默认情况下，开发者是不会犯错的，只有手动加上inner关键字之后，才可能会出现内存泄漏，而当我们加上inner之后，其实往往也就能够意识到内存泄漏的风险了。</p><p>也就是说，<strong>Kotlin这样的设计，就将默认犯错的风险完全抹掉了！</strong></p><h2>Kotlin中的特殊类</h2><p>好了，到目前为止，我们接触到的都是Kotlin与Java都有的概念。接下来，我们来看两个Java当中没有的概念，数据类和密封类。</p><h3>数据类</h3><p>数据类（Data Class），顾名思义，就是<strong>用于存放数据的类</strong>。要定义一个数据类，我们只需要在普通的类前面加上一个关键字“data”即可。比如前面案例当中的Person类，我们只需要在它的前面加上data，就可以将它变为一个“数据类”。</p><pre><code class="language-plain">    // 数据类当中，最少要有一个属性\n                   ↓\ndata class Person(val name: String, val age: Int)\n</code></pre><p>在Kotlin当中，编译器会为数据类自动生成一些有用的方法。它们分别是：</p><ul>\n<li>equals()；</li>\n<li>hashCode()；</li>\n<li>toString()；</li>\n<li>componentN() 函数；</li>\n<li>copy()。</li>\n</ul><p>所以，即使我们的Person类只有一行Kotlin代码，我们仍然可以在其他地方调用编译器，为我们自动生成这些方法。</p><pre><code class="language-plain">val tom = Person("Tom", 18)\nval jack = Person("Jack", 19)\n\nprintln(tom.equals(jack)) // 输出：false\nprintln(tom.hashCode())   // 输出：对应的hash code\nprintln(tom.toString())   // 输出：Person(name=Tom, age=18)\n\nval (name, age) = tom     // name=Tom, age=18\nprintln("name is $name, age is $age .")\n\nval mike = tom.copy(name = "Mike")\nprintln(mike)             // 输出：Person(name=Mike, age=18)\n</code></pre><p>这里你需要注意的是最后的四行代码。</p><p>“val (name, age) = tom”这行代码，其实是使用了数据类的解构声明。这种方式，可以让我们快速通过数据类来创建一连串的变量。另外，就是copy方法。数据类为我们默认实现了copy方法，可以让我们非常方便地在创建一份拷贝的同时，修改某个属性。</p><h3>密封类</h3><p>Kotlin当中的密封类，常常用来表示某种受到限制的继承结构。这样说起来可能有点抽象，让我们换个说法：<strong>密封类，是更强大的枚举类</strong>。</p><p>首先，让我们看看枚举类是什么。</p><pre><code class="language-plain">enum class Human {\n    MAN, WOMAN\n}\n\nfun isMan(data: Human) = when(data) {\n    Human.MAN -&gt; true\n    Human.WOMAN -&gt; false\n    // 这里不需要else分支，编译器自动推导出逻辑已完备\n}\n</code></pre><p>我们通过enum就可以定义枚举类，<strong>所谓枚举，就是一组有限的数量的值</strong>。比如，人分为男人和女人。这样的分类是有限的，所以我们可以枚举出每一种情况。我们在when表达式当中使用枚举时，编译器甚至可以自动帮我们推导出逻辑是否完备。这是枚举的优势。</p><p>但是，枚举也有它的局限性。</p><pre><code class="language-plain">println(Human.MAN == Human.MAN)\nprintln(Human.MAN === Human.MAN)\n\n输出\ntrue\ntrue\n</code></pre><p>比如在这里我们可以看到，当我们尝试去判断枚举的“结构相等”和“引用相等”时，结果始终都是true。而这就代表了，每一个枚举的值，它在内存当中始终都是同一个对象引用。</p><p>那么万一，我们想要枚举的值拥有不一样的对象引用，我们该怎么办呢？这时候就需要“密封类”出场了！</p><p>想要定义密封类，我们需要使用<strong>sealed关键字</strong>，它的中文含义也代表着“密封”。在Android开发当中，我们会经常使用密封类对数据进行封装。比如我们可以来看一个代码例子：</p><pre><code class="language-plain">sealed class Result&lt;out R&gt; {\n    data class Success&lt;out T&gt;(val data: T, val message: String = "") : Result&lt;T&gt;()\n\n    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()\n\n    data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()\n}\n</code></pre><p>这个例子是改造于我实际工作中用过的代码。首先，我们使用sealed关键字定义了一个Result类，并且它需要一个泛型参数R，R前面的out我们可以暂时先忽略。</p><p>这个密封类，我们是专门用于封装网络请求结果的。可以看到，在Result类当中，分别有三个数据类，分别是Success、Error、Loading。我们将一个网络请求结果也分为了三大类，分别代表请求成功、请求失败、请求中。</p><p>这样，当网络请求有结果以后，我们的UI展示逻辑就会变得非常简单，也就是非常直白的三个逻辑分支：成功、失败、进行中。我们将其与Kotlin协程当中的when表达式相结合，就能很好地处理UI展示逻辑：如果是Loading，我们就展示进度条；如果是Success，我们就展示成功的数据；如果是Error，我们就展示错误提示框。</p><pre><code class="language-plain">fun display(data: Result) = when(data) {\n    is Result.Success -&gt; displaySuccessUI(data)\n    is Result.Error -&gt; showErrorMsg(data)\n    is Result.Loading -&gt; showLoading()\n}\n</code></pre><p>由于我们的密封类只有这三种情况，所以我们的when表达式不需要else分支。可以看到，这样的代码风格，既实现了类似枚举类的逻辑完备性，还完美实现了数据结构的封装。<br>\n而且，在最新的Kotlin 1.5 版本当中，sealed不仅仅可以用于修饰类，还可以用于修饰接口。这就为我们的密封类实现多个接口，提供了可能。</p><h2>小结</h2><p>在这节课当中，我们学习了面向对象常见的概念，包括类、继承、接口、实现、枚举，还有Kotlin独有的数据类、密封类。同时也进一步领略到了Kotlin语法在一些细节的良苦用心。比如说：</p><ul>\n<li>Kotlin的类，默认是public的。</li>\n<li>Kotlin的类继承语法、接口实现语法，是完全一样的。</li>\n<li>Kotlin当中的类默认是对继承封闭的，类当中的成员和方法，默认也是无法被重写的。这样的设计就很好地避免了继承被滥用。</li>\n<li>Kotlin接口可以有成员属性，还可以有默认实现。</li>\n<li>Kotlin的嵌套类默认是静态的，这种设计可以防止我们无意中出现内存泄漏问题。</li>\n<li>Kotlin独特的数据类，在语法简洁的同时，还给我们提供了丰富的功能。</li>\n<li>密封类，作为枚举和对象的结合体，帮助我们很好地设计数据模型，支持when表达式完备性。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/21/bf/21080a921b3aa73872bfd55f7c1cddbf.jpg?wh=1920x911" alt="图片"></p><p>看到这里，你一定会发现，我们上面提到的这些点，正好也是决定着Kotlin编程思想的关键。也正是Kotlin这样独特的设计，才形成了Kotlin迥然不同的编程风格。曾经有不少人问过我这样的问题：“如何才能拥有Kotlin编程思维，而不是用Kotlin写Java风格代码？如何才能写出优雅的Kotlin代码？”</p><p>答案其实很简单，我们先要掌握Kotlin的语法，然后透过这些语法细节去揣摩Kotlin设计者的意图，当我们理解Kotlin设计者为什么要设计某个语法时，我们就不可能用错这个语法了。而当我们能够用好Kotlin的每个语法的时候，我们自然而然地就可以写出优雅的Kotlin代码了。</p><p>比如，当我们知道数据类是为了解决冗余的Java Bean而设计的，那我们无论如何都不会在Kotlin当中再写一遍Kotlin Bean了。又或者，当我们知道when表达式可以自动判断逻辑分支是否完备的时候，我们自然就会想办法让when与枚举类/密封类结合使用了。</p><p>正如课程开头我提到过的：入门Kotlin很容易，精通Kotlin很难。让我们一起努力吧！</p><h2>思考题</h2><p>在课程中，我提到了Kotlin接口的“成员属性”是存在一定的局限性的。那么，请问你能想到，它的局限性在哪里吗？</p><p>欢迎你在评论区分享你的思路，这个问题我会在下节课给出答案。另外在学完这节课之后，如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "02 | 面向对象：理解Kotlin设计者的良苦用心",
      },
      {
        title: "03 | Kotlin原理：编译器在幕后干了哪些“好事”？",
        id: 473529,
        content:
          '<p>你好，我是朱涛。</p><p>在前面两节课里，我们学了不少Kotlin的语法，其中有些语法是和Java类似的，比如数字类型、字符串；也有些语法是Kotlin所独有的，比如数据类、密封类。另外，我们还知道Kotlin和Java完全兼容，它们可以同时出现在一个代码工程当中，并且可以互相调用。</p><p>但是，这样就会引出一个问题：<strong>Java是如何识别Kotlin的独有语法的呢？</strong>比如，Java如何能够认识Kotlin里的“数据类”？</p><p>这就要从整个Kotlin的实现机制说起了。</p><p>所以，今天这节课，我会从Kotlin的编译流程出发，来带你探索这门语言的底层原理。在这个过程中，你会真正地理解，Kotlin是如何在实现灵活、简洁的语法的同时，还做到了兼容Java语言的。并且你在日后的学习和工作中，也可以根据今天所学的内容，来快速理解Kotlin的其他新特性。</p><h2>Kotlin的编译流程</h2><p>在介绍Kotlin的原理细节之前，我们先从宏观上看看它是如何运行在电脑上的，这其实就涉及到它的编译流程。</p><p>那么首先，你需要知道一件事情：你写出的Kotlin代码，电脑是无法直接理解的。即使是最简单的<code>println("Hello world.")</code>，你将这行代码告诉电脑，它也是无法直接运行的。这是因为，Kotlin的语法是基于人类语言设计的，电脑没有人的思维，它只能理解二进制的0和1，不能理解println到底是什么东西。</p><!-- [[[read_end]]] --><p>因此，Kotlin的代码在运行之前，要先经过编译（Compile）。举个例子，假如我们现在有一个简单的Hello World程序：</p><pre><code class="language-plain">println("Hello world.")\n</code></pre><p>经过编译以后，它会变成类似这样的东西：</p><pre><code class="language-plain">LDC "Hello world."\nINVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V\n</code></pre><p>上面两行代码，其实是Java的字节码。对，你没看错，<strong>Kotlin代码经过编译后，最终会变成Java字节码</strong>。这给人的感觉就像是：我说了一句中文，编译器将其翻译成了英文。而Kotlin和Java能够兼容的原因也在于此，<strong>Java和Kotlin本质上是在用同一种语言进行沟通。</strong></p><p>英语被看作人类世界的通用语言，那么Kotlin和Java用的是什么语言呢？没错，它们用的就是Java字节码。Java字节码并不是为人类设计的语言，它是专门给JVM执行的。</p><p>JVM，也被称作Java虚拟机，它拿到字节码后就可以解析出字节码的含义，并且在电脑里输出打印“<code>Hello World.</code>”。所以，你可以先把Java虚拟机理解为一种执行环境。回想我们在<a href="https://time.geekbang.org/column/article/472154">第一节课</a>开头所安装的JDK，就是为了安装Java的编译器和Java的运行环境。</p><p>不过现在，你可能会有点晕头转向，还是没有搞清楚Kotlin的这个编译流程具体是怎么回事儿，也不清楚Kotlin和Java之间到底是什么关系。别着急，我们一起来看看下面这张图：</p><p><img src="https://static001.geekbang.org/resource/image/d6/0f/d67630808ee59a642b93d955ae8fa60f.jpg?wh=1920x1480" alt="图片"></p><p>这张图的内容其实非常直观，让我们从上到下，将整个过程再梳理一遍。</p><p>首先，我们写的Kotlin代码，编译器会以一定的规则将其翻译成Java字节码。这种字节码是专门为JVM而设计的，它的语法思想和汇编代码有点接近。</p><p>接着，JVM拿到字节码以后，会根据特定的语法来解析其中的内容，理解其中的含义，并且让字节码运行起来。</p><p><strong>那么，JVM到底是如何让字节码运行起来的呢？</strong>其实，JVM是建立在操作系统之上的一层抽象运行环境。举个简单的例子，Windows系统当中的程序是无法直接在Mac上面运行的。但是，我们写的Java程序却能同时在Windows、Mac、Linux系统上运行，这就是因为JVM在其中起了作用。</p><p>JVM定义了一套字节码规范，只要是符合这种规范的，都可以在JVM当中运行。至于JVM是如何跟不同的操作系统打交道的，我们不管。</p><p>还有一个更形象的例子，<strong>JVM就像是一个精通多国语言的翻译</strong>，我们只需要让JVM理解要做的事情，不管去哪个国家都不用关心，翻译会帮我们搞定剩下的事情。</p><p>最后，是计算机硬件。常见的计算机硬件包括台式机和笔记本电脑，这就是我们所熟知的东西了。</p><h2>如何研究Kotlin？</h2><p>在了解了Kotlin的编译流程之后，其实我们很容易就能想到办法了。</p><p>第一种思路，<strong>直接研究Kotlin编译后的字节码</strong>。如果我们能学会Java字节码的语法规则，那么就可以从字节码的层面去分析Kotlin的实现细节了。不过，这种方法明显吃力不讨好，即使我们学会了Java字节码的语法规则，对于一些稍微复杂一点的代码，我们分析起来也会十分吃力。</p><p>因此，我们可以尝试另一种思路：<strong>将Kotlin转换成字节码后，再将字节码反编译成等价的Java代码</strong>。最终，我们去分析等价的Java代码，通过这样的方式来理解Kotlin的实现细节。虽然这种方式不及字节码那样深入底层，但它的好处是足够直观，也方便我们去分析更复杂的代码逻辑。</p><p>这个过程看起来会有点绕，让我们用一个流程图来表示：</p><p><img src="https://static001.geekbang.org/resource/image/fd/24/fdfbcf0b8a293acc91b5e435c99cb324.jpg?wh=2000x1074" alt=""></p><p>我们将其分为两个部分来看。先看红色虚线框外面的图，这是一个典型的Kotlin编译流程，Kotlin代码变成了字节码。另一个部分，是红色虚线框内部的图，我们用反编译器将Java字节码翻译成Java代码。经过这样一个流程后，我们就能得到和Kotlin等价的Java代码。</p><p>而这样，我们也可以得出这样一个结论，Kotlin的“<code>println</code>”和Java的“<code>System.out.println</code>”是等价的。</p><pre><code class="language-plain">println("Hello world.") /*\n          编译\n           ↓            */    \nLDC "Hello world."\nINVOKESTATIC kotlin/io/ConsoleKt.println (Ljava/lang/Object;)V  /*\n         反编译\n           ↓            */\nString var0 = "Hello world.";\nSystem.out.println(var0);\n</code></pre><p>好了，思想和流程我们都清楚了，具体我们应该要怎么做呢？有以下几个步骤。</p><p>第一步，打开我们要研究的Kotlin代码。</p><p><img src="https://static001.geekbang.org/resource/image/54/5f/54b189024034ae24bba4a40d1082995f.png?wh=717x260" alt="图片"></p><p>第二步，依次点击菜单栏：Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode。</p><p><img src="https://static001.geekbang.org/resource/image/3b/e0/3b3439996bc37e26c0f12fa943c726e0.png?wh=933x499" alt="图片"></p><p>这时候，我们在右边的窗口中就可以看见Kotlin对应的字节码了。但这并不是我们想要的，所以要继续操作，将字节码转换成Java代码。</p><p>第三步，点击画面右边的“Decompile”按钮。</p><p><img src="https://static001.geekbang.org/resource/image/5e/be/5e7d2835867b19de523c266d39980fbe.png?wh=1194x552" alt="图片"></p><p>最后，我们就能看见反编译出来的Java文件“Test_decompiled.java”。显而易见，main函数中的代码和我们前面所展示的是一致的：</p><p><img src="https://static001.geekbang.org/resource/image/40/52/40f13a1277f35113cb968fa7cc464f52.png?wh=1177x940" alt="图片"></p><p>OK，在知道如何研究Kotlin原理后，让我们来看一些实际的例子吧！</p><h2>Kotlin里到底有没有“原始类型”？</h2><p>不知道你还记不记得，之前我在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>中给你留过一个思考题：</p><blockquote>\n<p>虽然Kotlin在语法层面摒弃了“原始类型”，但有的时候为了性能考虑，我们确实需要用“原始类型”。这时候我们应该怎么办？</p>\n</blockquote><p>那么现在，我们已经知道了Kotlin与Java直接存在某种对应关系，所以要弄清楚这个问题，我们只需要知道“Kotlin的Long”与“Java long/Long”是否存在某种联系就可以了。</p><blockquote>\n<p><strong>注意：Java当中的long是原始类型，而Long是对象类型（包装类型）。</strong></p>\n</blockquote><p>说做就做，我们以Kotlin的Long类型为例。</p><pre><code class="language-plain">// kotlin 代码\n\n// 用 val 定义可为空、不可为空的Long，并且赋值\nval a: Long = 1L\nval b: Long? = 2L\n\n// 用 var 定义可为空、不可为空的Long，并且赋值\nvar c: Long = 3L\nvar d: Long? = 4L\n\n// 用 var 定义可为空的Long，先赋值，然后改为null\nvar e: Long? = 5L\ne = null\n\n// 用 val 定义可为空的Long，直接赋值null\nval f: Long? = null\n\n// 用 var 定义可为空的Long，先赋值null，然后赋值数字\nvar g: Long? = null\ng = 6L\n</code></pre><p>这段代码的思路，其实就是将Kotlin的Long类型可能的使用情况都列举出来，然后去研究代码对应的Java反编译代码，如下所示：</p><pre><code class="language-java">// 反编译后的 Java 代码\n\nlong a = 1L;\nlong b = 2L;\n\nlong c = 3L;\nlong d = 4L;\n\nLong e = 5L;\ne = (Long)null;\n\nLong f = (Long)null;\n\nLong g = (Long)null;\ng = 6L;\n</code></pre><p>可以看到，最终a、b、c、d被Kotlin转换成了Java的原始类型long；而e、f、g被转换成了Java里的包装类型Long。这里我们就来逐步分析一下：</p><ul>\n<li>对于变量a、c来说，它们两个的类型是不可为空的，所以无论如何都不能为null，对于这种情况，Kotlin编译器会直接将它们优化成原始类型。</li>\n<li>对于变量b、d来说，它们两个的类型虽然是可能为空的，但是它的值不为null，并且，编译器对上下文分析后发现，这两个变量也没有在别的地方被修改。这种情况，Kotlin编译器也会将它们优化成原始类型。</li>\n<li>对于变量e、f、g来说，不论它们是val还是var，只要它们被赋值过null，那么，Kotlin就无法对它们进行优化了。这背后的原因也很简单，Java的原始类型不是对象，只有对象才能被赋值为null。</li>\n</ul><p>我们可以用以下两个规律，来总结下Kotlin对基础类型的转换规则：</p><ul>\n<li>只要基础类型的变量可能为空，那么这个变量就会被转换成Java的包装类型。</li>\n<li>反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成Java的原始类型。</li>\n</ul><p>好，接着我们再来看看另外一个例子。</p><h2>接口语法的局限性</h2><p>我在上节课，带你了解了Kotlin面向对象编程中的“接口”这个概念，其中我给你留了一个问题，就是：</p><blockquote>\n<p>接口的“成员属性”，是Kotlin独有的。请问它的局限性在哪？</p>\n</blockquote><p>那么在这里，我们就通过这个问题，来分析下Kotlin接口语法的实现原理，从而找出它的局限性。下面给出的，是一段接口代码示例：</p><pre><code class="language-plain">// Kotlin 代码\n\ninterface Behavior {\n    // 接口内可以有成员属性\n    val canWalk: Boolean\n\n    // 接口方法的默认实现\n    fun walk() {\n        if (canWalk) {\n            println(canWalk)\n        }\n    }\n}\n\nprivate fun testInterface() {\n    val man = Man()\n    man.walk()\n}\n</code></pre><p>那么，要解答这个问题，我们也要弄清楚Kotlin的这两个特性，转换成对应的Java代码是什么样的。</p><pre><code class="language-plain">// 等价的 Java 代码\n\npublic interface Behavior {\n   // 接口属性变成了方法\n   boolean getCanWalk();\n\n   // 方法默认实现消失了\n   void walk();\n\n   // 多了一个静态内部类\n   public static final class DefaultImpls {\n      public static void walk(Behavior $this) {\n         if ($this.getCanWalk()) {\n            boolean var1 = $this.getCanWalk();\n            System.out.println(var1);\n         }\n      }\n   }\n}\n</code></pre><p>从上面的Java代码中我们能看出来，Kotlin接口的“默认属性”canWalk，本质上并不是一个真正的属性，当它转换成Java以后，就变成了一个普通的接口方法getCanWalk()。</p><p>另外，Kotlin接口的“方法默认实现”，它本质上也没有直接提供实现的代码。对应的，它只是在接口当中定义了一个静态内部类“DefaultImpls”，然后将默认实现的代码放到了静态内部类当中去了。</p><p><strong>我们能看到，Kotlin的新特性，最终被转换成了一种Java能认识的语法。</strong></p><p>我们再具体来看看接口使用的细节：</p><pre><code class="language-plain">// Kotlin 代码\n\nclass Man: Behavior {\n    override val canWalk: Boolean = true\n}\n</code></pre><p>以上代码中，我们定义了一个Man类，它实现了Behavior接口，与此同时它也重写了canWalk属性。另外，由于Behavior接口的walk()方法已经有了默认实现，所以Man可以不必实现walk()方法。</p><p>那么，<strong>Man类反编译成Java后，会变成什么样子呢？</strong></p><pre><code class="language-java">// 等价的 Java 代码\n\npublic final class Man implements Behavior {\n   private final boolean canWalk = true;\n\n   public boolean getCanWalk() {\n      // 关键点 ①\n      return this.canWalk;\n   }\n\n   public void walk() {\n      // 关键点 ②\n      Behavior.DefaultImpls.walk(this);\n   }\n}\n</code></pre><p>可以看到，Man类里的getCanWalk()实现了接口当中的方法，从注释①那里我们注意到，getCanWalk()返回的还是它内部私有的canWalk属性，这就跟Kotlin当中的逻辑“override val canWalk: Boolean = true”对应上了。</p><p>另外，对于Man类当中的walk()方法，它将执行流程交给了“Behavior.DefaultImpls.walk()”，并将this作为参数传了进去。这里的逻辑，就可以跟Kotlin接口当中的默认方法逻辑对应上来了。</p><p>看完这一堆的代码之后，你的脑子可能会有点乱，我们用一张图来总结一下前面的内容吧：</p><p><img src="https://static001.geekbang.org/resource/image/88/b9/886dc2d7a5d5ee47934c1003447412b9.png?wh=1770x1230" alt="图片"></p><p>以上图中一共有5个箭头，它们揭示了Kotlin接口新特性的实现原理，让我们一个个来分析：</p><ul>\n<li>箭头①，代表Kotlin接口属性，实际上会被当中接口方法来看待。</li>\n<li>箭头②，代表Kotlin接口默认实现，实际上还是一个普通的方法。</li>\n<li>箭头③，代表Kotlin接口默认实现的逻辑是被放在DefaultImpls当中的，它成了静态内部类当中的一个静态方法DefaultImpls.walk()。</li>\n<li>箭头④，代表Kotlin接口的实现类必须要重写接口当中的属性，同时，它仍然还是一个方法。</li>\n<li>箭头⑤，即使Kotlin里的Man类没有实现walk()方法，但是从Java的角度看，它仍然存在walk()方法，并且，walk()方法将它的执行流程转交给了DefaultImpls.walk()，并将this传入了进去。这样，接口默认方法的逻辑就可以成功执行了。</li>\n</ul><p>到这里，我们的答案就呼之欲出了。Kotlin接口当中的属性，在它被真正实现之前，本质上并不是一个真正的属性。因此，Kotlin接口当中的属性，它既不能真正存储任何状态，也不能被赋予初始值，因为<strong>它本质上还是一个接口方法</strong>。</p><h2>小结</h2><p>到这里，你应该就明白了：你写的Kotlin代码，最终都会被Kotlin编译器进行一次统一的翻译，把它们变成Java能理解的格式。Kotlin的编译器，在这个过程当中就像是一个藏在幕后的翻译官。</p><p>可以说，Kotlin的每一个语法，最终都会被翻译成对应的Java字节码。但如果你不去反编译，你甚至感觉不到它在幕后做的那些事情。而正是因为Kotlin编译器在背后做的这些翻译工作，才可以让我们写出的Kotlin代码更加简洁、更加安全。</p><p>我们举一些更具体的例子：</p><ul>\n<li>类型推导，我们写Kotlin代码的时候省略的变量类型，最终被编译器补充回来了。</li>\n<li>原始类型，虽然Kotlin没有原始类型，但编译器会根据每一个变量的可空性将它们转换成“原始类型”或者“包装类型”。</li>\n<li>字符串模板，编译器最终会将它们转换成Java拼接的形式。</li>\n<li>when表达式，编译器最终会将它们转换成类似switch case的语句。</li>\n<li>类默认public，Kotlin当中被我们省略掉public，最终会被编译器补充。</li>\n<li>嵌套类默认static，我们在Kotlin当中的嵌套类，默认会被添加static关键字，将其变成静态内部类，防止不必要的内存泄漏。</li>\n<li>数据类，Kotlin当中简单的一行代码“data class Person(val name: String, val age: Int)”，编译器帮我们自动生成很多方法：getter()、setter()、equals()、hashCode()、toString()、componentN()、copy()。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/02/34/02702d48a28378817ed1598849bfbb34.jpg?wh=1920x912" alt="图片"></p><p>最后，我们还需要思考一个问题：<strong>Kotlin编译器一直在幕后帮忙做着翻译的好事，那它有没有可能“好心办坏事”？</strong>这个悬念留着，我们在第8讲再探讨。</p><h2>思考题</h2><p>在上节课当中，我们曾提到过，为Person类增加isAdult属性，我们要通过自定义getter来实现，比如说：</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    val isAdult\n        get() = age &gt;= 18\n}\n</code></pre><p>而下面这种写法则是错误的：</p><pre><code class="language-plain">class Person(val name: String, var age: Int) {\n    val isAdult = age &gt;= 18\n}\n</code></pre><p>请运用今天学到的知识来分析这个问题背后的原因。欢迎你在留言区分享你的答案和思路，我们下节课再见。</p>',
        article_title: "03 | Kotlin原理：编译器在幕后干了哪些“好事”？",
      },
      {
        title: "04 | 实战：构建一个Kotlin版本的四则运算计算器",
        id: 473656,
        content:
          '<p>你好，我是朱涛。</p><p>前面几节课，我们学了不少Kotlin的语法，也算是对Kotlin有了一个基本认识。不过，单纯只认识Kotlin是远远不够的，我们还要<strong>会用Kotlin</strong>。当遇到一个具体问题的时候，我们得能用Kotlin来解决这个问题。换句话说，就是要实战。在实战的过程中，我们对Kotlin的理解也会进一步加深。</p><p>那么这节课，我们就把前面的知识点串联起来，一起做一个Kotlin版本的计算器。为了便于理解，我会以<strong>循序渐进</strong>的方式来编写这个计算器程序，由简单到复杂。你在这个由易到难的实操过程中，可以实际体会到Kotlin的代码实现思路以及编码方式的变化，进而也就能更好地掌握和运用前面所学的基础语法，以及与面向对象相关的知识点。</p><p>这个计算器程序大致会分为三个版本：</p><ul>\n<li>计算器1.0，实现两个整数的“加减乘除”，对输入数据有严格要求。</li>\n<li>计算器2.0，对输入数据无严格要求，融入面向对象的编程思想。</li>\n<li>计算器3.0，支持“大数的加法”，增加单元测试。</li>\n</ul><p>现在，我们就开始实战吧。</p><h2>创建Kotlin工程</h2><p>如果你之前没有使用过IntelliJ或Android Studio，你可能还不知道怎么创建一个工程。别担心，这个过程其实很简单，它分为以下几个步骤。</p><!-- [[[read_end]]] --><ul>\n<li>第一步：选择菜单“File -&gt; New -&gt; Project”。</li>\n<li>第二步：选中菜单左边的“Gradle”，然后在右边勾选“Java 和 Kotlin/JVM”，最后点击右下角的“Next”。</li>\n<li>第三步：给工程取一个你喜欢的名字，我们这里就用Calculator。GroupId这个地方一般使用倒过来的域名，这里根据你的实际情况填写即可。默认情况下，IDE会自动帮你设置成“org.example”，所以你不去改动它也没问题。最后，我们点击Finish，工程就创建成功了！</li>\n<li>第四步：等待工程配置完成。<strong>如果你是第一次创建Kotlin工程，点击Finish以后，你可能需要等待一段时间，IDE需要下载Gradle，然后用Gradle下载工程所需的依赖。</strong>当你在IDE当中能看到这样的工程结构时，这个工程就算配置完成了。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/89/9f/89cyycca9830e62538528df5e62fbc9f.gif?wh=1000x750" alt="图片"></p><h2>导入初始化工程</h2><p>其实，你只需要知道如何创建一个Kotlin工程就行了，也没必要真的跟着我一步步操作。课程配套的源代码已经在<a href="https://github.com/chaxiu/Calculator.git">GitHub</a>开源，你可以将其下载下来并切换到start分支，这样就可以跟着课程一步步实现计算器的三个版本了。</p><p><strong>具体做法是这样的：</strong>打开IntelliJ，点击“Get from VCS”按钮，接着在弹出的窗口中，填入我们的GitHub URL“<a href="https://github.com/chaxiu/Calculator.git">https://github.com/chaxiu/Calculator.git</a>”，然后点击右下角的Clone按钮即可。</p><p><img src="https://static001.geekbang.org/resource/image/47/03/477cd386aa83dddb7e2ab659b433f503.gif?wh=1000x750" alt="图片"></p><p>等代码下载完成以后，IDE会问你是否要打开此工程，我们选择打开。这样，我们的计算器工程就算导入进来了。</p><p>最后，我们还需要将工程改为初始化状态，借助Git我们可以非常方便地实现：</p><ul>\n<li>在IntelliJ的右下角，找到main按钮并且点击；</li>\n<li>在弹出的菜单中，点击start分支；</li>\n<li>最后，点击Checkout，代表将当前代码切换到初始状态。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/73/a7/730f5377ef2ee6e9d8dbe9179eb849a7.png?wh=581x379" alt="图片"></p><p>这样，我们就完成了整个工程的初始化配置了。为了测试我们的开发环境是否已经配置好，我们可以打开工程里的HelloWorld文件，运行一下，看看程序是否正常执行。</p><p><img src="https://static001.geekbang.org/resource/image/db/1f/db316ef784abb04cd3fc87fcd9b0a31f.gif?wh=976x544" alt="图片"></p><p>如果你也能在工程当中看见控制台输出“Hello world.”，说明你的开发环境已经完全没问题了。接下来，就让我们一起用Kotlin完成计算器的1.0版本吧！</p><h2>计算器1.0</h2><p>第一个版本的计算器，它的功能非常简单，你可以看看下面的动图演示。</p><p><img src="https://static001.geekbang.org/resource/image/dd/10/dd01d14119706f7eeef220576dda5510.gif?wh=596x359" alt="图片"></p><p>我们大致列举一下这个计算器的功能需求：</p><ul>\n<li>交互式界面，输入算式，按下回车，程序就会帮我们计算出结果；</li>\n<li>数字与字符之间要求有空格，“1 + 1”是可以的，“1+1”则不行；</li>\n<li>输入exit，按下回车，程序就会退出；</li>\n<li>支持“加减乘除”，四种运算，仅支持两个数的运算。</li>\n</ul><p>搞清楚功能需求以后，我们就可以开始写代码了。</p><p>首先，我们要创建一个Kotlin源代码文件：在Kotlin文件夹下，点击右键，选择“New -&gt; Kotlin Class/File”，然后填写文件名字即可，这里我们创建一个名为Calculator的Kotlin文件。</p><p><img src="https://static001.geekbang.org/resource/image/32/19/32be58b2b1ee01ccb888yy862546d019.png?wh=815x225" alt="图片"></p><p>由于我们的程序要和命令进行交互，根据不同的命令来做出不同的行为，因此，我们的程序需要有一个 <strong>while循环</strong>的逻辑，在循环当中，还要读取命令行的输入，然后根据输入的结果来判断执行逻辑。我们可以将整个程序分为以下几个步骤：</p><ul>\n<li>初始化，打印提示信息；</li>\n<li>第一步，读取输入命令；</li>\n<li>第二步，判断命令是不是exit，如果用户输入的是“exit”则直接退出程序；</li>\n<li>第三步，解析算式，分解出“数字”与“操作符”：“1”“+”“2”；</li>\n<li>第四步，根据操作符类型，算出结果：3；</li>\n<li>第五步，输出结果：1 + 2 = 3；</li>\n<li>第六步，进入下一个while循环。</li>\n</ul><pre><code class="language-plain">fun main() {\n    while(true) {\n        // 初始化，打印提示信息\n        println("请输入标准的算式，并且按回车; \\n" +\n                "比如：1 + 1，注意符合与数字之间要有空格。\\n" +\n                "输入exit，退出程序。")\n\n        // 第一步，读取输入命令；\n        var input = readLine()\n        if (input == null) continue\n        // 第二步，判断命令是不是exit，如果是则直接退出程序；\n        if (input == "exit") exitProcess(0)\n\n        // 第三步，解析算式，分解出“数字”与“操作符”：“1”“+”“2”；\n        var inputList = input.split(" ")\n        // 第四步，根据操作符类型，算出结果：3；\n        var result = calculate(inputList)\n\n        // 第五步，输出结果：1 + 2 = 3；\n        if (result == null) {\n            println("输入格式不对")\n            continue\n        } else {\n            println("$input = $result")\n        }\n\n        // 第六步，进入下一个while循环。\n    }\n}\n\n// 具体计算逻辑\nprivate fun calculate(inputList: List&lt;String&gt;): Int? {\n    if (inputList.size != 3) return null\n\n    // 第七步，取出数字和操作符\n    var left = inputList.get(0).toInt()\n    var operation = inputList.get(1)\n    var right = inputList.get(2).toInt()\n\n    // 第八步，根据操作符的类型，执行计算\n    when(operation) {\n        "+" -&gt; return left + right\n        "-" -&gt; return left - right\n        "*" -&gt; return left * right\n        "/" -&gt; return left / right\n        else -&gt; return null\n    }\n}\n</code></pre><p>上面的代码非常简单直白，即使你没有任何编程经验，应该也能够理解。它也非常符合人的编程直觉。</p><p>不过，站在Kotlin的角度上看，以上的代码其实是有不少问题的，让我们通过一个图来对比着看：</p><p><img src="https://static001.geekbang.org/resource/image/84/03/84cac3866e2b1e14fd3ae6dc68074a03.png?wh=1240x1016" alt="图片"></p><ul>\n<li>箭头①，表示程序中的“提示信息”应该使用Kotlin的“三引号”的原始字符串，这样的话，我们可以省去繁琐的“\\n和+”，并且所见即所得；</li>\n<li>箭头②，表示读取输入命令后，我们可以直接使用Elvis表达式，两行代码就会变成一行；</li>\n<li>箭头③，表示程序中所有的var都应该改为val，我在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>中说过，在Kotlin当中，我们应该优先使用val，尽量避免使用可变的变量。</li>\n<li>箭头④，表示inputList.get(i)可以改为inputList[i]，这是因为Kotlin统一了数组和集合的元素访问操作，我们再也不用担心弄混了。</li>\n<li>箭头⑤，表示了两点。首先，我们可以将return放到when表达式的前面，这样就省得我们每个分支都写一遍return。另外，当我们使用when表达式的时候，应该尽量结合“枚举”或者“密封类”来使用。为此，我们可以为“加减乘除”四个操作符创建一个枚举类。这样，when表达式的分支会自动判定完备，而不需要else分支了。</li>\n</ul><p>那么经过调整，最终的源代码应该是这样的：</p><pre><code>val help = &quot;&quot;&quot;\n--------------------------------------\n使用说明：\n1. 输入 1 + 1，按回车，即可使用计算器；\n2. 注意：数字与符号之间要有空格；\n3. 想要退出程序，请输入：exit\n--------------------------------------&quot;&quot;&quot;.trimIndent()\n\nfun main() {\n    while (true) {\n        println(help)\n\n        val input = readLine() ?: continue\n        if (input == &quot;exit&quot;) exitProcess(0)\n\n        val inputList = input.split(&quot; &quot;)\n        val result = calculate(inputList)\n\n        if (result == null) {\n            println(&quot;输入格式不对&quot;)\n            continue\n        } else {\n            println(&quot;$input = $result&quot;)\n        }\n    }\n}\n\nprivate fun calculate(inputList: List&lt;String&gt;): Int? {\n    if (inputList.size != 3) return null\n\n    val left = inputList[0].toInt()\n    //                           ①\n    //                           ↓\n    val operation = Operation.valueOf(inputList[1])\n    val right = inputList[2].toInt()\n\n    return when (operation) {\n        Operation.ADD -&gt; left + right\n        Operation.MINUS -&gt; left - right\n        Operation.MULTI -&gt; left * right\n        Operation.DIVI -&gt; left / right\n    }\n}\n\nenum class Operation(val value: String) {\n    ADD(&quot;+&quot;),\n    MINUS(&quot;-&quot;),\n    MULTI(&quot;*&quot;),\n    DIVI(&quot;/&quot;)\n}\n</code></pre><p>好，我们的计算器1.0版本，到这里就算是完成了。</p><p>如果你跟随着我，一起来实现了这个简单的计算器，那么你在这个实操过程中就可以体会到，Kotlin编程与传统的Java/C之间确实是存在着一定的差别的。</p><p><strong>想要学会Kotlin语法其实不难，但要写出优雅的Kotlin代码，却不是一件容易的事情。</strong>我们唯一能做的，就是多写Kotlin代码，同时多看优秀的Kotlin代码，以及多思考改进自己已有的代码。</p><p>不过，代码中注释①处其实还有一些问题，接着让我们进入第二个版本的开发吧！</p><h2>计算器2.0</h2><p>在2.0版本中，我们会分成两个阶段：</p><ul>\n<li>第一个阶段，<strong>融入面向对象的思想</strong>。1.0版本中，我们只写了两个函数，一个是main()函数，另一个是calculate()函数。虽然这样的设计非常直观且便于理解，但却不太符合我们工程界的思维习惯。我们应该将程序封装到一个类当中，并且尽量让每个函数的功能划分清楚，保持每个函数尽量简单。</li>\n<li>第二个阶段，<strong>兼容输入格式</strong>。1.0版本中，我们对输入有严格的要求，数字和符号之间必须有空格，否则我们的算式解析会出错。在2.0版本中，我们尝试兼容不同的输入格式，不管数字和符号之间有没有空格，我们都要能成功执行。</li>\n</ul><p>让我们一步步来，首先是融入面向对象的思想。</p><h3>第一阶段：融入面向对象思想</h3><p>具体做法其实也很简单，我们可以将前面定义的两个函数收拢到一个类当中去，比如“CalculatorV2”：</p><pre><code class="language-plain">class CalculatorV2 {\n    fun start() {}\n    fun calculate(input: String): Int? {}\n}\n</code></pre><p>可以看到，在这个CalculatorV2类当中有两个方法，<strong>start()</strong> 用于启动我们的计算器程序，监听控制台的文本输入；<strong>calculate(input)</strong> 用于接收输入文本，计算出算式的结果，然后返回一个可为空的整型，当输入不合法的时候会返回null。</p><p>这样，我们的计算器作为一个整体已经是一个对象了，我们可以很方便地在main()函数当中，创建一个实例，并且调用它的start()函数。这样一来，我们的计算器也就可以充分发挥出面向对象的优势。</p><pre><code class="language-plain">fun main() {\n    val calculator = CalculatorV2()\n    calculator.start()\n}\n</code></pre><p>除了计算器本身需要面向对象，我们的输入表达式也可以抽象出一个具体模型出来。</p><p>我们知道，一个算式分为左边的数字、操作符和右边的数字。因此我们还可以定义一个类，来代表算式表达式。</p><pre><code class="language-plain">data class Expression(\n    val left: String,\n    val operator: Operation,\n    val right: String\n)\n</code></pre><p>比如，我们想要表达“1 + 2”这个式子的话，我们就可以用这样一个结构来表示：</p><pre><code class="language-plain">Expression("1", Operation.ADD, "2")\n</code></pre><p>那么，在完成了面向对象的模型化以后，我们还需要进一步拆分函数的职责与颗粒度。其中，start()方法，主要用于控制程序的流程、输入与输出：</p><pre><code class="language-plain">fun start() {\n    while (true) {\n        println(HELP)\n        val input = readLine() ?: continue\n        val result = calculate(input)\n        if (result == null) {\n            println("输入格式不对")\n            continue\n        } else {\n            println("$input = $result")\n        }\n    }\n}\n</code></pre><p>而calculate()方法，则需要进一步地拆分：</p><pre><code class="language-plain">fun calculate(input: String): String? {\n    if (shouldExit(input)) exitProcess(0)\n    val exp = parseExpression(input) ?: return null\n    val left = exp.left\n    val operator = exp.operator\n    val right = exp.right\n    return when (operator) {\n        Operation.ADD -&gt; addString(left, right)\n        Operation.MINUS -&gt; minusString(left, right)\n        Operation.MULTI -&gt; multiString(left, right)\n        Operation.DIVI -&gt; diviString(left, right)\n    }\n}\n\nfun addString(left: String, right: String): String {\n    val result = left.toInt() + right.toInt()\n    return result.toString()\n}\nfun minusString(left: String, right: String): String {\n    val result = left.toInt() - right.toInt()\n    return result.toString()\n}\nfun multiString(left: String, right: String): String {\n    val result = left.toInt() * right.toInt()\n    return result.toString()\n}\nfun diviString(left: String, right: String): String {\n    val result = left.toInt() / right.toInt()\n    return result.toString()\n}\n\nfun shouldExit(input: String): Boolean {\n    return input == EXIT\n}\n\nfun parseExpression(input: String): Expression? {\n    // 待完成\n}\n\nfun parseOperator(input: String): Operation? {\n    // 待完成\n}\n</code></pre><p>通过以上代码可以看到，我们拆分calculate()方法主要做了三件事：</p><ul>\n<li>第一，<strong>将“是否退出”的逻辑封装到了shouldExit()方法当中</strong>，如果将来这部分逻辑变得更复杂，我们只改动这一个方法即可。</li>\n<li>第二，<strong>将算式的解析，封装到了parseExpression()方法当中</strong>，而解析算式的时候也需要解析操作符，这时候我们也需要parseOperator()。</li>\n<li>第三，<strong>将具体的计算逻辑交给了对应的方法</strong>。这么做的原因，是可以让我们的程序变得更加灵活。比如，我们在下个版本当中会更改“加法”的计算逻辑，那么我们就只需要改动这一个方法就行了。</li>\n</ul><p>同时，以上所有独立抽出来的方法，它们也都将变得<strong>可测试</strong>，这有利于提升程序的稳定性。</p><p>到这里，我们对计算器2.0的第一阶段改造就差不多完成了，我们融入了面向对象的思想，也对calculate()方法进行了更细颗粒度的拆分。下一步，我们要做的就是兼容算式的格式，让它能够解析没有空格的算式。</p><h3>第二阶段：兼容输入格式</h3><p>现在，假设我们的输入是“1+2”，数字与字符之间没有空格。那在这种情况下，我们就无法使用空格作为分隔符了。所以要换一种方式，想办法从算式当中，解析出操作符“加减乘除”中的一种，然后再用操作符作为我们的分隔符去找出数字。</p><p>其实，因为操作符只有这四种情况，所以我们很容易就能想到一种方案，一个个去尝试：</p><pre><code class="language-plain">fun parseOperator(input: String): Operation? {\n    return when {\n        input.contains(Operation.ADD.value) -&gt; Operation.ADD\n        input.contains(Operation.MINUS.value) -&gt; Operation.MINUS\n        input.contains(Operation.MULTI.value) -&gt; Operation.MULTI\n        input.contains(Operation.DIVI.value) -&gt; Operation.DIVI\n        else -&gt; null\n    }\n}\n</code></pre><p>虽然，这段代码运行起来没什么问题，逻辑也非常得清晰，但它看起来很丑陋。而且它还有一个坏处：随着枚举类型的增多，我们的逻辑分支也会增多，手动添加起来也特别麻烦。</p><p>因此这种情况，我们就应该充分借助 <strong>Kotlin枚举</strong>的优势，通过遍历的方式来做：</p><pre><code class="language-plain">fun parseOperator(input: String): Operation? {\n    Operation.values().forEach {\n        if (input.contains(it.value)) {\n            return it\n        }\n    }\n    return null\n}\n</code></pre><p>可以看到，优化后的代码中，我们不再需要手动地去写when的逻辑分支，也不必自己去枚举Operation的每一种情况，就连代码量也降低了很多，即使将来枚举种类增加了，我们也不必修改这部分代码了。</p><p>需要注意，以上的代码中，我们用到了集合遍历的语法“forEach”，你可以将它想象成强化版的for循环，它具体的用法我会在后面“Kotlin集合”那一节中讲解。</p><p>现在，对于一个算式“1+2”，我们已经可以成功解析出操作符“+”了，接下来要做的，就是通过“+”来分割字符串，将左右两个数字取出来“1”“2”。这个逻辑就很简单了：</p><pre><code class="language-plain">fun parseExpression(input: String): Expression? {\n    // 解析操作符\n    val operation = parseOperator(input) ?: return null\n    // 用操作符分割算式，拿到数字\n    val list = input.split(operation.value)\n    if (list.size != 2) return null\n\n    return Expression(\n        // 算式左边\n        left = list[0].trim(),\n        operator = operation,\n        // 算式右边\n        right = list[1].trim()\n    )\n}\n</code></pre><p>以上代码大致分为三个步骤，我们以“1+2”为例：</p><ul>\n<li>第一个步骤，调用parseOperator()方法解析操作符“+”；</li>\n<li>第二个步骤，根据操作符分割算式的数字，分割之后得到的会是“1”“2”组成的列表；</li>\n<li>第三个步骤，将操作符、数字组合成Expression对象。</li>\n</ul><p>这里有一个细节需要注意，我们兼容的输入其实有两种情况，第一种是<strong>不包含空格</strong>“1+2”，那么我们解析出来的数字会是“1”“2”，这种情况下不会有问题；但还有第二种情况<strong>包含空格</strong>，对于原本正确的格式，我们更应该支持，比如“1 + 2”，被分隔之后的结果会是“1 ”“2”，这两个数字当中是包含空格符的。</p><p>所以，我们使用了<code>list[0].trim()</code>，这里的<code>trim()</code>方法就是用于去掉多余空格的。</p><p>让我们实际运行一下看看效果：</p><p><img src="https://static001.geekbang.org/resource/image/ce/b2/ce2c6debc469a274d7d0a6fd488978b2.gif?wh=852x452" alt="图片"></p><p>至此，我们的计算器2.0版本就完成了。在2.0版本的实操过程中，我们其实是在原有的基础上，融入了面向对象的思想，将计算器功能收拢到了一个类当中，同时也对计算器内部的方法进行了细颗粒度的拆分。</p><p>在这个过程中，我们创建了三个类：“Calculator”类，代表整个计算器；“Operation”枚举类，代表加减乘除四种运算操作符；“Expression”数据类，代表我们算式当中的数字和操作符。之后，我们又对计算器的核心功能进行了更细颗粒度的拆分，提高了程序的灵活性，为我们的功能扩展打下了基础。</p><p>好了，现在让我们进入3.0版本的开发吧。</p><h2>计算器3.0</h2><p>针对3.0这个版本，我们也分为了两个阶段：</p><ul>\n<li>第一阶段，<strong>增加单元测试</strong>。单元测试是软件工程当中的一个概念，它指的是对软件当中的最小可执行单元进行测试，以提高软件的稳定性。在Java当中，最小单元一般会认为是类，因此，我们一般会以类为单元，对类当中的方法进行一一测试。</li>\n<li>第二阶段，<strong>支持大数的加法</strong>。我们知道Java、Kotlin当中的整型都是有范围限制的，如果我们输入两个特别大的数字进行计算，那么程序是无法正常工作的。因此，我们需要对特别大的数进行兼容。</li>\n</ul><p>下面，我们先来搞定单元测试。</p><h3>第一阶段：单元测试</h3><p>在Kotlin当中，如果要使用单元测试，我们需要在gradle文件当中，添加Kotlin官方提供的依赖：</p><pre><code class="language-plain">testImplementation \'org.jetbrains.kotlin:kotlin-test\'\n</code></pre><p>这样，我们的工程就拥有单元测试的能力了。单元测试的代码，我们一般会放在工程的test目录下：</p><p><img src="https://static001.geekbang.org/resource/image/c3/1f/c305f53c828d94e671f7e89267c2111f.png?wh=395x629" alt="图片"></p><p>我们可以从这个图中看出很多信息：</p><ul>\n<li>第一，test目录、main目录，它们是平级的目录，内部拥有着相同的结构。main目录下放的是功能代码，test目录下放的则是测试代码。</li>\n<li>第二，由于我们要开发3.0版本，所以我们在main目录下创建了CalculatorV3这个类；另外，由于我们需要在3.0版本加入单元测试，所以对应的，我们在test目录下相同的地方，创建了TestCalculatorV3。这两个类的关系是一一对应的，CalculatorV3是为了实现3.0版本的功能，TestCalculatorV3是为了测试3.0版本的功能，确保功能正常。</li>\n</ul><p>不过这里你要<strong>注意</strong>，虽然我们创建了CalculatorV3这个类，但其实它里面的代码还是用的CalculatorV2的代码。3.0版本的功能，我们放到第二阶段才会去实现。</p><p>接下来，让我们来编写测试代码：</p><pre><code class="language-plain">class TestCalculatorV3 {\n    @Test\n    fun testCalculate() {\n        val calculator = CalculatorV3()\n\n        val res1 = calculator.calculate("1+2")\n        assertEquals("3", res1)\n    }\n}\n</code></pre><p>首先，我们定义了一个方法testCalculate()，并且使用了一个注解@Test来修饰它。因为这样做以后，IntelliJ就会知道：哦，这是一个用来做测试的方法。</p><p>接着，我们在testCalculate()当中创建了一个CalculatorV3的对象，然后调用了它的calculate()方法，传入了“1+2”。我们知道，如果程序正常工作的话，返回的结果应该是“3”。因此，我们紧接着就执行了一个<strong>断言</strong>“assertEquals(“3”, res1)”，它的意思是“res1一定等于3”。如果res1=3，那么我们的单元测试就会成功，否则就会失败。</p><p>我们可以看看单元测试运行成功的效果：</p><p><img src="https://static001.geekbang.org/resource/image/b1/b1/b1c48ab4dd9c900bc3ee2e020da187b1.gif?wh=1348x960" alt="图片"></p><p>如果这时候，我们将“1+2”改成大数的加法，比如“2333333333333332+1”，并且将断言也修改一下：</p><pre><code class="language-plain">val res1 = calculator.calculate("2333333333333332+1")\nassertEquals("2333333333333333", res1)\n</code></pre><p>那么，你觉得单元测试的结果会是怎么样的呢？</p><p><img src="https://static001.geekbang.org/resource/image/b9/bc/b968fc9666cefc95545cd022e7a523bc.gif?wh=1348x960" alt="图片"></p><p>单元测试失败了！</p><p>具体原因相信你一定也能猜到，因为“2333333333333332”这个数实在太大了，已经远远超出了Int类型的范围，如果不做特殊处理的话，我们的程序是无法正常运行的。而这正好就是我们下一个阶段要做的事情：支持大数的加法。不论多大的两个数字相加，我们都要算出正确的结果。</p><p>这个单元测试的代码我们先留着，等我们实现“大数的加法”后，我们再重新运行一遍，这样一来，我们就可以借此验证代码是否正确。</p><h3>第二阶段：大数加法</h3><p>大数的加法，其实是我们程序员面试当中的一道高频题。它的解题思路也很简单，就是通过模拟我们<strong>手写加法竖式</strong>的方法，从个位、十位、百位、千位，一直累加，超过10的时候，我们需要进位。</p><p>我们以“135+99”为例：</p><p><img src="https://static001.geekbang.org/resource/image/f7/83/f777d39dd91641f5fb0b58a43e9bfc83.gif?wh=405x434" alt="图片"></p><p>从上面的手写加法竖式的过程我们可以看出，这个计算其实就是分了三个步骤在进行，分别是个位、十位、百位：</p><ul>\n<li>个位计算，“5+9=14”，出现进位，这时候我们用carry来存储进位：carry=1，个位结果为4；</li>\n<li>十位计算，十位相加“3+9=12”，由于之前有过进位，所以应该是“3+9+1=13”，十位结果为3；</li>\n<li>百位计算，由于99不存在百位，我们自动补零，所以就应该是“1+0+1=2”，百位结果为2。</li>\n</ul><p>最终，我们将每一位的结果拼接起来，就得到了最终的结果。有了这样的思路后，我们的代码就很容易实现了。</p><pre><code class="language-plain">fun addString(leftNum: String, rightNum: String): String {\n    // ①\n    val result = StringBuilder()\n    // ②\n    var leftIndex = leftNum.length - 1\n    var rightIndex = rightNum.length - 1\n    // ③\n    var carry = 0\n\n    // ④\n    while (leftIndex &gt;= 0 || rightIndex &gt;= 0) {\n        // ⑤\n        val leftVal = if (leftIndex &gt;= 0) leftNum.get(leftIndex).digitToInt() else 0\n        val rightVal = if (rightIndex &gt;= 0) rightNum.get(rightIndex).digitToInt() else 0\n        val sum = leftVal + rightVal + carry\n        // ⑥\n        carry = sum / 10\n        result.append(sum % 10)\n        leftIndex--\n        rightIndex--\n    }\n    // ⑦\n    if (carry != 0) {\n        result.append(carry)\n    }\n\n    // ⑧\n    return result.reverse().toString()\n}\n</code></pre><p>上面的代码一共有8处注释，代表了整体的程序流程，让我们一步步来分析：</p><ul>\n<li>注释①，我们<strong>创建了一个StringBuilder对象，</strong>用于存储最终结果，由于我们的结果是一位位计算出来的，所以每一位结果都是慢慢拼接上去的，在这里，为了提高程序的性能，我们选择使用StringBuilder。</li>\n<li>注释②，我们<strong>定义了两个可变的变量index</strong>，它们分别指向了两个数字的个位，这是因为我们的计算是从个位开始的。</li>\n<li>注释③，<strong>carry</strong>，我们用它来存储每一位计算结果的进位。</li>\n<li>注释④，这个 <strong>while循环</strong>当中，我们会让两个index从低位一直到高位，直到遍历完它们所有的数字位。</li>\n<li>注释⑤，这里的逻辑是<strong>取每一位上的数字</strong>，其中有个细节就是补零操作，比如当程序运行到百位的时候，99没有百位，这时候rightVal = 0。</li>\n<li>注释⑥，当我们的程序计算出结果后，我们要<strong>分别算出carry，以及当前位的结果</strong>。这时候我们分别使用“除法”计算carry，使用“取余”操作计算当前位的结果。</li>\n<li>注释⑦，这里是<strong>为了兼容一个特殊的场景</strong>，在“99+1”的情况下，我们的while循环最多只会遍历到十位，如果不做特殊处理的话，结果将变成“99+1=00”。这并不是我们想要的，所以，为了兼容这种特殊情况，我们<strong>在while循环结束后增加了一个判断</strong>，如果carry=1，那就说明在最大的那一位数计算完以后，仍然有进位，我们要手动添加。</li>\n<li>注释⑧，对于一个算式“135+99”，我们的result拼接其实是倒叙的“432”，这时候我们需要<strong>将其翻转</strong>一下，才能得到正确的结果“135+99=234”。</li>\n</ul><p>到这里，我们的大数加法功能，就算实现了。让我们回过头，再去运行一次单元测试，来验证下我们的代码是否正确：</p><p><img src="https://static001.geekbang.org/resource/image/4d/eb/4dd2dyyf2b31cd5379a7134b0f6822eb.gif?wh=1348x960" alt="图片"></p><p>果然，在我们兼容了“大数加法”以后，单元测试就可以成功通过了。至此，我们的计算器3.0版本就算是完成了。</p><p>在这个版本的开发过程中，首先我们引入了单元测试，通过这种方式，我们可以测试代码逻辑是否正确，并可以辅助我们排查问题。接着，我们写了一个“2333333333333332+1”的测试用例，并且失败了，不过在完成大数加法的功能后，这个测试也最终通过了。</p><p>这里我需要特殊说明的是，为了不偏离本次实战课的目的，我们的单元测试只写了两个，但在实际的开发工作当中，单元测试是需要尽量覆盖所有情况的。换句话说，仅仅只是测试“1+2”“2333333333333332+1”这两种情况，是无法保证我们的计算器逻辑正确的。一般来说，一个应用于商业的计算器，它的单元测试用例数量会达到几百上千个。</p><h2>小结</h2><p>到这里，我们就通过完成三个不同版本的四则运算计算器，一起梳理了前面课程中，学习的那些重要的Kotlin的知识点，比如不可变的变量val、when表达式、数据类、枚举类，等等。并且也在实操过程中，一起思考了代码实现时可能会出现的问题。</p><p>你也可以在动手操作的过程中，具体感受下跟Java代码的不同，同时也看看自己的思路与课程的思路有什么不同，课程当中的代码还有哪些可以改进的地方。</p><p>最后我想让你注意的是，在3.0版本中，我们引入了<strong>单元测试功能</strong>。实际上，单元测试的作用，不仅仅可以验证新开发的功能，同时它还可以用于保证旧的功能不受影响。在实际开发工作中，我们很容易因为对功能A的改动，导致功能B出问题。然后往往由于时间限制，测试人员只测试了功能A，忽略了功能B，最终导致线上故障带来经济损失。</p><p>而借助单元测试，在每一次的开发工作完成以后，我们就统一跑一遍所有的单元测试，只要单元测试通过了，我们就能保证，新的功能没问题，而旧的功能也没问题。</p><h2>动手实操</h2><p>在3.0版本的开发当中，我们仅仅只实现了“大数的加法”，其余的“大数的减法”“大数的乘法”“大数的除法”都没有实现。请你挑其中一个功能，尝试自己实现，参考答案我会在之后放出来。</p><p>欢迎你在评论区分享你的实现思路，我们下节课再见。</p>',
        article_title: "04 | 实战：构建一个Kotlin版本的四则运算计算器",
      },
      {
        title: "05 | object关键字：你到底有多少种用法？",
        id: 475058,
        content:
          '<p>你好，我是朱涛。这节课我们来学习Kotlin当中object关键字的三种语义，以及它的具体使用场景。</p><p>在前面课程中，我们学习了Kotlin语言的基础语法和面向对象相关的语法，其中涵盖了很多不同类型的关键字。比如说，fun关键字代表了定义函数，class关键字代表了定义类，这些都是一成不变的。但是今天我们要学习的object关键字，却有三种迥然不同的语义，分别可以定义：</p><ul>\n<li>匿名内部类；</li>\n<li>单例模式；</li>\n<li>伴生对象。</li>\n</ul><p>之所以会出现这样的情况，是因为Kotlin的设计者认为，这三种语义本质上都是<strong>在定义一个类的同时还创建了对象</strong>。在这样的情况下，与其分别定义三种不同的关键字，还不如将它们统一成object关键字。</p><p>那么，理解object关键字背后的统一语义，对我们学习这个语法是极其关键的，因为它才是这三种不同语义背后的共同点。通过这个统一语义，我们可以在这三种语义之间建立联系，形成知识体系。这样，我们在后面的学习中才不会那么容易迷失，也不会那么容易遗忘。</p><p>接下来，我们就一起来逐一探讨这三种情况吧。</p><h2>object：匿名内部类</h2><p>首先是object定义的匿名内部类。</p><p>Java当中其实也有匿名内部类的概念，这里我们可以通过跟Java的对比，来具体理解下Kotlin中对匿名内部类的定义。</p><!-- [[[read_end]]] --><p>在Java开发当中，我们经常需要写类似这样的代码：</p><pre><code class="language-java">public interface OnClickListener {\n    void onClick(View v);\n}\n\nimage.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        gotoPreview();\n    }\n});\n</code></pre><p>这就是典型的匿名内部类的写法，View.OnClickListener是一个接口，因此我们在创建它的时候，必须<strong>实现它内部没有实现的方法</strong>。</p><p>类似地，在Kotlin当中，我们会使用object关键字来创建匿名内部类。同样，在它的内部，我们也必须要实现它内部未实现的方法。这种方式不仅可以用于创建接口的匿名内部类，也可以创建抽象类的匿名内部类。</p><pre><code class="language-plain">image.setOnClickListener(object: View.OnClickListener {\n    override fun onClick(v: View?) {\n        gotoPreview()\n    }\n})\n</code></pre><p>需要特殊说明的是，当Kotlin的匿名内部类只有一个需要实现的方法时，我们可以使用SAM转换，最终使用Lambda表达式来简化它的写法。这个话题我们会留到第7讲再详细分析。</p><p>所以也就是说，Java和Kotlin相同的地方就在于，它们的接口与抽象类，都不能直接创建实例。想要创建接口和抽象类的实例，我们必须通过匿名内部类的方式。</p><p>不过，在Kotlin中，匿名内部类还有一个特殊之处，就是我们在使用object定义匿名内部类的时候，其实还可以<strong>在继承一个抽象类的同时，来实现多个接口</strong>。</p><p>我们看个具体的例子：</p><pre><code class="language-plain">interface A {\n    fun funA()\n}\n\ninterface B {\n    fun funB()\n}\n\nabstract class Man {\n    abstract fun findMan()\n}\n\nfun main() {\n    // 这个匿名内部类，在继承了Man类的同时，还实现了A、B两个接口\n    val item = object : Man(), A, B{\n        override fun funA() {\n            // do something\n        }\n        override fun funB() {\n            // do something\n        }\n        override fun findMan() {\n            // do something\n        }\n    }\n}\n</code></pre><p>让我们分析一下这段代码。接口A，它内部有一个funA()方法，接口B，它内部有一个funB()方法，抽象类Man，它内部有一个抽象方法findMan()。</p><p>接着，在main()函数当中，我们使用object定义了一个匿名内部类。这个匿名内部类，不仅继承了抽象类Man，还同时实现了接口A、接口B。而这种写法，在Java当中其实是不被支持的。</p><p>在日常的开发工作当中，我们有时会遇到这种情况：我们需要继承某个类，同时还要实现某些接口，为了达到这个目的，我们不得不定义一个内部类，然后给它取个名字。但这样的类，往往只会被用一次就再也没有其他作用了。</p><p>所以针对这种情况，使用object的这种语法就正好合适。我们既不用再定义内部类，也不用想着该怎么给这个类取名字，因为用过一次后就不用再管了。</p><h2>object：单例模式</h2><p>接着，我们再来了解下object定义的第二种语义，也就是单例模式。</p><p>在Kotlin当中，要实现<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a>其实非常简单，我们直接用object修饰类即可：</p><pre><code class="language-plain">object UserManager {\n    fun login() {}\n}\n</code></pre><p>从以上代码中我们可以发现，当使用object以后，就不必再写class关键字了。<strong>我们只需要关注业务逻辑</strong>，至于这个单例模式到底是如何实现的，我们交给Kotlin编译器就行了。这种便捷性，在Java当中是不可想象的。要知道，单例模式的实现，在Java当中是会被当做面试题来考的！而在Kotlin当中，它已变得无比简单。</p><p>在<a href="https://time.geekbang.org/column/article/473529">第3讲</a>里，我带你学习过如何研究Kotlin的原理，那么如果你想看看Kotlin编译器到底是如何实现单例模式的，你也可以反编译看看对应的Java代码：</p><pre><code class="language-java">public final class UserManager {\n\n   public static final UserManager INSTANCE; \n\n   static {\n      UserManager var0 = new UserManager();\n      INSTANCE = var0;\n   }\n\n   private UserManager() {}\n\n   public final void login() {}\n}\n</code></pre><p>可以看到，当我们使用object关键字定义单例类的时候，Kotlin编译器会将其<strong>转换成静态代码块的单例模式</strong>。因为<code>static{}</code>代码块当中的代码，由虚拟机保证它只会被执行一次，因此，它在保证了线程安全的前提下，同时也保证我们的INSTANCE只会被初始化一次。</p><p>不过到这里，你或许就会发现，这种方式定义的单例模式，虽然具有简洁的优点，但同时也存在两个缺点。</p><ul>\n<li><strong>不支持懒加载。</strong>这个问题很容易解决，我们在后面会提到。</li>\n<li><strong>不支持传参构造单例。</strong>举个例子，在Android开发当中，很多情况下我们都需要用到Context作为上下文。另外有的时候，在单例创建时可能也需要Context才可以创建，那么如果这时候单纯只有object创建的单例，就无法满足需求了。</li>\n</ul><p>那么，Kotlin当中有没有其他方式来实现单例模式呢？答案当然是有的，不过，我们要先掌握object的第三种用法：伴生对象。</p><h2>object：伴生对象</h2><p>我们都知道，Kotlin当中没有static关键字，所以我们没有办法直接定义静态方法和静态变量。不过，Kotlin还是为我们提供了伴生对象，来帮助实现静态方法和变量。</p><p>在正式讲解伴生对象之前，我们先来看看object定义单例的一种特殊情况，看看它是如何演变成“伴生对象”的：</p><pre><code class="language-plain">class Person {\n    object InnerSingleton {\n        fun foo() {}\n    }\n}\n</code></pre><p>可以看到，我们可以将单例定义到一个类的内部。这样，单例就跟外部类形成了一种嵌套的关系，而我们要使用它的话，可以直接这样写：</p><pre><code class="language-plain">Person.InnerSingleton.foo()\n</code></pre><p>以上的代码看起来，foo()就像是静态方法一样。不过，为了一探究竟，我们可以看看Person类反编译成Java后是怎样的。</p><pre><code class="language-plain">public final class Person {\n   public static final class InnerSingleton {\n\n      public static final Person.InnerSingleton INSTANCE;\n\n      public final void foo() {}\n\n      private InnerSingleton() {}\n\n      static {\n         Person.InnerSingleton var0 = new Person.InnerSingleton();\n         INSTANCE = var0;\n      }\n   }\n}\n</code></pre><p>可以看到，foo()并不是静态方法，它实际上是通过调用单例InnerSingleton的实例上的方法实现的：</p><pre><code class="language-plain">// Kotlin当中这样调用\nPerson.InnerSingleton.foo()\n//      等价\n//       ↓  java 当中这样调用\nPerson.InnerSingleton.INSTANCE.foo()\n</code></pre><p>这时候，你可能就会想：<strong>要如何才能实现类似Java静态方法的代码呢？</strong></p><p>其实很简单，我们可以使用“@JvmStatic”这个注解，如以下代码所示：</p><pre><code class="language-plain">class Person {\n    object InnerSingleton {\n        @JvmStatic\n        fun foo() {}\n    }\n}\n</code></pre><p>所以这个时候，如果你再反编译Person类，你会发现，foo()这个方法就变成了InnerSingleton类当中的一个静态方法了。</p><pre><code class="language-plain">public final class Person {\n   public static final class InnerSingleton {\n      // 省略其他相同代码\n      public static final void foo() {}\n   }\n}\n</code></pre><p>这样一来，对于foo()方法的调用，不管是Kotlin还是Java，它们的调用方式都会变成一样的：</p><pre><code class="language-plain">Person.InnerSingleton.foo()\n</code></pre><p>看到这里，如果你足够细心，你一定会产生一个疑问：上面的静态内部类“InnerSingleton”看起来有点多余，我们平时在Java当中写的静态方法，不应该是只有一个层级吗？比如：</p><pre><code class="language-java">public class Person {\n    public static void foo() {}\n}\n\n// 调用的时候，只有一个层级\nPerson.foo()\n</code></pre><p>那么，在Kotlin当中有办法实现这样的静态方法吗？</p><p>答案当然是有的，我们只需要在前面例子当中的object关键字前面，加一个<strong>companion关键字</strong>即可。</p><pre><code class="language-plain">class Person {\n//  改动在这里\n//     ↓\n    companion object InnerSingleton {\n        @JvmStatic\n        fun foo() {}\n    }\n}\n</code></pre><p>companion object，在Kotlin当中就被称作伴生对象，它其实是我们嵌套单例的一种特殊情况。也就是，<strong>在伴生对象的内部，如果存在“@JvmStatic”修饰的方法或属性，它会被挪到伴生对象外部的类当中，变成静态成员。</strong></p><pre><code class="language-java">public final class Person {\n\n   public static final Person.InnerSingleton InnerSingleton = new Person.InnerSingleton((DefaultConstructorMarker)null);\n\n   // 注意这里\n   public static final void foo() {\n      InnerSingleton.foo();\n   }\n\n   public static final class InnerSingleton {\n      public final void foo() {}\n\n      private InnerSingleton() {}\n\n      public InnerSingleton(DefaultConstructorMarker $constructor_marker) {\n         this();\n      }\n   }\n}\n</code></pre><p>根据上面反编译后的代码，我们可以看出来，被挪到外部的静态方法foo()，它最终还是调用了单例InnerSingleton的成员方法foo()，所以它只是做了一层转接而已。</p><p>到这里，也许你已经明白object单例、伴生对象中间的演变关系了：普通的object单例，演变出了嵌套的单例；嵌套的单例，演变出了伴生对象。</p><p>你也可以换个说法：<strong>嵌套单例，是object单例的一种特殊情况；伴生对象，是嵌套单例的一种特殊情况。</strong></p><h2>伴生对象的实战应用</h2><p>前面我们已经使用object关键字实现了最简单的单例模式，这种方式的缺点是不支持懒加载、不支持“getInstance()传递参数”。而借助Kotlin的伴生对象，我们可以实现功能更加全面的单例模式。</p><p>不过，在使用伴生对象实现单例模式之前，我们需要先热热身，用它来实现工厂模式。下面，我就给你详细介绍一下。</p><h3>工厂模式</h3><p>所谓的<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">工厂模式</a>，就是指当我们想要统一管理一个类的创建时，我们可以将这个类的构造函数声明成private，然后用工厂模式来暴露一个统一的方法，以供外部使用。Kotlin的伴生对象非常符合这样的使用场景：</p><pre><code class="language-plain">//  私有的构造函数，外部无法调用\n//            ↓\nclass User private constructor(name: String) {\n    companion object {\n        @JvmStatic\n        fun create(name: String): User? {\n            // 统一检查，比如敏感词过滤\n            return User(name)\n        }\n    }\n}\n</code></pre><p>在这个例子当中，我们将User的构造函数声明成了private的，这样，外部的类就无法直接使用它的构造函数来创建实例了。与此同时，我们通过伴生对象，暴露出了一个create()方法。在这个create()方法当中，我们可以做一些统一的判断，比如敏感词过滤、判断用户的名称是否合法。</p><p>另外，由于“伴生对象”本质上还是属于User的嵌套类，伴生对象仍然还算是在User类的内部，所以，我们是可以在create()方法内部调用User的构造函数的。</p><p>这样，我们就通过“伴生对象”巧妙地实现了工厂模式。接下来，我们继续看看如何使用“伴生对象”来实现更加复杂的单例设计模式。</p><h3>另外4种单例模式的写法</h3><p>在前面，我们已经学习了Kotlin当中最简单的单例模式，也就是object关键字。同时，我们也提到了，这种方式虽然简洁，但它也存在两大问题：第一，无法懒加载；第二，不支持传参。</p><p>那么，Kotlin当中有没有既支持懒加载又支持传参的单例模式呢？</p><p>答案当然是有的。接下来，我们就来了解下Kotlin里功能更加全面的4种单例模式，分别是懒加载委托单例模式、Double Check单例模式、抽象类模板单例，以及接口单例模板。</p><p><strong>第一种写法：借助懒加载委托</strong></p><p>其实，针对懒加载的问题，我们在原有的代码基础上做一个非常小的改动就能优化，也就是借助Kotlin提供的“委托”语法。</p><p>比如，针对前面的单例代码，我们在它内部的属性上使用by lazy将其包裹起来，这样我们的单例就能得到一部分的懒加载效果。</p><pre><code class="language-plain">object UserManager {\n    // 对外暴露的 user\n    val user by lazy { loadUser() }\n\n    private fun loadUser(): User {\n        // 从网络或者数据库加载数据\n        return User.create("tom")\n    }\n\n    fun login() {}\n}\n</code></pre><p>可以看到，UserManager内部的user变量变成了懒加载，只要user变量没有被使用过，它就不会触发loadUser()的逻辑。</p><p>这其实是一种<strong>简洁与性能的折中方案</strong>。一个对象所占用的内存资源毕竟不大，绝大多数情况我们都可以接受。而从服务器去请求用户信息所消耗的资源更大，我们能够保证这个部分是懒加载的，就算是不错的结果了。</p><blockquote>\n<p><strong>注意：</strong>这里我们用到了by lazy，它是Kotlin当中的“懒加载委托”语法。我们会在第9讲里详细介绍它。目前你只需要知道，它可以保证懒加载的同时，还能保证线程安全即可。</p>\n</blockquote><p><strong>第二种写法：伴生对象Double Check</strong></p><p>我们直接看代码吧：</p><pre><code class="language-plain">class UserManager private constructor(name: String) {\n    companion object {\n        @Volatile private var INSTANCE: UserManager? = null\n\n        fun getInstance(name: String): UserManager =\n            // 第一次判空\n            INSTANCE?: synchronized(this) {\n            // 第二次判空\n                INSTANCE?:UserManager(name).also { INSTANCE = it }\n            }\n    }\n}\n\n// 使用\nUserManager.getInstance("Tom")\n</code></pre><p>这种写法，其实是借鉴于GitHub上的<a href="https://github.com/android/architecture-components-samples/blob/master/BasicRxJavaSampleKotlin/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.kt">Google官方Demo</a>，它本质上就是Java的<strong>Double Check</strong>。</p><p>首先，我们定义了一个伴生对象，然后在它的内部，定义了一个INSTANCE，它是private的，这样就保证了它无法直接被外部访问。同时它还被注解“@Volatile”修饰了，这可以保证INSTANCE的可见性，而getInstance()方法当中的synchronized，保证了INSTANCE的原子性。因此，这种方案还是线程安全的。</p><p>同时，我们也能注意到，初始化情况下，INSTANCE是等于null的。这也就意味着，只有在getInstance()方法被使用的情况下，我们才会真正去加载用户数据。这样，我们就实现了整个UserManager的懒加载，而不是它内部的某个参数的懒加载。</p><p>另外，由于我们可以在调用getInstance(name)方法的时候传入初始化参数，因此，这种方案也是支持传参的。</p><p>不过，以上的实现方式仍然存在一个问题，在实现了UserManager以后，假设我们又有一个新的需求，要实现PersonManager的单例，这时候我们就需要重新写一次Double Check的逻辑。</p><pre><code class="language-plain">class UserManager private constructor(name: String) {\n    companion object {\n    // 省略代码\n    }\n}\n\nclass PersonManager private constructor(name: String) {\n    companion object {\n        @Volatile private var INSTANCE: PersonManager? = null\n\n        fun getInstance(name: String): PersonManager =\n            INSTANCE?: synchronized(this) {\n                INSTANCE?:PersonManager(name).also { INSTANCE = it }\n            }\n    }\n}\n</code></pre><p>可以看到，不同的单例当中，我们必须反复写Double Check的逻辑，这是典型的坏代码。这种方式不仅很容易出错，同时也不符合编程规则（Don’t Repeat Yourself）。</p><p>那么，有没有一种办法可以让我们复用这部分逻辑呢？答案当然是肯定的。</p><p><strong>第三种写法：抽象类模板</strong></p><p>我们来仔细分析下第二种写法的单例。其实很快就能发现，它主要由两个部分组成：第一部分是INSTANCE实例，第二部分是getInstance()函数。</p><p>现在，我们要尝试对这种模式进行抽象。在面向对象的编程当中，我们主要有两种抽象手段，第一种是<strong>类抽象模板</strong>，第二种是<strong>接口抽象模板</strong>。</p><p>这两种思路都是可以实现的，我们先来试试<strong>抽象类</strong>的方式，将单例当中通用的“INSTANCE实例”和“getInstance()函数”，抽象到BaseSingleton当中来。</p><pre><code class="language-plain">//  ①                          ②                      \n//  ↓                           ↓                       \nabstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n\n    //                       ③\n    //                       ↓\n    protected abstract fun creator(param: P): T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            //            ④\n            //            ↓\n            instance ?: creator(param).also { instance = it }\n    }\n}\n</code></pre><p>在仔细分析每一处注释之前，我们先来整体看一下上面的代码：我们定义了一个抽象类BaseSingleton，在这个抽象类当中，我们把单例当中通用的“INSTANCE实例”和“getInstance()函数”放了进去。也就是说，我们把单例类当中的核心逻辑放到了抽象类当中去了。</p><p>现在，我们再来看看上面的4处注释。</p><ul>\n<li>注释①：abstract关键字，代表了我们定义的BaseSingleton是一个抽象类。我们以后要实现单例类，就只需要继承这个BaseSingleton即可。</li>\n<li>注释②：in P, out T是Kotlin当中的泛型，P和T分别代表了getInstance()的参数类型和返回值类型。注意，这里的P和T，是在具体的单例子类当中才需要去实现的。如果你完全不知道泛型是什么东西，可以先看看<a href="https://zh.wikipedia.org/zh/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型的介绍</a>，我们在第10讲会详细介绍Kotlin泛型。</li>\n<li>注释③：creator(param: P): T是instance构造器，它是一个抽象方法，需要我们在具体的单例子类当中实现此方法。</li>\n<li>注释④：creator(param)是对instance构造器的调用。</li>\n</ul><p>这里，我们就以前面的UserManager、PersonManager为例，用抽象类模板的方式来实现单例，看看代码会发生什么样的变化。</p><pre><code class="language-plain">class PersonManager private constructor(name: String) {\n    //               ①                  ②\n    //               ↓                   ↓\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //                  ③\n    //                  ↓ \n        override fun creator(param: String): PersonManager = PersonManager(param)\n    }\n}\n\nclass UserManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, UserManager&gt;() {\n        override fun creator(param: String): UserManager = UserManager(param)\n    }\n}\n</code></pre><p>在仔细分析注释之前，我们可以看到：UserManager、PersonManager的代码已经很简洁了，我们不必重复去写“INSTANCE实例”和“Double Check”这样的模板代码，只需要简单继承BaseSingleton这个抽象类，按照要求传入泛型参数、实现creator这个抽象方法即可。</p><p>下面我们来分析上面的3处注释。</p><ul>\n<li>注释①：companion object : BaseSingleton，由于伴生对象本质上还是嵌套类，也就是说，它仍然是一个类，那么它就具备类的特性“继承其他的类”。因此，我们让伴生对象继承BaseSingleton这个抽象类。</li>\n<li>注释②：String, PersonManager，这是我们传入泛型的参数P、T对应的实际类型，分别代表了creator()的“参数类型”和“返回值类型”。</li>\n<li>注释③：override fun creator，我们在子类当中实现了creator()这个抽象方法。</li>\n</ul><p>至此，我们就完成了单例的“抽象类模板”。通过这样的方式，我们不仅将重复的代码都统一封装到了抽象类“BaseSingleton”当中，还大大简化了单例的实现难度。</p><p>接下来，让我们对比着看看单例的“接口模板”。</p><p><strong>第四种写法：接口模板</strong></p><p>首先我需要重点强调，<strong>这种方式是不被推荐的</strong>，这里提出这种写法是为了让你熟悉Kotlin接口的特性，并且明白Kotlin接口虽然能做到这件事，但它做得并不够好。</p><p>如果你理解了上面的“抽象类模板”，那么，接口的这种方式你应该也很容易就能想到：</p><pre><code class="language-plain">interface ISingleton&lt;P, T&gt; {\n    // ①\n    var instance: T?\n\n    fun creator(param: P): T\n\n    fun getInstance(p: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(p).also { instance = it }\n        }\n}\n</code></pre><p>可以看到，接口模板的代码结构和抽象类的方式如出一辙。而我们之所以可以这么做，也是因为Kotlin接口的两个特性：<strong>接口属性、接口方法默认实现</strong>。在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>的时候，我们提到过，Kotlin当中的接口被增强了，让它与抽象类越来越接近，这个例子正好就可以说明这一点。抽象类能实现单例模板，我们的接口也可以。</p><p>说实话，上面的接口单例模板看起来还是比较干净的，好像也挑不出什么大的毛病。但实际上，如果你看注释①的地方，你会发现：</p><ul>\n<li><strong>instance无法使用private修饰</strong>。这是接口特性规定的，而这并不符合单例的规范。正常情况下的单例模式，我们内部的instance必须是private的，这是为了防止它被外部直接修改。</li>\n<li><strong>instance无法使用@Volatile修饰</strong>。这也是受限于接口的特性，这会引发多线程同步的问题。</li>\n</ul><p>除了ISingleton接口有这样的问题，我们在实现ISingleton接口的类当中，也会有类似的问题。</p><pre><code class="language-plain">class Singleton private constructor(name: String) {\n    companion object: ISingleton&lt;String, Singleton&gt; {\n        //  ①      ②\n        //  ↓       ↓\n        @Volatile override var instance: Singleton? = null\n        override fun creator(param: String): Singleton = Singleton(param)\n    }\n}\n</code></pre><ul>\n<li>注释①：@Volatile，这个注解虽然可以在实现的时候添加，但<strong>实现方</strong>可能会忘记，这会导致隐患。</li>\n<li>注释②：我们在实现instance的时候，仍然无法使用private来修饰。</li>\n</ul><p>因此综合来看，单例“接口模板”并不是一种合格的实现方式。</p><p>不过，在研究这个接口模板的过程中，我们又重温了Kotlin接口属性、接口方法默认实现这两个特性，并且对这两个特性进行一次应用。与此同时，我们也理解了接口模板存在的缺陷，以及不被推荐的原因。</p><p>实际上，从一个知识锚点着手，我们用类似的方式，也可以帮助自己理解Kotlin其他的新特性。而在这个时候，我们会发现，Kotlin语法之间并不是一些孤立的知识点，而是存在一些关联的，通过这种学习方式，能帮助我们快速建立起知识体系，这其实也是保持学习与思考连贯性的好办法。</p><h2>小结</h2><p>这节课，我们学习了object的三种语义，分别是匿名内部类、单例、伴生对象。</p><p><img src="https://static001.geekbang.org/resource/image/cc/67/cc75cc62f08d1b4f2e604630499f8b67.jpg?wh=1920x1260" alt="图片"></p><p>Kotlin的匿名内部类和Java的类似，只不过它多了一个功能：匿名内部类可以在继承一个抽象类的同时还实现多个接口。</p><p>另外，object的单例和伴生对象，这两种语义从表面上看是没有任何联系的。但通过这节课的学习我们发现了，单例与伴生对象之间是存在某种演变关系的。<strong>“单例”演变出了“嵌套单例”，而“嵌套单例”演变出了“伴生对象”。</strong></p><p>然后，我们也借助Kotlin伴生对象这个语法，研究了伴生对象的实战应用，比如可以实现工厂模式、懒加载+带参数的单例模式。</p><p>尤其是单例模式，这节课中，我们一共提出了Kotlin当中5种单例模式的写法。除了最后一种“接口模板”的方式，是为了学习研究不被推荐使用以外，其他4种单例模式都是有一定使用场景的。这4种单例之间各有优劣，我们可以在工作中根据实际需求，来选择对应的实现方式：</p><ul>\n<li>如果我们的单例占用内存很小，并且对内存不敏感，不需要传参，直接使用object定义的单例即可。</li>\n<li>如果我们的单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，我们可以使用object搭配by lazy懒加载。</li>\n<li>如果我们的工程很简单，只有一两个单例场景，同时我们有懒加载需求，并且getInstance()需要传参，我们可以直接手写Double Check。</li>\n<li>如果我们的工程规模大，对内存敏感，单例场景比较多，那我们就很有必要使用抽象类模板BaseSingleton了。</li>\n</ul><h2>思考题</h2><p>这节课当中，我们提到的BaseSingleton是否还有改进的空间？这个问题会在第7讲“高阶函数”里做出解答。</p><p>欢迎你在评论区分享你的思路，我们下节课再见。</p>',
        article_title: "05 | object关键字：你到底有多少种用法？",
      },
      {
        title: "06 | 扩展：你的能力边界到底在哪里？",
        id: 475684,
        content:
          '<p>你好，我是朱涛。</p><p>Kotlin的扩展（Extension），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改JDK当中的String，想在它的基础上增加一个方法“lastElement()”来获取末尾元素，如果使用Java，我们是无法通过常规手段实现的，因为我们没办法修改JDK的源代码。<strong>任何第三方提供的SDK，我们都无权修改。</strong></p><p>不过，借助Kotlin的扩展函数，我们就完全可以在语义层面，来为第三方SDK的类扩展新的成员方法和成员属性。不管是为JDK的String增加新的成员方法，还是为Android SDK的View增加新成员属性，我们都可以实现。</p><p>Kotlin的这个“扩展”功能看起来很神奇，它会不会很难学？其实不然，它的语法非常简洁。今天这节课，我们就一起来学习下Kotlin当中的扩展。通过研究它的原理，来探索它的能力边界，并在理解和掌握核心知识点之后，去思考它的实战应用场景。</p><h2>什么是扩展函数和扩展属性？</h2><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以JDK当中的String为例，来看看如何通过Kotlin的扩展特性，为它新增一个lastElement()方法。</p><!-- [[[read_end]]] --><pre><code class="language-plain">// Ext.kt\npackage com.boycoder.chapter06\n\n/*\n ①    ②      ③            ④\n ↓     ↓       ↓            ↓      */\nfun String.lastElement(): Char? {\n    //    ⑤\n    //    ↓\n    if (this.isEmpty()) {\n        return null\n    }\n\n    return this[length - 1]\n}\n\n// 使用扩展函数\nfun main() {\n    val msg = "Hello Wolrd"\n    // lastElement就像String的成员方法一样可以直接调用\n    val last = msg.lastElement() // last = d\n}\n</code></pre><p>我们先是定义了一个String的扩展函数“lastElement()”，然后在main函数当中调用了这个函数。并且，这个扩展函数是直接定义在Kotlin文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为“<strong>顶层扩展</strong>”，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释。</p><ul>\n<li>注释①，<code>fun</code>关键字，代表我们要定义一个函数。也就是说，不管是定义普通Kotlin函数，还是定义扩展函数，我们都需要fun关键字。</li>\n<li>注释②，“<code>String.</code>”，代表我们的扩展函数是为String这个类定义的。在Kotlin当中，它有一个名字，叫做接收者（Receiver），也就是扩展函数的接收方。</li>\n<li>注释③，<code>lastElement()</code>，是我们定义的扩展函数的名称。</li>\n<li>注释④，“<code>Char?</code>”，代表扩展函数的返回值是可能为空的Char类型。</li>\n<li>注释⑤，“<code>this.</code>”，代表“具体的String对象”，当我们调用 <code>msg.lastElement()</code> 的时候，this就代表了msg。</li>\n</ul><p>需要注意的是，<strong>在整个扩展函数的方法体当中，this都是可以省略的。</strong>这一点，Kotlin和Java是一样的，this代表当前作用域，它可写可不写。</p><p>另外，如果你足够细心的话，你会发现如果去掉注释②处的“<code>String.</code>”，这段代码就会变成一个普通的函数定义：</p><pre><code class="language-plain">fun lastElement(): Char? {}\n\nfun String.lastElement(): Char? {}\n// 普通函数与扩展函数之间的差别\n</code></pre><p>换句话说，就是如果我们在普通函数的名称前面加上一个“接收者类型”，比如“<code>String.</code>”，Kotlin的“普通函数”就变成了“扩展函数”。</p><p>可见，Kotlin扩展语法设计得非常巧妙，只要你记住了普通函数的语法，那么，只需要再记住一点点细微的区别，你就能记住扩展函数的语法。而通过这个细微的语法差异，你也可以体会到，所谓的扩展函数，就是多了个“扩展接收者”的函数。</p><h3>扩展函数的实现原理</h3><p>在<a href="https://time.geekbang.org/column/article/473529">第3讲</a>中，我们学习了如何研究Kotlin的原理，也就是通过Java字节码来做反编译。那么在这里，我们就以刚才写的lastElement()为例，一起来看看它反编译后的Java代码是什么样的。</p><pre><code class="language-java">public final class ExtKt {\n   // ①\n   public static final Character lastElement(String $this) {\n      CharSequence var1 = (CharSequence)$this;\n      if (var1.length() == 0) {\n        return null\n      }\n\n      return  var1.charAt(var1.length() - 1);\n   }\n}\n\npublic static final void main() {\n  String msg = "Hello Wolrd";\n  //                        ②\n  //                        ↓\n  Character last = ExtKt.lastElement(msg);\n}\n</code></pre><p>以上代码有两个地方需要注意，我分别用两个注释标记出来了。</p><p>通过第一个注释，我们可以看到，原本定义在String类型上面的扩展函数lastElement()，变成了一个<strong>普通的静态方法</strong>。另外，之前定义的扩展函数lastElement()是没有参数的，但反编译后的Java代码中，lastElement(String $this) <strong>多了一个String类型的参数</strong>。</p><p>还有第二个注释，这是扩展函数的调用处，原本msg.lastElement()的地方，变成了ExtKt.lastElement(msg)。这说明，<strong>Kotlin编写的扩展函数调用代码，最终会变成静态方法的调用</strong>。</p><p>看到这里，也许你一下就能反应过来：Kotlin的扩展函数只是从表面上将lastElement()变成String的成员，但它实际上并没有修改String这个类的源代码，lastElement()也并没有真正变成String的成员方法。</p><p>也就是说，<strong>由于JVM不理解Kotlin的扩展语法，所以Kotlin编译器会将扩展函数转换成对应的静态方法，而扩展函数调用处的代码也会被转换成静态方法的调用。</strong></p><p>而如果我们将上面的ExtKt修改成StringUtils，它就变成了典型的Java工具类。</p><pre><code class="language-java">public final class StringUtils {\n   public static final Character lastElement(String $this) {\n     // 省略\n   }\n}\n\npublic static final void main() {\n  Character last = StringUtils.lastElement(msg);\n}\n</code></pre><h3>如何理解扩展属性？</h3><p>在学习了Kotlin的扩展函数以后，扩展属性就很好理解了。扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以lastElement为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><pre><code class="language-plain">// 接收者类型\n//     ↓\nval String.lastElement: Char?\n    get() = if (isEmpty()) {\n            null\n        } else {\n            get(length - 1)\n        }\n\nfun main() {\n    val msg = "Hello Wolrd"\n    // lastElement就像String的成员属性一样可以直接调用\n    val last = msg.lastElement // last = d\n}\n</code></pre><p>在这段的代码中，我们为String类型扩展了一个新的成员属性“lastElement”。然后在main函数当中，我们直接通过“msg.lastElement”方式使用了这个扩展属性，就好像它是一个成员一样。而如果你将以上的代码进行反编译，你会发现它反编译后的Java代码几乎和我们前面扩展函数的一模一样。</p><p>为了让你看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://static001.geekbang.org/resource/image/2a/ed/2a38487b61ec06e437c1425b2a69ffed.png?wh=1920x752" alt="图片"></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被Kotlin编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被Kotlin编译器转换成静态方法的调用。</p><p>所以也就是说，Kotlin的扩展表面上看起来是为一个类扩展了新的成员，但是<strong>本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的lastElement，它更适合作为一个扩展属性。这样设计的话，在语义上，lastElement就像是String类当中的属性一样，它代表了字符串里的最后一个字符。</p><h2>扩展的能力边界</h2><p>在理解了扩展的使用与原理后，我们再来探讨一下扩展的能力边界：扩展能做什么，不能做什么。Kotlin的扩展看起来很神奇，但它并不是无所不能的，通过探索它的能力边界，我们就能对它有一个更加深入的认识。</p><h3><strong>扩展能做什么？</strong></h3><p>我们先从“扩展能做什么”说起。</p><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在Kotlin当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的Java类。唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，Kotlin扩展的应用范围还是非常广的。它最主要的用途，就是<strong>用来取代Java当中的各种工具类</strong>，比如StringUtils、DateUtils等等。</p><p>所有Java工具类能做的事情，Kotlin扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><p><img src="https://static001.geekbang.org/resource/image/23/9c/239e540b768560c6cd119b1bb9e1eb9c.gif?wh=1210x682" alt="图片"></p><h3><strong>扩展不能做什么？</strong></h3><p>我们再聊聊扩展不能做什么。</p><p>Kotlin的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制</strong>，Kotlin扩展不是真正的类成员，因此它无法被它的子类重写。举个例子，我们定义一个这样的Person类，并且分别为它扩展了一个isAdult属性和 walk()方法：</p><pre><code class="language-plain">open class Person {\n    var name: String = ""\n    var age: Int = 0\n}\n\nval Person.isAdult: Boolean\n    get() = age &gt;= 18\n\nfun Person.walk() {\n    println("walk")\n}\n</code></pre><p>由于Person类有open关键字修饰，所以我们可以继承这个Person类。不过，当我们尝试去重写它的成员时，会发现isAdult和walk()是无法被重写的，因为它们压根就不属于Person这个类。这个很好理解，让我们看下一个。</p><p><strong>第二个限制</strong>，扩展属性无法存储状态。就如前面代码当中的isAdult属性一般，它的值是由age这个成员属性决定的，它本身没有状态，也无法存储状态。这一点，和我们在<a href="https://time.geekbang.org/column/article/473349">第2讲</a>学习的“接口成员属性”一样，背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制</strong>，扩展的访问作用域仅限于两个地方。第一，定义处的成员；第二，接收者类型的公开成员。我们以前面的代码为例：</p><pre><code class="language-plain">// Ext.kt\npackage com.boycoder.chapter06\n\n// ①\nprivate val msg: String = ""\n\nfun String.lastElement(): Char? {\n    if (this.isEmpty()) {\n        //       ②\n        //       ↓\n        println(msg)\n        return null\n    }\n\n    //            ③\n    //            ↓\n    return this[length - 1]\n}\n</code></pre><p>这段代码一共有三处注释，我们一个个看：</p><ul>\n<li>在注释①的地方，我们在Ext这个Kotlin文件里定义了一个私有的变量msg。</li>\n<li>由于lastElement()与msg是定义在同一个文件当中的，因此，在注释②处我们可以直接访问msg，即使它是私有的。</li>\n<li>最后，是注释③，由于length是String类的公开属性，因此我们可以在扩展函数当中直接访问它。对应的，如果length是String的private、protected成员，那我们将无法在扩展函数当中访问它。归根结底，还是因为扩展函数并非真正的类成员。</li>\n</ul><p>看到这里，也许你会冒出一个有趣的想法：<strong>如果将扩展定义在某个类的内部，它能够访问这个类的私有属性吗？</strong></p><p>让我们来试试看：</p><pre><code class="language-plain">open class Person {\n    var name: String = ""\n    var age: Int = 0\n}\n\nclass Helper {\n    private fun walkOnFoot() {\n        println("用脚走路")\n    }\n    val Person.isAdult: Boolean\n        get() = age &gt;= 18\n\n    fun Person.walk() {\n        // 调用了Helper的私有方法\n        walkOnFoot()\n    }\n\n    fun test() {\n        val person = Person()\n        // 仅可以在Helper类当中使用此扩展\n        person.walk()\n    }\n}\n</code></pre><p>我们创建了一个Helper类，它内部有一个私有的成员方法，同时，我们在这个类的内部定义了一个扩展属性和一个扩展函数。可以看到，我们在扩展函数walk()方法当中，能直接调用Helper类的私有成员方法walkOnFoot()，这体现了类的内部定义扩展的优势。</p><p>但是与此同时，这种方式定义的扩展也存在一个劣势，那就是无法在Helper类的外部作为扩展被调用。如果你将上面的代码反编译成Java，你会发现，我们定义的内部扩展，最终都变成了Helper类的普通成员函数和成员属性。</p><p>所以，针对扩展的第三个限制来说：</p><ul>\n<li>如果扩展是<strong>顶层的扩展</strong>，那么扩展的访问域仅限于该Kotlin文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</li>\n<li>如果扩展是<strong>被定义在某个类当中</strong>的，那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</li>\n</ul><h2>实战与思考</h2><p>到这里，我们就了解了Kotlin的扩展，包括扩展函数、扩展属性以及扩展的实现原理，同时我们也在了解它原理的基础上分析了它的能力边界。</p><p>不过，即使在学习完上面所有的知识点后，你也许还是不太清楚Kotlin扩展的实际使用场景。所以下面，我再带你来看两个案例，这两个工业界的实际案例，可以完美地向你展示Kotlin扩展的两个核心使用场景。你可以通过学习这两种思路，将其运用在实际的工作当中。</p><p>第一个案例，是来自Kotlin标准库当中的源代码。我们先看看在Kotlin当中，<a href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt</a>的源代码是什么样的：</p><pre><code class="language-plain">// String.kt\npublic class String : Comparable&lt;String&gt;, CharSequence {\n    companion object {}\n\n    public operator fun plus(other: Any?): String\n\n    public override val length: Int\n\n    public override fun get(index: Int): Char\n\n    public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    public override fun compareTo(other: String): Int\n}\n</code></pre><p>你一定会很惊讶，Kotlin里面的String类竟然只有不到十行代码。那么，String类的那些字符操作的方法到哪里去了？比如，String.trim()、String.lowercase()它们定义在什么地方？</p><p>实际上，String相关的操作方法全都放到了<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt</a>当中去了。而这些字符操作方法全部都是以扩展函数的方式定义的：</p><pre><code class="language-plain">// Strings.kt 部分代码\n\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\npublic expect fun String.lowercase(): String\n</code></pre><p>那么，Kotlin官方能不能将“字符操作方法”放到String类当中合并到一起呢？源代码是Kotlin官方写的，他们当然能将所有的代码都合并到一个类当中去，形成一个几千行的String类，但他们却没有这么做。这是为啥呢？</p><p>这就是Kotlin扩展的<strong>第一个典型使用场景：</strong><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">关注点分离</a>。所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以上面的String类为例，<a href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt</a>这个类，只关注String的核心逻辑；而<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt</a>则只关注String的操作符逻辑。</p><p>需要注意的是，只有借助Kotlin的扩展，我们才能实现这样的关注点分离设计。如果你去看Java的String类，你会发现它的源代码有三千多行。这是因为，Java的String核心属性跟它的操作方法全都混合在了一起。</p><p>第二个代码案例，是我工作当中用到的一段Android扩展函数代码：</p><pre><code class="language-plain">inline fun &lt;reified T : ViewGroup.LayoutParams&gt; View.updateLayoutParams(block: T.() -&gt; Unit) {\n    val params = layoutParams as T\n    block(params)\n    layoutParams = params\n}\n\nfun View.updateMargin(left: Int? = null, top: Int? = null, right: Int? = null, bottom: Int? = null) {\n    (layoutParams as? ViewGroup.MarginLayoutParams)?.let { param -&gt;\n        updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {\n            left?.let {\n                marginStart = left\n            }\n\n            right?.let {\n                marginEnd = right\n            }\n\n            top?.let {\n                topMargin = top\n            }\n\n            bottom?.let {\n                bottomMargin = bottom\n            }\n        }\n    }\n}\n</code></pre><p>上面的代码定义了两个扩展函数，updateLayoutParams()、updateMargin()，后者的方法体当中用到了前者。通过updateMargin()这个扩展函数，可以大大简化Android当中的margin更新。</p><pre><code class="language-plain">view.updateMargin(top = 100, bottom = 100)\n</code></pre><p>而如果不借助扩展函数，我们将不得不写一堆的模板代码：</p><pre><code class="language-plain">val params = view.layoutParams\nif (params is ViewGroup.MarginLayoutParams) {\n    params.marginTop = 100\n    params.marginBottom = 100\n    view.layoutParams = params\n}\n</code></pre><p>可以看到，借助扩展函数，我们不仅提升了代码的可读性，还提升了编码效率，而这种效率可以说是<strong>成倍</strong>的提升：借助扩展函数，我们只需要写一行代码，IntelliJ还会智能提示，帮我们补全代码；不借助扩展函数的话，我们需要写5行代码，这样的代码模式不仅枯燥繁琐，IntelliJ也无法智能提示，也更容易出错。</p><p>我们来小结一下，Kotlin扩展主要有两个核心使用场景。</p><ul>\n<li><strong>主动使用扩展，通过它来优化软件架构。</strong></li>\n</ul><p>对复杂的类进行职责划分，关注点分离。让类的核心尽量简单易懂，而让类的功能性属性与方法以扩展的形式存在于类的外部。比如我们的<a href="https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/String.kt">String.kt</a>与<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/text/Strings.kt">Strings.kt</a>。</p><ul>\n<li><strong>被动使用扩展，提升可读性与开发效率。</strong></li>\n</ul><p>当我们无法修改外部的SDK时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型，比如view.updateMargin()。</p><h2>小结</h2><p>好，让我们来做个简单的总结吧。</p><ul>\n<li>Kotlin的扩展，从<strong>语法角度</strong>来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li>\n<li>从<strong>作用域角度</strong>来看，分为顶层扩展和类内扩展。</li>\n<li>从<strong>本质</strong>上来看，扩展函数和扩展属性，它们都是Java静态方法，与Java当中的工具类别无二致。对比Java工具类，扩展最大的优势就在于，IDE可以为我们提供代码补全功能。</li>\n<li>从<strong>能力</strong>的角度来看，Kotlin扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li>\n<li>从<strong>使用场景</strong>的角度来看，Kotlin扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li>\n</ul><p>最后在这里，我还想和你分享一下我在学Kotlin扩展的思考过程，希望这种思考的方式可以给你带来一些启发。</p><p>刚开始，我学习扩展的时候，脑子里其实是一片混乱的，就像下面这张图一样：扩展的每一个知识点都是散乱的。</p><p>这时候，我们就要将这些知识点做一个分类整理，同时，在学习扩展语法的时候，还要与前面的普通函数、普通属性的语法进行关联记忆。这样一来，我们零散的知识点就连接到一起，形成体系化的知识面。</p><p><img src="https://static001.geekbang.org/resource/image/3d/5c/3d0715ee9ba1461bcee1bea99de8e25c.jpg?wh=1920x1080" alt="图片"></p><p>当我们的知识形成一个体系之后，记忆起来就很容易了，这样，一个简单的<strong>浅层知识结构</strong>就形成了。</p><p><img src="https://static001.geekbang.org/resource/image/5b/ac/5b2f0b9560d9198a9166f5e9016c83ac.jpg?wh=1920x1080" alt="图片"></p><p>接着，在这个基础上，我们再进行深度的思考，去探索扩展的底层原理，还有它的能力边界，从而形成一个更加<strong>深层次的知识结构</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/3e/18/3e42099e82472869f87e33e9202c1218.jpg?wh=1999x1273" alt=""></p><p>到目前为止，这些都是理论层面的一些知识，我们还需要进一步探索Kotlin扩展的实际应用场景。这时候，就会发现它的两个主要使用场景，一个是<strong>主动的</strong>，<strong>一个是被动的</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/b4/10/b4a3ce7c3e0b2228161faa4769618a10.jpg?wh=1999x1333" alt=""></p><p>其实，学习就是一个不断向下挖掘探索的过程。学习Kotlin是这样，学习其他计算机知识也是这样，甚至学习其他领域的知识也是这个道理。</p><h2>思考题</h2><p>在这节课中的所有案例中，我们的“扩展接收者”都是不为空的类型。但实际上，Kotlin的扩展是允许我们为“可为空的类型”进行扩展的。比如说：</p><pre><code class="language-plain">// 不为空的接收者类型\n//     ↓\nfun String.lastElement(): Char? {}\n\n// 可为空的接收者类型\n//     ↓\nfun String?.lastElement(): Char? {}\n</code></pre><p>那么，请问这两种扩展有什么不同？欢迎在评论区分享你的思路，我们下节课再见。</p>',
        article_title: "06 | 扩展：你的能力边界到底在哪里？",
      },
      {
        title: "07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？",
        id: 476637,
        content:
          '<p>你好，我是朱涛。</p><p>高阶函数在Kotlin里有着举足轻重的地位。<strong>它是Kotlin函数式编程的基石，是各种框架的关键元素。</strong>高阶函数掌握好了，我们理解协程的launch、async函数就会轻松一些，阅读协程的源代码也会不那么吃力；高阶函数理解透彻了，我们学习Jetpack Compose也会得心应手，在特定业务场景下，我们甚至可以用它来实现自己的DSL（Domain Specific Language）。</p><p>不过，如果你没有函数式编程的相关经验，在初次接触高阶函数的时候，很可能会被绕晕。因为它是一个全新的概念，你很难从经典的C/Java里找到同等的概念迁移过来（Java从1.8开始才引入相关概念）。然而，对于高阶函数这么重要的概念，Kotlin官方文档又惜字如金。</p><p>文档里只是突兀地介绍了高阶函数、函数类型、Lambda表达式的简单用法，接着就丢出一段复杂的代码案例，然后丢出一个更复杂的概念，“带接收者的函数类型”（Function Types With Receiver），接着又丢出了一段更复杂的代码案例。说实话，这真的让人难以理解。</p><p>所以今天这节课，我会采用Java和Kotlin对照的方式，来给你讲解Kotlin高阶函数的核心概念。并且我会通过一个实际案例，来帮助你理解其中最晦涩难懂的“带接收者的函数类型”，为你今后的Kotlin学习之路打下坚实的基础。</p><!-- [[[read_end]]] --><h2>Kotlin为什么要引入高阶函数？</h2><p>想要掌握好高阶函数，我们首先要知道，Kotlin为什么要引入这一全新的概念。这个问题，Kotlin官方并没有给出解释，但是我们很容易在它的使用上找到蛛丝马迹。</p><p>我们来看个实际的例子，这是Android中的View定义，这里我省略了大部分代码，主要是想带你来看看Kotlin高阶函数的一个典型使用场景。</p><blockquote>\n<p>补充：如果你不了解Android开发也没关系，Java Swing中也有类似的代码模式。如果两者你都不熟悉，借助我提供的注释，也不难理解。</p>\n</blockquote><pre><code class="language-java">// View.java\n\n// 成员变量\nprivate OnClickListener mOnClickListener;\nprivate OnContextClickListener mOnContextClickListener;\n\n// 监听手指点击事件\npublic void setOnClickListener(OnClickListener l) {\n    mOnClickListener = l;\n}\n\n// 为传递这个点击事件，专门定义了一个接口\npublic interface OnClickListener {\n    void onClick(View v);\n}\n\n// 监听鼠标点击事件\npublic void setOnContextClickListener(OnContextClickListener l) {\n    getListenerInfo().mOnContextClickListener = l;\n}\n\n// 为传递这个鼠标点击事件，专门定义了一个接口\npublic interface OnContextClickListener {\n    boolean onContextClick(View v);\n}\n</code></pre><p>这段代码，其实是一个典型的“可以用高阶函数来优化”的例子。让我们来看看它都做了什么：</p><ul>\n<li>首先，为了设置点击事件的监听，代码里特地定义了一个OnClickListener接口；</li>\n<li>接着，为了设置鼠标点击事件的监听，又专门定义了一个OnContextClickListener接口。</li>\n</ul><p>乍一看，我们貌似是可以复用同一个接口就行了，对吧？但事实上，<strong>借助高阶函数，我们一个接口都不必定义</strong>。</p><p>当然了，上面的代码是Android团队十几年前用Java写的，在那个场景下，这么写代码是完全没问题的。可是这段代码在使用的时候，问题更大。比如，我们可以来看看如下所示的Android里设置点击监听的代码：</p><pre><code class="language-java">// 设置手指点击事件\nimage.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n        gotoPreview();\n    }\n});\n\n// 设置鼠标点击事件\nimage.setOnContextClickListener(new View.OnContextClickListener() {\n    @Override\n    public void onContextClick(View v) {\n        gotoPreview();\n    }\n});\n</code></pre><p>看完了这两段代码之后，你有没有觉得这样的代码会很啰嗦？因为，真正逻辑只有一行代码：gotoPreview()，而实际上我们却写了6行代码。</p><p><img src="https://static001.geekbang.org/resource/image/18/ac/1876d635751fd11662fbfcc3285a0eac.jpg?wh=1852x494" alt="图片"></p><p>如果我们将其中的核心逻辑提取出来，会发现这样才是最简单明了的：</p><pre><code class="language-plain">//                      { gotoPreview() } 就是 Lambda\n//                             ↑\nimage.setOnClickListener({ gotoPreview() })\nimage.setOnContextClickListener({ gotoPreview() })\n</code></pre><p>那么，Kotlin语言的设计者是怎么做的呢？实际上他们是分成了两个部分：</p><ul>\n<li>用函数类型替代接口定义；</li>\n<li>用Lambda表达式作为函数参数。</li>\n</ul><p>这里我们再来看看与前面View.java的等价Kotlin代码：</p><pre><code class="language-plain">//View.kt\n//                     (View) -&gt; Unit 就是「函数类型 」\n//                       ↑        ↑ \nvar mOnClickListener: ((View) -&gt; Unit)? = null\nvar mOnContextClickListener: ((View) -&gt; Unit)? = null\n\n// 高阶函数\nfun setOnClickListener(l: (View) -&gt; Unit) {\n    mOnClickListener = l;\n}\n\n// 高阶函数\nfun setOnContextClickListener(l: (View) -&gt; Unit) {\n    mOnContextClickListener = l;\n}\n</code></pre><p>那么通过对比，我们能看到，Kotlin中引入高阶函数会带来几个<strong>好处</strong>：一个是针对定义方，代码中减少了两个接口类的定义；另一个是对于调用方来说，代码也会更加简洁。这样一来，就大大减少了代码量，提高了代码可读性，并通过减少类的数量，提高了代码的性能。</p><p><img src="https://static001.geekbang.org/resource/image/a7/eb/a7yy974d95cd3938f0f36781afb425eb.jpg?wh=1531x699" alt="图片"></p><blockquote>\n<p>注：关于“inline”，我会在下节课中详细介绍。</p>\n</blockquote><p>通过上面的例子，我们已经清楚高阶函数存在的意义和价值了。不过，前面出现的一些新的概念我们还没来得及详细解释，比如，<strong>函数类型、Lambda，它们到底是什么呢？还有高阶函数的具体定义是什么呢？</strong></p><p>接下来，我会通过一个具体的代码案例，来给你一一解读与高阶函数关系密切的概念及使用定义，让你能进一步夯实函数式编程的基础知识。</p><h2>理解高阶函数的相关概念</h2><p>首先，我们来了解下什么是函数类型。</p><h3>函数类型</h3><p>顾名思义，函数类型（Function Type）就是<strong>函数的类型</strong>。如果你之前没有函数式编程的经验，刚接触这个概念的话也许会觉得奇怪：函数也有类型吗？</p><p>是的，既然变量可以有类型，函数也可以有。在Kotlin的世界里，<a href="https://kotlinlang.org/docs/lambdas.html">函数是一等公民</a>。你可以将其理解为Kotlin里的VIP，普通人有的东西，VIP当然也有。比如，我们可以仔细看看下面的函数：</p><pre><code class="language-plain">//         (Int,  Int) -&gt;Float 这就是 add 函数的类型\n//           ↑     ↑      ↑\nfun add(a: Int, b: Int): Float { return (a+b).toFloat() }\n</code></pre><p>请注意这里我给出代码注释，第二行注释里面的“↑”代表的是一种映射关系。其实，将第三行代码里的“Int Int Float”抽出来，就代表了该函数的类型。</p><p>我们可以用更精练的语言来描述函数类型的规律：<strong>将函数的“参数类型”和“返回值类型”抽象出来后，就得到了“函数类型”</strong>。(Int, Int) -&gt;Float就代表了参数类型是两个Int，返回值类型为Float的函数类型。</p><p>理解了函数类型以后，我们再来看<strong>函数的引用</strong>。普通的变量也有引用的概念，我们可以将一个变量赋值给另一个变量。而这一点，在函数上也是同样适用的，函数也有引用，并且也可以赋值给变量。</p><pre><code class="language-plain">// 函数赋值给变量                    函数引用\n//    ↑                              ↑\nval function: (Int, Int) -&gt; Float = ::add\n</code></pre><h3>高阶函数</h3><p>好，接着我们再来看看高阶函数的具体定义。当然，前面解释了这么多，现在我们对高阶函数应该已经有了比较清晰的认识了，我们用Kotlin实现的View点击事件函数，它就是一个高阶函数。</p><p>而它明确的定义其实是这样的：<strong>高阶函数是将函数用作参数或返回值的函数。</strong></p><p>这句话有点绕，我们还是直接看例子吧。如果我们将Android里点击事件的监听用Kotlin来实现的话，它其实就是一个典型的高阶函数。</p><pre><code class="language-plain">//                      函数作为参数的高阶函数\n//                              ↓\nfun setOnClickListener(l: (View) -&gt; Unit) { ... }\n</code></pre><p>换句话说，一个函数的参数或是返回值，它们当中有一个是函数的情况下，这个函数就是高阶函数。</p><h3>Lambda</h3><p>而前面我们还提到过，Kotlin语言的设计者是用Lambda表达式作为函数参数的，那么这里的Lambda，就可以理解为是<strong>函数的简写</strong>：</p><pre><code class="language-plain">fun onClick(v: View): Unit { ... }\nsetOnClickListener(::onClick)\n\n// 用 Lambda 表达式来替代函数引用\nsetOnClickListener({v: View -&gt; ...})\n</code></pre><p>那么，如果你够细心的话，可能已经发现了一个问题：Android并没有提供View.java的Kotlin实现，那么为什么我们的Demo里面可以用Lambda来简化事件监听呢？</p><pre><code class="language-plain">// 在实际开发中，我们经常使用这种简化方式\nsetOnClickListener({ gotoPreview() }\n</code></pre><p>原因是这样的，由于OnClickListener符合SAM转换的要求，因此编译器自动帮我们做了一层转换，让我们可以用Lambda表达式来简化我们的函数调用。</p><p>那么，SAM又是个什么鬼？</p><h3>SAM转换</h3><p>SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，<strong>SAM代表着只有一个抽象方法的接口</strong>。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。</p><p>注意，Java 8中的SAM有明确的名称，叫做<strong>函数式接口</strong>（FunctionalInterface）。FunctionalInterface的限制如下，缺一不可：</p><ul>\n<li>必须是接口，抽象类不行；</li>\n<li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li>\n</ul><p>也就是说，对于View.java来说，它虽然是Java代码，但Kotlin编译器知道它的参数OnClickListener符合SAM转换的条件，所以会自动做以下转换。</p><p>转换前：</p><pre><code class="language-java">public void setOnClickListener(OnClickListener l)\n</code></pre><p>转换后：</p><pre><code class="language-plain">fun setOnClickListener(l: (View) -&gt; Unit)\n// 实际上是这样：\nfun setOnClickListener(l: ((View!) -&gt; Unit)?)\n</code></pre><p>其中，((View!) -&gt; Unit)?代表的是这个参数可能为空。</p><h2>Lambda表达式引发的8种写法</h2><p>当一个函数的参数是SAM的情况下，我们同样也可以使用Lambda作为参数。所以，<strong>我们既可以用匿名内部类的方式传参，也可以使用Lambda的方式传参</strong>。这两种方式在我们前面都已经提到过了。然而，在这两种写法的中间，还有6种“过渡状态”的写法。这对大部分初学者简直是噩梦：同样的代码，能有8种不同的写法，确实也挺懵的。</p><p>而要理解Lambda表达式的简写逻辑，其实很简单，那就是：<strong>多写</strong>。你也可以跟着我接下来的流程来一起写一写。</p><ul>\n<li>第1种写法</li>\n</ul><p>这是原始代码，它的本质是用 object 关键字定义了一个匿名内部类：</p><pre><code class="language-plain">image.setOnClickListener(object: View.OnClickListener {\n    override fun onClick(v: View?) {\n        gotoPreview(v)\n    }\n})\n</code></pre><ul>\n<li>第2种写法</li>\n</ul><p>在这种情况下，object关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是Lambda表达式了，因此它里面override的方法也要跟着删掉：</p><pre><code class="language-plain">image.setOnClickListener(View.OnClickListener { v: View? -&gt;\n    gotoPreview(v)\n})\n</code></pre><p>上面的<code>View.OnClickListener</code>被称为SAM Constructor（SAM构造器），它是编译器为我们生成的。</p><ul>\n<li>第3种写法</li>\n</ul><p>由于Kotlin的Lambda表达式是不需要SAM Constructor的，所以它也可以被删掉：</p><pre><code class="language-plain">image.setOnClickListener({ v: View? -&gt;\n    gotoPreview(v)\n})\n</code></pre><ul>\n<li>第4种写法</li>\n</ul><p>由于Kotlin支持类型推导，所以View可以被删掉：</p><pre><code class="language-plain">image.setOnClickListener({ v -&gt;\n    gotoPreview(v)\n})\n</code></pre><ul>\n<li>第5种写法</li>\n</ul><p>当Kotlin Lambda表达式只有一个参数的时候，它可以被写成it：</p><pre><code class="language-plain">image.setOnClickListener({ it -&gt;\n    gotoPreview(it)\n})\n</code></pre><ul>\n<li>第6种写法</li>\n</ul><p>Kotlin Lambda的it是可以被省略的：</p><pre><code class="language-plain">image.setOnClickListener({\n    gotoPreview(it)\n})\n</code></pre><ul>\n<li>第7种写法</li>\n</ul><p>当Kotlin Lambda作为函数的最后一个参数时，Lambda可以被挪到外面：</p><pre><code class="language-plain">image.setOnClickListener() {\n    gotoPreview(it)\n}\n</code></pre><ul>\n<li>第8种写法</li>\n</ul><p>当Kotlin只有一个Lambda作为函数参数时，()可以被省略：</p><pre><code class="language-plain">image.setOnClickListener {\n    gotoPreview(it)\n}\n</code></pre><p>这里，我把这8种写法的演进过程以动图的形式展现了出来，让你对Lambda这几种写法的差异有一个更加直观的认识。</p><p><img src="https://static001.geekbang.org/resource/image/e4/bf/e441323968c0c061898257fd06db37bf.gif?wh=1080x608" alt="图片"></p><p>按照这个流程，在IDE里多写几遍，你自然就会理解了。一定要写，光看是记不住的。</p><p>好了，到这里，你就搞明白这些概念是什么意思了。下面我们来做一个小的总结，在后续的Kotlin学习当中，这些都是要铭记在心的。</p><ul>\n<li>将函数的参数类型和返回值类型抽象出来后，我们就得到了函数类型。比如<code>(View) -&gt; Unit</code> 就代表了参数类型是View，返回值类型为Unit的函数类型。</li>\n<li>如果一个函数的“参数”或者“返回值”的类型是函数类型，那这个函数就是高阶函数。很明显，我们刚刚就写了一个高阶函数，只是它比较简单而已。</li>\n<li>Lambda就是函数的一种简写。</li>\n</ul><p>然后，你也可以再通过一张图来回顾下函数类型、高阶函数以及Lambda表达式三者之间的关系：</p><p><img src="https://static001.geekbang.org/resource/image/ec/71/ecf85d05f6fdc5ea2d015a61d7e64771.png?wh=1920x914" alt="图片"></p><p>你也可以再回过头来看看官方文档提供的例子：</p><pre><code class="language-plain">fun &lt;T, R&gt; Collection&lt;T&gt;.fold(\n    initial: R, \n    combine: (acc: R, nextElement: T) -&gt; R\n): R {\n    var accumulator: R = initial\n    for (element: T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n</code></pre><p>你看到这个函数类型：(acc: R, nextElement: T) -&gt; R，是不是瞬间就懂了呢？这个函数接收了两个参数，第一个参数类型是R，第二个参数是T，函数的返回类型是R。</p><h2>难点：带接收者的函数类型</h2><p>那么现在，我们就把高阶函数这个知识点理解得有80%了。而在这节课一开始，我还提到，在Kotlin的函数类型这个知识点当中，还有一个特殊的概念，叫做<strong>带接收者的函数类型</strong>，它尤其晦涩难懂。</p><p>说实话，这个名字也对初学者不太友好，“带接收者的函数类型”，这里面的每一个字我都认识，可放到一块我就懵了。所以我们其实还是绕不开一个问题：为什么？</p><h3>为什么要引入带接收者的函数类型？</h3><p>这里，让我们先来看一下Kotlin的标准函数apply的使用场景。</p><p>不用 apply：</p><pre><code class="language-plain">if (user != null) {\n    ...\n    username.text = user.name\n    website.text = user.blog\n    image.setOnClickListener { gotoImagePreviewActivity(user) }\n}\n</code></pre><p>使用apply：</p><pre><code class="language-plain">user?.apply {\n    ...\n    username.text = name\n    website.text = blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>请问这个apply方法应该怎么实现呢？</p><p>上面的写法其实是简化后的Lambda表达式，让我们来反推一下，看看它简化前是什么样的：</p><pre><code class="language-plain">// apply 肯定是个函数，所以有 ()，只是被省略了\nuser?.apply() {\n    ...\n}\n\n// Lambda 肯定是在 () 里面\nuser?.apply({ ... })\n\n// 由于 gotoImagePreviewActivity(this) 里的 this 代表了 user\n// 所以 user 应该是 apply 函数的一个参数，而且参数名为：this\nuser?.apply({ this: User -&gt; ... })\n</code></pre><p>所以，现在问题非常明确了，apply其实是接收了一个Lambda表达式：<code>{ this: User -&gt; ... }</code>。那么现在，我们就尝试来实现这个apply方法：</p><pre><code class="language-plain">fun User.apply(self: User, block: (self: User) -&gt; Unit): User{\n    block(self)\n    return this\n}\n\nuser?.apply(self = user) { self: User -&gt;\n            username.text = self.name\n            website.text = self.blog\n            image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>由于Kotlin里面的函数形参是不允许被命名为this的，因此我这里用的是self。另外，这里我们自己写出来的apply，仍然还要通过self.name这样的方式来访问成员变量，但Kotlin的语言设计者能做到这样：</p><pre><code class="language-plain">//           改为this             改为this\n//               ↓                    ↓ \nfun User.apply(this: User, block: (this: User) -&gt; Unit): User{\n//    这里还要传参数\n//         ↓ \n    block(this)\n    return this\n}\n\nuser?.apply(this = user) { this: User -&gt;\n    ...\n//               this 可以省略\n//                   ↓ \n    username.text = this.name\n    website.text = blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>从上面的例子能看到，我们反推的apply实现会比较繁琐：</p><ul>\n<li>需要我们传入this：user?.apply(this = user)。</li>\n<li>需要我们自己调用：block(this)。</li>\n</ul><p>因此，Kotlin就引入了带接收者的函数类型，可以简化apply的定义：</p><pre><code class="language-plain">//              带接收者的函数类型\n//                     ↓  \nfun User.apply(block: User.() -&gt; Unit): User{\n//  不用再传this\n//       ↓ \n    block()\n    return this\n}\n\nuser?.apply { this: User -&gt;\n//               this 可以省略\n//                   ↓\n    username.text = this.name\n    website.text = this.blog\n    image.setOnClickListener { gotoImagePreviewActivity(this) }\n}\n</code></pre><p>现在，关键来了。上面的apply方法是不是看起来就像是在User里，增加了一个成员方法apply()？</p><pre><code class="language-plain">class User() {\n    val name: String = ""\n    val blog: String = ""\n\n    fun apply() {\n        // 成员方法可以通过 this 访问成员变量\n        username.text = this.name\n        website.text = this.blog\n        image.setOnClickListener { gotoImagePreviewActivity(this) }\n    }\n}\n</code></pre><p>所以，从外表上看，带接收者的函数类型，就等价于成员方法。但<strong>从本质上讲，它仍是通过编译器注入this来实现的</strong>。</p><p>我们可以再通过一张图，来理解下什么是带接收者的函数类型：</p><p><img src="https://static001.geekbang.org/resource/image/9a/04/9acd54ac08d88c94ca52336a576b3304.png?wh=1890x1156" alt="图片"></p><p>看到这里，也许你会想起前面我们讲过的“扩展函数”。那么，带接收者的函数类型，是否也能代表扩展函数呢？</p><p>答案是肯定的。毕竟，<strong>从语法层面讲，扩展函数就相当于成员函数。</strong></p><h2>实战与思考</h2><p>在<a href="https://time.geekbang.org/column/article/475058">第5讲</a>当中，我们实现了“单例的抽象类模板”，在课程的最后，我还给你留了一个思考题：</p><blockquote>\n<p>我们的抽象类模板BaseSingleton是否还有改进的空间？</p>\n</blockquote><p>这里，让我们先回顾一下BaseSingleton的代码：</p><pre><code class="language-plain">                     \nabstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n    //                       ①\n    //                       ↓\n    protected abstract fun creator(param: P): T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(param).also { instance = it }\n    }\n}\n\nclass PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n        override fun creator(param: String): PersonManager = PersonManager(param)\n    }\n}\n</code></pre><p>从上面的代码我们可以看到，BaseSingleton是单例抽象模板，而PersonManager则是实际的单例类。</p><p>在前面的<a href="https://time.geekbang.org/column/article/473349">第2讲</a>里，我们就讨论过Person的isAdult应该是属性，而walk则应该是方法。那么现在，请看注释①，它是我们定义的一个抽象方法，名字叫做creator。这时候，相信你马上就能反应过来：creator应该定义成属性。</p><p>可是，<strong>如何才能将一个方法改成属性呢？</strong>答案当然就是刚学过的：<strong>高阶函数</strong>。</p><p>运用这节课学到的知识，我们很容易就能将creator改成一个类型为：<code>(P)-&gt;T</code>的属性，如下所示：</p><pre><code class="language-plain">abstract class BaseSingleton&lt;in P, out T&gt; {\n    @Volatile\n    private var instance: T? = null\n    //               变化在这里，函数类型的属性\n    //                  ↓              ↓\n    protected abstract val creator: (P)-&gt; T\n\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(param).also { instance = it }\n    }\n}\n</code></pre><p>上面的代码中，我们将creator改成了一个抽象的属性，如果其他的单例类继承了BaseSingleton这个类，就必须实现这个creator属性。不过，这时候一个问题就出现了：<strong>PersonManager该怎么写呢？</strong></p><p>如果我们依葫芦画瓢，在实现creator的时候传入PersonManager的构造函数，会发现代码报错：类型不匹配。</p><pre><code class="language-plain">class PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //             报错，类型不匹配\n    //                  ↓ \n        override val creator = PersonManager(name)\n    }\n}\n</code></pre><p>这段代码报错的原因其实也很简单，creator的类型是一个(String)-&gt; PersonManager，而PersonManager构造函数这个表达式的值类型，是PersonManager类型。<strong>前者是函数类型，后者是普通对象类型</strong>。那么，如何才能正确实现creator这个函数类型的属性呢？</p><p>答案就是我们前面刚学的：<strong>函数引用</strong>！</p><pre><code class="language-plain">class PersonManager private constructor(name: String) {\n    companion object : BaseSingleton&lt;String, PersonManager&gt;() {\n    //                             函数引用\n    //                                ↓ \n        override val creator = ::PersonManager\n    }\n}\n</code></pre><p>从上面的代码中可以看到，我们直接将PersonManager的构造函数，以函数引用的方式传给了creator这个属性，这样就成功地实现了这个函数类型的属性。</p><p>在这个案例里，我们将函数引用以及高阶函数应用到了单例抽象类模板当中，而在这个过程当中，我们也就能更加透彻地理解这两个特性的使用场景了。</p><p>这里我制作了一个代码的转换动图，帮你建立一个更加直观的认识。</p><p><img src="https://static001.geekbang.org/resource/image/49/5c/49b134d723c11c7d50762497b44afa5c.gif?wh=1080x608" alt="图片"></p><p>从这个动图里，我们可以清晰地看到某些元素的转移过程。比如泛型P、T，还有PersonManager的构造函数，这些都是代码中的关键元素。这些关键元素只是换了一种语法排列规则：<strong>从函数的语法变成了属性的语法，语法从复杂变得简洁，其中的关键元素并未丢失</strong>。</p><p>因此，这两种代码是完全等价的，但后者更加简洁易懂。</p><h2>小结</h2><p>到现在为止，咱们高阶函数部分的内容就进入尾声了。让我们再来做一次总结：</p><ul>\n<li><strong>为什么引入高阶函数？</strong>答：为了简化。</li>\n<li><strong>高阶函数是什么？</strong>答：函数作为参数or返回值。</li>\n<li><strong>函数类型是什么？</strong>答：函数的类型。</li>\n<li><strong>函数引用是什么？</strong>答：类比变量的引用。</li>\n<li><strong>Lambda是什么？</strong>答：可以简单理解为“函数的简写”（官方定义我们以后再讨论）。</li>\n<li><strong>带接收者的函数类型是什么？</strong>答：可以简单理解为“成员函数的类型”。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/45/3e/45e23ce48a64711943366fec784af23e.jpg?wh=1920x1171" alt="图片"></p><p>事实上，对于初学者来说，要一下子理解并掌握Kotlin“高阶函数”不是一件容易的事情。在掌握好这节课内容的基础上，我们可以尝试去读一些优秀的代码。</p><p>比如Kotlin官方的源代码<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt</a>，你可以去分析其中的with、let、also、takeIf、repeat、apply，来进一步加深对高阶函数的理解。还有就是<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/common/src/generated/_Collections.kt">CollectionsKt</a>，你可以去分析其中的map、flatMap、fold、groupBy等操作符，从而对高阶函数的应用场景有一个更具体的认知。</p><p>另外，在<a href="https://time.geekbang.org/column/article/473349">第</a><a href="https://time.geekbang.org/column/article/473349">2讲</a>的时候，我们曾经提到过：理论上讲，Kotlin与Java是完全兼容的。那么问题来了，<strong>Kotlin引入全新的高阶函数，最终变成JVM字节码后是怎么执行呢？</strong>毕竟，JVM可不知道什么是高阶函数啊。</p><p>答案其实也很简单：<strong>匿名内部类</strong>。</p><p>而这样又引出了另一个问题：所以Kotlin弄了个这么高端的高阶函数，最终还是以匿名内部类的形式在运行呗？那它们两者的性能差不多？这不是多此一举吗？</p><p>答案当然是否定的，Kotlin高阶函数的性能，在极端情况下可以达到匿名内部类的100倍！具体是怎么回事儿呢？别着急，下节课讲“inline”时，我们就会来详细探讨。</p><h2>小作业</h2><p>请你去阅读一下Kotlin官方的标准函数库<a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">StandardKt的源代码</a>，尝试去解析其中任意一个高阶函数的原理和意义，并分享出来，我们一起探讨。</p><pre><code class="language-plain">public inline fun &lt;R&gt; run(block: () -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\npublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\npublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\npublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\npublic inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n\npublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\npublic inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\npublic inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\npublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n</code></pre><p>好了，这节课就到这里，如果觉得有收获，非常欢迎你把今天的内容分享给更多的朋友，咱们下节课再见。</p>',
        article_title: "07 | 高阶函数：为什么说函数是Kotlin的“一等公民”？",
      },
      {
        title: "08 | 实战：用Kotlin写一个英语词频统计程序",
        id: 477295,
        content:
          '<p>你好，我是朱涛。</p><p>前面几节课，我们学了一些Kotlin独有的特性，包括扩展、高阶函数等等。虽然我在前面的几节课当中都分别介绍了这些特性的实际应用场景，但那终归不够过瘾。因此，这节课我们来尝试将这些知识点串联起来，一起来写一个“单词词频统计程序”。</p><p>英语单词的频率统计，有很多实际应用场景，比如高考、研究生考试、雅思考试，都有对应的“高频词清单”，考生优先突破这些高频词，可以大大提升备考效率。那么这个高频词是如何统计出来的呢？当然是通过计算机统计出来的。只是，我们的操作系统并没有提供这样的程序，想要用这样的功能，我们必须自己动手写。</p><p>而这节课，我将带你用Kotlin写一个单词频率统计程序。为了让你更容易理解，我们的程序同样会分为三个版本。</p><ul>\n<li><strong>1.0 版本</strong>：实现频率统计基本功能，使用“命令式风格”的代码。</li>\n<li><strong>2.0 版本</strong>：利用扩展函数、高阶函数来优化代码，实现“函数式风格”的代码。</li>\n<li><strong>3.0 版本</strong>：使用inline进一步提升软件的性能，并分析高阶函数的实现原理，以及inline到底能带来多大的性能提升。</li>\n</ul><p>在正式开始学习之前，我也建议你去clone我GitHub上面的TextProcessor工程：<a href="https://github.com/chaxiu/TextProcessor.git">https://github.com/chaxiu/TextProcessor.git</a>，然后用IntelliJ打开，并切换到 <strong>start</strong> 分支跟着课程一步步敲代码。</p><!-- [[[read_end]]] --><h2>1.0版本：命令式风格</h2><p>在正式开始写代码之前，我们先看看程序运行之后是什么样的，一起来分析一下整体的编程思路：</p><p><img src="https://static001.geekbang.org/resource/image/57/66/5757bb50b199c4e3faafd8ba8791e866.gif?wh=2182x1362" alt="图片"></p><p>首先，我们的词频统计程序是一个类，“TextProcessorV1”，这是第一个版本的类名称。text是需要被统计的一段测试文本。</p><p>所以，我们很容易就能写出这样的代码结构：</p><pre><code class="language-plain">class TextProcessorV1 {\n    fun processText(text: String): List&lt;WordFreq&gt; {\n\n    }\n}\n\ndata class WordFreq(val word: String, val frequency: Int)\n</code></pre><p>这段代码中，我们定义了一个方法processText，它接收的参数类型是String，返回值类型是List。与此同时，我们还定义了一个数据类WordFreq，它里面有两个属性，分别是word和对应的频率frequency。</p><p>所以，这个程序最关键的逻辑都在 <strong>processText</strong> 这个方法当中。</p><p>接下来我们以一段简短的英语作为例子，看看整体的统计步骤是怎样的。我用一张图来表示：</p><p><img src="https://static001.geekbang.org/resource/image/95/0c/950672a2d7629a47b313aa77636afd0c.jpg?wh=900x1212" alt=""></p><p>上面的流程图一共分为4个步骤：</p><ul>\n<li>步骤1，<strong>文本清洗</strong>。正常的英语文本当中是会有很多标点符号的，比如“.”“！”，而标点符号是不需要被统计进来的。所以，在进行词频统计之前，我们还需要对文本数据进行清洗。这里的做法是将标点符号替换成空格。</li>\n<li>步骤2，<strong>文本分割</strong>。有了步骤1作为基础，我们的英语文本当中除了单词之外，就都是空格了。所以，为了分割出一个个单词，我们只需要以空格作为分隔符，对整个文本进行分割即可。在这个过程中，我们的文本数据就会变成一个个单词组成的列表，也就是<strong>List类型</strong>。</li>\n<li>步骤3，<strong>统计单词频率</strong>。在上个步骤中，我们已经得到了单词组成的List，但这个数据结构并不适合做频率统计。为了统计单词频率，我们要借助Map这个数据结构。我们可以通过遍历List的方式，将所有单词都统计一遍，并将“单词”与“频率”以成对的方式存储在Map当中。</li>\n<li>步骤4，<strong>词频排序</strong>。在步骤3中，我们得到的词频数据是无序的，但实际场景中，频率越高的单词越重要，因此我们希望高频词可以放在前面，低频词则放在后面。</li>\n</ul><p>经过以上分析，我们就能进一步完善processText()方法当中的结构了。</p><pre><code class="language-plain">class TextProcessorV1 {\n    fun processText(text: String): List&lt;WordFreq&gt; {\n        // 步骤1\n        val cleaned = clean(text)\n        // 步骤2\n        val words = cleaned.split(" ")\n        // 步骤3\n        val map = getWordCount(words)\n        // 步骤4\n        val list = sortByFrequency(map)\n\n        return list\n    }\n}\n</code></pre><p>其中，步骤2的逻辑很简单，我们直接使用Kotlin标准库提供的 <strong>split()</strong> 就可以实现空格分割。其余的几个步骤1、3、4，则是由单独的函数来实现。所以下面，我们就来分析下clean()、getWordCount()、sortByFrequency()这几个方法该如何实现。</p><h3>文本清洗</h3><p>首先，是文本清洗的方法clean()方法。</p><p>经过分析，现在我们知道针对一段文本数据，我们需要将其中的标点符号替换成空格：</p><pre><code class="language-plain">//                            标点            标点\n// 清洗前                       ↓              ↓\n"Kotlin is my favorite language. I love Kotlin!"\n\n//                            空格            空格\n// 清洗后                       ↓              ↓\n"Kotlin is my favorite language  I love Kotlin "\n</code></pre><p>那么对于这样的逻辑，我们很容易就能写出以下代码：</p><pre><code class="language-plain">fun clean(text: String): String {\n    return text.replace(".", " ")\n        .replace("!", " ")\n        .trim()\n}\n</code></pre><p>这样的代码对于前面这种简单文本是没问题的，但这样的方式存在几个明显的问题。</p><p>第一个问题是<strong>普适性差</strong>。在复杂的文本当中，标点符号的类型很多，比如“,”“?”等标点符号。为了应对这样的问题，我们不得不尝试去枚举所有的标点符号：</p><pre><code class="language-plain">fun clean(text: String): String {\n    return text.replace(".", " ")\n        .replace("!", " ")\n        .replace(",", " ")\n        .replace("?", " ")\n        .replace("\'", " ")\n        .replace("*", " ")\n        .replace("#", " ")\n        .replace("@", " ")\n        .trim()\n}\n</code></pre><p>那么随之而来的第二个问题，就是<strong>很容易出错</strong>，因为我们可能会遗漏枚举的标点符号。第三个问题则是<strong>性能差</strong>，随着枚举情况的增加，replace执行的次数也会增多。</p><p>因此这个时候，我们必须要换一种思路，<a href="https://time.geekbang.org/column/intro/100053301">正则表达式</a>就是一个不错的选择：</p><pre><code class="language-plain">fun clean(text: String): String {\n    return text.replace("[^A-Za-z]".toRegex(), " ")\n        .trim()\n}\n</code></pre><p>上面的正则表达式的含义就是，<strong>将所有不是英文字母的字符都统一替换成空格</strong>（为了不偏离主题，这里我们不去深究正则表达式的细节）。</p><p>这样，数据清洗的功能完成以后，我们就可以对文本进行切割了，这个步骤通过split()就能实现。在经过分割以后，我们就得到了单词的列表。接下来，我们就需要进行词频统计getWordCount()了。</p><h3>词频统计</h3><p>在getWordCount()这个方法当中，我们需要用到Map这个数据结构。如果你不了解这个数据结构也不必紧张，我制作了一张动图，描述getWordCount()的工作流程。</p><p><img src="https://static001.geekbang.org/resource/image/43/46/43598fd9f2d476f9ffa717dba38cd846.gif?wh=720x405" alt="图片"></p><p>看过上面的Gif动图以后，相信你对词频统计的实现流程已经心中有数了。其实它就是跟我们生活中做统计一样，遇到一个单词，就把这个单词的频率加一就行。只是我们生活中是用本子和笔来统计，而这里，我们用程序来做统计。</p><p>那么，根据这个流程，我们就可以写出以下这样的频率统计的代码了，这里面主要用了一个Map来存储单词和它对应频率：</p><pre><code class="language-plain">fun getWordCount(list: List&lt;String&gt;): Map&lt;String, Int&gt; {\n    val map = hashMapOf&lt;String, Int&gt;()\n\n    for (word in list) {\n        // ①\n        if (word == "") continue\n        val trim = word.trim()\n        // ②\n        val count = map.getOrDefault(trim, 0)\n        map[trim] = count + 1\n    }\n    return map\n}\n</code></pre><p>上面的代码一共有两处需要注意，我们一个个看：</p><ul>\n<li>注释①，当我们将标点符号替换成空格以后，两个连续的空格进行分割后会出现空字符""，这是脏数据，我们需要将其过滤掉。</li>\n<li>注释②，map.getOrDefault是Map提供的一个方法，如果当前map中没有对应的Key，则返回一个默认值。这里我们设置的默认值为0，方便后面的代码计数。</li>\n</ul><p>这样，通过Map这个数据结构，我们的词频统计就实现了。而因为Map是无序的，所以我们还需要对统计结果进行排序。</p><h3>词频排序</h3><p>那么到这里，我们就又要将无序的数据结构换成有序的。这里我们选择List，因为List是有序的集合。但由于List每次只能存储单个元素，为了同时存储“单词”与“频率”这两个数据，我们需要用上前面定义的<strong>数据类WordFreq</strong>：</p><pre><code class="language-plain">fun sortByFrequency(map: Map&lt;String, Int&gt;): MutableList&lt;WordFreq&gt; {\n    val list = mutableListOf&lt;WordFreq&gt;()\n    for (entry in map) {\n        if (entry.key == "") continue\n        val freq = WordFreq(entry.key, entry.value)\n        // ①\n        list.add(freq)\n    }\n\n    // ②\n    list.sortByDescending {\n        it.frequency\n    }\n    return list\n}\n</code></pre><p>这部分的排序代码其实思路很简单：</p><ul>\n<li>注释①处，我们将Map当中的词频数据，封装到WordFreq数据类当中，并且添加到了List当中，这样就将所有的信息都放到了一个有序的集合当中来了；</li>\n<li>注释②处，我们调用了Kotlin标准库提供的排序方法“sortByDescending”，它代表了以词频降序排序。</li>\n</ul><p>到这里，我们的1.0版本就算是完成了，按照惯例，我们可以写一个单元测试来看看代码运行结果是否符合预期。</p><p><img src="https://static001.geekbang.org/resource/image/a4/yy/a4d2e9c146517e984bf17a6dfbc403yy.gif?wh=2182x1362" alt="图片"></p><p>由于我们的测试文本很简单，我们一眼就能分析出正确的结果。其中单词“Kotlin”出现的频率最高，是2次，它会排在result的第一位。所以，我们可以通过断言来编写以上的测试代码。最终单元测试的结果，也显示我们的代码运行结果符合预期。</p><p>这时候，你也许会想：测试的文本数据太短了，<strong>如果数据量再大一些，程序是否还能正常运行呢？</strong></p><p>其实，我们可以让程序支持统计文件当中的单词词频，要实现这个功能也非常简单，就是利用我们在<a href="https://time.geekbang.org/column/article/475684">第6讲</a>学过的扩展方法：</p><pre><code class="language-plain">fun processFile(file: File): List&lt;WordFreq&gt; {\n    val text = file.readText(Charsets.UTF_8)\n    return processText(text)\n}\n</code></pre><p>从代码中我们可以看到，readText()就是Kotlin标准库里提供的一个扩展函数，它可以让我们非常方便地从文件里读取文本。增加这样一行代码，我们的程序就能够统计文件当中的单词频率了。</p><h2>2.0版本：函数式风格</h2><p>好，下面我们就一起来实现下第二个版本的词频统计程序。这里，我想先带你回过头来看看咱们1.0版本当中的代码：</p><pre><code class="language-plain">class TextProcessorV1 {\n    fun processText(text: String): List&lt;WordFreq&gt; {\n        val cleaned = clean(text)\n        val words = cleaned.split(" ")\n        val map = getWordCount(words)\n        val list = sortByFrequency(map)\n\n        return list\n    }\n}\n</code></pre><p>是不是觉得咱们的代码实在太整齐了？甚至整齐得有点怪怪的？而且，我们定义的临时变量cleaned、words、map、list都只会被用到一次。</p><p>其实上面的代码，就是很明显地在用Java思维写Kotlin代码。这种情况下，我们甚至可以省略掉中间所有的临时变量，将代码缩减成这样：</p><pre><code class="language-plain">fun processText(text: String): List&lt;WordFreq&gt; {\n    return sortByFrequency(getWordCount(clean(text).split(" ")))\n}\n</code></pre><p>不过，很明显的是，以上代码的可读性并不好。在<a href="https://time.geekbang.org/column/article/472129">开篇词</a>当中，我曾提到过，Kotlin既有<strong>命令式</strong>的一面，也有<strong>函数式</strong>的一面，它们有着各自擅长的领域。而在这里，我们就完全可以借助<a href="https://zh.wikipedia.org/zh/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>的思想来优化代码，就像下面这样：</p><pre><code class="language-plain">fun processText(text: String): List&lt;WordFreq&gt; {\n    return text\n        .clean()\n        .split(" ")\n        .getWordCount()\n        .sortByFrequency { WordFreq(it.key, it.value) }\n}\n</code></pre><p>可以发现，这段代码从上读到下，可读性非常高，它也非常接近我们说话的习惯：我们拿到参数text，接着对它进行清洗clean()，然后对单词频率进行统计，最后根据词频进行排序。</p><p>那么，我们要如何修改1.0版本的代码，才能实现这样的代码风格呢？<strong>问题的关键还是在于clean()、getWordCount()、sortByFrequency()这几个方法。</strong></p><p>我们一个个来分析。首先是text.clean()，为了让String能够直接调用clean()方法，我们必须将clean()定义成<strong>扩展函数</strong>：</p><pre><code class="language-plain">// 原函数\nfun clean(text: String): String {\n    return text.replace("[^A-Za-z]".toRegex(), " ")\n        .trim()\n}\n\n// 转换成扩展函数\nfun String.clean(): String {\n    return this.replace("[^A-Za-z]".toRegex(), " ")\n        .trim()\n}\n</code></pre><p>从上面的代码中，我们可以清晰地看到普通函数转换为扩展函数之间的差异：</p><ul>\n<li>原本的参数类型String，在转换成扩展函数后，就变成了“接收者类型”；</li>\n<li>原本的参数text，变成了扩展函数的this。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/d2/59/d27f98fe4234c10a14bd18c7770b8f59.gif?wh=720x405" alt="图片"></p><p>对应的，我们的getWordCount()方法也同样可以修改成扩展函数的形式。</p><pre><code class="language-plain">private fun List&lt;String&gt;.getWordCount(): Map&lt;String, Int&gt; {\n    val map = HashMap&lt;String, Int&gt;()\n    for (element in this) {\n        if (element == "") continue\n        val trim = element.trim()\n        val count = map.getOrDefault(trim, 0)\n        map[trim] = count + 1\n    }\n    return map\n}\n</code></pre><p>你能看到，原本是作为参数的List，现在同样变成了接收者类型，原本的参数list集合变成了this。</p><p>最后是sortByFrequency()，我们很容易就能写出类似下面的代码：</p><pre><code class="language-plain">private fun Map&lt;String, Int&gt;.sortByFrequency(): MutableList&lt;WordFreq&gt; {\n    val list = mutableListOf&lt;WordFreq&gt;()\n    for (entry in this) {\n        val freq = WordFreq(entry.key, entry.value)\n        list.add(freq)\n    }\n\n    list.sortByDescending {\n        it.frequency\n    }\n\n    return list\n}\n</code></pre><p>同样的步骤，将参数类型变成“接收者类型”，将参数变成this。不过，这里的做法并不符合函数式编程的习惯，因为这个方法明显包含两个功能：</p><ul>\n<li>功能1，将Map转换成List；</li>\n<li>功能2，使用sort对List进行排序。</li>\n</ul><p>因此针对这样的情况，我们应该再对这个方法进行拆分：</p><pre><code class="language-plain">private fun &lt;T&gt; Map&lt;String, Int&gt;.mapToList(transform: (Map.Entry&lt;String, Int&gt;) -&gt; T): MutableList&lt;T&gt; {\n    val list = mutableListOf&lt;T&gt;()\n    for (entry in this) {\n        val freq = transform(entry)\n        list.add(freq)\n    }\n    return list\n}\n</code></pre><p>在上面的代码当中，为了让Map到List的转换更加得灵活，我们引入了高阶函数，它的参数transform是函数类型的参数。那么相应的，我们的调用处代码也需要做出改变，也就是传入一个Lambda表达式：</p><pre><code class="language-plain">fun processText(text: String): List&lt;WordFreq&gt; {\n    return text\n        .clean()\n        .split(" ")\n        .getWordCount()\n        .mapToList { WordFreq(it.key, it.value) }\n        .sortedByDescending { it.frequency }\n}\n</code></pre><p>看着上面的代码，我们几乎可以像读普通的英语文本一般地阅读上面的代码：首先是对text进行清理；然后使用split以空格形式进行分割；接着计算出单词的频率，然后再将无序的Map转换成List；最后对List进行排序，排序的依据就是词频降序。</p><p>至此，我们的2.0版本就算完成了。让我们再次执行一次单元测试，看看我们的代码逻辑是否正确：</p><p><img src="https://static001.geekbang.org/resource/image/7c/y3/7cb66e38089f63b82a136316233a3yy3.gif?wh=2182x1362" alt="图片"></p><p>单元测试的结果告诉我们，代码运行结果符合预期。接下来，我们就可以进行3.0版本的开发工作了。</p><h2>3.0版本：inline优化</h2><p>在上一个版本当中，我们的mapToList被改造成了一个高阶函数。那到了这个版本，我们实际的代码量其实很少，只需要为mapToList这个高阶函数增加一个inline关键字即可。</p><pre><code class="language-plain">//  增加inline关键字\n//        ↓\nprivate inline fun &lt;T&gt; Map&lt;String, Int&gt;.mapToList(transform: (Map.Entry&lt;String, Int&gt;) -&gt; T): MutableList&lt;T&gt; {\n    val list = mutableListOf&lt;T&gt;()\n    for (entry in this) {\n        val freq = transform(entry)\n        list.add(freq)\n    }\n    return list\n}\n</code></pre><p>到这里，我们3.0版本的开发工作其实就完成了。</p><p>但是你要清楚，虽然我们只花几秒钟就能增加这个inline关键字，可我们这么做的原因却比较复杂。这涉及到 <strong>inline关键字的实现原理</strong>。</p><p>不过，在正式研究inline之前，我们要先来了解下高阶函数的实现原理。由于Kotlin兼容Java 1.6，因此JVM是不懂什么是高阶函数的，我们的高阶函数最终一定会被编译器转换成JVM能够理解的格式。</p><p>而又因为，我们的词频统计代码略微有些复杂，所以为了更好地研究高阶函数的原理，这里我们可以先写一个简单的高阶函数，然后看看它反编译后的代码长什么样。</p><pre><code class="language-plain">// HigherOrderExample.kt\n\nfun foo(block: () -&gt; Unit) {\n    block()\n}\n\nfun main() {\n    var i = 0\n    foo{\n        i++\n    }\n}\n</code></pre><p>以上代码经过反编译成Java后，会变成这样：</p><pre><code class="language-java">public final class HigherOrderExampleKt {\n   public static final void foo(Function0 block) {\n      block.invoke();\n   }\n\n   public static final void main() {\n      int i = 0\n      foo((Function0)(new Function0() {\n         public final void invoke() {\n            i++;\n         }\n      }));\n   }\n}\n</code></pre><p>可以看到，Kotlin高阶函数当中的函数类型参数，变成了Function0，而main()函数当中的高阶函数调用，也变成了“匿名内部类”的调用方式。那么，Function0又是个什么东西？</p><pre><code class="language-plain">public interface Function0&lt;out R&gt; : Function&lt;R&gt; {\n    public operator fun invoke(): R\n}\n</code></pre><p>Function0其实是Kotlin标准库当中定义的接口，它代表没有参数的函数类型。在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt">Functions.kt</a>这个文件当中，Kotlin一共定义了23个类似的接口，从Function0一直到Function22，分别代表了“无参数的函数类型”到“22个参数的函数类型”。</p><p>好，现在，我们已经知道Kotlin高阶函数是如何实现的了，接下来我们看看使用inline优化过的高阶函数会是什么样的：</p><pre><code class="language-plain">// HigherOrderInlineExample.kt\n/*\n多了一个关键字\n   ↓                                    */\ninline fun fooInline(block: () -&gt; Unit) {\n    block()\n}\n\nfun main() {\n    var i = 0\n    fooInline{\n        i++\n    }\n}\n</code></pre><p>和前面的例子唯一的不同点在于，我们在foo()函数的定义处增加了一个inline关键字，同时，为了区分，我们也改了一下函数的名称。这个时候，我们再来看看它反编译后的Java长什么样：</p><pre><code class="language-java">public final class HigherOrderInlineExampleKt {\n   // 没有变化\n   public static final void fooInline(Function0 block) {\n      block.invoke();\n   }\n\n   public static final void main() {\n      // 差别在这里\n      int i = 0;\n      int i = i + 1;\n   }\n}\n</code></pre><p>为了看得更加清晰，我们将有无inline的main()放到一起来对比下：</p><p><img src="https://static001.geekbang.org/resource/image/de/c8/de4c7c3ee9b93c60ca93ab4074db78c8.png?wh=1920x1080" alt="图片"></p><p>所以你能发现，<strong>inline的作用其实就是将inline函数当中的代码拷贝到调用处。</strong></p><p>而是否使用inline，main()函数会有以下两个区别：</p><ul>\n<li>在不使用inline的情况下，我们的main()方法当中，需要调用foo()这个函数，这里多了一次函数调用的开销。</li>\n<li>在不使用inline的情况下，调用foo()函数时，还创建了“Function0”的匿名内部类对象，这也是额外的开销。</li>\n</ul><p>为了验证这一猜测，我们可以使用<a href="https://github.com/openjdk/jmh">JMH</a>（Java Microbenchmark Harness）对这两组代码进行性能测试。JMH这个框架可以最大程度地排除外界因素的干扰（比如内存抖动、虚拟机预热），从而判断出我们这两组代码执行效率的差异。它的结果不一定非常精确，但足以说明一些问题。</p><p>不过，为了不偏离本节课的主题，在这里我们不去深究JMH的使用技巧，而是只以两组测试代码为例，来探究下inline到底能为我们带来多少性能上的提升：</p><pre><code class="language-plain">// 不用inline的高阶函数\nfun foo(block: () -&gt; Unit) { \n    block()\n}\n\n// 使用inline的高阶函数\ninline fun fooInline(block: () -&gt; Unit) { \n    block()\n}\n\n// 测试无inline的代码\n@Benchmark\nfun testNonInlined() {\n    var i = 0\n    foo {\n        i++\n    }\n\n}\n\n// 测试无inline的代码\n@Benchmark\nfun testInlined() {\n    var i = 0\n    fooInline {\n        i++\n    }\n}\n</code></pre><p>最终的测试结果如下，分数越高性能越好：</p><pre><code class="language-plain">Benchmark       Mode         Score       Error   Units\ntestInlined     thrpt   3272062.466 ± 67403.033  ops/ms\ntestNonInlined  thrpt    355450.945 ± 12647.220  ops/ms\n</code></pre><p>从上面的测试结果我们能看出来，是否使用inline，它们之间的效率几乎相差10倍。而这还仅仅只是最简单的情况，如果在一些复杂的代码场景下，多个高阶函数嵌套执行，它们之间的执行效率会相差上百倍。</p><p>为了模拟复杂的代码结构，我们可以简单地将这两个函数分别嵌套10个层级，然后看看它们之间的性能差异：</p><pre><code class="language-plain">// 模拟复杂的代码结构，这是错误示范，请不要在其他地方写这样的代码。\n\n@Benchmark\nfun testNonInlined() {\n    var i = 0\n    foo {\n        foo {\n            foo {\n                foo {\n                    foo {\n                        foo {\n                            foo {\n                                foo {\n                                    foo {\n                                        foo {\n                                            i++\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Benchmark\nfun testInlined() {\n    var i = 0\n    fooInline {\n        fooInline {\n            fooInline {\n                fooInline {\n                    fooInline {\n                        fooInline {\n                            fooInline {\n                                fooInline {\n                                    fooInline {\n                                        fooInline {\n                                            i++\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre><p><strong>注意：以上的代码仅仅只是为了做测试，请不要在其他地方写类似这样的代码。</strong></p><pre><code class="language-plain">Benchmark        Mode         Score       Error   Units\ntestInlined     thrpt   3266143.092 ± 85861.453  ops/ms\ntestNonInlined  thrpt     31404.262 ±   804.615  ops/ms\n</code></pre><p>从上面的性能测试数据我们可以看到，在嵌套了10个层级以后，我们testInlined的性能几乎没有什么变化；而当testNonInlined嵌套了10层以后，性能也比1层嵌套差了10倍。</p><p>在这种情况下，testInlined()与testNonInlined()之间的性能差异就达到了100倍，那么随着代码复杂度的进一步上升，它们之间的性能差异会更大。</p><p>我在下面这张Gif动图里展示了它们反编译成Java的代码：</p><p><img src="https://static001.geekbang.org/resource/image/f7/a1/f7b342a7ecf56c100ec6b2bb488yyaa1.gif?wh=480x253" alt=""></p><p>我们能看到，对于testNonInlined()，由于foo()嵌套了10层，它反编译后的代码也嵌套了10层函数调用，中间还伴随了10次匿名内部类的创建。而testInlined()则只有简单的两行代码，完全没有任何嵌套的痕迹。难怪它们之间的性能相差100倍！</p><h3>inline的局限性</h3><p>看到这，你也许会有这样的想法：<strong>既然inline这么神奇，那我们是不是可以将“词频统计程序”里的所有函数都用inline来修饰？</strong></p><p>答案当然是<strong>否定</strong>的。事实上，Kotlin官方只建议我们将inline用于<strong>修饰高阶函数</strong>。对于普通的Kotlin函数，如果我们用inline去修饰它，IntelliJ会对我们发出警告。而且，也不是所有高阶函数都可以用inline，它在使用上有一些局限性。</p><p>举个例子，如果我们在processText()的前面增加inline关键字，IntelliJ会提示一个警告：</p><p><img src="https://static001.geekbang.org/resource/image/ba/ff/ba3175a460470887c852cfd14778f0ff.png?wh=1624x672" alt="图片"></p><p>这个警告的意思是：“对于普通的函数，inline带来的性能提升并不显著，inline用在高阶函数上的时候，才会有显著的性能提升”。</p><p>另外，在processText()方法的内部，getWordCount()和mapToList()这两个方法还会报错：</p><p><img src="https://static001.geekbang.org/resource/image/31/4c/3113667bb87e2fe9929a704a0a14a24c.png?wh=1708x736" alt="图片"></p><p>出现这个报错的原因是：getWordCount()和mapToList()这两个函数是私有的，无法inline。为什么呢？</p><p>前面我们提到过：<strong>inline的作用其实就是将inline函数当中的代码拷贝到调用处。</strong>由于processText()是公开的，因此它会从外部被调用，这意味着它的代码会被拷贝到外部去执行，而getWordCount()和mapToList()这两个函数却无法在外部被访问。这就是导致编译器报错的原因。</p><p>所以，inline虽然可以为我们带来极大的性能提升，但我们不能滥用。在使用inline的时候，我们还需要时刻注意它的实现机制，有时候，稍有不慎就会引发问题。</p><p>除此之外，在第3讲中我们曾提到：Kotlin编译器一直在幕后帮忙做着翻译的好事，那它有没有可能“好心办坏事”？</p><p>这个问题，现在我们就能够回答了：<strong>Kotlin编译器是有可能好心办坏事的。如果我们不够了解Kotlin的底层细节，不够了解Kotlin的语法实现原理，我们就可能会用错某些Kotlin语法，比如inline，当我们用错这些语法后，Kotlin在背后做的这些好事，就可能变成一件坏事。</strong></p><h2>小结</h2><p>最后，让我们来做个简单的总结。</p><ul>\n<li>通过1.0版本的开发，我们初步实现了单词频率统计的功能，同时也使用了面向对象的思想，也使用了单元测试；</li>\n<li>在2.0版本的开发中，我们初步尝试了函数式编程的风格，在这个过程中，我们灵活运用了我们前面学习的扩展、高阶函数知识。</li>\n<li>在3.0版本中，我们使用inline优化了高阶函数。随后我们着重研究了高阶函数的原理，以及inline背后的细节。在这个过程中，我们发现inline可以为高阶函数带来超过100倍的性能提升，同时我们也了解到inline并不是万能的，它也存在一定的局限性。</li>\n</ul><p>经过这节课的实战演练之后，相信你一定感受到了Kotlin函数式风格的魅力。在日后不断地学习、实操中，我也希望，你可以把Kotlin函数式的代码应用到自己的开发工作当中，并且充分发挥出Kotlin简洁、优雅、可读性强的优势。</p><h2>思考题</h2><p>咱们的词频统计程序其实还有很多可以优化和提升的地方，请问你能想到哪些改进之处？欢迎你在评论区分享你的思路，我们下节课再见。</p>',
        article_title: "08 | 实战：用Kotlin写一个英语词频统计程序",
      },
      {
        title: "加餐一 | 初识Kotlin函数式编程",
        id: 478106,
        content:
          '<p>你好，我是朱涛。在上一节实战课当中，我们算是用Kotlin实践了一把函数式编程的思想。不过，上节课我们其实只是浅尝辄止，也不完全算是函数式编程，咱们只是借鉴了它的思想。</p><p>函数式编程（Functional Programming），是一个跟“<a href="https://time.geekbang.org/column/article/473349">面向对象</a>”类似的概念，它也是软件工程中的一种编程范式，它是声明式编程（Declarative Programming）的一种，而与它相反的，我们叫做命令式编程（Imperative Programming）。</p><p>虽然说，Kotlin的函数式编程还不属于主流，但近几年它的关注度也越来越高了，所以今天我们就借着这节加餐，一起来简单聊聊Kotlin的函数式编程，也为上一节实战课做一个延伸。这样，等将来你想深入研究Kotlin函数式编程的时候，有了这节课的认知基础，也会更加轻松。</p><h2>函数式与命令式的区别</h2><p>那么，在介绍函数式编程之前，我们首先要来看几个编程范式的概念：声明式、命令式，还有四个常见的编程范式：函数式、逻辑式、面向过程、面向对象。它们之间的关系大致如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/12/6a/12fe0504cd5329b2634a6b3746c0yy6a.jpg?wh=1920x1013" alt="图片"></p><p>我们的校园里学习编程的时候，一般都是学的C、Java，它们分别是面向过程语言、面向对象语言的代表，它们都属于“命令式”的范畴。</p><!-- [[[read_end]]] --><p>那么，想要理解“函数式”，我们首先就要理解什么是“命令式编程”，这是两种截然相反的编程范式。</p><p>所谓命令式编程，其实就是最常见的编程方式：<strong>在编程的时候，我们需要告诉计算机每一步具体都要干什么。</strong>比如说，我们要过滤集合当中所有的偶数，那么使用命令式编程的话，会需要以下几个步骤：</p><ul>\n<li>使用for循环遍历集合；</li>\n<li>在for循环当中，取出集合元素，并且判断它是否能够被2整除；</li>\n<li>对于能被2整除的元素，我们将它们添加到新的集合当中；</li>\n<li>最后，返回新的集合。</li>\n</ul><p>具体来说，命令式的代码是这样的：</p><pre><code class="language-plain">fun foo(): List&lt;Int&gt; {\n    val list = listOf(1, 2, 3, 4)\n    val result = mutableListOf&lt;Int&gt;()\n    for (i in list) {\n        if (i % 2 == 0) {\n            result.add(i)\n        }\n    }\n\n    return result\n}\n</code></pre><p>那么，如果是函数式，或者说“声明式”的代码呢？</p><pre><code class="language-plain">fun fp() = listOf(1, 2, 3, 4).filter { it % 2 == 0 }\n</code></pre><p>这段代码，我们是使用了Kotlin标准库当中的filter方法，它是一个高阶函数，作用就是过滤符合要求的集合元素并且返回。而具体的过滤要求呢，我们会在Lambda表达式里传进来。<br>\n由此我们也可以感受到，函数式风格的代码，它对比命令式的代码主要是有两个区别：</p><ul>\n<li>第一个区别是：它只需要声明我们想要什么，而不必关心底层如何实现。</li>\n<li>第二个区别是：代码更加简洁，可读性更高。</li>\n</ul><p>在上节课的实战案例当中，我们3.0版本的词频统计程序，其实并没有完全发挥出Kotlin函数式编程的优势，因为其中的“getWordCount()”“mapToList()”都是我们自己实现的。事实上，我们完全可以借助Kotlin标准库函数来实现。</p><pre><code class="language-plain">fun processText(text: String): List&lt;WordFreq&gt; {\n    return text\n        .clean()\n        .split(" ")\n        .filter { it != "" }\n        .groupBy { it }\n        .map { WordFreq(it.key, it.value.size) }\n        .sortedByDescending { it.frequency }\n}\n</code></pre><p>根据这段代码我们可以看到，借助Kotlin库函数，我们用简单的几行代码，就成功实现了单词频率统计功能。这就是函数式编程的魅力。</p><p>要知道，我们1.0版本命令式的代码，足足有五十多行代码！这中间的差距是非常大的。</p><h2>到底什么是函数式编程？</h2><p>那么，到底什么是函数式编程呢？函数式编程在数学理论上的定义很复杂，而对于我们初次接触Kotlin函数式编程来说，其实我们需要记住两个重点：</p><ul>\n<li>函数是一等公民；</li>\n<li>纯函数。</li>\n</ul><p>而以这两个点作为延伸，我们就可以扩展出很多函数式编程的其他概念。比如说，<strong>函数是一等公民</strong>，这就意味着：</p><ul>\n<li>函数可以独立于类之外，这就是Kotlin的<a href="https://time.geekbang.org/column/article/475684">顶层函数</a>；</li>\n<li>函数可以作为参数和返回值，这就是<a href="https://time.geekbang.org/column/article/476637">高阶函数和Lambda</a>；</li>\n<li>函数可以像变量一样，这就是函数的引用；</li>\n<li>当函数的功能更加强大以后，我们就可以几乎可以做到：只使用函数来解决所有编程的问题。</li>\n</ul><p>再比如，对于<strong>纯函数</strong>的理解，这就意味着：</p><ul>\n<li>函数不应该有副作用。所谓副作用，就是“对函数作用域以外的数据进行修改”，而这就引出了函数式的<strong>不变性</strong>。在函数式编程当中，我们不应该修改任何变量，当我们需要修改变量的时候，我们要创建一份新的拷贝再做修改，然后再使用它（这里，你是不是马上就想到了数据类的copy方法呢？）。</li>\n<li>无副作用的函数，它具有<strong>幂等性</strong>，换句话说就是：函数调用一次和调用N次，它们的效果是等价的。</li>\n<li>无副作用的函数，它具有<strong>引用透明</strong>的特性。</li>\n<li>无副作用的函数，它具有<strong>无状态</strong>的特性。</li>\n</ul><p>当然，函数式编程还有很多其他的特点，但是，在Kotlin当中，我们把握好“函数是一等公民”和“纯函数”这两个核心概念，就算初步理解了。</p><p>好，前面我们提到过，我们可以使用函数来解决所有编程问题，那么接下来，我们就来试试如何用函数来实现循环的功能吧。</p><h2>实战：函数式的循环</h2><p>for循环，是命令式编程当中最典型的语句。举个例子，我们想要计算从1到10的总和，使用for循环，我们很容易就可以写出这样的代码：</p><pre><code class="language-plain">fun loop(): Int {\n    var result = 0\n    for (i in 1..10) {\n        result += i\n    }\n\n    return result\n}\n</code></pre><p>上面的代码很简单，我们定义了一个result变量，然后在for循环当中，将每一个数字与其相加，最后返回result这个变量作为结果。这很明显就是在告诉计算机每一步应该做什么，这其实也是它叫做命令式风格的原因。</p><p>那么，如果不使用for循环，仅仅只使用函数，我们该如何实现这样的功能呢？答案其实很简单，那就是<strong>递归</strong>。</p><pre><code class="language-plain">fun recursionLoop(): Int {\n    fun go(i: Int, sum: Int): Int =\n        if (i &gt; 10) sum else go(i + 1, sum + i)\n\n    return go(1, 0)\n}\n</code></pre><p>从这段代码当中，我们可以看到，在recursionLoop()这个函数当中，我们定义了一个内部的函数go()，它才是我们实现递归的核心函数。</p><p>在函数式编程当中，请不要觉得这种代码很奇怪，<strong>毕竟咱们函数都是一等公民了，类的内部可以继续嵌套内部类，那函数里面为什么就不可以嵌套一个内部的函数呢？</strong></p><p>实际上，在函数式编程当中，我们有时候也会<strong>使用递归来替代循环</strong>。我们知道，递归都是有调用栈开销的，所以我们应该尽量使用<a href="https://zh.wikipedia.org/wiki/%25E5%25B0%25BE%25E8%25B0%2583%25E7%2594%25A8#%25E5%25B0%25BE%25E9%2580%2592%25E5%25BD%2592">尾递归</a>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是O(1)。</p><pre><code class="language-plain">fun recursionLoop(): Int {\n// 变化在这里\n//     ↓\n    tailrec fun go(i: Int, sum: Int): Int =\n        if (i &gt; 10) sum else go(i + 1, sum + i)\n\n    return go(1, 0)\n}\n</code></pre><p>当然，上面的递归思路只是为了说明我们可以用它替代循环。在实际的开发工作中，这种方式是不推荐的，毕竟它太绕了，对吧？如果要在工作中实现类似的需求，我们使用Kotlin集合操作符一行代码就能搞定：</p><pre><code class="language-plain">fun reduce() = (1..10).reduce { acc, i -&gt; acc + i } // 结果 55\n</code></pre><p>这里的reduce操作符也许你会觉得难以理解，没关系，Kotlin还为我们提供了另一个更简单的操作符，也就是sum：</p><pre><code class="language-plain">fun sum() = (1..10).sum() // 结果 55\n</code></pre><p>在这里，我们也能发现一些问题：<strong>使用Kotlin，我们运用不同的思维，可以写出截然不同的4种代码</strong>。而即使同样都是函数式的思想的3种代码，它们之间的可读性也有很大的差异。</p><p>Kotlin官方一直宣扬自己是支持多种编程范式的语言，它不像某些语言，会强制你使用某种编程范式（比如C、Haskell等）。这样一来，面对不同的问题，我们开发者就可以灵活选择不同的范式进行编程。</p><p>而且，Kotlin也没有完全拥抱函数式编程，它只是在一些语法设计上，借鉴了函数式编程的思想，而且这种借鉴的行为也十分克制，比如<a href="https://zh.wikipedia.org/zh-hans/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B1%BB">类型类</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)">单子</a>。另外，函数式编程领域的很多高级概念，Kotlin也都没有天然支持，需要我们开发者自己去实现。对比起其他JVM的现代语言（如<a href="https://zh.wikipedia.org/wiki/Scala">Scala</a>），<strong>Kotlin也显得更加务实，有点“博采众长”的意味</strong>。</p><h2>小结</h2><p>Kotlin作为一门刚出生不久的语言，它融合了很多现代化语言的特性，它在支持命令式编程的同时呢，也对“函数式编程”有着天然的亲和力。</p><p>命令式编程与函数式编程，它们之间本来就各有优劣。</p><p>函数式编程的优点在于，在部分场景下，它的开发效率高、可读性强，以及由于不变性、无状态等特点，更适合并发编程。而函数式编程的劣势也很明显，它的学习曲线十分陡峭、反直觉，由于自身特性的限制，往往会导致性能更差。所以，Kotlin函数式编程目前仍未成为主流，这是有一定道理的。</p><p>不过，随着2021年Android推出Jetpack Compose声明式UI框架，以及Kotlin官方推出的Compose Multiplatform以后，Kotlin函数式编程的关注度也被推向了一个前所未有的高度。总的来说，Kotlin函数式编程是一个非常大的话题，它自身就足够写一个完整的专栏了。如果有机会的话，我们在课程后面，还会再来详细聊聊Kotlin函数式编程在Compose当中的体现。</p><p>我相信，在不久的将来，Kotlin函数式编程的方式，一定会被更多的人认可和接受。</p><h2>思考题</h2><p>今天，咱们从“编程范式”聊到了Kotlin函数式编程，也请你说说你对“编程范式”以及“函数式编程”的理解吧。这个问题没有标准答案，请畅所欲言吧！</p>',
        article_title: "加餐一 | 初识Kotlin函数式编程",
      },
      {
        title: "09 | 委托：你为何总是被低估？",
        id: 479112,
        content:
          '<p>你好，我是朱涛。今天我们来学习Kotlin的委托特性。</p><p>Kotlin的委托主要有两个应用场景，一个是委托类，另一个是委托属性。对比第6讲我们学过的<a href="https://time.geekbang.org/column/article/475684">扩展</a>来看的话，Kotlin委托这个特性就没有那么“神奇”了。</p><p>因为扩展可以从类的外部，为一个类“添加”成员方法和属性，因此Kotlin扩展的应用场景也十分明确，而Kotlin委托的应用场景就没那么清晰了。这也是很多人会“重视扩展”，而“轻视委托”的原因。</p><p>然而，我要告诉你的是，<strong>Kotlin“委托”的重要性一点也不比“扩展”低</strong>。Kotlin委托在软件架构中可以发挥巨大的作用，在掌握了Kotlin委托特性后，你不仅可以改善应用的架构，还可以大大提升开发效率。</p><p>另外，如果你是Android工程师，你会发现Jetpack Compose当中大量使用了Kotlin委托特性。可以说，如果你不理解委托，你就无法真正理解Jetpack Compose。</p><p>看到这里，想必你也已经知道Kotlin委托的重要性了，接下来就来开启我们的学习之旅吧！</p><h2>委托类</h2><p>我们先从委托类开始，它的使用场景非常简单易懂：它常常用于实现类的“委托模式”。我们来看个简单例子：</p><pre><code class="language-plain">interface DB {\n    fun save()\n}\n\nclass SqlDB() : DB {\n    override fun save() { println("save to sql") }\n}\n\nclass GreenDaoDB() : DB {\n    override fun save() { println("save to GreenDao") }\n}\n//               参数  通过 by 将接口实现委托给 db \n//                ↓            ↓\nclass UniversalDB(db: DB) : DB by db\n\nfun main() {\n    UniversalDB(SqlDB()).save()\n    UniversalDB(GreenDaoDB()).save()\n}\n\n/*\n输出：\nsave to sql\nsave to GreenDao\n*/\n</code></pre><!-- [[[read_end]]] --><p>以上的代码当中，我们定义了一个DB接口，它的save()方法用于数据库存储，SqlDB和GreenDaoDB都实现了这个接口。接着，我们的UniversalDB也实现了这个接口，同时通过by这个关键字，将接口的实现委托给了它的参数db。</p><p>这种委托模式在我们的实际编程中十分常见，UniversalDB相当于一个壳，它虽然实现了DB这个接口，但并不关心它怎么实现。具体是用SQL还是GreenDao，传不同的委托对象进去，它就会有不同的行为。</p><p>另外，以上委托类的写法，等价于以下Java代码，我们可以再进一步来看下：</p><pre><code class="language-java">class UniversalDB implements DB {\n    DB db;\n    public UniversalDB(DB db) { this.db = db; }\n             //  手动重写接口，将 save 委托给 db.save()\n    @Override//            ↓\n    public void save() { db.save(); }\n}\n</code></pre><p>以上代码显示，save()将执行流程委托给了传入的db对象。所以说，Kotlin的委托类提供了<strong>语法层面的委托模式</strong>。通过这个by关键字，就可以自动将接口里的方法委托给一个对象，从而可以帮我们省略很多接口方法适配的模板代码。</p><p>委托类很好理解，下面让我们重点来看看Kotlin的委托属性。</p><h2>委托属性</h2><p>正如我们前面所讲的，<strong>Kotlin“委托类”委托的是接口方法，而“委托属性”委托的，则是属性的getter、setter。</strong>在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>中，我们知道val定义的属性，它只有get()方法；而var定义的属性，既有get()方法，也有set()方法。</p><p>那么，属性的getter、setter委托出去以后，能有什么用呢？我们可以从Kotlin官方提供的标准委托那里找到答案。</p><h3>标准委托</h3><p>Kotlin提供了好几种标准委托，其中包括两个属性之间的直接委托、by lazy懒加载委托、Delegates.observable观察者委托，以及by map映射委托。前面两个的使用频率比较高，后面两个频率比较低。这里，我们就主要来了解下前两种委托属性。</p><p><strong>将属性A委托给属性B</strong></p><p>从Kotlin 1.4 开始，我们可以直接在语法层面将“属性A”委托给“属性B”，就像下面这样：</p><pre><code class="language-plain">class Item {\n    var count: Int = 0\n    //              ①  ②\n    //              ↓   ↓\n    var total: Int by ::count\n}\n</code></pre><p>以上代码定义了两个变量，count和total，其中total的值与count完全一致，因为我们把total这个属性的getter和setter都委托给了count。</p><p>注意，代码中的两处注释是关键：注释①，代表total属性的getter、setter会被委托出去；注释②，::count，代表total被委托给了count。这里的“::count”是<strong>属性的引用</strong>，它跟我们前面学过的<a href="https://time.geekbang.org/column/article/476637">函数引用</a>是一样的概念。</p><p>total和count两者之间的委托关系一旦建立，就代表了它们两者的getter和setter会完全绑定在一起，如果要用代码来解释它们背后的逻辑，它们之间的关系会是这样：</p><pre><code class="language-plain">// 近似逻辑，实际上，底层会生成一个Item$total$2类型的delegate来实现\n\nclass Item {\n    var count: Int = 0\n\n    var total: Int\n        get() = count\n\n        set(value: Int) {\n            count = value\n        }\n}\n</code></pre><p>也就是，当total的get()方法被调用时，它会直接返回count的值，也就意味着会调用count的get()方法；而当total的set()方法被调用时，它会将value传递给count，也就意味着会调用count的set()方法。</p><p>也许你会好奇：Kotlin 1.4提供的这个特性有啥用？为什么要分别定义count和total？我们直接用count不好吗？</p><p>这个特性，其实对我们<strong>软件版本之间的兼容</strong>很有帮助。假设Item是服务端接口的返回数据，1.0版本的时候，我们的Item当中只count这一个变量：</p><pre><code class="language-plain">// 1.0 版本\nclass Item {\n    var count: Int = 0\n}\n</code></pre><p>而到了2.0版本的时候，我们需要将count修改成total，这时候问题就出现了，如果我们直接将count修改成total，我们的老用户就无法正常使用了。但如果我们借助委托，就可以很方便地实现这种兼容。我们可以定义一个新的变量total，然后将其委托给count，这样的话，2.0的用户访问total，而1.0的用户访问原来的count，由于它们是委托关系，也不必担心数值不一致的问题。</p><p>好了，除了属性之间的直接委托以外，还有一种委托是我们经常会用到的，那就是懒加载委托。</p><p><strong>懒加载委托</strong></p><p>懒加载，顾名思义，就是对于一些需要消耗计算机资源的操作，我们希望它在被访问的时候才去触发，从而避免不必要的资源开销。前面<a href="https://time.geekbang.org/column/article/475058">第5讲</a>学习单例的时候，我们就用到了by lazy的懒加载。其实，这也是软件设计里十分常见的模式，我们来看一个例子：</p><pre><code class="language-plain">//            定义懒加载委托\n//               ↓   ↓\nval data: String by lazy {\n    request()\n}\n\nfun request(): String {\n    println("执行网络请求")\n    return "网络数据"\n}\n\nfun main() {\n    println("开始")\n    println(data)\n    println(data)\n}\n\n结果：\n开始\n执行网络请求\n网络数据\n网络数据\n</code></pre><p>通过“<strong>by lazy{}</strong>”，我们就可以实现属性的懒加载了。这样，通过上面的执行结果我们会发现：main()函数的第一行代码，由于没有用到data，所以request()函数也不会被调用。到了第二行代码，我们要用到data的时候，request()才会被触发执行。到了第三行代码，由于前面我们已经知道了data的值，因此也不必重复计算，直接返回结果即可。</p><p>并且，如果你去看懒加载委托的源代码，你会发现，它其实是一个<strong>高阶函数</strong>：</p><pre><code class="language-plain">public actual fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)\n\n\npublic actual fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =\n    when (mode) {\n        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)\n        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)\n        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)\n    }\n</code></pre><p>可以看到，lazy()函数可以接收一个LazyThreadSafetyMode类型的参数，如果我们不传这个参数，它就会直接使用SynchronizedLazyImpl的方式。而且通过它的名字我们也能猜出来，它是为了多线程同步的。而剩下的SafePublicationLazyImpl、UnsafeLazyImpl，则不是多线程安全的。</p><p>好了，除了这两种标准委托以外，Kotlin也还提供了<a href="https://kotlinlang.org/docs/delegated-properties.html#observable-properties">Delegates.observable观察者委托</a>、<a href="https://kotlinlang.org/docs/delegated-properties.html#storing-properties-in-a-map">by map映射委托</a>，这两种委托比较简单，你可以点击这里给出的链接去了解它们的定义与用法。</p><h3>自定义委托</h3><p>在学完Kotlin的标准委托以后，你也许会好奇：<strong>是否可以根据需求实现自己的属性委托呢？</strong>答案当然是可以的。</p><p>不过，为了自定义委托，我们必须遵循Kotlin制定的规则。</p><pre><code class="language-plain">class StringDelegate(private var s: String = "Hello") {\n//     ①                           ②                              ③\n//     ↓                            ↓                               ↓\n    operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): String {\n        return s\n    }\n//      ①                          ②                                     ③ \n//      ↓                           ↓                                      ↓\n    operator fun setValue(thisRef: Owner, property: KProperty&lt;*&gt;, value: String) {\n            s = value\n    }\n}\n\n//      ②\n//      ↓\nclass Owner {\n//               ③\n//               ↓     \n    var text: String by StringDelegate()\n}\n</code></pre><p>以上代码一共有三套注释，我分别标注了①、②、③，其中注释①有两处，注释②有三处，注释③也有三处，相同注释标注出来的地方，它们之间存在密切的关联。</p><p>首先，看到两处注释①对应的代码，对于var修饰的属性，我们必须要有getValue、setValue这两个方法，同时，这两个方法必须有 <strong>operator</strong> 关键字修饰。</p><p>其次，看到三处注释②对应的代码，我们的text属性是处于Owner这个类当中的，因此getValue、setValue这两个方法中的thisRef的类型，必须要是Owner，或者是Owner的父类。也就是说，我们将thisRef的类型改为 <strong>Any</strong> 也是可以的。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将thisRef的类型定义为“Any?”。</p><p>最后，看到三处注释③对应的代码，由于我们的text属性是String类型的，为了实现对它的委托，getValue的返回值类型，以及setValue的参数类型，都必须是 <strong>String类型或者是它的父类</strong>。大部分情况下，这三处的类型都应该是一致的。</p><p>不过上面这段代码看起来还挺吓人的，刚开始的时候你也许会不太适应。但没关系，<strong>你只需要把它当作一个固定格式就行了</strong>。你在自定义委托的时候，只需要关心3个注释标注出来的地方即可。</p><p>而如果你觉得这样的写法实在很繁琐，也可以借助Kotlin提供的ReadWriteProperty、ReadOnlyProperty这两个接口，来自定义委托。</p><pre><code class="language-plain">public fun interface ReadOnlyProperty&lt;in T, out V&gt; {\n    public operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V\n}\n\npublic interface ReadWriteProperty&lt;in T, V&gt; : ReadOnlyProperty&lt;T, V&gt; {\n    public override operator fun getValue(thisRef: T, property: KProperty&lt;*&gt;): V\n\n    public operator fun setValue(thisRef: T, property: KProperty&lt;*&gt;, value: V)\n}\n</code></pre><p>如果我们需要为val属性定义委托，我们就去实现ReadOnlyProperty这个接口；如果我们需要为var属性定义委托，我们就去实现ReadWriteProperty这个接口。这样做的好处是，通过实现接口的方式，IntelliJ可以帮我们自动生成override的getValue、setValue方法。</p><p>以前面的代码为例，我们的StringDelegate，也可以通过实现ReadWriteProperty接口来编写：</p><pre><code class="language-plain">class StringDelegate(private var s: String = "Hello"): ReadWriteProperty&lt;Owner, String&gt; {\n    override operator fun getValue(thisRef: Owner, property: KProperty&lt;*&gt;): String {\n        return s\n    }\n    override operator fun setValue(thisRef: Owner, property: KProperty&lt;*&gt;, value: String) {\n        s = value\n    }\n}\n</code></pre><h3>提供委托（provideDelegate）</h3><p>接着前面的例子，假设我们现在有一个这样的需求：我们希望StringDelegate(s: String)传入的初始值s，可以根据委托属性的名字的变化而变化。我们应该怎么做？</p><p>实际上，要想在属性委托之前再做一些额外的判断工作，我们可以使用<strong>provideDelegate</strong>来实现。</p><p>看看下面的SmartDelegator你就会明白：</p><pre><code class="language-plain">class SmartDelegator {\n\n    operator fun provideDelegate(\n        thisRef: Owner,\n        prop: KProperty&lt;*&gt;\n    ): ReadWriteProperty&lt;Owner, String&gt; {\n\n        return if (prop.name.contains("log")) {\n            StringDelegate("log")\n        } else {\n            StringDelegate("normal")\n        }\n    }\n}\n\nclass Owner {\n    var normalText: String by SmartDelegator()\n    var logText: String by SmartDelegator()\n}\n\nfun main() {\n    val owner = Owner()\n    println(owner.normalText)\n    println(owner.logText)\n}\n\n结果：\nnormal\nlog\n</code></pre><p>可以看到，为了在委托属性的同时进行一些额外的逻辑判断，我们使用创建了一个新的SmartDelegator，通过它的成员方法provideDelegate嵌套了一层，在这个方法当中，我们进行了一些逻辑判断，然后再把属性委托给StringDelegate。</p><p>如此一来，通过provideDelegate这样的方式，我们不仅可以嵌套Delegator，还可以根据不同的逻辑派发不同的Delegator。</p><h2>实战与思考</h2><p>至此，我们就算是完成了Kotlin委托的学习，包括委托类、委托属性，还有4种标准委托模式。除了这些之外，我们还学习了如何自定义委托属性，其中包括我们自己实现getValue、setValue两个方法，还有通过实现ReadOnlyProperty、ReadWriteProperty这两个接口。而对于更复杂的委托逻辑，我们还需要采用provideDelegate的方式，来嵌套Delegator。</p><p>这里，为了让你对Kotlin委托的应用场景有一个更清晰的认识，我再带你一起来看看几个Android的代码案例。</p><h3>案例1：属性可见性封装</h3><p>在软件设计当中，我们会遇到这样的需求：对于某个成员变量data，我们希望类的外部可以访问它的值，但不允许类的外部修改它的值。因此我们经常会写出类似这样的代码：</p><pre><code class="language-plain">class Model {\n    var data: String = ""\n        // ①\n        private set\n\n    private fun load() {\n        // 网络请求\n        data = "请求结果"\n    }\n}\n</code></pre><p>请留意代码注释①处，我们将data属性的set方法声明为private的，这时候，data属性的set方法只能从类的内部访问，这就意味着类的外部无法修改data的值了，但类的外部仍然可以访问data的值。</p><p>这样的代码模式很常见，我们在Java/C当中也经常使用，不过当我们的data类型从String变成集合以后，问题就不一样了。</p><pre><code class="language-plain">class Model {\n    val data: MutableList&lt;String&gt; = mutableListOf()\n\n    private fun load() {\n        // 网络请求\n        data.add("Hello")\n    }\n}\n\nfun main() {\n    val model = Model()\n    // 类的外部仍然可以修改data\n    model.data.add("World")\n}\n</code></pre><p>对于集合而言，即使我们将其定义为只读变量val，类的外部一旦获取到data的实例，它仍然可以调用集合的add()方法修改它的值。这个问题在Java当中几乎没有优雅的解法。只要你暴露了集合的实例给外部，外部就可以随意修改集合的值。这往往也是Bug的来源，这样的Bug还非常难排查。</p><p>而在这个场景下，我们前面学习的“两个属性之间的委托”这个语法，就可以派上用场了。</p><pre><code class="language-plain">class Model {\n    val data: List&lt;String&gt; by ::_data\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add("Hello")\n    }\n}\n</code></pre><p>在上面的代码中，我们定义了两个变量，一个变量是公开的“data”，它的类型是List，这是Kotlin当中不可修改的List，它是没有add、remove等方法的。</p><p>接着，我们通过委托语法，将data的getter委托给了_data这个属性。而_data这个属性的类型是MutableList，这是Kotlin当中的可变集合，它是有add、remove方法的。由于它是private修饰的，类的外部无法直接访问，通过这种方式，我们就成功地将修改权保留在了类的内部，而类的外部访问是不可变的List，因此类的外部只能访问数据。</p><h3>案例2：数据与View的绑定</h3><p>在Android当中，如果我们要对“数据”与“View”进行绑定，我们可以用DataBinding，不过DataBinding太重了，也会影响编译速度。其实，除了DataBinding以外，我们还可以借助Kotlin的自定义委托属性来实现类似的功能。这种方式不一定完美，但也是一个有趣的思路。</p><p>这里我们以TextView为例：</p><pre><code class="language-plain">operator fun TextView.provideDelegate(value: Any?, property: KProperty&lt;*&gt;) = object : ReadWriteProperty&lt;Any?, String?&gt; {\n    override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String? = text\n    override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String?) {\n        text = value\n    }\n}\n</code></pre><p>以上的代码，我们为TextView定义了一个扩展函数TextView.provideDelegate，而这个扩展函数的返回值类型是ReadWriteProperty。通过这样的方式，我们的TextView就相当于支持了String属性的委托了。</p><p>它的使用方式也很简单：</p><pre><code class="language-plain">val textView = findViewById&lt;textView&gt;(R.id.textView)\n\n// ①\nvar message: String? by textView\n\n// ②\ntextView.text = "Hello"\nprintln(message)\n\n// ③\nmessage = "World"\nprintln(textView.text)\n\n\n结果：\nHello\nWorld\n</code></pre><p>在注释①处的代码，我们通过委托的方式，将message委托给了textView。这意味着，message的getter和setter都将与TextView关联到一起。</p><p>在注释②处，我们修改了textView的text属性，由于我们的message也委托给了textView，因此这时候，println(message)的结果也会变成“Hello”。</p><p>在注释③处，我们改为修改message的值，由于message的setter也委托给了textView，因此这时候，println(textView.text)的结果会跟着变成“World”。</p><h3>案例3：ViewModel委托</h3><p>在Android当中，我们会经常用到ViewModel来存储界面数据。同时，我们不会直接创建ViewModel的实例，而对应的，我们会使用委托的方式来实现。</p><pre><code class="language-plain">// MainActivity.kt\n\nprivate val mainViewModel: MainViewModel by viewModels()\n</code></pre><p>这一行代码虽然看起来很简单，但它背后隐藏了ViewModel复杂的实现原理。为了不偏离本节课的主题，我们先抛开ViewModel的实现原理不谈。在这里，我们专注于研究ViewModel的委托是如何实现的。</p><p>我们先来看看viewModels()是如何实现的：</p><pre><code class="language-plain">public inline fun &lt;reified VM : ViewModel&gt; ComponentActivity.viewModels(\n    noinline factoryProducer: (() -&gt; Factory)? = null\n): Lazy&lt;VM&gt; {\n    val factoryPromise = factoryProducer ?: {\n        defaultViewModelProviderFactory\n    }\n\n    return ViewModelLazy(VM::class, { viewModelStore }, factoryPromise)\n}\n\npublic interface Lazy&lt;out T&gt; {\n\n    public val value: T\n\n    public fun isInitialized(): Boolean\n}\n</code></pre><p>原来，viewModels()是Activity的一个<strong>扩展函数</strong>。也是因为这个原因，我们才可以直接在Activity当中直接调用viewModels()这个方法。</p><p>另外，我们注意到，viewModels()这个方法的返回值类型是Lazy，那么，它是如何实现委托功能的呢？</p><pre><code class="language-plain">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value\n</code></pre><p>实际上，Lazy类在<strong>外部</strong>还定义了一个扩展函数getValue()，这样，我们的只读属性的委托就实现了。而Android官方这样的代码设计，就再一次体现了<strong>职责划分、关注点分离</strong>的原则。Lazy类只包含核心的成员，其他附属功能，以扩展的形式在Lazy外部提供。</p><h2>小结</h2><p>最后，让我们来做一个总结吧。</p><ul>\n<li>委托类，委托的是<strong>接口的方法</strong>，它在语法层面支持了“委托模式”。</li>\n<li>委托属性，委托的是<strong>属性的getter、setter</strong>。虽然它的核心理念很简单，但我们借助这个特性可以设计出非常复杂的代码。</li>\n<li>另外，Kotlin官方还提供了几种标准的属性委托，它们分别是：两个属性之间的直接委托、by lazy懒加载委托、Delegates.observable观察者委托，以及by map映射委托；</li>\n<li>两个属性之间的直接委托，它是Kotlin 1.4提供的新特性，它在<strong>属性版本更新、可变性封装</strong>上，有着很大的用处；</li>\n<li>by lazy懒加载委托，可以让我们灵活地使用<strong>懒加载</strong>，它一共有三种线程同步模式，默认情况下，它就是线程安全的；Android当中的viewModels()这个扩展函数在它的内部实现的懒加载委托，从而实现了功能强大的ViewModel；</li>\n<li>除了标准委托以外，Kotlin可以让我们开发者<strong>自定义委托</strong>。自定义委托，我们需要<strong>遵循Kotlin提供的一套语法规范</strong>，只要符合这套语法规范，就没问题；</li>\n<li>在自定义委托的时候，如果我们有灵活的需求时，可以使用<strong>provideDelegate</strong>来动态调整委托逻辑。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/bd/2c/bd5668ecfb84e324f6239e7f24ddcf2c.jpg?wh=2000x1160" alt=""></p><p>看到这里，相信你也发现了，Kotlin当中看起来毫不起眼的委托，实际上它的功能是极其强大的，甚至可以说它比起<strong>扩展</strong>毫不逊色。其实，只是因为Kotlin的委托语法要比扩展更难一些，所以它的价值才更难被挖掘出来，进而也就容易被开发者所低估。</p><p>希望这节课的内容可以对你有所启发，也希望你可以将Kotlin强大的委托语法，应用到自己的工作当中去。</p><h2>思考题</h2><p>这节课我们学习了Kotlin的委托语法，也研究了几个委托语法的使用场景，请问你还能想到哪些Kotlin委托的使用场景呢？欢迎在评论区分享你的思路，我们下节课再见。</p>',
        article_title: "09 | 委托：你为何总是被低估？",
      },
      {
        title: "10 | 泛型：逆变or协变，傻傻分不清？",
        id: 480022,
        content:
          '<p>你好，我是朱涛。这节课我们来学习Kotlin的泛型（Generics），包括泛型基础、使用处型变、声明处型变以及星投影。</p><p>泛型，这个概念在很多编程语言里面都存在。在中大型软件开发当中，我们对泛型的使用也十分频繁，因为它可以让我们<strong>在不同类型之间复用相似的逻辑代码</strong>。</p><p>不管是Android领域，还是后端领域，泛型在软件的架构当中都有着举足轻重的地位。只有透彻理解了泛型，我们才能理解各种设计模式，进而才可能设计出合理的软件架构。</p><p>然而，想要学好泛型却不是一件容易的事情。这是因为，泛型实在太抽象了。</p><p>我们都知道，程序其实是对真实世界的抽象，比如我们在前面实战课里写的计算器程序，现实生活当中就有计算器这个东西，我们想要在电脑里写一个抽象的计算器程序，也不会那么难理解，因为它和现实生活相关。可是泛型，它是<strong>对程序的抽象</strong>。程序本来就已经够抽象了，我们还要在它的基础上再做一次抽象。</p><p>这样一来，泛型和我们真实的物理世界差了两层抽象，因此，泛型对于我们人类来说，会显得尤为虚无缥缈。</p><p><img src="https://static001.geekbang.org/resource/image/14/d0/14f371f5352321cb32d085d7ab25dbd0.jpg?wh=2000x797" alt=""></p><p>不过，程序其实也是源自于生活的。所以在这节课里，我会尽量用生活中的例子来给你解释下Kotlin的泛型概念，让你能更直观、更立体地感知到泛型与现实生活的联系，然后，你也能够从这些生活的场景中，更深刻地理解并掌握Kotlin的泛型，从而为你将来构建大型软件打好基础。</p><!-- [[[read_end]]] --><p>好，那么下面，我们就拿“遥控器”这个生活中常见的物件儿，来聊聊它跟“泛型”之间，都能产生哪些联系。</p><h2>掌握泛型基础</h2><p>在现实生活中，我们能看到各式各样的电视机遥控器，比如小米就有1S、2S、3S、4S电视遥控器。</p><p>那么，如果我们将遥控器的概念迁移到程序的世界，我们就需要定义各种各样的“遥控器类”，比如说：</p><pre><code class="language-plain">// 小米1S电视机遥控\nclass TvMi1SController {\n    fun turnOn() {}\n    fun turnOff() {}\n}\n\n// 小米2S电视机遥控\nclass TvMi2SController {\n    fun turnOn() {}\n    fun turnOff() {}\n}\n\n// 小米3S电视机遥控\nclass TvMi3SController {\n    fun turnOn() {}\n    fun turnOff() {}\n}\n\n// 小米4S电视机遥控\nclass TvMi4SController {\n    fun turnOn() {}\n    fun turnOff() {}\n}\n\n...\n省略几千种不同的遥控器\n</code></pre><p>从上面的代码我们可以看到，如果我们为每一个型号的电视机都创建一个对应的遥控器类，然后在里面重复编写“开机”“关机”的方法，我们的工作量会很大，而且没有意义。</p><p>这个时候，我们其实需要一个<strong>万能遥控器</strong>，而借助Kotlin的<strong>泛型</strong>，我们就可以很容易地实现了。</p><pre><code class="language-plain">//          T代表泛型的形参\n//               ↓\nclass Controller&lt;T&gt; {\n    fun turnOn(tv: T) {}\n    fun turnOff(tv: T) {}\n}\n\nfun main() {\n//                                泛型的实参\n//                                   ↓\n    val mi1Controller = Controller&lt;XiaoMiTV1&gt;()\n    mi1Controller.turnOn()\n\n//                                  泛型的实参\n//                                     ↓\n    val mi2Controller = Controller&lt;XiaoMiTV2&gt;()\n    mi2Controller.turnOn()\n}\n</code></pre><p>在这段代码里，我们定义了一个“万能遥控器类”<code>Controller&lt;T&gt;</code>，它当中的字母T代表了，这个遥控器可以控制很多种型号的电视，至于我们到底想要控制哪种型号，在使用的时候，只需要把T替换成实际的电视机型号即可。在上面的main函数当中，我们是传入了“XiaoMi1S”“XiaoMi2S”这两个型号。</p><p>可见，使用泛型的好处就在于，我们可以复用程序代码的逻辑，借助这个特性，我们可以在程序的基础上再做一次抽象。这样，通过这个<code>Controller&lt;T&gt;</code>，<strong>不管将来有多少型号的电视机，我们都可以用这一个类来搞定。</strong></p><p><img src="https://static001.geekbang.org/resource/image/c1/e7/c1248f3042f62b3ddb74618bb43e38e7.jpg?wh=2000x856" alt=""></p><p>另外，我们在定义泛型的时候，其实还可以为它的泛型参数增加一些<strong>边界限制</strong>，比如说，强制要求传入的泛型参数，必须是TV或者是它的子类。这叫做泛型的<strong>上界</strong>。</p><pre><code class="language-plain">//               差别在这里\n//                   ↓\nclass Controller&lt;T: TV&gt; {\n    fun turnOn(tv: T) {}\n    fun turnOff(tv: T) {}\n}\n</code></pre><p>和Kotlin的<a href="https://time.geekbang.org/column/article/473349">继承语法</a>一样，我们是使用冒号来表示泛型的边界。注意，当我们定义了边界之后，如果我们传入Controller的类型不是TV的子类，那么编译器是会报错的。</p><pre><code class="language-plain">fun main() {\n    // 报错，因为Car不是TV的子类\n    val controller = Controller&lt;Car&gt;()\n}\n</code></pre><p>还有一点你也需要注意，由于函数是Kotlin当中的一等公民，所以你也可以用两个简单的函数turnOn()和turnOff()，来解决前面所说的“遥控器的问题”：</p><pre><code class="language-plain">//     函数的泛型参数\n//   ↓             ↓\nfun &lt;T&gt; turnOn(tv: T){ ... }\nfun &lt;T&gt; turnOff(tv: T){ ... }\n\nfun turnOnAll(mi1: XiaoMiTV1, mi2: XiaoMiTV2) {\n//      泛型实参自动推导\n//          ↓\n    turnOn(mi1)\n    turnOn(mi2)\n}\n</code></pre><p>从上面的代码里我们可以看到，我们直接在fun关键字的后面加上用尖括号包起来的T，就可以为函数增加泛型支持。这里我们选择用字母“T”，完全是因为约定俗成，你将T改为其他英文字母也是不会影响编译的。</p><p>好了，泛型是什么、使用的好处、如何表示等问题，现在我们就都搞清楚了。下面我们再来看看学习泛型的一大难点：型变。</p><h2>型变（Variance）</h2><p>首先，型变是什么呢？</p><p>简单来说，它就是为了解决泛型的<strong>不变性</strong>问题。事实上，型变讨论的是：在已知Cat是Animal的子类的情况下，<code>MutableList&lt;Cat&gt;</code>与<code>MutableList&lt;Animal&gt;</code>之间是什么关系。</p><p>在正常情况下，编译器会认为它们两者是没有任何关系的。换句话，也就是说，<strong>泛型是不变的</strong>。Kotlin编译器会这样处理的原因也很简单，这里我们可以先来假设一下：如果编译器不阻止我们用<code>MutableList&lt;Cat&gt;</code>来替代<code>MutableList&lt;Animal&gt;</code>，代码会出什么问题呢？</p><pre><code class="language-plain">// 需要父类集合，传入子类集合\n\nfoo(list: MutableList&lt;Animal&gt;) {\n    // 出错，Cat集合不能存Dog对象\n    list.add(Dog())\n    // 通过\n    val animal: Animal = list[0] // 取出的Cat对象\n}\n\nfun main() {\n    // 需要MutableList&lt;Animal&gt;，实际传MutableList&lt;Cat&gt;\n    foo(mutableListOf&lt;Cat&gt;(Cat()))\n    // 实际上，编译器在这里就会提示错误，我们现在假设编译器不阻止我们，会出什么问题\n}\n</code></pre><p>从这段代码的注释中，我们能看到，当程序需要Animal的集合时，如果我们传入的是Cat的集合，<strong>我们就可以往list里添加其他类型的动物</strong>，比如Dog。然而，Dog是无法存入Cat的集合的。</p><p>那么如果我们反过来呢？</p><pre><code class="language-plain">// 需要子类集合，传入父类集合\n\nfoo(list: MutableList&lt;Cat&gt;) {\n    // 通过\n    list.add(Cat())\n    // 出错\n    val cat\u0010\u0010\u0010\u0010\u0010\u0010: Cat = list[0] // 实际取出来的是Animal对象\n}\n\nfun main() {\n    // 需要MutableList&lt;Cat&gt;，实际传MutableList&lt;Animal&gt;\n    foo(mutableListOf(Animal()))\n    // 实际上，编译器在这里就会提示错误，我们现在假设编译器不阻止我们，会出什么问题\n}\n</code></pre><p>我们会发现，反过来之后，当需要子类集合传入父类集合的时候，我们在函数体内部存储的行为是不会受到影响的，存储Cat、Animal类型都没问题。可是，一旦我们想从集合当中取出Cat对象的时候，会发现取出来的是Animal对象，这时候又错了。</p><p>所以，在默认情况下，编译器会认为<code>MutableList&lt;Cat&gt;</code>与<code>MutableList&lt;Animal&gt;</code>之间不存在任何继承关系，它们也无法互相替代，这样就不会出现前面提到的两种问题。这就是泛型的<strong>不变性</strong>。</p><p>但是啊，在某些特定场景下，编译器这种行为还是会给我们带来麻烦的。而这个时候，就需要泛型的<strong>逆变与协变</strong>了。具体是什么特定场景呢？别着急，下面我带你来看个例子。</p><h3>逆变（Contravariant）</h3><p>让我们继续以前面的遥控器为例：</p><pre><code class="language-plain">open class TV {\n    open fun turnOn() {}\n}\n\nclass XiaoMiTV1: TV() {\n    override fun turnOn() {}\n}\n\nclass Controller&lt;T&gt; {\n    fun turnOn(tv: T)\n}\n</code></pre><p>在这里，我们有一个电视机的父类，叫做TV，另外还有一个子类，叫做XiaoMiTV1。它们两者是继承关系。由于它们是父子的关系，当函数的参数需要TV这个父类的时候，我们是可以传入子类作为参数的。这很好理解，我们接着往下看：</p><pre><code class="language-plain">fun foo(tv: TV) {}\n\nfun main() {\n// 要求父类，可以传入子类\n    foo(XiaoMiTV1())\n}\n</code></pre><p>现在问题来了，<code>Controller&lt;XiaoMiTV1&gt;</code>和<code>Controller&lt;TV&gt;</code>之间是什么关系呢？让我们来设想一个<strong>买遥控器的场景</strong>：</p><pre><code class="language-plain">//                      需要一个小米电视1的遥控器\n//                                ↓\nfun buy(controller: Controller&lt;XiaoMiTV1&gt;) {\n    val xiaoMiTV1 = XiaoMiTV1()\n    // 打开小米电视1\n    controller.turnOn(xiaoMiTV1)\n}\n</code></pre><p>在上面的代码中，我们的函数需要一个“小米电视1的遥控器”，在函数的内部，我们需要打开一台小米电视机。那么，当我们需要打开一台小米电视机的时候，我们是否可以用一个“万能的遥控器”呢？当然可以！所以，我们可以写出下面这样的代码：</p><pre><code class="language-plain">fun main() {\n//                             实参\n//                              ↓\n    val controller = Controller&lt;TV&gt;()\n    // 传入万能遥控器，报错\n    buy(controller)\n}\n</code></pre><p>在这段代码中，由于我们传入的泛型实参是TV，它是所有电视机的父类。因此，Controller内部将会处理所有电视机型号的开机、关机。这时候，<strong>它就相当于一个万能遥控器</strong>，万能遥控器当然也可以打开小米电视1。</p><p>从道理上来讲，我们的推理是没有错的，不过Kotlin编译器会报错，报错的内容是说“类型不匹配”，需要的是小米遥控器<code>Controller&lt;XiaoMiTV1&gt;</code>，你却买了个万能遥控器<code>Controller&lt;TV&gt;</code>。在默认情况下，Kotlin编译器就是这么认死理。</p><p>所以，为了让我们的代码通过编译，我们需要主动告诉编译器一些额外的信息，具体的做法有两种。</p><p><strong>第一种做法</strong>，是修改泛型参数的使用处代码，它叫做<strong>使用处型变</strong>。具体做法就是修改buy函数的声明，在XiaoMiTV1的前面增加一个in关键字：</p><pre><code class="language-plain">//                         变化在这里\n//                             ↓\nfun buy(controller: Controller&lt;in XiaoMiTV1&gt;) {\n    val xiaoMiTV1 = XiaoMiTV1()\n    // 打开小米电视1\n    controller.turnOn(xiaoMiTV1)\n}\n</code></pre><p><strong>第二种做法</strong>，是修改Controller的源代码，这叫<strong>声明处型变</strong>。具体做法就是，在泛型形参T的前面增加一个关键字in：</p><pre><code class="language-plain">//            变化在这里\n//               ↓\nclass Controller&lt;in T&gt; {\n    fun turnOn(tv: T)\n}\n</code></pre><p>我们使用以上任意一种方式修改后，代码就能够通过Kotlin编译了。这样修改之后，我们就可以使用<code>Controller&lt;TV&gt;</code>来替代<code>Controller&lt;XiaoMiTV1&gt;</code>，也就是说，<code>Controller&lt;TV&gt;</code>是<code>Controller&lt;XiaoMiTV1&gt;</code>的子类。</p><p><img src="https://static001.geekbang.org/resource/image/6a/22/6acd7ea7c06df0fd2f25626965ac6022.jpg?wh=2000x517" alt=""></p><p>如果你足够细心，你会发现：在这个场景下，遥控器与电视机之间的父子关系颠倒了。“小米电视”是“电视”的子类，但是，“万能遥控”成了“小米遥控”的子类。这种父子关系颠倒的现象，我们就叫做“<strong>泛型的逆变</strong>”。上面这两种修改方式，就分别叫做<strong>使用处逆变</strong>和<strong>声明处逆变</strong>。</p><p>而除了父子关系颠倒的现象，泛型当中还存在一种父子关系一致的现象，也就是<strong>泛型的协变</strong>。</p><h3>协变（Covariant）</h3><p>这次，我们仍然以一个生活中的场景来做分析。现在，<strong>请你想象一个点外卖的场景</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/37/68/37fd3346e8de26327b0e09768378fa68.png?wh=1280x765" alt="图片"></p><p>为了模拟这个场景，我们需要用代码来描述其中的几个角色：普通的食物、肯德基的食物，它们两者之间是父子关系。</p><pre><code class="language-plain">open class Food {}\n\nclass KFC: Food() {}\n</code></pre><p>除此之外呢，我们还有一个饭店的角色：</p><pre><code class="language-plain">class Restaurant&lt;T&gt; {\n    fun orderFood(): T { /*..*/ }\n}\n</code></pre><p>在上面的Restaurant泛型参数处，我们传入不同的食物类型，就代表了不同类型的饭店。接下来，就是我们的点外卖方法了：</p><pre><code class="language-plain">//                      这里需要一家普通的饭店，随便什么饭店都行\n//                                     ↓\nfun orderFood(restaurant: Restaurant&lt;Food&gt;) {\n    // 从这家饭店，点一份外卖\n    val food = restaurant.orderFood()\n}\n\nfun main() {\n//                  找到一家肯德基\n//                        ↓\n    val kfc = Restaurant&lt;KFC&gt;()\n// 需要普通饭店，传入了肯德基，编译器报错\n    orderFood(kfc)\n}\n</code></pre><p>如果我们直接运行上面的代码，会发现编译器提示最后一行代码报错，报错的原因同样是：“类型不匹配”，我们需要的是一家随便类型的饭店<code>Restaurant&lt;Food&gt;</code>，而传入的是肯德基<code>Restaurant&lt;KFC&gt;</code>，不匹配。</p><p>是不是觉得很荒谬？既然随便找一家饭店就能点外卖，为什么肯德基不可以呢？</p><p>不过，有了上次的经验，这次我们就轻车熟路了，由于编译器认死理，我们必须额外提供一些信息给编译器，让它知道我们是在特殊场景使用泛型。具体的做法呢，还是有两种\u0010。</p><p><strong>第一种做法</strong>，还是修改泛型参数的使用处，也就是使用处型变。具体的做法就是修改orderFood()函数的声明，在Food的前面增加一个out关键字：</p><pre><code class="language-plain">//                                变化在这里\n//                                    ↓\nfun orderFood(restaurant: Restaurant&lt;out Food&gt;) {\n    // 从这家饭店，点一份外卖\n    val food = restaurant.orderFood()\n}\n</code></pre><p><strong>第二种做法</strong>，是修改Restaurant的源代码，也就是声明处型变。具体做法就是，在它泛型形参T的前面增加一个关键字out：</p><pre><code class="language-plain">//            变化在这里\n//                ↓\nclass Restaurant&lt;out T&gt; {\n    fun orderFood(): T { /*..*/ }\n}\n</code></pre><p>在做完以上任意一种修改以后，代码就可以通过编译了。这也就意味着，在这种情况下，我们可以使用<code>Restaurant&lt;KFC&gt;</code>替代<code>Restaurant&lt;Food&gt;</code>，也就意味着<code>Restaurant&lt;KFC&gt;</code>可以看作是<code>Restaurant&lt;Food&gt;</code>的子类。</p><p><img src="https://static001.geekbang.org/resource/image/8f/c0/8f9yyb56537bf5f5248b9a484e26b6c0.jpg?wh=2000x533" alt=""></p><p>到了这时候，你会发现，食物与饭店它们之间的父子关系一致了。这种现象，我们称之为“<strong>泛型的协变</strong>”。上面两种修改的方式，就分别叫做<strong>使用处协变</strong>和<strong>声明处协变</strong>。</p><p>需要特别注意的是，虽然Java当中也有型变的概念，但是呢，Java当中是没有声明处型变的。Java里面只有使用处型变，下面是它们的语法对比：</p><p><img src="https://static001.geekbang.org/resource/image/3d/ca/3d3a24ffff462a6019c42e43b7e4f3ca.jpg?wh=2000x622" alt=""></p><p>而通过对比，你也会发现，Java的型变语法十分抽象，远不如Kotlin来得简洁。</p><p>好了，到这里，我们就差不多把Kotlin的泛型这个特性理解清楚了，那么是不是就说明，我们可以开始实战了呢？其实还不行，我们还需要了解另一个跟泛型相关的概念，也就是星投影。</p><h2>星投影（Star-Projections）</h2><p>Kotlin当中还有一个概念叫做“星投影”。虽然你听起来可能会觉得这个词很吓人，但其实它的概念很简单。所谓的星投影，其实就是<strong>用“星号”作为泛型的实参</strong>。</p><p>那么，什么情况下，我们需要用星号作为泛型实参呢？答案其实也很简单，<strong>当我们不关心实参到底是什么的时候</strong>。</p><p>举个例子，我们现在需要开发一个“找饭店”的功能，借助泛型，我们可以写出这样的代码：</p><pre><code class="language-plain">fun &lt;T&gt; findRestaurant(): Restaurant&lt;T&gt; {}\n</code></pre><p>不过，如果我们并不关心找到的饭店到底是什么类型，不管它是肯德基还是麦当劳的话，那么，我们就完全可以把“星号”作为泛型的实参，比如这样：</p><pre><code class="language-plain">class Restaurant&lt;out T&gt; {\n    fun orderFood(): T {}\n}\n\n//                        把星号作为泛型实参\n//                               ↓\nfun findRestaurant(): Restaurant&lt;*&gt; {}\n\nfun main() {\n    val restaurant = findRestaurant()\n    // 注意这里\n    val food: Any? = restaurant.orderFood() // 返回值可能是：任意类型\n}\n</code></pre><p>在上面的代码当中，我们没有传递任何具体的类型给Restaurant，而是使用了“星号”作为Restaurant的泛型实参，因此，我们就无法知道饭店到底是什么类型。</p><p>相应的，当我们调用restaurant.orderFood()的时候，就无法确定它返回的值到底是什么类型。这时候，变量food的实际类型可能是任意的，比如String、Int、Food、KFC，甚至可能是null，因此，在这里我们只能将其看作是“Any?”类型。</p><p>那么，对于上面的这种food可能是任意类型的情况，我们有没有办法让food的类型更加精确一些呢？当然是有的。如果我们为Restaurant的泛型类型加上边界的话，food的类型就可以更精确一些。</p><pre><code class="language-plain">//                   区别在这里\n//                       ↓\nclass Restaurant&lt;out T: Food&gt; {\n    fun orderFood(): T {}\n}\n\nfun findRestaurant(): Restaurant&lt;*&gt; {}\n\nfun main() {\n    val restaurant = findRestaurant()\n    //       注意这里\n    //          ↓\n    val food: Food = restaurant.orderFood() // 返回值是：Food或其子类\n}\n</code></pre><p>从这个例子我们能看到，当我们为Restaurant泛型类型增加了上界Food以后，即使我们使用了“星投影”，也仍然可以通过调用restaurant.orderFood()，来拿到Food类型的变量。在这里，food的实际类型肯定是Food或者是Food的子类，因此我们可以将其看作是Food类型。</p><p>泛型虽然很抽象，但它存在的目的，仍然是为了解决我们生活的实际问题。所以，当我们将泛型应用到实际的生活场景时，它就显得不是那么抽象了。</p><h2>实战与思考</h2><p>在学完型变以后，也许你会有点迷惑：<strong>到底什么时候用逆变，什么时候用协变</strong>？如果你看过Kotlin的官方文档，你会看到一句这样的话：</p><blockquote>\n<p>Consumer in, Producer out !</p>\n</blockquote><p>直译的话，大概意思就是：消费者in，生产者out。不过，这个对我们中国人的说话语境而言，不是那么好理解。让我们继续根据前面的遥控器、点外卖两个场景，来做个说明。</p><pre><code class="language-plain">//              逆变\n//               ↓\nclass Controller&lt;in T&gt; {\n//                 ①\n//                 ↓\n    fun turnOn(tv: T)\n}\n\n//               协变\n//                ↓\nclass Restaurant&lt;out T&gt; {\n//                   ②\n//                   ↓\n    fun orderFood(): T { /*..*/ }\n}\n</code></pre><p>在这段代码中，分别是我们前面提到的逆变、协变的例子。把它们两个放到一起后，你应该就能很容易地发现它们两个的差别了。需要特别留意的地方，我都在注释当中标记出来了，让我来解释给你听：</p><ul>\n<li>对于逆变的情况，我们模拟的是买遥控器的场景。请注意注释①的地方，我们的泛型T，它最终会以函数的参数的形式，被<strong>传入</strong>函数的<strong>里面</strong>，这往往是一种<strong>写入</strong>行为，这时候，我们使用关键字<strong>in</strong>。</li>\n<li>对于协变的情况，我们模拟的是点外卖的场景。请注意注释②的地方，我们的泛型T，它最终会以返回值的形式，被<strong>传出</strong>函数的<strong>外面</strong>，这往往是一种<strong>读取</strong>行为，这时候，我们使用关键字<strong>out</strong>。</li>\n</ul><p>所以，如果要以更加通俗的语言来解释逆变与协变的使用场景的话，我们可以将其总结为：<strong>传入in，传出out</strong>。或者，我们也可以说：泛型作为<strong>参数</strong>的时候，用in，泛型作为<strong>返回值</strong>的时候，用out。</p><p>我们再来看一下Kotlin源码当中型变的应用。首先，是逆变的应用。</p><pre><code class="language-plain">//                          逆变\n//                           ↓\npublic interface Comparable&lt;in T&gt; {\n//                                   泛型作为参数\n//                                       ↓\n    public operator fun compareTo(other: T): Int\n}\n</code></pre><p>在以上代码中，由于泛型是作为了compareTo方法的<strong>参数</strong>传入的，因此，对于Comparable的泛型T，我们应该使用<strong>in</strong>来修饰，这就是<strong>逆变</strong>的实际应用。</p><p>我们再来看看协变在Kotlin源码当中的应用。</p><pre><code class="language-plain">//                        协变\n//                         ↓\npublic interface Iterator&lt;out T&gt; {\n//                         泛型作为返回值\n//                              ↓    \n    public operator fun next(): T\n    \n    public operator fun hasNext(): Boolean\n}\n</code></pre><p>从上面的代码里我们可以看到，由于泛型是作为next方法的<strong>返回值</strong>的，因此，对于Iterator的泛型T，我们应该使用<strong>out</strong>来修饰，这就是<strong>协变</strong>的应用。</p><p>我们再来看看<a href="https://time.geekbang.org/column/article/473349">第2讲</a>当中密封类的代码案例，一起回顾下当中的泛型细节：</p><pre><code class="language-plain">sealed class Result&lt;out R&gt; {\n//                     协变    ①\n//                      ↓      ↓\n    data class Success&lt;out T&gt;(val data: T, val message: String = "") : Result&lt;T&gt;()\n\n    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()\n\n    data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()\n}\n</code></pre><p>这段代码里，我们对Success这个数据类的泛型参数使用了out来修饰，这就代表了协变。看到这里，如果你足够细心，就会觉得奇怪：这里为什么可以使用协变呢？前面我们不是说过：“泛型作为参数，用in；泛型作为返回值，用out”吗？<strong>这里并没有任何函数参数或者返回值啊？</strong></p><p>其实，这里就又体现出了我们<strong>对Kotlin底层理解的重要性</strong>了。请注意我在上面标记的注释①，val在Kotlin当中，代表不可变的变量，当它修饰类成员属性的时候，代表它只有getter，没有setter。当我们看到这样的代码时，我们要能自动脑补出Success反编译后的Java结构：</p><pre><code class="language-plain">public static final class Success extends Result {\n   private final Object data;\n   \n// Success 这个类当中，是会有getter方法的\n   public final Object getData() {\n      return this.data;\n   }\n   \n// 省略其他代码\n}\n</code></pre><p>所以，我们可以用out修饰Success泛型的原因，是因为data的getter方法，它本质上是一个返回T类型的方法。这时候，如果我们将注释①处的val改为var，那么代码就会立马报错。</p><pre><code class="language-plain">sealed class Result&lt;out R&gt; {\n//                 改为var后，编译器就会立马报错\n//                             ↓\n    data class Success&lt;out T&gt;(var data: T, val message: String = "") : Result&lt;T&gt;()\n\n    data class Error(val exception: Exception) : Result&lt;Nothing&gt;()\n\n    data class Loading(val time: Long = System.currentTimeMillis()) : Result&lt;Nothing&gt;()\n}\n</code></pre><p>到这里，有了前面的铺垫，我想你应该很快就能反应过来，编译器报错的原因是由于var修饰的成员属性，Kotlin编译器会在背后生成对应getter和setter，这个时候泛型参数<strong>既是“参数”也是“返回值”</strong>。所以，如果此时我们还用out修饰泛型T，编译器就会报错了。</p><p>也就是说，如果泛型的T，既是函数的参数类型，又是函数的返回值类型，那么，我们就无法直接使用in或者out来修饰泛型T。</p><p>不过，<strong>函数传入参数的时候，并不一定就意味着写入</strong>，这时候，即使泛型T是作为参数类型，我们也仍然要想一些办法来用out修饰泛型。让我们拿一段官方源码来举例说明一下：</p><pre><code class="language-plain">//                   协变    \n//                    ↓      \npublic interface List&lt;out E&gt; : Collection&lt;E&gt; {\n//                                泛型作为返回值\n//                                       ↓    \n    public operator fun get(index: Int): E\n//                                           泛型作为参数\n//                                                 ↓    \n    override fun contains(element: @UnsafeVariance E): Boolean\n//                                        泛型作为参数\n//                                              ↓   \n    public fun indexOf(element: @UnsafeVariance E): Int\n}\n</code></pre><p>Kotlin官方源码当中的List，也就是这里的泛型E，它既作为了返回值类型，又作为了参数类型。在正常情况下，如果我们用out修饰E，那编译器是会报错的。但我们其实很清楚，对于contains、indexOf这样的方法，它们虽然以E作为参数类型，但本质上并没有产生写入的行为。所以，我们用out修饰E并不会带来实际的问题。</p><p>所以这个时候，我们就可以通过@UnsafeVariance这样的注解，来让编译器忽略这个型变冲突的问题。</p><p>另外，让我们再来看看<a href="https://time.geekbang.org/column/article/475058">第5讲</a>当中提到过的单例抽象模板，一起回顾下当中的泛型细节：</p><pre><code class="language-plain">//                           逆变   协变\n//                            ↓     ↓\nabstract class BaseSingleton&lt;in P, out T&gt; {\n//                        ①\n    @Volatile//           ↓\n    private var instance: T? = null\n    //                              参数  返回值\n    //                               ↓    ↓\n    protected abstract val creator: (P)-&gt; T\n\n    //                    参数 返回值\n    //                     ↓   ↓\n    fun getInstance(param: P): T =\n        instance ?: synchronized(this) {\n            instance ?: creator(param).also { instance = it }\n    }\n}\n</code></pre><p>在这个单例模板的例子当中，P一直作为参数，而T则是作为返回值。因此我们用in来修饰P，这就是逆变；对应的我们用out修饰T，这就是协变。</p><p>不过，如果你足够细心的话，会发现注释①处还有一个instance是用泛型T修饰的。而它是var定义的成员变量，这就意味着，它既有getter，又有setter。那它为什么可以用协变的泛型T呢？其实，<strong>这是因为它是private的</strong>，如果你把private关键字删掉的话，上面的代码就会报错了。</p><h2>小结</h2><p>最后，让我们来做一个总结吧。</p><ul>\n<li><strong>泛型，是对程序的一种抽象</strong>。通过泛型，我们可以实现代码逻辑复用的目的，Kotlin标准库当中很多源代码也都是借助泛型来实现的。</li>\n<li>从<strong>型变的位置</strong>来分类的话，分为使用处型变和声明处型变。</li>\n<li>从<strong>型变的父子关系</strong>来分类的话，分为逆变和协变。逆变表示父子关系颠倒了，而协变表示父子关系和原来一致。</li>\n<li>型变的口诀：<strong>泛型作为参数，用in；泛型作为返回值，用out</strong>。在特殊场景下，同时作为参数和返回值的泛型参数，我们可以用<strong>@UnsafeVariance</strong>来解决型变冲突。</li>\n<li><strong>星投影</strong>，就是当我们对泛型的具体类型不感兴趣的时候，直接传入一个“星号”作为泛型的实参。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/0e/2c/0e115b3b553ddf6c0bb3yyf7827fe42c.jpg?wh=2000x1528" alt=""></p><p>最后，我还想和你分享一下我学习Kotlin泛型的方法论。正如开头我提到的：程序是对真实世界的抽象，而泛型是对程序的抽象。由于泛型与我们真实世界差了两层抽象，这就导致我们很难理解泛型的本质。</p><p>所以，为了让泛型更加易懂，我的思路就是让泛型与我们的真实世界建立一种关联：<strong>直接拿泛型来模拟真实世界的场景，建立类比的关系。</strong>就比如我们今天所讲的：</p><ul>\n<li>用万能遥控器，类比泛型；</li>\n<li>用买遥控器的场景，类比逆变；</li>\n<li>用点外卖的场景，类比协变、星投影。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/10/7a/102062dfdc96a48ae4f8c4671ff42e7a.jpg?wh=2000x808" alt=""></p><p>希望我的学习方法可以对你有所启发。</p><h2>思考题</h2><p>请你思考一下，“使用处型变”和“声明处型变”，它们有什么区别呢？ 欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "10 | 泛型：逆变or协变，傻傻分不清？",
      },
      {
        title: "11 | 注解与反射：进阶必备技能",
        id: 481037,
        content:
          '<p>你好，我是朱涛。今天这节课，我们来学习一下Kotlin的<strong>注解</strong>（Annotation）和<strong>反射</strong>（Reflection）。</p><p>注解和反射，是Kotlin当中比较难理解的内容了。和前面我们学习的<a href="https://time.geekbang.org/column/article/480022">泛型</a>一样，注解与反射都是比较抽象的概念。我们现在已经知道，Kotlin的泛型，就是在代码架构的层面进行的一种抽象，从而达到代码逻辑尽可能复用的目的。那么，注解与反射，它们存在的意义是什么呢？</p><p>答案是：提高代码的<strong>灵活性</strong>。</p><p>灵活性，就让注解与反射同样有着举足轻重的地位，借助这两种技术，我们可以做许多有趣的事情。Kotlin与Java领域，有许多著名的开源库，比如大名鼎鼎的<a href="https://spring.io/projects/spring-boot">Spring Boot</a>、<a href="https://github.com/square/retrofit">Retrofit</a>、<a href="https://github.com/google/gson">Gson</a>等，都会用到这两种技术。</p><p>所以，只有深刻理解了注解和反射，我们才可能理解那些著名开源库的设计思路，也才可能读懂这些世界顶级开发者的代码。</p><p>当然，课程进行到这里，学习的难度也越来越高了，不过你也不要因此产生畏难的情绪，只要你能多思考、多练习，把对知识点的理解都落实到代码上，那我相信你对Kotlin的掌握情况、代码能力甚至架构能力，都会有一个质的飞跃。并且，在课程中我也会尽量用通俗易懂的语言、例子来给你介绍这些陌生的概念知识，让你在学习的过程中可以轻松一些。</p><!-- [[[read_end]]] --><p>好，下面我们就正式开始吧。</p><h2>认识注解</h2><p>注解，可能是我们眼里<strong>最熟悉的陌生人</strong>。虽然经常见面，但我们并不真的认识它。</p><p>实际上，注解几乎无处不在，比如说，我们经常能在Kotlin标准库当中看见“@Deprecated”这样的注解，它代表了被标注的代码“已废弃”。如果你有Java的编程经验，你一定见过“@Override”这个注解，它代表了重写。</p><p>而就算你没有任何编程经验，你也已经在前面的课程中见到过注解了。比如我们在<a href="https://time.geekbang.org/column/article/473656">第4讲</a>的单元测试代码当中，就用到了@Test这个注解；在<a href="https://time.geekbang.org/column/article/477295">第8讲</a>的性能测试代码中，我们用到了@Benchmark这个注解。</p><p>其实，要理解Kotlin的注解也并不困难，因为在我们的生活当中也有类似的概念，那就是<strong>便利贴</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/7a/21/7a0a847eb0a881fba6413be150dd2f21.png?wh=1920x1280" alt="图片"></p><p>比如在学习的时候，你看到书本里的某个知识点有了新的感悟，就会拿起便利贴，写下来你当时的想法，然后贴到书本当中去。</p><p>另一个例子就是，我们经常会在论文或者维基百科当中看到的“注解”。</p><p><img src="https://static001.geekbang.org/resource/image/68/1e/68966cf6789af5ecf03cf65338a0451e.png?wh=887x196" alt="图片"></p><p>所以，从这个角度来看，我们很容易就能想清楚注解到底是什么。其实，它就是“对已有数据进行补充的一种数据”。这话读起来有点绕，让我用更通俗的语言来解释一下：</p><ul>\n<li>我们学习的时候，写下来的便利贴注解，其实就是对知识点的补充。</li>\n<li>维基百科当中的注解，其实就是对它描述内容的一种补充。</li>\n</ul><p>因此，<strong>Kotlin当中的注解，其实就是“程序代码的一种补充”</strong>。</p><p>现在我们就拿第4讲中的单元测试代码为例，来看看它的作用。</p><pre><code class="language-plain">class TestCalculatorV3 {\n//   注解\n//    ↓\n    @Test\n    fun testCalculate() {\n        val calculator = CalculatorV3()\n\n        val res1 = calculator.calculate("2333333333333332+1")\n        assertEquals("2333333333333333", res1)\n    }\n}\n</code></pre><p>上面这段代码中的“@Test”，它的作用是告诉我们的IDE，testCalculate()这个方法是一个测试方法。IDE检测到这个注解以后，就会在旁边的工具栏展示出一个绿色的三角形按钮，方便我们直接运行这个测试方法。</p><p>如果我们删掉“@Test”这个注解，这段代码就会变成一段普通的Kotlin代码，而旁边工具栏的绿色三角形按钮也会消失。</p><p><img src="https://static001.geekbang.org/resource/image/65/cb/65d02a01df21a579d05944aedeff59cb.gif?wh=1174x668" alt="图片"></p><p>从这个例子里，我们其实就能体会到注解的灵活性。我们开发者只需要用Kotlin的语法写代码即可，至于代码是不是用来做单元测试，我们用一个简单的“@Test”注解就可以搞定。这中间有<strong>解耦</strong>的思想在里面。</p><p>认识到注解是什么以后，我们后面的学习就很简单了。接下来，我们就来看看注解的定义还有使用。</p><h3>注解的定义</h3><p>首先，让我们来看看注解是如何定义的。Kotlin的源代码当中，提供了很多内置的注解，比如@Deprecated、@JvmStatic、@JvmOverloads等等。除了Kotlin默认就有的注解以外，我们也可以定义自己的注解。</p><p>比如说，如果我们想定义一个@Deprecated注解，应该怎么做呢？其实非常简单，总体结构和定义一个普通的Kotlin类差不多，只是多了一些额外的东西。</p><pre><code class="language-plain">@Target(CLASS, FUNCTION, PROPERTY, ANNOTATION_CLASS, CONSTRUCTOR, PROPERTY_SETTER, PROPERTY_GETTER, TYPEALIAS)\n@MustBeDocumented\npublic annotation class Deprecated(\n    val message: String,\n    val replaceWith: ReplaceWith = ReplaceWith(""),\n    val level: DeprecationLevel = DeprecationLevel.WARNING\n)\n</code></pre><p>从上面的代码里，我们可以看到，@Deprecated这个注解的定义上面，还有其他的注解@Target、@MustBeDocumented。这样的注解，我们叫做<strong>元注解</strong>，即它本身是注解的同时，还可以用来修饰其他注解。</p><p>Kotlin常见的元注解有四个：</p><ul>\n<li><strong>@Target</strong>，这个注解是指定了被修饰的注解都可以用在什么地方，也就是<strong>目标</strong>；</li>\n<li><strong>@Retention</strong>，这个注解是指定了被修饰的注解是不是编译后可见、是不是运行时可见，也就是<strong>保留位置</strong>；</li>\n<li><strong>@Repeatable</strong>，这个注解是允许我们在同一个地方，多次使用相同的被修饰的注解，使用场景比较少；</li>\n<li><strong>@MustBeDocumented</strong>，指定被修饰的注解应该包含在生成的API文档中显示，这个注解一般用于SDK当中。</li>\n</ul><p>这里，你需要注意的是Target和Retention的取值：</p><pre><code class="language-plain">public enum class AnnotationTarget {\n    // 类、接口、object、注解类\n    CLASS,\n    // 注解类\n    ANNOTATION_CLASS,\n    // 泛型参数\n    TYPE_PARAMETER,\n    // 属性\n    PROPERTY,\n    // 字段、幕后字段\n    FIELD,\n    // 局部变量\n    LOCAL_VARIABLE,\n    // 函数参数\n    VALUE_PARAMETER,\n    // 构造器\n    CONSTRUCTOR,\n    // 函数\n    FUNCTION,\n    // 属性的getter\n    PROPERTY_GETTER,\n    // 属性的setter\n    PROPERTY_SETTER,\n    // 类型\n    TYPE,\n    // 表达式\n    EXPRESSION,\n    // 文件\n    FILE,\n    // 类型别名\n    TYPEALIAS\n}\n\npublic enum class AnnotationRetention {\n    // 注解只存在于源代码，编译后不可见\n    SOURCE,\n    // 注解编译后可见，运行时不可见\n    BINARY,\n    // 编译后可见，运行时可见\n    RUNTIME\n}\n</code></pre><p>在这段代码的注释当中，我详细解释了Target和Retention的取值，以及它们各自代表的意义。现在我们就可以回过头，来看看我们定义的“@Deprecated”到底是什么含义。</p><p>通过@Target的取值，我们可以看到，@Deprecated只能作用于这些地方：类、 函数、 属性、注解类、构造器、属性getter、属性setter、类型别名。此外，@Deprecated这个类当中还包含了几个成员：message代表了废弃的提示信息；replaceWith代表了应该用什么来替代废弃的部分；level代表警告的程度，分别是WARNING、ERROR、HIDDEN。</p><p>OK，现在我们已经知道如何定义注解了，接下来看看如何用它。我们仍然以@Deprecated注解为例。</p><h3>注解的使用</h3><p>假设现在我们要开发一个计算器，第一个版本的Calculator代码出现了问题，然后这个问题在CalculatorV3当中修复了。这时候，我们希望所有的调用方都将Calculator改为CalculatorV3。这种情况，@Deprecated这个注解就恰好符合我们的需求。</p><pre><code class="language-plain">@Deprecated(\n    message = "Use CalculatorV3 instead.",\n    replaceWith = ReplaceWith("CalculatorV3"),\n    level = DeprecationLevel.ERROR\n)\nclass Calculator {\n    // 错误逻辑\n    fun add(a: Int, b: Int): Int = a - b\n}\n\nclass CalculatorV3 {\n    // 正确逻辑\n    fun add(a: Int, b: Int): Int = a + b\n}\n</code></pre><p>在上面的代码中，我们使用@Deprecated修饰了Calculator这个类。message代表了报错的提示信息；replaceWith代表了正确的解决方案；DeprecationLevel.ERROR则代表了IDE会把这个问题当作是错误的来看待。</p><p>现在，我们再来看看@Deprecated的实际效果：</p><p><img src="https://static001.geekbang.org/resource/image/62/89/6212fddyy950855b67c6f267c5351e89.gif?wh=2102x1754" alt="图片"></p><p>可以看到，当我们在代码当中使用了Calculator的时候，IDE会报错，鼠标挪到报错处后，IDE会显示message当中的内容“Use CalculatorV3 instead.”。另外，IDE还会提供一个快速修复的选项“Replace with CalculatorV3”，只要我们点击那个选项，我们的Calculator就会被直接替换成CalculatorV3，从而达到修复错误的目的。</p><p>还有，由于我们使用的level是DeprecationLevel.ERROR，所以IDE会直接报错。而如果我们使用的是DeprecationLevel.WARNING，IDE就只会提示一个警告，而不是错误了。</p><p>好了，到这里，我们就了解了注解要如何定义和使用。其实啊，只要我们真正理解了Kotlin的注解到底是什么东西，前面的这些注解的语法是很容易就能记住的。不过，Kotlin注解在使用的时候，还有一个细节需要注意，那就是注解的<strong>精确使用目标</strong>。</p><p>我们看一个具体的例子，比如<a href="https://github.com/google/dagger">Dagger</a>当中的@Inject注解：</p><pre><code class="language-plain">object Singleton {\n//    ①\n//    ↓\n    @set:Inject\n    lateinit var person: Person\n//     ↑\n//     ②\n}\n</code></pre><p>这段代码，是一个简单的Dagger使用场景。如果你不熟悉Dagger，那也没关系，你只需要关注一下上面的两个注释。</p><ul>\n<li><strong>注释①</strong>：如果去掉set这个标记，直接使用@Inject这个注解，我们的程序将无法正常工作。这是因为Kotlin当中的一个var修饰的属性，它会有多种含义：这个属性背后的字段（field）、这个属性对应的setter、还有这个属性对应的getter，在没有明确标注出来要用哪个的时候，@Inject根本不知道该如何决定。因此，这里的“@set:Inject”的作用，就是明确标记出注解的精确使用目标（Use-site targets）。</li>\n<li><strong>注释②</strong>：如果没有lateinit这个关键字，person这个属性是必须要有初始值的，要么直接赋值，要么在构造函数当中被赋值。因为如果它不被初始化，person这个属性将为空，而这个就和它的类型“不可为空的Person类型”冲突了。而加上lateinit修饰的属性，即使它是不可为空的，编译器也会允许它无初始值。但当我们需要依赖注入的时候，常常需要与lateinit结合使用。</li>\n</ul><p>实际上，注解的精确使用目标，一般是和注解一起使用的，在上面的例子当中，set就是和@Inject一起使用的。而除了set以外，Kotlin当中还有其他的使用目标：</p><ul>\n<li>file，作用于文件；</li>\n<li>property，作用于属性；</li>\n<li>field，作用于字段；</li>\n<li>get，作用于属性getter；</li>\n<li>set，作用于属性setter；</li>\n<li>receiver，作用于扩展的接受者参数；</li>\n<li>param，作用于构造函数参数；</li>\n<li>setparam，作用于函数参数；</li>\n<li>delegate，作用于委托字段。</li>\n</ul><p>好，理解了注解这个特性之后，我们再来看看Kotlin的反射。</p><h2>认识反射</h2><p>反射，是Kotlin当中另一个比较抽象的概念。如果说<strong>注解是最熟悉的陌生人</strong>，那<strong>反射就单纯只是个陌生人</strong>了。因为，我们很少会在平时的业务开发当中直接用到反射。但是，在架构设计的时候，反射却可以极大地提升架构的灵活性。很多热门的开源库，也都喜欢用反射来做一些不同寻常的事情。因此，反射也是极其重要的一个语法特性。</p><p>所有的计算机程序其实都是服务于真实世界，用来解决实际问题的。所以，其实我们也通过一些真实世界的例子来理解反射的本质。</p><p><img src="https://static001.geekbang.org/resource/image/81/3e/81b9c3253cce6a4b7a89cd44yyb21c3e.png?wh=1920x1280" alt="图片"></p><p>古人云：吾日三省吾身，指的是人的自我反省能力。<strong>反射，则是程序自我反省的能力。</strong>人的自我反省的能力，跟程序的反射，它们之间有许多相似之处。</p><ul>\n<li>人类可以<strong>反省自己当前的状态</strong>，比如说，我们随时可以知道自己是不是困了。而在Kotlin当中，程序可以通过反射来检查代码自身的状态，比如说，判断某个变量，它是不是可变的。</li>\n<li>另外，人类反省自己的状态以后，还可以<strong>主动改变自己的状态</strong>。比如说，困了就休息一会儿、饿了就吃饭、渴了就喝点水。而在Kotlin当中，我们可以在运行时，用反射来查看变量的值是否符合预期，如果不符合预期，我们就可以动态修改这个变量的值，即使这个变量是private的甚至是final的。</li>\n<li>还有，人类可以<strong>根据状态作出不同的决策</strong>。比如说，上班的路上，如果快迟到了，我们就会走快点，如果时间很充足，就可以走慢一点。而在程序世界里，<a href="https://github.com/google/gson/blob/master/UserGuide.md">JSON解析</a>经常会用到@SerializedName这个注解，如果属性有@SerializedName修饰的话，它就以指定的名称为准，如果没有，那就直接使用属性的名称来解析。</li>\n</ul><p>所以，总的来看，Kotlin反射具备这三个特质：</p><ul>\n<li><strong>感知</strong>程序的状态，包含程序的运行状态，还有源代码结构；</li>\n<li><strong>修改</strong>程序的状态；</li>\n<li>根据程序的状态，<strong>调整</strong>自身的决策行为。</li>\n</ul><h3>反射的应用</h3><p>在Kotlin当中，反射库并没有直接集成到标准库当中。这是为了方便一些对程序安装包敏感的应用，可以根据实际需求来选择是否要用Kotlin反射。比如，在Android开发当中，我们对安装包体积就十分敏感，如果没有反射的需求，就完全不需要多引入这个依赖。</p><p>而对应的，如果我们需要用到反射，就必须要引入这个依赖：</p><pre><code class="language-groovy">implementation "org.jetbrains.kotlin:kotlin-reflect"\n</code></pre><p>前面我们刚了解过Kotlin反射的三个特质，那么在这里，我们就用代码来探索下这三种特质。<br>\n在正常情况下，我们写出来的程序，其实也可以感知自身部分的状态。比如，我们前面课程中写的计算器程序，还有词频统计程序，本质上都是对输入数据状态的感知。不过，它们感知的状态十分有限。</p><p>假设，现在有一个待实现的函数readMembers。这个函数的参数obj可能是任何的类型，我们需要读取obj当中所有的成员属性的名称和值，那么具体该怎么做呢？</p><pre><code class="language-plain">fun main() {\n    val student = Student("Tom", 99.5, 170)\n    val school = School("PKU", "Beijing...")\n\n    readMembers(student)\n    readMembers(school)\n}\n\nfun readMembers(obj: Any) {\n    // 读取obj的所有成员属性的名称和值\n}\n\ndata class Student(\n    val name: String,\n    val score: Double,\n    val height: Int\n)\n\ndata class School(\n    val name: String,\n    var address: String\n)\n\n// 要求readMembers函数能够输出以下内容：\n\nStudent.height=170\nStudent.name=Tom\nStudent.score=99.5\nSchool.address=Beijing...\nSchool.name=PKU\n</code></pre><p>从上面的代码，我们可以看到，readMembers()这个函数无法提前知道参数是什么类型，但是，在这个函数当中，我们还是要能够准确找到obj的所有成员属性，然后输出它们的名称和值。<br>\n对于这样的问题，也许你会第一时间想到用when表达式，写出类似这样的代码：</p><pre><code class="language-plain">fun readMembers(obj: Any) {\n    when(obj) {\n        is Student -&gt; { /*...*/ }\n        is School -&gt; { /*...*/}\n        else -&gt; { /*...*/}\n    }\n}\n</code></pre><p>但是，在这个例子里，我们是只有Student、School这两种情况，而在实际情况下，obj可能的类型是成千上万的，我们根本无法用when的方式提前硬编码进行预测。比如你可以再看看下面这段示例：</p><pre><code class="language-plain">fun readMembers(obj: Any) {\n    when(obj) {\n        is Student -&gt; { /*...*/ }\n        is School -&gt; { /*...*/}\n        // 硬编码的话，这里要写成千上万个逻辑分支，根本不可能做到\n        else -&gt; { /*...*/}\n    }\n}\n</code></pre><p>可见，即使我们有心想要写上万个逻辑分支，那当中的代码量也是不可想象的。因此，对于类似这样的问题，我们就可以考虑使用反射了。</p><pre><code class="language-plain">fun readMembers(obj: Any) {\n    obj::class.memberProperties.forEach {\n        println("${obj::class.simpleName}.${it.name}=${it.getter.call(obj)}")\n    }\n}\n</code></pre><p>看，通过反射，简单的几行代码就搞定了这个需求。如果你是第一次接触反射，可能会觉得上面的代码有点难懂，我来带你分析一下。</p><p>首先，是<strong>obj::class</strong>，这是Kotlin反射的语法，我们叫做<strong>类引用</strong>，通过这样的语法，我们就可以读取一个变量的“类型信息”，并且就能拿到这个变量的类型，它的类型是KClass。</p><pre><code class="language-plain">public actual interface KClass&lt;T : Any&gt; : KDeclarationContainer, KAnnotatedElement, KClassifier {\n\n    public actual val simpleName: String?\n\n    public actual val qualifiedName: String?\n\n    override val members: Collection&lt;KCallable&lt;*&gt;&gt;\n    // 省略部分代码\n}\n</code></pre><p>这个KClass其实就代表了一个Kotlin类，通过obj::class，我们就可以拿到这个类型的所有信息，比如说，类的名称“obj::class.simpleName”。而如果要获取类的所有成员属性，我们访问它的扩展属性memberProperties就可以了。</p><pre><code class="language-plain">val &lt;T : Any&gt; KClass&lt;T&gt;.memberProperties: Collection&lt;KProperty1&lt;T, *&gt;&gt;\n    get() = (this as KClassImpl&lt;T&gt;).data().allNonStaticMembers.filter { it.isNotExtension &amp;&amp; it is KProperty1&lt;*, *&gt; } as Collection&lt;KProperty1&lt;T, *&gt;&gt;\n</code></pre><p>在拿到所有的成员属性以后，我们可以通过<strong>forEach</strong>遍历所有的属性，它的类型是KProperty1，同时也是KCallable的子类，我们通过调用属性的getter.call()，就可以拿到obj属性的值了。</p><p>这样，到目前为止，我们的程序就已经可以感知到自身的状态了，接下来我们来尝试修改自身的状态，这是反射的第二个特质。</p><p>具体需求是这样的：如果传入的参数当中，存在String类型的address变量，我们就将其改为China。</p><pre><code class="language-plain">fun main() {\n    val student = Student("Tom", 99.5, 170)\n    val school = School("PKU", "Beijing...")\n\n    readMembers(student)\n    readMembers(school)\n\n    // 修改其中的address属性\n    modifyAddressMember(school)\n\n    readMembers(school)\n    readMembers(student)\n}\n\nfun modifyAddressMember(obj: Any) {\n    obj::class.memberProperties.forEach {\n        if (it.name == "address" &amp;&amp; // ①\n            it is KMutableProperty1 &amp;&amp; // ②\n            it.setter.parameters.size == 2 &amp;&amp; // ③\n            it.getter.returnType.classifier == String::class // ④\n        ) {\n            // ⑤\n            it.setter.call(obj, "China")\n            println("====Address changed.====")\n        }\n    }\n}\n\n// 运行结果：\nStudent.height=170\nStudent.name=Tom\nStudent.score=99.5\n// 注意这里\nSchool.address=Beijing...\nSchool.name=PKU\n====Address changed.====\n// 注意这里\nSchool.address=China\nSchool.name=PKU\nStudent.height=170\nStudent.name=Tom\nStudent.score=99.5\n</code></pre><p>从上面的代码中，我们可以看到，当我们运行了modifyAddressMember(school)这行代码以后，反射代码就会检查传入的变量当中，是否存在String类型的address，如果存在，就会将它的值修改为“China”。</p><p>这里你可以关注下我在其中标出来的四个注释，它们就代表了关键的逻辑：</p><ul>\n<li>注释①，判断属性的名称是否为address，如果不是，则跳过；</li>\n<li>注释②，判断属性是否可变，在我们的例子当中address是用var修饰的，因此它的类型是KMutableProperty1；</li>\n<li>注释③，我们在后面要调用属性的setter，所以我们要先判断setter的参数是否符合预期，这里setter的参数个数应该是2，第一个参数是obj自身，第二个是实际的值；</li>\n<li>注释④，根据属性的getter的返回值类型returnType，来判断属性的类型是不是String类型；</li>\n<li>注释⑤，调用属性的setter方法，传入obj，还有“China”，来完成属性的赋值。</li>\n</ul><p>好，到这里，我们就已经了解了反射的两种特质，分别是感知程序的状态和修改程序的状态。现在只剩下第三种，根据程序状态作出不同决策。这个其实非常容易做到。</p><p>假如在前面的例子的基础上，我们想要增加一个功能：如果传入的参数没有符合需求的address属性，我们就输出一行错误日志。这其实也就代表了根据程序的状态，作出不同的行为。比如，我们可以看看下面这段示例，其中的else分支就是我们的决策行为“输出错误日志”：</p><pre><code class="language-plain">fun modifyAddressMember(obj: Any) {\n    obj::class.memberProperties.forEach {\n        if (it.name == "address" &amp;&amp;\n            it is KMutableProperty1 &amp;&amp;\n            it.getter.returnType.classifier == String::class\n        ) {\n            it.setter.call(obj, "China")\n            println("====Address changed.====")\n        } else {\n            // 差别在这里\n            println("====Wrong type.====")\n        }\n    }\n}\n\n// 输出结果：\nStudent.height=170\nStudent.name=Tom\nStudent.score=99.5\nSchool.address=Beijing...\nSchool.name=PKU\n====Address changed.====\n====Wrong type.====  // 差别在这里\nSchool.address=China\nSchool.name=PKU\nStudent.height=170\nStudent.name=Tom\nStudent.score=99.5\n</code></pre><p>在前面的几个案例当中，我们用到了Kotlin反射的几个关键的反射Api和类：KClass、KCallable、KParameter、KType。现在，我们来进一步看看它们的关键成员。</p><p><strong>KClass代表了一个Kotlin的类，下面是它的重要成员：</strong></p><ul>\n<li>simpleName，类的名称，对于匿名内部类，则为null；</li>\n<li>qualifiedName，完整的类名；</li>\n<li>members，所有成员属性和方法，类型是<code>Collection&lt;KCallable&lt;*&gt;&gt;</code>；</li>\n<li>constructors，类的所有构造函数，类型是<code>Collection&lt;KFunction&lt;T&gt;&gt;&gt;</code>；</li>\n<li>nestedClasses，类的所有嵌套类，类型是<code>Collection&lt;KClass&lt;*&gt;&gt;</code>；</li>\n<li>visibility，类的可见性，类型是<code>KVisibility?</code>，分别是这几种情况，PUBLIC、PROTECTED、INTERNAL、PRIVATE；</li>\n<li>isFinal，是不是final；</li>\n<li>isOpen，是不是open；</li>\n<li>isAbstract，是不是抽象的；</li>\n<li>isSealed，是不是密封的；</li>\n<li>isData，是不是数据类；</li>\n<li>isInner，是不是内部类；</li>\n<li>isCompanion，是不是伴生对象；</li>\n<li>isFun，是不是函数式接口；</li>\n<li>isValue，是不是Value Class。</li>\n</ul><p><strong>KCallable代表了Kotlin当中的所有可调用的元素，比如函数、属性、甚至是构造函数。下面是KCallable的重要成员：</strong></p><ul>\n<li>name，名称，这个很好理解，属性和函数都有名称；</li>\n<li>parameters，所有的参数，类型是<code>List&lt;KParameter&gt;</code>，指的是调用这个元素所需的所有参数；</li>\n<li>returnType，返回值类型，类型是KType；</li>\n<li>typeParameters，所有的类型参数(比如泛型)，类型是<code>List&lt;KTypeParameter&gt;</code>；</li>\n<li>call()，KCallable对应的调用方法，在前面的例子中，我们就调用过setter、getter的call()方法。</li>\n<li>visibility，可见性；</li>\n<li>isSuspend，是不是挂起函数。</li>\n</ul><p><strong>KParameter，代表了<code>KCallable</code>当中的参数，它的重要成员如下：</strong></p><ul>\n<li>index，参数的位置，下标从0开始；</li>\n<li>name，参数的名称，源码当中参数的名称；</li>\n<li>type，参数的类型，类型是KType；</li>\n<li>kind，参数的种类，对应三种情况：INSTANCE是对象实例、EXTENSION_RECEIVER是扩展接受者、VALUE是实际的参数值。</li>\n</ul><p><strong>KType，代表了Kotlin当中的类型，它重要的成员如下：</strong></p><ul>\n<li>classifier，类型对应的Kotlin类，即KClass，我们前面的例子中，就是用的classifier == String::class来判断它是不是String类型的；</li>\n<li>arguments，类型的类型参数，看起来好像有点绕，其实它就是这个类型的泛型参数；</li>\n<li>isMarkedNullable，是否在源代码中标记为可空类型，即这个类型的后面有没有“?”修饰。</li>\n</ul><p>所以，归根结底，<strong>反射，其实就是Kotlin为我们开发者提供的一个工具</strong>，通过这个工具，我们可以让程序在运行的时候“自我反省”。这里的“自我反省”一共有三种情况，其实跟我们的现实生活类似。</p><ul>\n<li>第一种情况，程序在运行的时候，可以通过反射来查看自身的状态。</li>\n<li>第二种情况，程序在运行的时候，可以修改自身的状态。</li>\n<li>第三种情况，程序在运行的时候，可以根据自身的状态调整自身的行为。</li>\n</ul><h2>小结</h2><p>好了，让我们来做个简单的总结吧。</p><p>注解和反射，是Kotlin当中十分重要的特性，它们可以极大地提升程序的灵活性。那么，在使用注解和反射的时候，你要知道，<strong>注解，其实就是“程序代码的一种补充”，而反射，其实就是“程序代码自我反省的一种方式”。</strong></p><p>在这节课当中，我们已经分别见识了注解与反射的威力。那么，如果我们将它们两者结合起来使用会产生什么样的反应呢？我们将在下节课当中揭晓！</p><h2>思考题</h2><p>这节课，我们学习了Kotlin的注解、反射，其实Java当中也是有注解与反射的。那么你知道Kotlin和Java之间有哪些异同点吗？欢迎给我留言，我们一起交流探讨。</p><p>好了，我们下节课再见吧！</p>',
        article_title: "11 | 注解与反射：进阶必备技能",
      },
      {
        title: "12 | 实战：用Kotlin实现一个网络请求框架KtHttp",
        id: 481787,
        content:
          '<p>你好，我是朱涛，又到了实战环节。</p><p>在前面几节课当中，我们一起学习了Kotlin的委托、泛型、注解、反射这几个高级特性。那么今天这节课，我们将会运用这些特性，来写一个<strong>Kotlin版本的HTTP网络请求框架</strong>。由于它是纯Kotlin开发的，我们就把它叫做是KtHttp吧。</p><p>事实上，在Java和Kotlin领域，有许多出色的网络请求框架，比如 <a href="https://github.com/square/okhttp">OkHttp</a>、<a href="https://github.com/square/Retrofit">Retrofit</a>、<a href="https://github.com/kittinunf/fue">Fuel</a>。而我们今天要实现的KtHttp，它的灵感来自于Retrofit。之所以选择Retrofit作为借鉴的对象，是因为它的底层使用了大量的<strong>泛型、注解和反射</strong>的技术。如果你能跟着我一起用泛型、注解、反射来实现一个简单的网络请求框架，相信你对这几个知识点的认识也会更加透彻。</p><p>在这节课当中，我会带你从0开始实现这个网络请求框架。和往常一样，为了方便你理解，我们的代码会分为两个版本：</p><ul>\n<li>1.0 版本，我们会用Java思维，以最简单直白的方式来实现KtHttp的基础功能——同步式的GET网络请求；</li>\n<li>2.0 版本，我们会用函数式思维来重构代码。</li>\n</ul><p>另外，在正式开始学习之前，我也建议你去clone我GitHub上面的KtHttp工程：<a href="https://github.com/chaxiu/KtHttp.git">https://github.com/chaxiu/KtHttp.git</a>，然后用IntelliJ打开，并切换到<strong>start</strong>分支跟着课程一步步敲代码。</p><!-- [[[read_end]]] --><h2>1.0：Java思维</h2><p>在正式开始之前，我们还是先来看看程序的运行效果：</p><p><img src="https://static001.geekbang.org/resource/image/32/bc/321d151db077766997ed8d8b911f1fbc.gif?wh=1294x862" alt="图片"></p><p>在上面的动图中，我们通过KtHttp请求了一个服务器的API，然后在控制台输出了结果。这其实是我们在开发工作当中十分常见的需求。通过这个KtHttp，我们就可以在程序当中访问任何服务器的API，比如<a href="https://docs.github.com/en">GitHub的API</a>。</p><p>那么，为了描述服务器返回的内容，我们定义了两个数据类：</p><pre><code class="language-plain">// 这种写法是有问题的，但这节课我们先不管。\n\ndata class RepoList(\n    var count: Int?,\n    var items: List&lt;Repo&gt;?,\n    var msg: String?\n)\n\ndata class Repo(\n    var added_stars: String?,\n    var avatars: List&lt;String&gt;?,\n    var desc: String?,\n    var forks: String?,\n    var lang: String?,\n    var repo: String?,\n    var repo_link: String?,\n    var stars: String?\n)\n</code></pre><p>除了数据类以外，我们还要定义一个用于网络请求的接口：</p><pre><code class="language-plain">interface ApiService {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): RepoList\n}\n</code></pre><p>在这个接口当中，有两个注解，我们一个个分析：</p><ul>\n<li><strong>GET注解</strong>，代表了这个网络请求应该是GET请求，这是<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP</a>请求的一种方式。GET注解当中的“/repo”，代表了API的path，它是和baseURL拼接的；</li>\n<li><strong>Field注解</strong>，代表了GET请求的参数。Field注解当中的值也会和URL拼接在一起。</li>\n</ul><p>也许你会好奇，<strong>GET、Field这两个注解是从哪里来的呢？</strong>这其实也是需要我们自己定义的。根据上节课学过的内容，我们很容易就能写出下面的代码：</p><pre><code class="language-plain">@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class GET(val value: String)\n\n@Target(AnnotationTarget.VALUE_PARAMETER)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Field(val value: String)\n</code></pre><p>从这段代码里我们可以看出，GET注解只能用于修饰函数，Field注解只能用于修饰参数。另外，这两个注解的Retention都是AnnotationRetention.RUNTIME，这意味着这两个注解都是运行时可访问的。而这，也正好是我们后面要使用的反射的前提。</p><p>最后，我们再来看看KtHttp是如何使用的：</p><pre><code class="language-plain">fun main() {\n    // ①\n    val api: ApiService = KtHttpV1.create(ApiService::class.java)\n\n    // ②\n    val data: RepoList = api.repos(lang = "Kotlin", since = "weekly")\n\n    println(data)\n}\n</code></pre><p>上面的代码有两个注释，我们分别来看。</p><ul>\n<li>注释①：我们调用KtHttpV1.create()方法，传入了ApiService::class.java，参数的类型是<code>Class&lt;T&gt;</code>，返回值类型是ApiService。这就相当于创建了ApiService这个接口的实现类的对象。</li>\n<li>注释②：我们调用api.repos()这个方法，传入了Kotlin、weekly这两个参数，代表我们想查询最近一周最热门的Kotlin开源项目。</li>\n</ul><p>看到这里，你也许会好奇，<strong>KtHttpV1.create()是如何创建ApiService的实例的呢？</strong>要知道ApiService可是一个接口，我们要创建它的对象，必须要先定义一个类实现它的接口方法，然后再用这个类来创建对象才行。</p><p>不过在这里，我们不会使用这种传统的方式，而是会用<strong>动态代理</strong>，也就是JDK的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html">Proxy</a>。Proxy的底层，其实也用到了反射。</p><p>不过，由于这个案例涉及到的知识点都很抽象，在正式开始编写逻辑代码之前，我们先来看看下面这个动图，对整体的程序有一个粗略的认识。</p><p><img src="https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608" alt=""></p><p>现在，相信你大概就知道这个程序是如何实现的了。下面，我再带你来看看具体的代码是怎么写的。</p><p>这里我要先说明一点，为了不偏离这次实战课的主题，我们不会去深究Proxy的底层原理。在这里，<strong>你只需要知道，我们通过Proxy，就可以动态地创建ApiService接口的实例化对象</strong>。具体的做法如下：</p><pre><code class="language-plain">fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n\n    // 调用 Proxy.newProxyInstance 就可以创建接口的实例化对象\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service),\n        object : InvocationHandler{\n            override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any {\n                // 省略\n            }\n        }\n    ) as T\n}    \n</code></pre><p>在上面的代码当中，我们在create()方法当中，直接返回了Proxy.newProxyInstance()这个方法的返回值，最后再将其转换成了T类型。</p><p>那么，newProxyInstance()这个方法又是如何定义的呢？</p><pre><code class="language-java">public static Object newProxyInstance(ClassLoader loader,\n                                          Class&lt;?&gt;[] interfaces,\n                                          InvocationHandler h){ \n        ...\n}\n\npublic interface InvocationHandler {\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n</code></pre><p>从上面的代码当中，我们可以看到，最后一个参数，InvocationHandler其实是符合SAM转换要求的，所以我们的create()方法可以进一步简化成这样：</p><pre><code class="language-plain">fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service)\n    ) { proxy, method, args -&gt;\n        // 待完成\n    } as T\n}\n</code></pre><p>那么到这里，我们程序的基本框架也就搭建好了。</p><p>细心的你一定发现了，我们<strong>程序的主要逻辑还没实现</strong>，所以接下来，我们就一起看看上面那个“待完成”的InvocationHandler，这个Lambda表达式应该怎么写。这个换句话说，也就是Proxy.newProxyInstance()，会帮我们创建ApiService的实例对象，而ApiService当中的接口方法的具体逻辑，我们需要在Lambda表达式当中实现。</p><p>好了，让我们回过头来看看ApiService当中的代码细节：</p><pre><code class="language-plain">interface ApiService {\n// 假设我们的baseurl是：https://baseurl.com\n// 这里拼接结果会是这样：https://baseurl.com/repo\n//          ↓\n    @GET("/repo")\n    fun repos(\n    //                Field注解当中的lang，最终会拼接到url当中去\n    //            ↓                                                 ↓\n        @Field("lang") lang: String,  // https://baseurl.com/repo?lang=Kotlin\n        @Field("since") since: String // https://baseurl.com/repo?lang=Kotlin&amp;since=weekly\n    ): RepoList\n}\n</code></pre><p>从代码注释中可以看出来，其实我们真正需要实现的逻辑，就是想办法把注解当中的值/repo、lang、since取出来，然后拼接到URL当中去。那么，我们如何才能得到注解当中的值呢？</p><p>答案自然就是我们在上节课学过的：<strong>反射</strong>。</p><pre><code class="language-plain">object KtHttpV1 {\n\n    // 底层使用 OkHttp\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    // 使用 Gson 解析 JSON\n    private var gson: Gson = Gson()\n\n    // 这里以baseurl.com为例，实际上我们的KtHttpV1可以请求任意API\n    var baseUrl = "https://baseurl.com"\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n        return Proxy.newProxyInstance(\n            service.classLoader,\n            arrayOf&lt;Class&lt;*&gt;&gt;(service)\n        //           ①     ②\n        //           ↓      ↓\n        ) { proxy, method, args -&gt;\n            // ③\n            val annotations = method.annotations\n            for (annotation in annotations) {\n                // ④\n                if (annotation is GET) {\n                    // ⑤\n                    val url = baseUrl + annotation.value\n                    // ⑥\n                    return@newProxyInstance invoke(url, method, args!!)\n                }\n            }\n            return@newProxyInstance null\n\n        } as T\n    }\n\n    private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 待完成\n    }\n}\n</code></pre><p>在上面的代码中，一共有6个注释，我们一个个看。</p><ul>\n<li>注释①：method的类型是反射后的Method，在我们这个例子当中，它最终会代表被调用的方法，也就是ApiService接口里面的repos()这个方法。</li>\n<li>注释②：args的类型是对象的数组，在我们的例子当中，它最终会代表方法的参数的值，也就是“<code>api.repos("Kotlin", "weekly")</code>”当中的<code>"Kotlin"</code>和<code>"weekly"</code>。</li>\n<li>注释③：method.annotations，代表了我们会取出repos()这个方法上面的所有注解，由于repos()这个方法上面可能会有多个注解，因此它是数组类型。</li>\n<li>注释④：我们使用for循环，遍历所有的注解，找到GET注解。</li>\n<li>注释⑤：我们找到GET注解以后，要取出@GET(“/repo”)当中的"/repo"，也就是“annotation.value”。这时候我们只需要用它与baseURL进行拼接，就可以得到完整的URL；</li>\n<li>注释⑥：return@newProxyInstance，用的是Lambda表达式当中的返回语法，在得到完整的URL以后，我们将剩下的逻辑都交给了invoke()这个方法。</li>\n</ul><p>接下来，我们再来看看invoke()当中的“待完成代码”应该怎么写。</p><pre><code class="language-plain">private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly\n    // ② 使用okHttpClient进行网络请求\n    // ③ 使用gson进行JSON解析\n    // ④ 返回结果\n}\n</code></pre><p>在上面的代码中，我们的invoke()方法一共分成了四个步骤，其中的③、④两个步骤其实很容易实现：</p><pre><code class="language-plain">private fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // ① 根据url拼接参数，也就是：url + ?lang=Kotlin&amp;since=weekly\n\n    // 使用okHttpClient进行网络请求\n    val request = Request.Builder()\n            .url(url)\n            .build()\n    val response = okHttpClient.newCall(request).execute()\n\n    // ② 获取repos()的返回值类型 genericReturnType\n\n    // 使用gson进行JSON解析\n    val body = response.body\n    val json = body?.string()\n    //                              根据repos()的返回值类型解析JSON\n    //                                            ↓\n    val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n    // 返回结果\n    return result\n}\n</code></pre><p>继续看，经过我们的分解，现在的问题变成了下面这样：</p><ul>\n<li>注释①，利用反射，解析出“<code>api.repos("Kotlin", "weekly")</code>”这个方法当中的<code>"Kotlin"</code>和<code>"weekly"</code>，将其与URL进行拼接得到：<code>url + ?lang=Kotlin&amp;since=weekly</code></li>\n<li>注释②，利用反射，解析出repos()的返回值类型，用于JSON解析。</li>\n</ul><p>我们来看看最终的代码：</p><pre><code class="language-plain">private fun invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 条件判断\n    if (method.parameterAnnotations.size != args.size) return null\n\n    // 解析完整的url\n    var url = path\n    // ①\n    val parameterAnnotations = method.parameterAnnotations\n    for (i in parameterAnnotations.indices) {\n        for (parameterAnnotation in parameterAnnotations[i]) {\n            // ②\n            if (parameterAnnotation is Field) {\n                val key = parameterAnnotation.value\n                val value = args[i].toString()\n                if (!url.contains("?")) {\n                    // ③\n                    url += "?$key=$value"\n                } else {\n                    // ④\n                    url += "&amp;$key=$value"\n                }\n\n            }\n        }\n    }\n    // 最终的url会是这样：\n    // https://baseurl.com/repo?lang=Kotlin&amp;since=weekly\n\n    // 执行网络请求\n    val request = Request.Builder()\n        .url(url)\n        .build()\n    val response = okHttpClient.newCall(request).execute()\n\n    // ⑤\n    val genericReturnType = method.genericReturnType\n    val body = response.body\n    val json = body?.string()\n    // JSON解析\n    val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n    // 返回值\n    return result\n}\n</code></pre><p>上面的代码一共涉及五个注释，它们都是跟注解与反射这两个知识点相关的。</p><ul>\n<li>注释①，method.parameterAnnotations，它的作用是取出方法参数当中的所有注解，在我们这个案例当中，repos()这个方法当中涉及到两个注解，它们分别是<code>@Field("lang")</code>、<code>@Field("since")</code>。</li>\n<li>注释②，由于方法当中可能存在其他注解，因此要筛选出我们想要的Field注解。</li>\n<li>注释③，这里是取出注解当中的值“lang”，以及参数当中对应的值“Kotlin”进行拼接，URL第一次拼接参数的时候，要用“?”分隔。</li>\n<li>注释④，这里是取出注解当中的值“since”，以及参数当中对应的值“weekly”进行拼接，后面的参数拼接格式，是用“&amp;”分隔。</li>\n<li>注释⑤，method.genericReturnType取出repos()的返回值类型，也就是RepoList，最终，我们用它来解析JSON。</li>\n</ul><p>说实话，动态代理的这种模式，由于它大量应用了反射，加之我们的代码当中还牵涉到了泛型和注解，导致这个案例的代码不是那么容易理解。不过，我们其实可以利用<strong>调试</strong>的手段，去查看代码当中每一步执行的结果，这样就能对注解、反射、动态代理有一个更具体的认识。</p><p>前面带你看过的这个动图，其实就是在向你展示代码在调试过程中的关键节点，我们可以再来回顾一下整个代码的执行流程：</p><p><img src="https://static001.geekbang.org/resource/image/cf/95/cf441d3df1bb4b49432319e160cd3c95.gif?wh=1080x608" alt=""></p><p>相信现在，你已经能够体会我们使用 <strong>动态代理+注解+反射</strong> 实现这个网络请求框架的原因了。通过这样的方式，我们就不必在代码当中去实现每一个接口，而是只要是符合这样的代码模式，任意的接口和方法，我们都可以直接传进去。在这个例子当中，我们用的是ApiService这个接口，如果下次我们定义了另一个接口，比如说：</p><pre><code class="language-plain">interface GitHubService {\n    @GET("/search")\n    fun search(\n        @Field("id") id: String\n    ): User\n}\n</code></pre><p>这时候，我们的KtHttp根本不需要做任何的改动，直接这样调用即可：</p><pre><code class="language-plain">fun main() {\n    KtHttpV1.baseUrl = "https://api.github.com"\n    //       换一个接口名即可                  换一个接口名即可\n    //              ↓                             ↓                \n    val api: GitHubService = KtHttpV1.create(GitHubService::class.java)\n    val data: User = api.search(id = "JetBrains")\n}\n</code></pre><p>可以发现，使用动态代理实现网络请求的优势，它的<strong>灵活性</strong>是非常好的。只要我们定义的Service接口拥有对应的注解GET、Field，我们就可以通过注解与反射，将这些信息拼凑在一起。下面这个动图就展示了它们整体的流程：</p><p><img src="https://static001.geekbang.org/resource/image/8b/31/8b5997dc2f036020dc16a1a5efb8c531.gif?wh=1080x608" alt="图片"></p><p>实际上，我们的KtHttp，就是将URL的信息存储在了注解当中（比如lang和since），而实际的参数值，是在函数调用的时候传进来的（比如Kotlin和weekly）。我们通过泛型、注解、反射的结合，将这些信息集到一起，完成整个URL的拼接，最后才通过OkHttp完成的网络请求、Gson完成的解析。</p><p>好，到这里，我们1.0版本的开发就算是完成了。这里的单元测试代码很容易写，我就不贴出来了，<strong>单元测试是个好习惯，我们不能忘</strong>。</p><p>接下来，我们正式进入2.0版本的开发。</p><h2>2.0：函数式思维</h2><p>其实，如果你理解了1.0版本的代码，2.0版本的程序也就不难实现了。因为这个程序的主要功能都已经完成了，现在要做的只是：<strong>换一种思路重构代码</strong>。</p><p>我们先来看看KtHttpV1这个单例的成员变量：</p><pre><code class="language-plain">object KtHttpV1 {\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    private var gson: Gson = Gson()\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {}\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {}\n}\n</code></pre><p>okHttpClient、gson这两个成员是不支持懒加载的，因此我们首先应该让它们<strong>支持懒加载</strong>。</p><pre><code class="language-plain">object KtHttpV2 {\n    private val okHttpClient by lazy { OkHttpClient() }\n    private val gson by lazy { Gson() }\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {}\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? {}\n}\n</code></pre><p>这里，我们直接使用了by lazy委托的方式，它简洁的语法可以让我们快速实现懒加载。<br>\n接下来，我们再来看看create()这个方法的定义：</p><pre><code class="language-plain">//                      注意这里\n//                         ↓\nfun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n    return Proxy.newProxyInstance(\n        service.classLoader,\n        arrayOf&lt;Class&lt;*&gt;&gt;(service)\n    ) { proxy, method, args -&gt;\n    }\n}\n</code></pre><p>在上面的代码中，create()会接收一个<code>Class&lt;T&gt;</code>类型的参数。其实，针对这样的情况，我们完全可以省略掉这个参数。具体做法，是使用我们前面学过的<a href="https://time.geekbang.org/column/article/477295">inline</a>，来实现<strong>类型实化</strong>（Reified Type）。我们常说，Java的泛型是伪泛型，而这里我们要实现的就是真泛型。</p><pre><code class="language-plain">//  注意这两个关键字\n//  ↓          ↓\ninline fun &lt;reified T&gt; create(): T {\n    return Proxy.newProxyInstance(\n        T::class.java.classLoader, // ① 变化在这里\n        arrayOf(T::class.java) // ② 变化在这里\n    ) { proxy, method, args -&gt;\n        // 待重构\n    }\n}\n</code></pre><p>正常情况下，泛型参数<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">类型会被擦除</a>，这就是Java的泛型被称为“伪泛型”的原因。而通过使用<strong>inline和reified</strong>这两个关键字，我们就能实现类型实化，也就是“真泛型”，进一步，我们就可以在代码注释①、②的地方，使用“T::class.java”来得到Class对象。</p><p>下面，我们来看看KtHttp的主要逻辑该如何重构。</p><p>为了方便理解，我们会使用Kotlin标准库当中已有的高阶函数，尽量不去涉及函数式编程里的高级概念。<strong>在这里我强烈建议你打开IDE一边敲代码一边阅读</strong>，这样一来，当你遇到不熟悉的标准函数时，就可以随时去看它的实现源码了。相信在学习过第7讲的<a href="https://time.geekbang.org/column/article/476637">高阶函数</a>以后，这些库函数都不会难倒你。</p><p>首先，我们来看看create()里面“待重构”的代码该如何写。在这个方法当中，我们需要读取method当中的GET注解，解析出它的值，然后与baseURL拼接。这里我们完全可以<strong>借助Kotlin的标准库函数</strong>来实现：</p><pre><code class="language-plain">inline fun &lt;reified T&gt; create(): T {\n    return Proxy.newProxyInstance(\n        T::class.java.classLoader,\n        arrayOf(T::class.java)\n    ) { proxy, method, args -&gt;\n\n        return@newProxyInstance method.annotations\n            .filterIsInstance&lt;GET&gt;()\n            .takeIf { it.size == 1 }\n            ?.let { invoke("$baseUrl${it[0].value}", method, args) }\n    } as T\n}\n</code></pre><p>这段代码的可读性很好，我们可以像读英语文本一样来阅读：</p><ul>\n<li>首先，我们通过method.annotations，来获取method的所有注解；</li>\n<li>接着，我们用<code>filterIsInstance&lt;GET&gt;()</code>，来筛选出我们想要找的GET注解。这里的filterIsInstance其实是filter的升级版，也就是<strong>过滤</strong>的意思；</li>\n<li>之后，我们判断GET注解的数量，它的数量必须是1，其他的都不行，这里的takeIf其实相当于我们的if；</li>\n<li>最后，我们通过拼接出URL，然后将程序执行流程交给invoke()方法。这里的"?.let{}"相当于判空。</li>\n</ul><p>好了，create()方法的重构已经完成，接下来我们来看看invoke()方法该如何重构。</p><pre><code class="language-plain">fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? =\n    method.parameterAnnotations\n        .takeIf { method.parameterAnnotations.size == args.size }\n        ?.mapIndexed { index, it -&gt; Pair(it, args[index]) }\n        ?.fold(url, ::parseUrl)\n        ?.let { Request.Builder().url(it).build() }\n        ?.let { okHttpClient.newCall(it).execute().body?.string() }\n        ?.let { gson.fromJson(it, method.genericReturnType) }\n</code></pre><p>这段代码读起来也不难，我们一行一行来分析。</p><ul>\n<li>第一步，我们通过method.parameterAnnotations，获取方法当中所有的参数注解，在这里也就是<code>@Field("lang")</code>、<code>@Field("since")</code>。</li>\n<li>第二步，我们通过takeIf来判断，参数注解数组的数量与参数的数量相等，也就是说<code>@Field("lang")</code>、<code>@Field("since")</code>的数量是2，那么<code>["Kotlin", "weekly"]</code>的size也应该是2，它必须是一一对应的关系。</li>\n<li>第三步，我们将<code>@Field("lang")</code>与<code>"Kotlin"</code>进行配对，将<code>@Field("since")</code>与<code>"weekly"</code>进行配对。这里的mapIndexed，其实就是map的升级版，它本质还是一种映射的语法，“注解数组类型”映射成了“Pair数组”，只是多了一个index而已。</li>\n<li>第四步，我们使用fold与parseUrl()这个方法，拼接出完整的URL，也就是：<a href="https://baseurl.com/repo?lang=Kotlin&since=weekly">https://baseurl.com/repo?lang=Kotlin&amp;since=weekly</a>。 这里我们使用了<strong>函数引用</strong>的语法“::parseUrl”。而fold这个操作符，其实就是高阶函数版的for循环。</li>\n<li>第五步，我们构建出OkHttp的Request对象，并且将URL传入了进去，准备做网络请求。</li>\n<li>第六步，我们通过okHttpClient发起了网络请求，并且拿到了String类型的JSON数据。</li>\n<li>最后，我们通过Gson解析出JSON的内容，并且返回RepoList对象。</li>\n</ul><p>到目前为止，我们的invoke()方法的主要流程就分析完了，接下来我们再来看看用于实现URL拼接的parseUrl()是如何实现的。</p><pre><code class="language-plain">private fun parseUrl(acc: String, pair: Pair&lt;Array&lt;Annotation&gt;, Any&gt;) =\n    pair.first.filterIsInstance&lt;Field&gt;()\n        .first()\n        .let { field -&gt;\n            if (acc.contains("?")) {\n                "$acc&amp;${field.value}=${pair.second}"\n            } else {\n                "$acc?${field.value}=${pair.second}"\n            }\n        }\n</code></pre><p>可以看到，这里我们只是把从前的for循环代码，换成了 <strong>Kotlin的集合操作符</strong>而已。大致流程如下：</p><ul>\n<li>首先，我们从注解的数组里筛选出Field类型的注解；</li>\n<li>接着，通过first()取出第一个Field注解，这里它也应该是唯一的；</li>\n<li>最后，我们判断当前的acc是否已经拼接过参数，如果没有拼接过，就用“?”分隔，如果已经拼接过参数，我们就用“&amp;”分隔。</li>\n</ul><p>至此，我们2.0版本的代码就完成了，完整的代码如下：</p><pre><code class="language-plain">object KtHttpV2 {\n\n    private val okHttpClient by lazy { OkHttpClient() }\n    private val gson by lazy { Gson() }\n    var baseUrl = "https://baseurl.com" // 可改成任意url\n\n    inline fun &lt;reified T&gt; create(): T {\n        return Proxy.newProxyInstance(\n            T::class.java.classLoader,\n            arrayOf(T::class.java)\n        ) { proxy, method, args -&gt;\n\n            return@newProxyInstance method.annotations\n                .filterIsInstance&lt;GET&gt;()\n                .takeIf { it.size == 1 }\n                ?.let { invoke("$baseUrl${it[0].value}", method, args) }\n        } as T\n    }\n\n    fun invoke(url: String, method: Method, args: Array&lt;Any&gt;): Any? =\n        method.parameterAnnotations\n            .takeIf { method.parameterAnnotations.size == args.size }\n            ?.mapIndexed { index, it -&gt; Pair(it, args[index]) }\n            ?.fold(url, ::parseUrl)\n            ?.let { Request.Builder().url(it).build() }\n            ?.let { okHttpClient.newCall(it).execute().body?.string() }\n            ?.let { gson.fromJson(it, method.genericReturnType) }\n\n\n    private fun parseUrl(acc: String, pair: Pair&lt;Array&lt;Annotation&gt;, Any&gt;) =\n        pair.first.filterIsInstance&lt;Field&gt;()\n            .first()\n            .let { field -&gt;\n                if (acc.contains("?")) {\n                    "$acc&amp;${field.value}=${pair.second}"\n                } else {\n                    "$acc?${field.value}=${pair.second}"\n                }\n            }\n}\n</code></pre><p>对应的，我们可以再看看1.0版本的完整代码：</p><pre><code class="language-plain">object KtHttpV1 {\n\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    private var gson: Gson = Gson()\n    var baseUrl = "https://baseurl.com" // 可改成任意url\n\n    fun &lt;T&gt; create(service: Class&lt;T&gt;): T {\n        return Proxy.newProxyInstance(\n            service.classLoader,\n            arrayOf&lt;Class&lt;*&gt;&gt;(service)\n        ) { proxy, method, args -&gt;\n            val annotations = method.annotations\n            for (annotation in annotations) {\n                if (annotation is GET) {\n                    val url = baseUrl + annotation.value\n                    return@newProxyInstance invoke(url, method, args!!)\n                }\n            }\n            return@newProxyInstance null\n\n        } as T\n    }\n\n    private fun invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        if (method.parameterAnnotations.size != args.size) return null\n\n        var url = path\n        val parameterAnnotations = method.parameterAnnotations\n        for (i in parameterAnnotations.indices) {\n            for (parameterAnnotation in parameterAnnotations[i]) {\n                if (parameterAnnotation is Field) {\n                    val key = parameterAnnotation.value\n                    val value = args[i].toString()\n                    if (!url.contains("?")) {\n                        url += "?$key=$value"\n                    } else {\n                        url += "&amp;$key=$value"\n                    }\n\n                }\n            }\n        }\n\n        val request = Request.Builder()\n            .url(url)\n            .build()\n\n        val response = okHttpClient.newCall(request).execute()\n\n        val genericReturnType = method.genericReturnType\n        val body = response.body\n        val json = body?.string()\n        val result = gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n\n        return result\n    }\n}\n</code></pre><p>可见，1.0版本、2.0版本，它们之间可以说是天壤之别。</p><h2>小结</h2><p>好了，这节实战就到这里。接下来我们来简单总结一下：</p><ul>\n<li>在1.0版本的代码中，我们灵活利用了<strong>动态代理、泛型、注解、反射</strong>这几个技术，实现了KtHttp的基础功能。</li>\n<li><strong>动态代理</strong>，由于它的底层原理比较复杂，课程当中我是通过ApiImpl这个类，来模拟了它动态生成的Proxy类。用这种直观的方式来帮助你理解它存在的意义。</li>\n<li><strong>泛型</strong>方面，我们将其用在了动态代理的create()方法上，后面我们还使用了“类型实化”的技术，也就是inline + reified关键字。</li>\n<li><strong>注解</strong>方面，我们首先自定义了两个注解，分别是GET、Field。其中，@GET用于标记接口的方法，它的值是URL的path；@Field用于标记参数，它的值是参数的key。</li>\n<li><strong>反射</strong>方面，这个技术点，几乎是贯穿于整个代码实现流程的。我们通过反射的自省能力，去分析repos()方法，从GET注解当中取出了“/repo”这个path，从注解Field当中取出了lang、since，还取出了repos()方法的返回值RepoList，用于JSON数据的解析。</li>\n<li>在2.0版本的代码中，我们几乎删除了之前所有的代码，<strong>以函数式的思维重写</strong>了KtHttp的内部逻辑。在这个版本当中，我们大量地使用了Kotlin标准库里的高阶函数，进一步提升了代码的可读性。</li>\n</ul><p>在前面的<a href="https://time.geekbang.org/column/article/478106">加餐</a>课程当中，我们也讨论过Kotlin的编程范式问题。<strong>命令式还是函数式，这完全取决于我们开发者自身。</strong></p><p>相比起前面实战课中的<a href="https://time.geekbang.org/column/article/477295">单词频率统计程序</a>，这一次我们的函数式范式的代码，实现起来就没有那么得流畅了。原因其实也很简单，Kotlin提供了强大的集合操作符，这就让Kotlin十分擅长“集合操作”的场景，因此词频统计程序，我们不到10行代码就解决了。而对于注解、反射相关的场景，函数式的编程范式就没那么擅长了。</p><p>在这节课里，我之所以费尽心思地用函数式风格，重构出KtHttp 2.0版本，主要还是想让你看到函数式编程在它不那么擅长的领域表现会如何。毕竟，我们在工作中什么问题都可能会遇到。</p><h2>思考题</h2><p>好了，学完这节课以后，请问你有哪些感悟和收获？请在评论区里分享出来，我们一起交流吧！</p>',
        article_title: "12 | 实战：用Kotlin实现一个网络请求框架KtHttp",
      },
      {
        title: "加餐二 | 什么是“表达式思维”？",
        id: 482603,
        content:
          '<p>你好，我是朱涛。</p><p>在<a href="https://time.geekbang.org/column/article/472129">开篇词</a>当中，我曾经说过，学好Kotlin的关键在于<strong>思维的转变</strong>。在上一次<a href="https://time.geekbang.org/column/article/478106">加餐课程</a>当中，我给你介绍了Kotlin的函数式编程思想，相信你对Kotlin的“函数思维”已经有了一定的体会。那么今天这节课，我们就来聊聊Kotlin的<strong>表达式思维</strong>。</p><p>所谓编程思维，其实是一种非常抽象的概念，很多时候是只可意会不可言传的。不过，从某种程度上看，学习编程思维，比学习编程语法还要重要。因为<strong>编程思维决定着我们的代码整体的架构与风格</strong>，而具体的某个语法反而没那么大的影响力。当然，如果对Kotlin的语法没有一个全面的认识，编程思维也只会是空中楼阁。</p><p>所以，准确地来说，掌握Kotlin的编程思维，是在掌握了Kotlin语法基础上的一次升华。这就好比是，我们学会了基础的汉字以后开始写作文一样。学了汉字以后，如果不懂得写作的技巧，是写不出优美的文章的。同理，如果学了Kotlin语法，却没有掌握它的编程思维，也是写不出优雅的Kotlin代码的。</p><p>好，那么接下来，我们就来看看Kotlin的表达式思维。</p><h2>表达式思维</h2><p>在正式开始学习表达式思维之前，我们先来看一段简单的Kotlin代码。</p><pre><code class="language-plain">var i = 0\nif (data != null) {\n    i = data\n}\n\nvar j = 0\nif (data != null) {\n    j = data\n} else {\n    j = getDefault()\n    println(j)\n}\n\nvar k = 0\nif (data != null) {\n    k = data\n} else {\n    throw NullPointerException()\n}\n\nvar x = 0\nwhen (data) {\n    is Int -&gt; x = data\n    else -&gt; x = 0\n}\n\nvar y = 0\ntry {\n    y = "Kotlin".toInt()\n} catch (e: NumberFormatException) {\n    println(e)\n    y = 0\n}\n</code></pre><!-- [[[read_end]]] --><p>这些代码，如果我们用Java的思维来分析的话，是挑不出太多毛病的。但是站在Kotlin的角度，就完全不一样了。</p><p>利用Kotlin的语法，我们完全可以将代码写得更加简洁，就像下面这样：</p><pre><code class="language-plain">val i = data ?: 0\nval j = data ?: getDefault().also { println(it) }\n\nval k = data?: throw NullPointerException()\n\n\n\nval x = when (data) {\n    is Int -&gt; data\n    else -&gt; 0\n}\n\nval y = try {\n    "Kotlin".toInt()\n} catch (e: NumberFormatException) {\n    println(e)\n    0\n}\n</code></pre><p>这段代码看起来就简洁了不少，但如果你有Java经验，你在写代码的时候，脑子里第一时间想到的一定不是这样的代码模式。这个，也是我们需要格外注意培养表达式思维的原因。</p><p>不过，现在你心里可能已经出现了一个疑问：<strong>Kotlin凭什么就能用这样的方式写代码呢？<strong>其实这是因为：if、when、throw、try-catch这些语法，在Kotlin当中都是</strong>表达式</strong>。</p><p>那么，这个“表达式”到底是什么呢？其实，与<a href="https://kotlinlang.org/spec/expressions.html#expressions">表达式</a>（Expression）对应的，还有另一个概念，我们叫做<a href="https://kotlinlang.org/spec/statements.html#statements">语句</a>（Statement）。这两者的准确定义其实很复杂，你可以点击我这里给出的链接去看看它们之间区别。</p><p>不过我们可以先简单来概括一下：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong>这样解释还是有些抽象，我们来看一些例子：</p><pre><code class="language-plain">val a = 1    // statement\nprintln(a)   // statement\n\n// statement\nvar i = 0\nif (data != null) {\n    i = data\n}\n\n// 1 + 2 是一个表达式，但是对b的赋值行为是statement\nval b = 1 + 2\n\n// if else 整体是一个表达式\n// a &gt; b是一个表达式\n// a - b是一个表达式\n// b - a是一个表达式。\nfun minus(a: Int, b: Int) = if (a &gt; b) a - b else b - a\n\n// throw NotImplementedError() 是一个表达式\nfun calculate(): Int = throw NotImplementedError()\n</code></pre><p>这段代码是描述了常见的Kotlin代码模式，从它的注释当中，我们其实可以总结出这样几个规律：</p><ul>\n<li>赋值语句，就是典型的statement；</li>\n<li>if语法，既可以作为语句，也可以作为表达式；</li>\n<li>语句与表达式，它们可能会出现在同一行代码中，比如val b = 1 + 2；</li>\n<li>表达式还可能包含“子表达式”，就比如这里的minus方法；</li>\n<li>throw语句，也可以作为表达式。</li>\n</ul><p>但是看到这里，你的心中应该还是有一个疑问没有解开，那就是：<strong>calculate()这个函数难道不会引起编译器报错吗？</strong></p><pre><code class="language-plain">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int\n//                ↓       ↓\nfun calculate(): Int = throw NotImplementedError()\n</code></pre><p>确实，在刚开始接触Kotlin的时候，我也无法理解这样的代码。直到我弄清楚Kotlin整个类型系统以后，我才真正找到答案。</p><p>所以，为了让你能真正理解Kotlin表达式背后的原理，接下来，我们就来系统学习一下Kotlin的类型系统吧。</p><h2>类型系统</h2><p>在课程的<a href="https://time.geekbang.org/column/article/472154">第1讲</a>我们就学过，在Kotlin当中，Any是所有类型的父类，我们可以称之为<strong>根类型</strong>。同时，我们也学过，Kotlin的类型还分为<strong>可空类型</strong>和<strong>不可空类型</strong>。举个例子，对于字符串类型，就有String、String?，它们两者分别代表了不为空的字符串、可能为空的字符串。</p><p>在这个基础上，我们很容易就能推测出，Kotlin的类型体系应该是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/18/40/1873d04968cd8aca90381b9f84651f40.jpg?wh=2000x979" alt=""></p><p>也就是，Any是所有非空类型的根类型；而Any?是所有可空类型的根类型。那么现在，你可能会想到这样的一个问题：<strong>Any与Any?之间是什么关系呢？</strong></p><h3>Any与Any?与Object</h3><p>从表面上看，这两个确实没有继承关系。不过，它们之间其实是存在一些微妙的联系的。</p><p>在Kotlin当中，我们可以把“子类型”赋值给“父类型”，就像下面的代码一样：</p><pre><code class="language-plain">val s: String = ""\nval any: Any = s\n</code></pre><p>由于String是Any的子类型，因此，我们可以将String类型赋值给Any类型。而实际上，Any和“Any?”之间也是类似的，我们可以将Any类型赋值给“Any？”类型，反之则不行。</p><pre><code class="language-plain">val a: Any = ""\nval b: Any? = a // 通过\n\nval c: Any = b  // 报错\n</code></pre><p>类似的，String类型可以赋值给“String？”类型，反之也不行。你可能会想这是为什么呢？<br>\n其实，<strong>任何类型，当它被“?”修饰，变成可空类型以后，它就变成原本类型的父类了。<strong>所以，从某种程度上讲，我们可以认为“Any？”是所有Kotlin类型的</strong>根类型</strong>。它的具体关系如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/d9/dd/d904d1ed5df67211058yya5098868cdd.jpg?wh=2000x1044" alt=""></p><p>因此，我们可以说：虽然Any与Any？之间没有继承的关系，但是我们可以将Any看作是Any？的子类；String类型可以看作是String？的子类。</p><p>而由于Any与“Any？”之间并没有明确的继承关系，但它们又存在父子类型的关系，所以在上面的示意图中，我们用虚线来表示。</p><p>所以到这里，我们就弄明白了一个问题：<strong>Kotlin的Any与Java的Object之间是什么关系？</strong></p><p>那么，答案也是显而易见的，Java当中的Object类型，对应Kotlin的“Any？”类型。但两者并<strong>不完全等价</strong>，因为Kotlin的Any可以没有wait()、notify()之类的方法。因此，我们只能说Kotlin的“Any？”与Java的Object是大致对应的。Intellij有一个功能，可以将Java代码转换成Kotlin代码，我们可以借此印证。</p><p>这是一段Java代码，它有三个方法，分别是可为空的Object类型、不可为空的Object类型，以及无注解的Object类型。</p><pre><code class="language-java">public class TestType {\n\n    @Nullable  // 可空注解\n    public Object test() { return null; }\n\n    public Object test1() { return null; }\n\n    @NotNull  // 不可空注解\n    public Object test2() { return 1; }\n}\n</code></pre><p>上面的代码转换成Kotlin以后，会变成这样：</p><pre><code class="language-plain">class TestType {\n    fun test(): Any? { return null }\n\n    fun test1(): Any? { return null }\n\n    fun test2(): Any { return 1 }\n}\n</code></pre><p>由此可见，在没有注解标明可空信息的时候，Object类型是会被当作“Any？”来看待的。而在有了注解修饰以后，Kotlin就能够识别出到底是Any，还是“Any？”。</p><h3>Unit与Void与void</h3><p>在Kotlin当中，除了普通的Any、String的类型之外，还有一个特殊的类型，叫做<strong>Unit</strong>。而Unit这个类型，经常会被拿来和Java的Void、void来对比。</p><p>那么在这里，你首先需要知道的是：在Java当中，Void和void不是一回事（注意大小写），前者是一个Java的类，后者是一个用于修饰方法的关键字。如下所示：</p><pre><code class="language-plain">public final class Void {\n\n    public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass("void");\n\n    private Void() {}\n}\n</code></pre><p>从语法含义上来讲，Kotlin的Unit与Java的void更加接近，但Unit远不止于此。在Kotlin当中，Unit也是一个类，这点跟Void又有点像。比如，在下面的代码中，Unit是一个类型的同时，还是一个单例：</p><pre><code class="language-plain">public object Unit {\n    override fun toString() = "kotlin.Unit"\n}\n</code></pre><p>所以，我们就可以用Unit写出很灵活的代码。就像下面这样：</p><pre><code class="language-plain">fun funUnit(): Unit { }\n\nfun funUnit1(): Unit { return Unit }\n</code></pre><p>可以看到，当返回值类型是Unit的时候，我们既可以选择不写return，也可以选择return一个Unit的单例对象。</p><p>另外，在使用泛型编程的时候，当T类型作为返回值类型的时候，我们传入Unit以后，就不再需要写return了。</p><pre><code class="language-plain">interface Task&lt;T&gt; {\n    fun excute(any: Any): T\n}\n\nclass PrintTask: Task&lt;Unit&gt; {\n    override fun excute(any: Any) {\n        println(any)\n        // 这里写不写return都可以\n    }\n}\n</code></pre><p>更重要的是，Unit还有助于我们实现函数类型。</p><pre><code class="language-plain">val f: () -&gt; Unit = {}\n</code></pre><p>所以，Kotlin的Unit与Java的Void或者void并不存在等价的关系，但它们之间确实存在一些概念上的相似性。至此，我们也可以更新一下前面那个类型系统关系图了：</p><p><img src="https://static001.geekbang.org/resource/image/74/7f/74e9ea7a804e30bc0e49982ce12f547f.jpg?wh=2000x1036" alt=""></p><p>可见，Unit其实和String类型一样，就是一个普通的类。只是因为Kotlin编译器会特殊对待它，当Unit作为返回值类型的时候，可以不需要return。</p><p>好了，接着，我们再来看看Kotlin当中经常被提到的Nothing类型。</p><h3>Nothing</h3><p>在有了前面的基础以后呢，Nothing就很容易理解了。其实，<strong>Nothing就是Kotlin所有类型的子类型</strong>。</p><p>Nothing的概念与“Any?”恰好相反。“Any?”是所有的Kotlin类型的父类，Nothing则是所有类型的子类。如果用一张图来概括，大概会是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt=""></p><p>事实上，像Nothing这样的概念，在函数式编程当中，也被叫做<strong>底类型</strong>（Bottom Type），因为它位于整个类型体系的最底部。</p><p>而了解了Kotlin的Nothing类型以后，我们其实就可以尝试着来解答前面例子中留下来的疑问了：</p><pre><code class="language-plain">//       函数返回值类型是Int，实际上却抛出了异常，没有返回Int\n//                ↓       ↓\nfun calculate(): Int = throw NotImplementedError() // 不会报错\n\n//       函数返回值类型是Any，实际上却抛出了异常，没有返回Any\n//                ↓       ↓\nfun calculate1(): Any = throw Exception() // 不会报错\n\n//       函数返回值类型是Unit，实际上却抛出了异常，没有返回Unit\n//                 ↓       ↓\nfun calculate2(): Unit = throw Exception() // 不会报错\n</code></pre><p>根据这段代码可以发现，不管函数的返回值类型是什么，我们都可以使用抛出异常的方式来实现它的功能。这样我们其实就可以推测出一个结论：<strong>throw这个表达式的返回值是Nothing类型。</strong>而既然Nothing是所有类型的子类型，那么它当然是可以赋值给任意其他类型的。</p><p>可是，我们如何才能印证这个结论是否正确呢？很简单，我们可以把两个函数的返回值类型都改成Nothing，然后看看编译器会不会报错：</p><pre><code class="language-plain">// 不会报错\nfun calculate(): Nothing = throw NotImplementedError() \n\n// 不会报错\nfun calculate1(): Nothing = throw Exception() \n\n// Nothing构造函数是私有的，因此我们无法构造它的实例\npublic class Nothing private constructor()\n</code></pre><p>可见，编译器仍然不会报错。这也就印证了我们前面的猜测：throw表达式的返回值类型是Nothing。</p><p>另外，我们应该也注意到了Nothing类的构造函数是私有的，因此我们无法构造出它的实例。而当Nothing类型作为函数参数的时候，一个有趣的现象就出现了：</p><pre><code class="language-plain">// 这是一个无法调用的函数，因为找不到合适的参数\nfun show(msg: Nothing) {\n}\n\nshow(null) // 报错\nshow(throw Exception()) // 虽然不报错，但方法仍然不会调用\n</code></pre><p>这里我们定义的这个show方法，它的参数类型是Nothing，而由于Nothing的构造函数是私有的，这就导致我们将无法调用show这个函数，除非我们抛出异常，但这没有意义。这个概念在泛型星投影的时候是有应用的，具体你可以点击<a href="https://kotlinlang.org/docs/generics.html#star-projections">这个链接</a>去查看详情。</p><p>而除此之外，Nothing还有助于编译器进行代码流程的推断。比如说，当一个表达式的返回值是Nothing的时候，就往往意味着它后面的语句不再有机会被执行。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/33/5a/3365f67ab5f828ef23af65484d317a5a.png?wh=676x371" alt="图片"></p><p>在了解了Unit与Nothing这两个不可空的类型以后，我们再来看看它们对应的可空类型。</p><h3>Unit?与Nothing?</h3><p>也许你也注意到了，Unit对应的还有一个“Unit?”类型，那么这个类型有什么意义吗？</p><p>我们可以看看下面的代码：</p><pre><code class="language-plain">fun f1(): Unit? { return null } // 通过\n\nfun f2(): Unit? { return Unit } // 通过\n\nfun f3(): Unit? { throw Exception() } // 通过\n\nfun f4(): Unit? { } // 报错，缺少return\n</code></pre><p>可见，Kotlin编译器只会把Unit类型当作无需返回值的类型，而Unit?则不行。</p><p>所以，Unit?这个类型其实没有什么广泛的应用场景，因为它失去了原本的编译器特权后，就只能有3种实现方式，即null、Unit单例、Nothing。也就是说，当Unit?作为返回值的时候，我们的函数必须要return一个值了，它返回值的类型可以是null、Unit单例、Nothing这三种情况。</p><p>好，接下来我们再来看看“Nothing?”这个类型。</p><pre><code class="language-plain">fun calculate1(): Nothing? = null\nfun calculate2(): Nothing? = throw Exception()\n</code></pre><p>由以上代码示例可知，当Nothing?作为返回值类型的时候，我们可以返回null，或者是抛出异常。这一切都符合预期，而当它作为函数参数的时候，也会有一些有趣的变化。</p><pre><code class="language-plain">//               变化在这里\n//                   ↓\nfun show(msg: Nothing?) {\n}\n\nshow(null) // 通过\nshow(throw Exception()) // 虽然不报错，但方法仍然不会调用\n</code></pre><p>可以看到，当参数类型是Nothing?的时候，我们的函数仍然是可以调用的。这其实就能进一步说明一个问题：<strong>Nothing才是底类型，而“Nothing?”则不是底类型。</strong><br>\n这一点其实在前面的类型关系图中就有体现，现在你就可以真正理解了：</p><p><img src="https://static001.geekbang.org/resource/image/35/3a/35dd00d1acyyd43b7b72dc4cf84d3c3a.jpg?wh=2000x1125" alt=""></p><p>到这里相信你也明白了，“Unit?”“Nothing?”这两个类型，其实并没有太多实际的应用场景，不过由于它们是Kotlin类型系统当中特殊的类型，因此我们也应该对它们有个清晰的认识。</p><p>这样，在系统学习了Kotlin的类型系统以后，我们对表达式理解就可以更上一层楼了。</p><h2>表达式的本质</h2><p>我们再来看看表达式的定义：<strong>表达式，是一段可以产生值的代码；而语句，则是一句不产生值的代码。</strong></p><p>也许你听说过这样一句话：在Kotlin当中，一切都是表达式。<strong>注意！这句话其实是错的。</strong>因为Kotlin当中还是存在语句的，比如while循环、for循环，等等。</p><p>不过，如果我们换个说法：<strong>在Kotlin当中，大部分代码都是表达式。</strong>这句话就对了。Kotlin的类型系统当中的Unit和Nothing，让很多原本无法产生返回值的语句，变成了表达式。</p><p>我们来举个例子：</p><pre><code class="language-plain">// statement\nprintln("Hello World.")\n\n// println("Hello World.") 变成了表达式\nval a = println("Hello World.")\n\n// statement\nthrow Exception()\n\n// throw 变成了表达式\nfun test1() = throw Exception() \n</code></pre><p>从上面的代码案例中，我们可以总结出两个规律。</p><ul>\n<li>由于Kotlin存在Unit这个类型，因此println(“Hello World.”)这行代码也可以变成表达式，它所产生的值就是Unit这个单例。</li>\n<li>由于Kotlin存在Nothing这个类型，因此throw也可以作为表达式，它所产生的值就是Nothing类型。</li>\n</ul><p>注意，因为Java当中不存在Unit、Nothing这样的类型，所以Java里返回值为void的函数是无法成为表达式的，另外，throw这样的语句也是无法成为表达式的。而也正是因为Kotlin这样的类型系统，才让大部分的语句都摇身一变成为了表达式。因为Unit、Nothing在Kotlin编译器看来，也是所有类型当中的一种。</p><p>可以说，Unit和Nothing填补了原本Java当中的类型系统，让Kotlin的类型系统更加全面。也正因为如此，Kotlin才可以拥有真正的函数类型，比如：</p><pre><code class="language-plain">val f: (String) -&gt; Unit = ::println\n</code></pre><p>可以看到，如果不存在Unit这个类型，我们是无法描述println这个函数的类型的。正因为println函数的返回值类型为Unit，我们才可以用“(String) -&gt; Unit”来描述它。</p><p>换句话说就是：<strong>Kotlin的类型系统让大部分的语句都变成了表达式，同时也让无返回值的函数有了类型。</strong></p><p>而所谓的表达式思维，其实就是要求我们开发者在编程的时候，<strong>时刻记住Kotlin大部分的语句都是可以作为表达式的</strong>，并且由于表达式都是有返回值的，这也就让我们可以用一种全新的思维来写代码。这在很多时候，都可以大大简化我们的代码逻辑。</p><p>那么现在，我们再回过头看之前的代码，就会觉得很顺眼了：</p><pre><code class="language-plain">val i = data ?: 0\nval j = data ?: getDefault().also { println(it) }\n\nval k = data?: throw NullPointerException()\n\n\nval x = when (data) {\n    is Int -&gt; data\n    else -&gt; 0\n}\n\nval y = try {\n    "Kotlin".toInt()\n} catch (e: NumberFormatException) {\n    0\n}\n</code></pre><h2>小结</h2><p>好，今天这节加餐，到这里就接近尾声了，我们来做个简单的总结。</p><ul>\n<li>所谓的<strong>表达式思维</strong>，就是要时刻记住：Kotlin大部分的语句都是表达式，它是可以产生返回值的。利用这种思维，往往可以大大简化代码逻辑。</li>\n<li>Any是所有非空类型的根类型，而“Any?”才是所有类型的<strong>根类型</strong>。</li>\n<li>Unit与Java的void类型，代表一个函数不需要返回值；而“Unit?”这个类型则没有太多实际的意义。</li>\n<li>当Nothing作为函数返回值的时候，意味着这个函数永远不会返回结果，而且还会截断程序的后续流程。Kotlin编译器也会根据这一点，进行流程分析。</li>\n<li>当Nothing作为函数参数的时候，就意味着这个函数永远无法被正常调用。这在泛型星投影的时候是有一定应用的。</li>\n<li>另外，Nothing可以看作是“Nothing?”子类型，因此，Nothing可以看作是Kotlin所有类型的<strong>底类型</strong>。</li>\n<li>正是因为Kotlin在类型系统当中，加入了Unit、Nothing这两个类型，才让大部分无法产生值的语句摇身一变，成为了表达式。这也是“Kotlin大部分的语句都是表达式”的根本原因。</li>\n</ul><h2>思考题</h2><p>这节课，我们学习了表达式思维，请问，你觉得它和我们前面学到的“函数式编程”有联系吗？为什么？欢迎在留言区分享你的答案和思考，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "加餐二 | 什么是“表达式思维”？",
      },
      {
        title: "加餐三 | 什么是“不变性思维”？",
        id: 484631,
        content:
          '<p>你好，我是朱涛。</p><p>在<a href="https://time.geekbang.org/column/article/472129">开篇词</a>里，我提到过学习Kotlin的五种思维转变，包括前面加餐中讲过的函数思维、表达式思维，以及接下来要给你介绍的不变性思维、空安全思维以及协程思维。所以今天，我们就一起来聊聊Kotlin的不变性思维。</p><p>Kotlin将不变性的思想发挥到了极致，并将其融入到了语法当中。当开发者想要定义一个变量的时候，必须明确规定这个变量是<strong>可变的</strong>（var），还是<strong>不可变的</strong>（val）。在定义集合变量的时候，也同样需要明确规定这个集合是可变的（比如MutableList），还是不可变的（比如List）。</p><p>不过，不变性其实会被很多Kotlin初学者所忽略。尤其是有Java、C经验的开发者，很容易将老一套思想照搬到Kotlin当中来，为了方便，写出来的变量全部都是var的，写出来的集合都是MutableXXX。</p><p>事实上，不变性思维，对我们写出优雅且稳定的Kotlin代码很关键。要知道，我们代码中很多的Bug都是因为某个变量被多个调用方改来改去，最后导致状态错误才出问题的。毕竟，变动越多，就越容易出错！</p><p><strong>那么，既然可变性这么“可恶”，我们为何不干脆直接在语法层面消灭var、MutableXXX这样的概念呢</strong>？</p><!-- [[[read_end]]] --><p>这当然是不行的，因为我们的程序本身就是“为了产生变化而生的”。你想想，如果你的程序在运行过程中不会改变任何数据，那程序运行还有什么意义呢？而且你可以再想象一下，如果没有可变性，你打游戏的时候，画面根本就不会动啊！游戏数据不变，画面自然也不会动了。</p><p>所以说，<strong>所谓不变性思维，是一种反直觉的思路</strong>。这也是Kotlin从函数式编程领域借鉴过来的思想。在Kotlin当中，所谓的不变性思维，其实就是在满足程序功能可变性需求的同时，尽可能地消灭可变性。</p><p>这颇有一种“戴着镣铐跳舞”的意味。其实换句话理解一下，就是说我们应该：尽可能消灭那些<strong>非必要</strong>可变性。</p><p>下面，我们就一起来看几个代码案例吧，在解读案例的过程中，我们来具体理解下究竟什么是不变性思维。</p><h2>表达式思维消灭var</h2><p>那么现在，我们的目标就变成了<strong>尽可能消灭那些非必要可变性</strong>。沿着这个思路，我们很容易就可以想到一个方向：尽可能将var变成val。就比如下面这段代码：</p><pre><code class="language-plain">fun testExp(data: Any) {\n    var i = 0\n\n    if (data is Number) {\n        i = data.toInt()\n    } else if (data is String) {\n        i = data.length\n    } else {\n        i = 0\n    }\n}\n</code></pre><p>在这段代码中，我们定义了一个可变的变量i，它的初始值是0，如果data是数字类型，我们就将其转换成整型，赋值给i；如果data是String类型，我们就将字符串的长度赋值给i，否则就用0赋值。</p><p>这段代码虽然没什么实际用途，但它代表了Java、C当中普遍存在的代码模式。这里的i，就是我们需要消灭的<strong>非必要</strong>可变性。其实，在学了上节课“表达式思维”以后，这个问题我们不费吹灰之力就可以解决了，也就是把整体的赋值逻辑变成一个表达式，代码示例如下所示：</p><pre><code class="language-plain">fun testExp(data: Any) {\n    val i = when (data) {\n        is Number -&gt; {\n            data.toInt()\n        }\n        is String -&gt; {\n            data.length\n        }\n        else -&gt; {\n            0\n        }\n    }\n}\n</code></pre><p>在这里你要注意，如果你把这个当做一道题目来做的话，它无疑是很容易的。但我想强调的是：在写Kotlin代码的时候，需要<strong>一步到位</strong>直接写出上面这样的代码。而想要做到这一点，你就一定要将不变性的思维铭记在心。因为要做到这一点其实不太容易，尤其是对Java、C开发者而言。</p><p>另外，如果你足够细心的话，相信你也发现了：我们上节课刚学的“表达式的思维”，对于我们的不变性思维，也是很有用的。</p><p>好，至此，我们就可以总结出不变性思维的第一条准则：<strong>尽可能使用条件表达式消灭var。</strong></p><h2>消灭数据类当中的可变性</h2><p>在<a href="https://time.geekbang.org/column/article/473349">第2讲</a>里，我们曾经简单学习过数据类，它是专门用来存放数据的类。它与Java当中的“Java Bean”是类似的，它的优势在于简洁。</p><p>不过，我仍然见过有人在Kotlin当中写出类似这样的代码：</p><pre><code class="language-plain">class Person {\n    private var name: String? = null\n    private var age: Int? = 0\n\n    fun getName(): String? {\n        return name\n    }\n\n    fun setName(n: String?) {\n        name = n\n    }\n\n    fun getAge(): Int? {\n        return age\n    }\n\n    fun setAge(a: Int?) {\n        age = a\n    }\n}\n</code></pre><p>上面的代码就是明显在用Java思维写Kotlin代码，有时候，我还能看到这样的代码：</p><pre><code class="language-plain">class Person {\n    var name: String? = null\n    var age: Int? = 0\n}\n</code></pre><p>这样的代码呢，看起来问题要小一些，但实际上呢，开发者脑子里想的可能是类似Java这样的代码模式：</p><pre><code class="language-java">public class Person {\n    public String name = null;\n    public int age = 0;\n}\n</code></pre><p>不过，总的来说，大部分Kotlin开发者都能写出类似这样的代码：</p><pre><code class="language-plain">data class Person(\n    var name: String?,\n    var age: Int?\n)\n</code></pre><p>但这段代码其实还可以继续优化。我们可以将var都改为val，就像下面这样：</p><pre><code class="language-plain">// var -&gt; val\ndata class Person(\n    val name: String?, \n    val age: Int?\n)\n</code></pre><p>而到这里，你可能就会产生一个疑问：<strong>Person的所有属性都改为val以后，万一想要修改它的值该怎么办呢？</strong></p><p>比如说，直接修改它的值的话，这段代码就会报错：</p><pre><code class="language-plain">class ImmutableExample {\n    // 修改Person的name，然后返回Person对象\n    fun changeUserName(person: Person, newName: String): Person {\n        person.name = newName // 报错，val无法修改\n        return person\n    }\n}\n</code></pre><p>这一点也是我们要尤为注意的：我们从Java、C那边带来的习惯，会促使我们第一时间想到上面这样的解决方案。但实际上，Kotlin更加推崇我们用下面的方式来解决：</p><pre><code class="language-plain">class ImmutableExample {\n    fun changeUserName(person: Person, newName: String): Person =\n        person.copy(name = newName)\n}\n</code></pre><p>在这段代码中，我们并没有直接修改参数person的值，而是返回了一个新的person对象。我们借助数据类的copy方法，快速创建了一份拷贝的同时，还完成了对name属性的修改。类似这样的代码模式，就可以极大地减少程序出Bug的可能。</p><p>那么到这里，我们也就能总结出Kotlin不变性思维的第二条准则了：<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。</p><h2>集合的不变性</h2><p>在Kotlin当中，提到不变性，我们就不得不谈它的<strong>集合库</strong>。我们在学习数据结构的时候，都会学到：数组、列表、HashMap、HashSet、栈、队列。这些概念在大部分的编程语言里都会存在，不过Kotlin在这方面的设计，却与Java之类的语言不太一样。</p><p>以最常见的列表（List）为例：</p><ul>\n<li>在Java当中，List是一个接口，它代表了一个可变的列表，会包含add()、remove()方法；</li>\n<li>在Kotlin当中，List也是一个接口，但是它代表了一个不可变的列表，或者说是“只读的列表”。在它的接口当中，是没有add()、remove()方法的，当我们想要使用可变列表的时候，必须使用MutableList。</li>\n</ul><p>关于集合的不变性，我们其实在第9讲<a href="https://time.geekbang.org/column/article/479112">委托</a>当中就提到了：</p><pre><code class="language-plain">class Model {\n    val data: MutableList&lt;String&gt; = mutableListOf()\n\n    private fun load() {\n        // 网络请求\n        data.add("Hello")\n    }\n}\n\nfun main() {\n    val model = Model()\n    // 类的外部仍然可以修改data\n    model.data.add("World")\n}\n</code></pre><p>当我们将类内部的集合对象暴露给外部以后，我们其实没办法阻止外部对集合的修改。在第9讲当中，我们是通过<strong>属性之间的直接委托</strong>来解决这个问题的：</p><pre><code class="language-plain">class Model {\n    val data: List&lt;String&gt; by ::_data\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add("Hello")\n    }\n}\n</code></pre><p>但其实，要解决这个问题，我们也可以借助其他的方法，比如像下面这样：</p><pre><code class="language-plain">class Model {\n    val data: List&lt;String&gt;\n        get() = _data // 自定义get\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add("Hello")\n    }\n}\n</code></pre><p>在这段代码中，我们为data属性自定义了get()方法，然后返回了_data这个集合的值。这种方式也可以实现目的。</p><p>另外，我们其实还有其他的办法：</p><pre><code class="language-plain">class Model {\n    private val data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        data.add("Hello")\n    }\n\n    // 变化在这里\n    fun getData(): List&lt;String&gt; = data\n}\n</code></pre><p>上面这种解决方案也很简单，我们直接对外暴露了一个方法，把这个方法的返回值类型改成了List类型，这样一来，外部访问这个集合以后就无法直接修改了。</p><p>以上这三种方式，本质上都是对外暴露了一个“不可变的集合”，完成了可变性的封装，它们基本上可以满足大部分的使用需求。不过啊，这三种方式其实还是会<strong>存在一定的风险</strong>，那就是外部可以进行类型转换，就像下面这样：</p><pre><code class="language-plain">fun main() {\n    val model = Model()\n    println("Before:${model.getData()}")\n    val data = model.getData()\n    (data as? MutableList)?.add("Some data")\n    println("After:${model.getData()}")\n}\n\n结果：\nBefore:[]\nAfter:[Some data]\n</code></pre><p>针对这种特殊情况，我们可以根据实际情况来决定是否要规避这个问题。其实要解决这个问题的话也很容易，我们只需要借助Kotlin提供的toList函数，让data变成真正的List类型即可。</p><p>比如像下面这样：</p><pre><code class="language-plain">class Model {\n    private val data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        data.add("Hello")\n    }\n\n    //                                 变化在这里\n    //                                    ↓\n    fun getData(): List&lt;String&gt; = data.toList()\n}\n\n// 改完以后的输出结果\nBefore:[]\nAfter:[]\n</code></pre><p>这段代码基本上可以帮助我们完成集合可变性的封装，不过在这里，有一点我们需要格外<strong>注意</strong>：当data集合数据量很大的时候，toList()操作可能会比较耗时。</p><p>好了，至此，相信你很快就能总结出第三条准则了：<strong>尽可能对外暴露只读集合</strong>。</p><h2>只读集合与Java</h2><p>另外，还有一点需要注意，当只读集合在Java代码中被访问的时候，它的不变性将会被破坏，因为Java当中不存在“不可变的集合”的概念。比如说，你在Java当中，仍然可以调用这个集合的set()方法。</p><pre><code class="language-plain">public List&lt;String&gt; test() {\n    Model model = new Model();\n    List&lt;String&gt; data = model.getData();\n    data.set(0， "Some Data"); // 抛出异常 UnsupportedOperationException\n    return data;\n}\n</code></pre><p>因此，当我们在与Java混合编程的时候，Java里使用Kotlin集合的时候一定要足够小心，最好要有详细的文档。就比如说在上面的例子当中，虽然我们可以在Java当中调用set()方法，但是这行代码最终会抛出异常，引起崩溃。而引起崩溃的原因，是Kotlin的List最终会变成Java当中的“<strong>SingletonList</strong>”，它是Java当中的不可变List，在它的add()、remove()方法被调用的时候，会抛出一个异常。</p><p>不得不说，Java这样的实现方式真的很丑陋。我相信，可能很多Java开发者甚至都不知道Java居然还有SingletonList这个私有的类。</p><p>并且，只读集合在和Java混编的时候，不仅仅只有这一个问题。毕竟，当我们尝试修改只读集合的值的时候，Java可以抛出一个异常的话，那也算是一个可以勉强接受的结局了。</p><p>但实际的情况还会更差，如果我们将代码改成这样：</p><pre><code class="language-plain">class Model1 {\n    val list: List&lt;String&gt; = listOf("hello", "world")\n}\n\npublic class ImmutableJava {\n    public List&lt;String&gt; test1() {\n        Model1 model = new Model1();\n        List&lt;String&gt; data = model.getList();\n        System.out.println(data.get(0));\n        data.set(0, "some data"); // 注意这里\n        System.out.println(data.get(0));\n        return data;\n    }\n}\n\n// 结果\nhello\nsome data\n</code></pre><p>我们在Java代码当中调用data.set()方法，并没有引起异常，程序也正常执行完毕，并且结果也符合预期。在这种情况下，Kotlin的List被编译器转换成了 <code>java.util.Arrays$ArrayList</code> 类型。因此，我们Kotlin当中的只读集合，在Java当中就变成了一个普通的可变集合了。</p><p>事实上，对于Kotlin的List类型来说，在它转换成Java字节码以后，可能会变成多种类型，比如前面我们看到的SingletonList、<code>java.util.Arrays$ArrayList</code>，甚至还可能会变成java.util.ArrayList。在这里，我们完全不必去深究编译器背后的翻译规则，我们只需要时刻记住，Kotlin当中的只读集合，在Java看来和普通的可变集合是一样的。</p><p>至此，我们就能总结出第四条准则了：<strong>只读集合底层不一定是不可变的，要警惕Java代码中的只读集合访问行为</strong>。</p><h2>反思：val 一定不可变吗？</h2><p>最后，我们再来反思一下Kotlin的不变性。通常来说，我们用val定义的临时变量，都会将其看做是不可变的，也就是只读变量。但是别忘了，<strong>val还可以定义成员属性</strong>。而在这种情况下，它意味着：属性+ get方法。而且，我们还可以自定义get()方法。</p><p>所以这时候，我们就要睁大眼睛看清楚它的本质了。比如我们可以来看看下面这段代码：</p><pre><code class="language-plain">object TestVal {\n    val a: Double\n        get() = Random.nextDouble()\n\n    fun testVal() {\n        println(a)\n        println(a)\n    }\n}\n\n// 结果\n0.0071073054825220305\n0.6478886064282862\n</code></pre><p>很明显，在上面的代码中，我们通过自定义get()方法，打破了val的不变性。我们两次访问属性a所得到的值都不一样。对于val定义的成员属性，我们得到这样的结果并不会觉得奇怪，上面代码的运行结果也十分符合直觉。</p><p>那么你也许会这样想：我们用val定义的<strong>局部变量</strong>，那就一定是不可变的了吧？</p><p>答案仍然是<strong>否定</strong>的！</p><p>我们可以看看下面这个例子，这里我们同样是借助了委托相关的知识点：</p><pre><code class="language-plain">class RandomDelegate() : ReadOnlyProperty&lt;Any?, Double&gt; {\n    override operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Double {\n        return Random.nextDouble()\n    }\n}\n\nfun testLocalVal() {\n    val i: Double by RandomDelegate()\n\n    println(i)\n    println(i)\n}\n\n// 输出结果\n0.1959507495773669\n0.5166803777645403\n</code></pre><p>在这段代码中，我们定义了一个委托RandomDelegate，然后把局部变量委托给了这个RandomDelegate，之后每次访问i这个变量，它的值都是不一样的。</p><p>那么，到这里，相信你马上就可以总结出第五条准则了：<strong>val并不意味着绝对的不可变</strong>。</p><h2>小结</h2><p>好了，我们来做一个简单的总结吧。所谓Kotlin的不变性思维，就是尽可能消灭代码中<strong>非必要</strong>的可变性。具体来说，一共有5大准则。</p><ul>\n<li>第一，<strong>尽可能使用条件表达式消灭var</strong>。由于Kotlin当中大部分语句都是表达式，我们可以借助这种思路减少var变量的定义。</li>\n<li>第二，<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。我们应该充分发挥Kotlin数据类的优势，借助它提供的copy方法，我们可以轻松实现不变性。</li>\n<li>第三，<strong>尽可能对外暴露只读集合</strong>。根据<a href="https://en.wikipedia.org/wiki/Open%25E2%2580%2593closed_principle">开放封闭原则</a>，我们的程序应该尽量对修改封闭。借助Kotlin的只读集合，我们在这方面可以做得比Java更好。</li>\n<li>第四，<strong>只读集合底层不一定是不可变的，要警惕Java代码中的只读集合访问行为</strong>。Kotlin为了兼容Java，它的集合类型必须要与Java兼容，因此它不能创造出Java以外的集合类型，这也就决定了它只能是语法层面的不可变性。Kotlin官方也在考虑进一步的优化，期待后续的版本能有更加优雅的处理方式。</li>\n<li>第五，<strong>val并不意味着绝对的不可变</strong>。在Kotlin当中定义的val变量与属性，它们并非绝对不可变的。由于Kotlin的语法十分灵活，我们完全可以用val写出可变的局部变量和成员属性。这一点，我们一定要小心。</li>\n</ul><h2>思考题</h2><p>简单的五个准则，是不可能完全概括出Kotlin的不变性思维的。请问你还能想到其他的不变性准则吗？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "加餐三 | 什么是“不变性思维”？",
      },
      {
        title: "加餐四 | 什么是“空安全思维”？",
        id: 484921,
        content:
          '<p>你好，我是朱涛。这节加餐，我们来聊聊空安全思维。</p><p>空（null），是很多编程语言中都有的设计，不同的语言中名字也都不太一样，比如Java和Kotlin里叫null，在Swift里叫做nil，而Objective-C当中，根据情况的不同还细分了NULL、nil、Nil等等。</p><p>如果你有Java的经验，那你一定不会对NullPointerException（NPE，代码中常见的逻辑错误）感到陌生。null会引起NPE，但是在很多场景下，你却不得不使用它。因为null用起来实在是太方便了。比如说，前面<a href="https://time.geekbang.org/column/article/473656">第4讲</a>里，我提到的计算器程序当中的calculate()方法，它的返回值就是可为空的，当我们的输入不合法的时候，calculate()就会返回null。</p><p>一般来说，我们会习惯性地用null来解决以下这些场景的问题：</p><ul>\n<li>当变量还没初始化的时候，用null赋值；</li>\n<li>当变量的值不合法的时候，用null赋值；</li>\n<li>当变量的值计算错误的时候，用null赋值。</li>\n</ul><p>虽然这些场景，我们不借助null也可以漂亮地解决，但null其实才是最方便的解决方案。因为总的来说，null代表了一切不正常的值。如果没有了null，我们编程的时候将会面临很多困难。</p><!-- [[[read_end]]] --><p>所以，null对于我们开发者来说，是一把双刃剑，我们既需要借助它提供的便利，还需要避开它引出的问题。这是一种取舍，我们要在null的利与弊当中找到一个平衡点。而且，这里的平衡点，在不同的场景中是不一样的。</p><p>那么，怎么才能把握好null的平衡点呢？这就体现出<strong>空安全思维</strong>的重要性了。</p><h2>Java的空安全思维</h2><p>在正式研究Kotlin的空安全思维之前，我们先来看看Java是否能给我们带来一些灵感。</p><p>在Java当中，其实也有一些手段来规避NPE，最常见的手段，当然就是<strong>判空</strong>，这是<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B">防御式编程</a>的一种体现，应用范围也很广泛。</p><p>另外一种手段是@Nullable、@NotNull之类的<strong>注解</strong>，开发者可以使用这样的注解来告诉IDE哪些变量是可能为空的，哪些是不可能为空的，IDE会借助这些注解信息来帮我们规避NPE。</p><p>不过，注解这样的方式，实际效果并不好，主要有两个原因：一方面是注解很难在代码中大面积使用，这全依赖于开发者的习惯，很难在大型团队中推行，即使推行了也会影响开发效率；另一方面，即使在工程当中大面积推行可空注解，也无法完全解决NPE的问题。</p><p>想象一下，虽然我们可以在函数的参数以及返回值上面都标注可空性，但无法为每一个变量、每一种类型，都标注这些可空信息。因此，可空注解这样的方式，必然是会留下很多死角的。</p><p>还有一种手段，是Java 1.8当中引入的Optional，这种手段的核心思路就是<strong>封装数据</strong>，不再直接使用null。举个例子，从前我们直接使用String类，使用Optional以后，我们就得改成 <code>Optional&lt;String&gt;</code>。如果我们要判断值是否为空，就用optional.isPresent()。</p><p>但Optional有几个缺点：</p><ul>\n<li>第一点，增加了代码的复杂度；</li>\n<li>第二点，降低了代码的执行效率，Optional的效率肯定比String更低；</li>\n<li>最后，业界普及度不高。这其实也是由前面两者而决定的，即使我们在自己的工程中用了Optional，而第三方SDK当中没有的话，它也很难与其交互。</li>\n</ul><p>由此可见，Java解决NPE的三种思路都无法令人满意。</p><p>那么，现在假设你自己就是Kotlin语言的设计者，在Java的三种思路的基础上，你能想到什么更好的思路吗？</p><p>前面我们曾提到了，使用@NotNull之类的注解，是存在死角的，因为我们无法为每一个变量、每一个类型都加上可空注解。一方面是注解的Target存在限制，另一方面是开发效率也会急剧下降。</p><p>所以，我们需要的其实是一种<strong>简洁，且能为每一种类型都标明可空性的方式。</strong>这样一来，我们自然而然就能想到一个更好的方案，那就是：<strong>从类型系统下手</strong>。</p><h2>Kotlin的空安全思维</h2><p>Kotlin虽然是与Java兼容的，但是它的类型系统与Java却有很大的不同。在Java当中，我们用String代表字符串类型。而在Kotlin当中，同样是字符串类型，它却有三种表示方法。</p><ul>\n<li>String，不可为空的字符串；</li>\n<li>String?，可能为空的字符串；</li>\n<li>String!，不知道是不是可能为空。</li>\n</ul><p>这有点像是电影里的分身术，Java当中的一个概念，在Kotlin当中分化出了三种概念。</p><p><img src="https://static001.geekbang.org/resource/image/70/82/706f679056d9074byycc66697a05dd82.jpg?wh=2000x740" alt=""></p><p>Kotlin的可空（String?）、不可空（String），我们在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>就已经介绍过了。Kotlin这样的类型系统，让开发者必须明确规定每一个变量类型是否可能为空，通过这样的方式，Kotlin编译器就能帮我们规避NPE了。</p><p>可以说，在不与Kotlin以外的环境进行交互的情况下，仅仅只是纯Kotlin开发当中，Kotlin编译器已经可以帮我们消灭NPE了。不过，现代商业化的软件当中，全栈使用Kotlin是不现实的，这也就意味着，我们将不得不与其他语言环境打交道，其中最常见的就是Java。</p><h3>Kotlin、Java混合编程的空安全</h3><p>在Java当中，是不存在可空类型这个概念的。因此，在Kotlin当中，我们把Java未知可空性的类型叫做<strong>平台类型</strong>，比如：String!。所有Java当中的不确定可空性的类型，在Kotlin看来都是平台类型，用“!”来表示。</p><p>让我们来看一个实际的例子：</p><pre><code class="language-java">// Java 代码\n\npublic class NullJava {\n    public static String getMsg(String s) {\n        return s + "Kotlin";\n    }\n\n    @Nullable\n    public static String getNullableString(@Nullable String s) {\n        return s + "Kotlin";\n    }\n\n    @NotNull\n    public static String getNotNullString(@NotNull String s) {\n        return "Hello World.";\n    }\n}\n</code></pre><p>上面的代码中，我们一共定义了三个Java方法，第一个getMsg()我们直接返回了一个字符串，但是没有用可空注解标注；第二个方法getNullableString()则使用了@Nullable修饰了，代表它的参数和返回值是可能为空的；第三个方法getNotNullString()则是用的@NotNull修饰的，代表它的参数和返回值是不可能为空的。</p><p>而以上三个Java方法在Kotlin调用的时候，就出现以下几种情况：</p><pre><code class="language-plain">// Kotlin代码\n\nfun testPlatformType() {\n    val nullableMsg: String? = NullJava.getNullableString(null)\n    val notNullMsg: String = NullJava.getNotNullString("Hey,")\n\n    val platformMsg1: String? = NullJava.getMsg(null)\n    val platformMsg2: String = NullJava.getMsg("Hello")\n}\n</code></pre><p>也就是，由于Java当中的getNullableString()是由@Nullable修饰的，因此Kotlin编译器会自动将其识别为可空类型“String?”；而getNotNullString()是由@NotNull修饰的，因此Kotlin编译器会自动将其识别为不可空类型“String”。</p><p>最后，是getMsg()，由于这个Java方法没有任何可空注解，因此，它在Kotlin代码中会被认为是平台类型“String!”。</p><p><img src="https://static001.geekbang.org/resource/image/24/9f/24516bc822c6187ca3be74c26a06859f.png?wh=1208x328" alt="图片"></p><p>对于平台类型，Kotlin会认为，它既能被当作可空类型“String?”，也可以被当作不可空类型“String”。Kotlin没有强制开发者，而是将选择权交给了开发者。所以我们开发者，就需要在这中间寻找平衡点。</p><p>我们不能将平台类型一概认为是不可空的，因为这会引发NPE；我们也不能一概认为平台类型是可空的，因为这会导致我们的代码出现过多的空安全检查。</p><p>在这里，结合我个人的一些实践经验来看，对于Kotlin与Java混合编程的情况，这几个建议你可以参考一下：</p><ul>\n<li>对于工程中的<strong>Java源代码</strong>，当它与Kotlin交互的时候，我们应该尽量为它的参数与返回值加上可空的注解。注意，这里并不是说要一次性为所有Java代码都加上注解，而是当它与Kotlin交互的时候。这个需求其实可以通过一些静态代码检测方案来实现。</li>\n<li>对于工程当中的<strong>Java SDK</strong>，当它需要与Kotlin交互的时候，如果SDK没有完善的可空注解，我们可以在SDK与业务代码之间建立一个抽象层，对Java SDK进行封装。</li>\n</ul><p>至此，我们就能总结出Kotlin空安全的第一条准则：<strong>警惕Kotlin以外的数据类型。</strong></p><p>从<strong>语言角度</strong>上看，Kotlin不仅只是和Java交互，它还可以与其他语言交互，而如果其他语言没有可空的类型系统，那么我们就一定要警惕起来。</p><p>另外，从<strong>环境角度</strong>上看，Kotlin还可以与其他外界环境交互，比如发起网络请求、解析网络请求、读取数据库，等等。这些外界的环境当中的数据，往往也是没有可空类型系统的，这时候我们更要警惕。</p><blockquote>\n<p>举个例子：很多Kotlin开发者会在JSON解析的时候，遇到NPE的问题，这也是一个相当棘手的问题，这个问题我们会在后面的实战项目中进一步分析。</p>\n</blockquote><p>聊完了Kotlin与外界交互的空安全准则后，我们再来看看纯Kotlin开发的准则。</p><h3>纯Kotlin的空安全</h3><p>正常情况下，我们使用纯Kotlin开发，编译器已经可以帮助解决大部分的空安全问题了。不过，纯Kotlin开发，仍然有<strong>三大准则</strong>需要严格遵守。接下来，我们就通过两个实际场景，来具体学习下这三个准则。</p><ul>\n<li><strong>非空断言</strong></li>\n</ul><p>在前面，我们曾经学习过Kotlin的空安全调用语法“?.”，其实，Kotlin还提供了一个<strong>非空安全</strong>的调用语法“!!.”。这样的语法，我们也叫做非空断言。让我们来看个具体的例子：</p><pre><code class="language-plain">fun testNPE(msg: String?) {\n//            非空断言\n//              ↓\n    val i = msg!!.length\n}\n\nfun main() {\n    NullExample.testNPE(null)\n}\n</code></pre><p>正常情况下，如果我们要调用“String?”类型的成员，需要使用空安全调用，而这里我们使用非空断言，强行调用了它的成员。毫无疑问，上面的代码就会产生空指针异常。</p><p>看到这里，相信你马上就能总结出第二条空安全准则了：<strong>绝不使用非空断言“!!.”</strong>。</p><p>看到这条准则，也许很多人都会觉得：这不是废话吗？谁会喜欢用非空断言呢？但是啊，在我过去的几年经验当中，确实见到过不少Kotlin断言相关的代码，它们大致有两个原因。</p><p>第一个原因，是当我们借助IDE的“Convert Java File To Kotlin File”的时候，这个工具会自动帮我们生成带有<strong>非空断言</strong>的代码。而我们在转换完代码以后，却没有review，进而将非空断言带到了生产环境当中。</p><p>就以下面这段代码为例：</p><pre><code class="language-java">// Java 代码\n\npublic class JavaConvertExample {\n    private String name = null;\n\n    void init() {\n        name = "";\n    }\n\n    void test(){\n        if (name != null) {\n            int count = name.length();\n        }\n    }\n}\n</code></pre><p>这段代码是非常典型的Java代码，其中我们也已经使用了if来判断name是否为空，然后再调用它的length。</p><p>那么，如果我们借助IDE的转换工具，它会变成什么样呢？</p><pre><code class="language-plain">class JavaConvertExample {\n    private var name: String? = null\n    fun init() {\n        name = ""\n    }\n\n    fun foo() {\n        name = null;\n    }\n\n    fun test() {\n        if (name != null) {\n//                        非空断言\n//                           ↓\n            val count = name!!.length\n        }\n    }\n}\n</code></pre><p>可以看到转成Kotlin代码以后，我们test()方法当中出现了<strong>非空断言</strong>。</p><p>你也许会好奇，Kotlin不是支持Smart Cast吗？既然我们已经在if当中判断了name不等于空，那么，它不是会被Smart Cast成为一个非空类型吗？毕竟，我们经常能写出这样的代码：</p><pre><code class="language-plain">val name: String? = getLocalName()\nif (name != null) {\n//   判断非空后，被转换成非空类型了\n//      ↓\n    name.length\n}\n</code></pre><p>那么，回到我们上面的例子当中，如果我们将转换出来的非空断言语法删除掉，会发生什么？</p><p><img src="https://static001.geekbang.org/resource/image/25/ae/253579d865aa407891025b809b8ebbae.gif?wh=1088x722" alt="图片"></p><p>可见，当我们删除掉非空断言以后，IDE报错了，大致意思是，在这种场景下，Smart Cast是不可能发生的。为什么呢？我们判空以后的代码明明就很安全了啊！为什么不能自动转换成非空类型？</p><p>这就是很多Kotlin开发者使用非空断言的第二个原因，在某些场景下，Smart Cast失效了，<strong>即使我们判空了，也免不了还是要继续使用非空断言</strong>。</p><p>注意了，这种情况下，并不是IDE出现了Bug。它在这种情况下不支持Smart Cast是有原因的。我给你举个例子：</p><pre><code class="language-plain">class JavaConvertExample {\n    private var name: String? = null\n    fun init() {\n        name = ""\n    }\n\n    fun foo() {\n        name = null;\n    }\n\n    fun test() {\n        if (name != null) {\n            // 几百行代码\n            foo()\n            //几百行代码\n            val count = name!!.length\n        }\n    }\n}\n</code></pre><p>当我们的程序逻辑变得复杂的时候，在判空后，我们可能又会不小心改变name的值，比如上面的foo()函数，这时候我们的非空断言就会产生NPE。这也是Kotlin编译器无法帮我们做Smart Cast的原因。</p><p>那么，在这种情况下，我们到底该如何避免使用非空断言呢？主要有这么几种方法。</p><p><strong>第一种</strong>，避免直接访问成员变量或者全局变量，将其改为传参的形式：</p><pre><code class="language-plain">//    改为函数参数\n//        ↓\nfun test(name: String?) {\n    if (name != null) {\n//             函数参数支持Smart Cast\n//                      ↓\n        val count = name.length\n    }\n}\n</code></pre><p>在Kotlin当中，函数的参数是不可变的，因此，当我们将外部的成员变量或者全局变量以函数参数的形式传进来以后，它可以用于Smart Cast了。</p><p><strong>第二种</strong>，避免使用可变变量var，改为val不可变变量：</p><pre><code class="language-plain">class JavaConvertExample {\n//       不可变变量\n//           ↓\n    private val name: String? = null\n\n    fun test() {\n        if (name != null) {\n//               不可变变量支持Smart Cast\n//                          ↓\n            val count = name.length\n        }\n    }\n}\n</code></pre><p>这种方式很好理解，既然引发问题的根本原因是可变性导致的，我们直接将其<strong>改为不可变</strong>的即可。从这里，我们也可以看到“空安全”与“不可变性”之间的关联。</p><p><strong>第三种</strong>，借助临时的不可变变量：</p><pre><code class="language-plain">class JavaConvertExample {\n    private var name: String? = null\n\n    fun test() {\n//        不可变变量\n//            ↓\n        val _name = name\n        if (_name != null) {\n            // 在if当中，只使用_name这个临时变量\n            val count = _name.length\n        }\n    }\n}\n</code></pre><p>以上代码，本质上还是借助了不可变性。这种方式看起来有点丑陋，但如果稍微封装一下也是有用的，比如接下来要用到的let。</p><p><strong>第四种</strong>，是借助Kotlin提供的标准函数let：</p><pre><code class="language-plain">class JavaConvertExample {\n    private var name: String? = null\n\n    fun test() {\n//                      标准函数\n//                         ↓\n        val count = name?.let { it.length }\n    }\n}\n</code></pre><p>这种方式和第三种方式，从本质上来讲是相似的，但是我们通过let可以更加优雅地来实现同样的需求。</p><p><strong>第五种</strong>，是借助Kotlin提供的lateinit关键字：</p><pre><code class="language-plain">class JavaConvertExample {\n//         稍后初始化             不可空\n//            ↓                   ↓\n    private lateinit var name: String\n\n    fun init() {\n        name = "Tom"\n    }\n\n    fun test() {\n        if (this::name.isInitialized) {\n            val count = name.length\n        } else {\n            println("Please call init() first!")\n        }\n    }\n}\n\nfun main() {\n    val example = JavaConvertExample()\n    example.init()\n    example.test()\n}\n</code></pre><p>如果你足够细心，你会发现这种思路其实是<strong>完全抛弃可空性</strong>的。我们直接用lateinit var定义了不可能为空的String类型，然后，当我们要用到这个变量的时候，再去判断这个变量是否已经完成了初始化。</p><p>由于它的类型是不可能为空的，因此我们初始化的时候，必须传入一个非空的值，这就能保证：只要name初始化了，它的值就一定不为空。在这种情况下，我们就将判空问题变成了一个判断是否初始化的问题。</p><p><strong>第六种</strong>，使用by lazy委托：</p><pre><code class="language-plain">class JavaConvertExample {\n//         不可变        非空   懒加载委托\n//           ↓           ↓        ↓\n    private val name: String by lazy { init() }\n    \n    fun init() = "Tom"\n    \n    fun test() {\n        val count = name.length\n    }\n}\n</code></pre><p>可以看到，我们将name这个变量改为了<strong>不可变的非空属性</strong>，并且，借助Kotlin的懒加载委托来完成初始化。借助这种方式，我们可以尽可能地延迟初始化，同时，也消灭了可变性、可空性。</p><p>到这里，相信你就可以总结出第三条准则了：<strong>尽可能使用非空类型</strong>。</p><p>下面我们再来看看另一个场景。</p><ul>\n<li><strong>泛型可空性</strong></li>\n</ul><p>在学习<a href="https://time.geekbang.org/column/article/480022">泛型</a>的时候，我曾经介绍过：我们可以用字母（比如T）来代表某种未知的类型，以此来提升程序的灵活性。比如，我们很容易就能写出下面这样的代码：</p><pre><code class="language-plain">// 泛型定义处              泛型使用处\n//   ↓                      ↓\nfun &lt;T&gt; saveSomething(data: T) {\n    val set = sortedSetOf&lt;T&gt;() // Java TreeSet\n    set.add(data)\n}\n\nfun main() {\n//                 泛型实参自动推导为String\n//                        ↓\n    saveSomething("Hello world!")\n}\n</code></pre><p>这段代码没有实际应用价值，它代表的是一种代码模式。我们重点来看看saveSomething()这个方法，请问你能找出它的问题在哪吗？说实话，如果不是实际踩过坑，我们是很难意识到这段代码的问题在何处的。</p><p>让我们来看看这段代码是怎么出问题的。</p><pre><code class="language-plain">// 泛型定义处              泛型使用处\n//   ↓                      ↓\nfun &lt;T&gt; saveSomething(data: T) {\n    val set = sortedSetOf&lt;T&gt;()\n//    空指针异常              \n//       ↓\n    set.add(data)\n}\n\nfun main() {\n//               编译通过\n//                  ↓\n    saveSomething(null)\n}\n</code></pre><p>在上面的代码中，虽然我们定义的泛型参数是“T”，函数的参数是“data: T”，看起来data好像是不可为空的，但实际上，我们是可以将null作为参数传进去的。这时候，编译器也不会报错。紧接着，由于TreeSet内部无法存储null，所以我们的代码在“set.add(data)”这里，会产生运行时的空指针异常。</p><p>出现这样的问题的原因，其实是因为泛型的参数T给了我们一种错觉，让我们觉得：T是非空的，而“T?”才是可空的。实际上，我们的T是等价于 <code>&lt;T: Any?&gt;</code> 的，因为Any?才是Kotlin的<strong>根类型</strong>。这也就意味着，泛型的T是可以接收null作为实参的。</p><pre><code class="language-plain">\nfun &lt;T&gt; saveSomething(data: T) {}\n//   ↑ \n//  等价              \n//   ↓                      \nfun &lt;T: Any?&gt; saveSomething(data: T) {}\n\n</code></pre><p>那么，saveSomething()这个方法，正确的写法应该是怎样的呢？答案其实也很简单：</p><pre><code class="language-plain">// 增加泛型的边界限制              \n//       ↓                      \nfun &lt;T: Any&gt; saveSomething(data: T) {\n    val set = sortedSetOf&lt;T&gt;()\n    set.add(data)\n}\n\nfun main() {\n//              编译无法通过\n//                  ↓\n    saveSomething(null)\n}\n</code></pre><p>以上代码中，我们为泛型T <strong>增加了上界“Any”</strong>，由于Any是所有非空类型的“根类型”，这样就能保证我们的data一定是非空的。这样一来，当我们尝试往saveSomething()这个方法里传入null的时候，编译器就会报错，让这个问题在编译期就能暴露出来。</p><p>看到这里，相信你也可以总结出Kotlin空安全的第四条准则了：<strong>明确泛型可空性</strong>。</p><h2>小结</h2><p>学完了这节课，相信现在你对Kotlin的空安全思维就已经有了一个全面的认识。最后，我也再给你总结一下，你需要重点关注Kotlin的空安全思维，主要有四大准则：</p><ul>\n<li>第一个准则：<strong>警惕Kotlin与外界的交互</strong>。这里主要分为两大类，第一种是：Kotlin与其他语言的交互，比如和Java交互；第二种是：Kotlin与外界环境的交互，比如JSON解析。</li>\n<li>第二个准则：<strong>绝不使用非空断言“!!.”</strong>。这里主要是两个场景需要注意，一个是：IDE的“Convert Java File To Kotlin File”功能转换的Kotlin代码，一定要review，消灭其中的非空断言；另一个是：当Smart Cast失效的时候，我们要用其他办法来解决，而不是使用非空断言。</li>\n<li>第三个准则：<strong>尽可能使用非空类型</strong>。借助lateinit、懒加载，我们可以做到灵活初始化的同时，还能消灭可空类型。</li>\n<li>第四个准则：<strong>明确泛型的可空性</strong>。我们不能被泛型T的外表所迷惑，当我们定义 <code>&lt;T&gt;</code> 的时候，一定要记住，它是可空的。在非空的场景下，我们一定要明确它的可空性，这一点，通过增加泛型的边界就能做到 <code>&lt;T: Any&gt;</code>。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/39/94/39fc08c17f4a4f9fff42bdb536a4c494.jpg?wh=2000x1050" alt=""></p><p>其实，Kotlin的空安全思维，也并不是四个准则就可以完全概括的，不过这四个准则可以为我们指明方向，为我们后面的学习打下基础。Kotlin的空安全，其实和Kotlin的每一个特性都息息相关。比如，我们在前面课程里就应用了不变性、lateinit、懒加载委托、泛型边界等特性，来解决空安全问题。</p><h2>思考题</h2><p>这节课我介绍了空安全的四大准则，请问你还能想到其他的准则吗？欢迎在评论区分享你的思路。</p>',
        article_title: "加餐四 | 什么是“空安全思维”？",
      },
    ],
  },
  {
    chapterTitle: "春节特别放送",
    children: [
      {
        title: "春节刷题计划（一）| 当Kotlin遇上LeetCode",
        id: 482822,
        content:
          '<p>你好，我是朱涛。</p><p>时光飞逝，不知不觉间，我们就已经完成了基础篇的学习，并且也已经完成了三个实战项目，但这终归是不够过瘾的。想要完全掌握Kotlin的基础语法，我们还需要更多的练习。我相信，你现在的心情就像是一个手握屠龙刀的勇士，热切希望找一些对手来验证自己的学习成果。</p><p>其实，我自己在学习一门新的编程语言的时候，有一个高效的方法，也分享给你。这里我以Kotlin为例，假设我现在是一个新手，想快速掌握Kotlin的话，我会这样做：</p><ul>\n<li>第一步，我会<strong>去Google搜索一些语言特性对比的文章</strong>。比如，我熟悉Java，想学Kotlin，我就会去搜“from Java to Kotlin”，然后去看一些Java、Kotlin语法对比的文章。这时候，我大脑里就会建立起Java与Kotlin的语法联系。</li>\n<li>第二步，我会打开<a href="https://kotlinlang.org/docs/basic-syntax.html">Kotlin官方文档</a>，花几个小时的时间粗略看一遍，对Kotlin的语法有个大致印象。</li>\n<li>最后一步，我会<strong>打开LeetCode之类的网站</strong>，开始用Kotlin刷题。在刷题的过程中，我也会先从模拟类的题目开始，之后再到数组、链表、Map、二叉树之类的数据结构。整个过程由易到难，刚开始的时候，我会选择“简单题”，等熟练以后，再选择“中等题”，心情好的时候，我偶尔会做个“困难题”挑战一下。</li>\n</ul><!-- [[[read_end]]] --><p>当然，对于你来说，第一步和第二步都已经不是问题了，通过前面十几节课程的学习，你已经有了牢固的Kotlin基础。现在欠缺的，只是大量的练习而已。</p><p>说回来，其实我认为，我这种学习编程的方法是个一举多得的，比如它可以让我们：</p><ul>\n<li><strong>快速掌握一门新的编程语言</strong>。</li>\n<li><strong>夯实基本功</strong>。通过刷算法题，可以进一步巩固自己的数据结构与算法知识，这对于以后的工作也会有很大的帮助。所谓软件的架构，其实一定程度上就是在选择不同的数据结构与算法解决问题。而基本功的扎实程度，也决定了一名开发者的能力上限。</li>\n<li><strong>面试加分</strong>。众所周知，顶级的IT公司面试的时候，都是要做算法题的。假如你是一名Android或Java工程师，如果你能用Kotlin写出漂亮的题解，那将会是大大加分项。</li>\n</ul><p>另外，由于语法的简洁性，你会发现，用Kotlin做算法题，<strong>比Java要“爽”很多</strong>。同样的一道题目，用Java你可能要写很多代码，但Kotlin却只需要简单的几行。</p><p>所以接下来的春节假期呢，我就会带你来一起刷题，希望你在假期放松休息、陪伴家人之余，也不要停下学习的脚步。好，那么今天，我们就先来看几个简单的题目，就当作是热身了。</p><h2>热身1：移除字符串当中的“元音字母”</h2><p>这是LeetCode的1119号题。题意大致是这样的：程序的输入是一个字符串s。题目要求我们移除当中的所有元音字母a、e、i、o、u，然后返回。</p><p>这个问题，如果我们用Java来实现的话，大致会是这样的：</p><pre><code class="language-java">public String removeVowels(String s) {\n    StringBuilder builder = new StringBuilder();\n    char[] array = s.toCharArray();\n\n    for(char c: array) {\n        // 不是元音字母，才会拼接\n        if(c != \'a\' &amp;&amp; c != \'e\' &amp;&amp; c != \'i\' &amp;&amp; c !=\'o\' &amp;&amp; c != \'u\') {\n            builder.append(c);\n        }\n    }\n\n    return builder.toString();\n}\n</code></pre><p>但如果是用Kotlin，我们一行代码就可以搞定：</p><pre><code class="language-plain">fun removeVowels(s: String): String =\n        s.filter { it !in setOf(\'a\', \'e\', \'i\', \'o\', \'u\') }\n</code></pre><p>这里，我们是使用了字符串的扩展函数filter，轻松就实现了前面的功能。这个题目很简单，同时也比较极端，下面我们来看一个更复杂的例子。</p><h2>热身2：最常见的单词</h2><p>这是LeetCode的819号题。题意大致如下：程序的输入是一段英语文本（paragraph），一个禁用单词列表（banned）返回出现次数最多、同时不在禁用列表中的单词。</p><p>这个题目其实跟我们第2次的实战项目“<a href="https://time.geekbang.org/column/article/477295">英语词频统计</a>”有点类似，我们之前实现的是完整的单词频率，并且降序。这个题目只需要我们找到频率最高的单词，不过就是多了一个<strong>单词黑名单</strong>而已。</p><p>那么，这个题目如果我们用Java来实现，肯定是要不少代码的，但如果用Kotlin，简单的几行代码就可以搞定了：</p><pre><code class="language-plain">fun mostCommonWord1(paragraph: String, banned: Array&lt;String&gt;) =\n            paragraph.toLowerCase()\n                .replace("[^a-zA-Z ]".toRegex(), " ")\n                .split("\\\\s+".toRegex())\n                .filter { it !in banned.toSet() }\n                .groupBy { it }\n                .mapValues { it.value.size }\n                .maxBy { it.value }\n                ?.key?:throw IllegalArgumentException()\n</code></pre><p>可以看到，这段代码我们只需要在原有TextProcessor的基础上，做一点修改，就完成了。</p><p>另外，你可能也发现了，我们前面的两个例子都是用函数式思维来解决的，这其实是因为这两个问题用命令式会更复杂。而对于一些其他的问题，我们其实仍然可以选择命令式来解决。比如：手写排序算法。</p><h2>热身3：用Kotlin实现冒泡排序</h2><p>冒泡排序，是计算机里最基础的一种排序算法。如果你忘了它的实现方式，也没关系，我做了一个动图，让你可以清晰地看到算法的执行过程。</p><p><img src="https://static001.geekbang.org/resource/image/89/14/896c2b92f5837fa05aa8e0d17d16e514.gif?wh=1080x608" alt="图片"></p><p>那么针对冒泡排序法，如果我们用Kotlin来实现，命令式的方式会更加直观一些，就像下面这样：</p><pre><code class="language-plain">fun sort(array: IntArray): IntArray {\n    for (end in (array.size - 1) downTo 1) {\n        for (begin in 1..end) {\n            if (array[begin - 1] &gt; array[begin]) {\n                val temp = array[begin - 1]\n                array[begin - 1] = array[begin]\n                array[begin] = temp\n            }\n        }\n    }\n    return array\n}\n</code></pre><p>这里，我们需要格外注意的是，在逆序遍历数组的时候，我们是使用了<strong>逆序</strong>的Range：“(array.size - 1) downTo 1”，而如果这里是用“1…(array.size - 1)”的话，其实是会出问题的。因为Kotlin当中的Range要求必须是右边不能小于左边，比如“1…3”是可以的，而“3…1”是不行的。</p><p>好了，到这里，相信你对用Kotlin刷算法题已经有了一定认识了。正如Kotlin官方所宣传的那样，Kotlin是一门多范式的编程语言，对于不同的问题，我们完全可以选择不同范式来进行编程。说到底就是：<strong>怎么爽就怎么来</strong>。</p><h2>小作业</h2><p>好，最后也再给你留一个小作业，请你用Kotlin来完成<a href="https://leetcode-cn.com/problems/compare-version-numbers/">LeetCode的165号题《版本号判断》</a>。</p><p><strong>注意：</strong>LeetCode中文站使用的Kotlin版本，仍然停留在1.3.10。如果你是使用Kotlin 1.6解题，代码在IDE当中编译通过了，而LeetCode显示编译出错，那么你就需要修改一下对应的实现。或者，你也可以将新版本的库函数一起拷贝到Solution当中去。</p><p>这道题目我会在下节课给出答案解析，我们下节课再见。</p>',
        article_title: "春节刷题计划（一）| 当Kotlin遇上LeetCode",
      },
      {
        title: "春节刷题计划（二）| 一题三解，搞定版本号判断",
        id: 484149,
        content:
          '<p>你好，我是朱涛。今天是除夕夜，先祝你虎年春节快乐！</p><p>在上节刷题课中，我给你留了一个作业，那就是：用Kotlin来完成 <a href="https://leetcode-cn.com/problems/compare-version-numbers/">LeetCode的165号题《版本号判断》</a>。那么今天这节课，我就来讲讲我的解题思路，希望能给你带来一些启发。</p><p>这道题目其实跟我们平时的工作息息相关。给你两个字符串代表的版本号，需要你判断哪个版本号是新的，哪个版本号是旧的。比如，2.0与1.0对比的话，2.0肯定是新版本，1.0肯定是旧版本。对吧？</p><p>不过，这里面还有一些问题需要留意，这些都是我们在正式写代码之前要弄清楚的。</p><ul>\n<li>首先，版本号是可能以0开头的。比如0.1、1.01，这些都是合理的版本号。</li>\n<li>另外，如果是以0开头的话，1个0和多个0，它们是等价的，比如1.01、1.001、1.00001之间就是等价的，也就是说这几个版本号其实是相等的。</li>\n<li>还有，1.0、1.0.0、1.0.0.0它们之间也是等价的，也就是说这几个版本号也是相等的。</li>\n</ul><h2>思路一</h2><p>好了，理解了题意以后，我们就可以开始写代码了，LeetCode上面给了我们一个待实现的方法，大致如下：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int {\n    // 待完善\n}\n</code></pre><!-- [[[read_end]]] --><p>分析完题目以后，也许你已经发现了，这道题目其实并不需要什么特殊的数据结构和算法基础，这是一道单纯的“模拟题”。我们脑子里是如何对比两个版本号的，我们的代码就可以怎么写。<br>\n下面我做了一个动图，展示了版本号对比的整体流程。</p><p><img src="https://static001.geekbang.org/resource/image/25/ab/25a423b14908721aef1dd36082d345ab.gif?wh=1080x608" alt="图片"></p><p>我们可以看到，这个对比的流程，大致可以分为以下几个步骤。</p><ul>\n<li>第一步，将版本号的字符串用“点号”进行分割，得到两个字符串的列表。</li>\n<li>第二步，同时遍历这两个列表，将列表中的每一个元素转换成整数，比如，当遍历到第二位的时候，5、05这两个字符串，都会转换成数字5。这里<strong>有个细节</strong>，那就是当版本号的长度不一样的时候，比如，遍历到7.05.002.2的最后一位时，7.5.2其实已经越界了，这时候我们需要进行补零，然后再转换成数字。</li>\n<li>第三步，根据转换后的数字进行对比，如果两者相等的话，我们就继续遍历下一位。如果不相等的话，我们就能直接返回对比的结果了。</li>\n<li>第四步，如果两个版本号都遍历到了末尾，仍然没有对比出大小的差异，那么我们就认为这两个版本号相等，返回0即可。</li>\n</ul><p>所以，按照上面的思路，我们可以把compareVersion()这个函数分为以下几个部分：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int {\n    // ① 使用“.”，分割 version1 和 version2，得到list1、list2\n    // ② 同时遍历list1、list2，取出的元素v1、v2，并将其转换成整数，这里注意补零操作\n    // ③ 对比v1、v2的大小，如果它们两者不一样，我们就可以终止流程，直接返回结果。\n    // ④ 当遍历完list1、list2后仍然没有判断出大小话，说明两个版本号其实是相等的，这时候应该返回0\n}\n</code></pre><p>那么接下来，其实就很简单了。我们只需要将注释里面的自然语言，用代码写出来就行了。具体代码如下：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int {\n    // ① 分割\n    val list1 = version1.split(".")\n    val list2 = version2.split(".")\n\n    var i = 0\n    while (i &lt; list1.size || i &lt; list2.size) {\n        // ② 遍历元素\n        val v1 = list1.getOrNull(i)?.toInt()?:0\n        val v2 = list2.getOrNull(i)?.toInt()?:0\n\n        // ③ 对比\n        if (v1 != v2) {\n            return v1.compareTo(v2)\n        }\n        i++\n    }\n\n    // ④ 相等\n    return 0\n}\n</code></pre><p>在上面的代码中，有两个地方需要格外注意。</p><p><strong>一个是while循环的条件</strong>。由于list1、list2的长度可能是不一样的，所以，我们的循环条件是：list1、list2当中只要有一个没有遍历完的话，我们就要继续遍历。</p><p>还有一个需要注意的地方，<strong>getOrNull(i)，这是Kotlin独有的库函数</strong>。使用这个方法，我们不必担心越界问题，当index越界以后，这个方法会返回null，在这里我们把它跟 <a href="https://time.geekbang.org/column/article/472154">Elvis表达式</a>结合起来，就实现了自动补零操作。这也体现出了Kotlin表达式语法的优势。</p><p>好，到这里，我们就用第一种思路实现了版本号对比的算法。下面我们再来看看第二种思路。</p><h2>思路二</h2><p>前面的思路，我们是使用的Kotlin的库函数split()进行分割，然后对列表进行遍历来判断的版本号。其实，这种思路还可以<strong>进一步优化</strong>，那就是我们自己遍历字符串，来模拟split的过程，然后在遍历过程中，我们顺便就把比对的工作一起做完了。</p><p>思路二的整体过程比较绕，我同样是制作了一个动图来描述这个算法的整体流程：</p><p><img src="https://static001.geekbang.org/resource/image/dd/67/dd6a09c1428892c7dc5a52623842d067.gif?wh=1080x608" alt="图片"></p><p>以上的整体算法过程，是典型的“<strong>双指针</strong>”思想。运用这样的思想，我们大致可以写出下面这样的代码：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int {\n    val length1 = version1.length\n    val length2 = version2.length\n\n    // ①\n    var i = 0\n    var j = 0\n    // ②\n    while (i &lt; length1 || j &lt; length2) {\n        // ③\n        var x = 0\n        while (i &lt; length1 &amp;&amp; version1[i] != \'.\') {\n            x = x * 10 + version1[i].toInt() - \'0\'.toInt()\n            i++\n        }\n        i++\n\n        // ④\n        var y = 0\n        while (j &lt; length2 &amp;&amp; version2[j] != \'.\') {\n            y = y * 10 + version2[j].toInt() - \'0\'.toInt()\n            j++\n        }\n        j++\n\n        // ⑤\n        if (x != y) {\n            return x.compareTo(y)\n        }\n    }\n    // ⑥\n    return 0\n}\n</code></pre><p>这段代码一共有6个注释，我们来一个个解释。</p><ul>\n<li>注释①，代表的就是我们遍历两个版本号的index，双指针，指的就是它们两个。</li>\n<li>注释②，最外层的while循环，其实就是为了确保双指针可以遍历到两个字符串的末尾。你注意下这里的循环条件，只要version1、version2当中有一个没到末尾，就会继续遍历。</li>\n<li>注释③，这里就是在遍历version1，一直到字符串末尾，或者遇到“点号”。在同一个循环当中，我们会对x的值进行累加，这个做法其实就是把字符串的数字转换成十进制的数字。</li>\n<li>注释④，这里和注释③的逻辑一样，只是遍历的对象是version2。</li>\n<li>注释⑤，这里会对累加出来的x、y进行对比，不相同的话，我们就可以返回结果了。</li>\n<li>注释⑥，如果遍历到末尾还没有结果，这就说明version1、version2相等。</li>\n</ul><p>现在，我们就已经用Kotlin写出了两个题解，使用的思路都是命令式的编程方式。也许你会好奇，<strong>这个问题能用函数式的思路来实现吗？</strong></p><p>答案当然是可以的！</p><h2>思路三</h2><p>我们在前面就提到过，Kotlin是支持多范式的，我们可以根据实际场景来灵活选择编程范式。那么在这里，我们可以借鉴一下前面第一种解法的思路。</p><p>其实，想要解决这个问题，我们只要能把version1、version2转换成两个整数的列表，就可以很好地进行对比了。我制作了一个动图，方便你理解：</p><p><img src="https://static001.geekbang.org/resource/image/ee/32/eea4765d618437d7145ae77c8e404a32.gif?wh=1080x608" alt="图片"></p><p>根据这个流程，我们可以大致写出下面这样的代码：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(".")\n        .zipLongest(version2.split("."), "0") // ①\n        .onEach { // ②\n            with(it) {\n                if (first != second) {\n                    return first.compareTo(second)\n                }\n            }\n        }.run { return 0 }\n</code></pre><p>这段代码看起来很简洁，核心的逻辑在两个方法当中，我分别用注释标注了。</p><ul>\n<li>注释①，zipLongest()这个方法，它的作用是将version1、version2对应的列表合并到一起，它返回值的类型是List&lt;Pair&lt;Int, Int&gt;&gt;。</li>\n<li>注释②，onEach()，其实它是一个高阶函数，它的作用就是遍历List当中的每一个Pair，将其中的整型版本号拿出来对比，如果不一样，就可以直接返回结果。</li>\n</ul><p>现在，你可能会感慨，这代码看起来真香啊！这个嘛……别高兴得太早。虽然Kotlin支持基础的zip语法，但它目前还不支持zipLongest()这么高级的操作符。</p><p>那么这该怎么办呢？我们只能自己来实现zipLongest()了！为了让前面的代码通过编译，我们必须要自己动手实现下面三个扩展函数。</p><pre><code class="language-plain">private fun Iterable&lt;String&gt;.zipLongest(\n    other: Iterable&lt;String&gt;,\n    default: String\n): List&lt;Pair&lt;Int, Int&gt;&gt; {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() || second.hasNext()) {\n        val v1 = (first.nextOrNull() ?: default).toInt()\n        val v2 = (second.nextOrNull() ?: default).toInt()\n        list.add(Pair(v1, v2))\n    }\n    return list\n}\n\nprivate fun &lt;T&gt; Iterable&lt;T&gt;.collectionSizeOrDefault(default: Int): Int =\n        if (this is Collection&lt;*&gt;) this.size else default\n\nprivate fun &lt;T&gt; Iterator&lt;T&gt;.nextOrNull(): T? = if (hasNext()) next() else null\n\n// Pair 是Kotlin标准库提供的一个数据类\n// 专门用于存储两个成员的数据\n// 提交代码的时候，Pair不需要拷贝进去\npublic data class Pair&lt;out A, out B&gt;(\n    public val first: A,\n    public val second: B\n) : Serializable {\n    public override fun toString(): String = "($first, $second)"\n}\n</code></pre><p>这三个扩展函数实现起来还是比较简单的，zipLongest()其实就是合并了两个字符串列表，然后将它们按照index合并成Pair，另外那两个扩展函数都只是起了辅助作用。</p><p>这样，我们把前面的代码一起粘贴到LeetCode当中，其实代码是可以通过的。不过呢，我们的代码当中其实还有一个<strong>比较深的嵌套</strong>，看起来不是很顺眼：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(".")\n        .zipLongest(version2.split("."), "0")\n        .onEach {\n            // 这里的嵌套比较深\n            with(it) {\n                if (first != second) {\n                    return first.compareTo(second)\n                }\n            }\n        }.run { return 0 }\n</code></pre><p>你可以注意到，在onEach当中，有一个代码块，它有两层嵌套，这看起来有点丑陋。那么，我们能不能对它进一步优化呢？</p><p>当然是可以的。</p><p>这里，我们只需要想办法让onEach当中的Lambda，变成<a href="https://time.geekbang.org/column/article/476637">带接收者的函数类型</a>即可。具体做法就是，我们自己实现一个新的onEachWithReceiver()的高阶函数。</p><pre><code class="language-plain">//                                                        注意这里\n//                                                           ↓\ninline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEachWithReceiver(action: T.() -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n//                                                   注意这里\n// Kotlin库函数当中的onEach                                ↓\npublic inline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEach(action: (T) -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n</code></pre><p>上面的代码展示了onEach()和onEachWithReceiver()之间的差别，可以看到，它们两个的函数体其实没有任何变化，区别只是action的函数类型而已。</p><p>所以在这里，借助onEachWithReceiver()，就可以进一步简化我们的代码：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(".")\n        .zipLongest(version2.split("."), "0")\n        .onEachWithReceiver {\n            // 减少了一层嵌套\n            if (first != second) {\n                return first.compareTo(second)\n            }\n        }.run { return 0 }\n</code></pre><p>在这段代码中，我们把onEach()改成了onEachWithReceiver()，因为它里面的Lambda是带有接收者，原本的Pair对象变成了this对象，这样，我们就可以直接使用first、second来访问Pair当中的成员了。</p><p>现在，就让我们来看看整体的代码吧：</p><pre><code class="language-plain">fun compareVersion(version1: String, version2: String): Int =\n    version1.split(".")\n        .zipLongest(version2.split("."), "0")\n        .onEachWithReceiver {\n            if (first != second) {\n                return first.compareTo(second)\n            }\n        }.run { return 0 }\n\nprivate inline fun &lt;T, C : Iterable&lt;T&gt;&gt; C.onEachWithReceiver(action: T.() -&gt; Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\nprivate fun &lt;T&gt; Iterable&lt;T&gt;.collectionSizeOrDefault(default: Int): Int =\n    if (this is Collection&lt;*&gt;) this.size else default\n\nprivate fun &lt;T&gt; Iterator&lt;T&gt;.nextOrNull(): T? = if (hasNext()) next() else null\n\nprivate fun Iterable&lt;String&gt;.zipLongest(\n    other: Iterable&lt;String&gt;,\n    default: String\n): List&lt;Pair&lt;Int, Int&gt;&gt; {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() || second.hasNext()) {\n        val v1 = (first.nextOrNull() ?: default).toInt()\n        val v2 = (second.nextOrNull() ?: default).toInt()\n        list.add(Pair(v1, v2))\n    }\n    return list\n}\n</code></pre><p>好了，这就是我们的第三种思路。看完这三种思路以后，你会更倾向于哪种思路呢？</p><h2>小结</h2><p>这节课，我们使用了三种思路，实现了<a href="https://leetcode-cn.com/problems/compare-version-numbers/">LeetCode的165号题《版本号判断》</a>。其中，前两种思路，是命令式的编程方式，第三种是偏函数式的方式。在我看来呢，这三种方式各有优劣。</p><ul>\n<li>思路一，代码逻辑比较清晰，代码量小，时间复杂度、空间复杂度较差。</li>\n<li>思路二，代码逻辑比较复杂，代码量稍大，时间复杂度、空间复杂度非常好。</li>\n<li>思路三，代码主逻辑非常清晰，代码量大，时间复杂度、空间复杂度较差。</li>\n</ul><p>第三个思路其实还有一个额外的优势，那就是，我们自己实现的扩展函数，可以用于以后解决其他问题。这就相当于沉淀出了有用的工具。</p><h2>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用Kotlin来完成<a href="https://leetcode-cn.com/problems/solve-the-equation/">LeetCode的640号题《求解方程》</a>。这道题目我同样会在下节课给出答案解析。</p><p>欢迎继续给我留言，我们下节课再见。</p>',
        article_title: "春节刷题计划（二）| 一题三解，搞定版本号判断",
      },
      {
        title: "春节刷题计划（三）| 一题双解，搞定求解方程",
        id: 484366,
        content:
          '<p>你好，我是朱涛。初二过年好！</p><p>在上节课里，我给你留了一个作业，那就是：用Kotlin来完成 <a href="https://leetcode-cn.com/problems/solve-the-equation/">LeetCode的640号题《求解方程》</a>。那么这节课，我就来讲讲我的解题思路，我们互相学习。</p><p>这道题也非常容易理解，程序的输入是一个“一元一次方程”，我们需要根据输入的方程，计算出正确的结果。根据输入方程的不同，结果可能有三种情况：</p><ul>\n<li><strong>方程仅有一个解</strong>，这时，我们只需要按照格式返回结果即可，比如输入“2x=4”，那么输出就应该是“x=2”。</li>\n<li><strong>方程有无数个解</strong>，比如输入“x=x”，那么输出就应该是“Infinite solutions”。</li>\n<li><strong>方程无解</strong>，比如输入“x=x+5”，那么输出结果就应该是“No solution”。</li>\n</ul><p>另外，对于程序的<strong>输入格式</strong>，其实我们还有几个问题需要弄清楚。只有弄清楚了这些问题，我们才能开始写代码：</p><ul>\n<li>方程当中的未知数只会用x表示，不会是y，也不会是大写的“X”。</li>\n<li>方程当中不会出现空格，比如“2x=4”，不会出现“2x   =  4   ”的情况。</li>\n<li>方程当中只会有加减法，不会出现乘除法。</li>\n<li>方程当中的数字，一定是整数，不会出现分数、小数。</li>\n<li>输入的方程一定是一个正确的方程，不会出现“x=…”之类的脏数据。</li>\n</ul><p>好，问题的细节都弄清楚了，下面我们来分析一下解题的思路。</p><!-- [[[read_end]]] --><p>对于这种简单的一元一次方程的解法，其实我们在小学就学过了，概括起来，就是分为三个步骤。</p><ul>\n<li>第一步，<strong>移项</strong>。将含有x的式子全部移到等式的左边，将数字全部都移到等式的右边。另外，移项的时候符号要变。比如“3x-4=x+2”这个方程，移项以后，就会变成这样：“3x-x=2+4”。</li>\n<li>第二步，<strong>合并同类项</strong>。这里其实就是将等式的左边与右边合并起来，对于“3x-x=2+4”这个式子，合并完以后，就会变成“2x=6”。</li>\n<li>第三步，<strong>系数化为一</strong>。这时候，我们就需要拿右边的数字，除以左边的系数。比如上面的式子“2x=6”，系数化为一之后，就会变成“x=3”，这就是我们想要的方程解。当然，这只是方程只有一个解的情况，其实在系数化为一之前，还存在其他的情况，比如“x=x+5”最终会变成“0=5”，这时候左边是零，右边不是零，这时候就代表方程无解；对于“2x=2x”这样的方程，它最终会变成“0=0”，这种两边都等于零的情况，就代表了方程有无数个解。</li>\n</ul><p>好，如何求解方程的思路我们已经知道了，那么代码该如何写呢？这里，我们仍然有两种解法，这两种解法的思路是一致的，只是其中一种是偏命令式的，另一种是偏函数式的。</p><p>这里，我照样是制作了一张动图，给你展示下程序运行的整体思路：</p><p><img src="https://static001.geekbang.org/resource/image/4b/91/4bbc7f1f21cd04e1b17f8032304a2691.gif?wh=1080x608" alt="图片"></p><h2>解法一：命令式</h2><p>首先，我们按照前面分析的思路，把待实现的程序分为以下几个步骤：</p><pre><code class="language-plain">fun solveEquation(equation: String): String {\n    // ① 分割等号\n    // ② 遍历左边的等式，移项，合并同类项\n    // ③ 遍历右边的等式，移项，合并同类项\n    // ④ 系数化为一，返回结果\n}\n</code></pre><p>根据注释，我们很容易就能完成其中①、④两个步骤的代码：</p><pre><code class="language-plain">fun solveEquation(equation: String): String {\n        // ① 分割等号\n        val list = equation.split("=")\n\n        // ② 遍历左边的等式，移项，合并同类项\n        // ③ 遍历右边的等式，移项，合并同类项\n\n        // ④ 系数化为一,返回结果\n        return when {\n            leftSum == 0 &amp;&amp; rightSum == 0 -&gt; "Infinite solutions"\n            leftSum == 0 &amp;&amp; rightSum != 0 -&gt; "No solution"\n            else -&gt; "x=${rightSum / leftSum}"\n        }\n    }\n</code></pre><p>现在，关键还是在于②、③两个步骤的代码。这里，list[0]其实就代表了左边的式子，list[1]就代表了右边的式子。</p><p>按照之前的思路分析，我们其实用两个for循环，分别遍历它们，然后顺便完成移项与合并同类项就行了。具体的代码如下：</p><pre><code class="language-plain">var leftSum = 0\nvar rightSum = 0\n\nval leftList = splitByOperator(list[0])\nval rightList = splitByOperator(list[1])\n\n// ② 遍历左边的等式，移项，合并同类项\nleftList.forEach {\n    if (it.contains("x")) {\n        leftSum += xToInt(it)\n    } else {\n        rightSum -= it.toInt()\n    }\n}\n\n// ③ 遍历右边的等式，移项，合并同类项\nrightList.forEach{\n    if (it.contains("x")) {\n        leftSum -= xToInt(it)\n    } else {\n        rightSum += it.toInt()\n    }\n}\n</code></pre><p>这段代码的逻辑其实也比较清晰了，leftList、rightList是根据“+”、“-”分割出来的元素。在完成分割以后，我们再对它们进行了遍历，从而完成了移项与合并同类项。</p><p>并且，这里我们还用到了另外两个方法，分别是splitByOperator()、xToInt()，它们具体的代码如下：</p><pre><code class="language-plain">private fun splitByOperator(list: String): List&lt;String&gt; {\n    val result = mutableListOf&lt;String&gt;()\n    var temp = ""\n    list.forEach {\n        if (it == \'+\' || it == \'-\') {\n            if (temp.isNotEmpty()) {\n                result.add(temp)\n            }\n            temp = it.toString()\n        } else {\n            temp += it\n        }\n    }\n\n    result.add(temp)\n    return result\n}\n\nprivate fun xToInt(x: String) =\n    when (x) {\n        "x",\n        "+x" -&gt; 1\n        "-x" -&gt; -1\n        else -&gt; x.replace("x", "").toInt()\n    }\n</code></pre><p>从以上代码中，我们可以看到splitByOperator()就是使用“+”、“-”作为分隔符，将字符串类型的式子，分割成一个个的元素。而xToInt()的作用则是为了提取x的系数，比如“2x”，提取系数以后，就是“2”；而“-2x”的系数就是“-2”。</p><p>最后，我们再来看看整体的代码：</p><pre><code class="language-plain">fun solveEquation(equation: String): String {\n    // ① 分割等号\n    val list = equation.split("=")\n\n    var leftSum = 0\n    var rightSum = 0\n\n    val leftList = splitByOperator(list[0])\n    val rightList = splitByOperator(list[1])\n\n    // ② 遍历左边的等式，移项，合并同类项\n    leftList.forEach {\n        if (it.contains("x")) {\n            leftSum += xToInt(it)\n        } else {\n            rightSum -= it.toInt()\n        }\n    }\n\n    // ③ 遍历右边的等式，移项，合并同类项\n    rightList.forEach{\n        if (it.contains("x")) {\n            leftSum -= xToInt(it)\n        } else {\n            rightSum += it.toInt()\n        }\n    }\n\n    // ④ 系数化为一,返回结果\n    return when {\n        leftSum == 0 &amp;&amp; rightSum == 0 -&gt; "Infinite solutions"\n        leftSum == 0 &amp;&amp; rightSum != 0 -&gt; "No solution"\n        else -&gt; "x=${rightSum / leftSum}"\n    }\n}\n\n// 根据“+”、“-”分割式子\nprivate fun splitByOperator(list: String): List&lt;String&gt; {\n    val result = mutableListOf&lt;String&gt;()\n    var temp = ""\n    list.forEach {\n        if (it == \'+\' || it == \'-\') {\n            if (temp.isNotEmpty()) {\n                result.add(temp)\n            }\n            temp = it.toString()\n        } else {\n            temp += it\n        }\n    }\n\n    result.add(temp)\n    return result\n}\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        "x",\n        "+x" -&gt; 1\n        "-x" -&gt; -1\n        else -&gt; x.replace("x", "").toInt()\n    }\n</code></pre><p>至此，偏命令式的代码就完成了，接下来我们看看偏函数式的代码该怎么写。</p><h2>解法二：函数式</h2><p>这里你要注意了，函数式的思路呢，和命令式的思路其实是<strong>一样</strong>的。解方程的步骤是不会变的，仍然是移项、合并同类项、系数化为一。只不过，对比前面的实现方式，我们这里会更多地<strong>借助Kotlin的标准库函数</strong>。</p><p>首先，我们来看看第一部分的代码怎么写：</p><pre><code class="language-plain">fun solveEquation(equation: String): String {\n    val list = equation\n        .replace("-", "+-") // 预处理逻辑\n        .split("=")\n\n    // 用“+”分割字符串\n    val leftList = list[0].split("+")\n    val rightList = list[1].split("+")\n\n    // 省略\n}\n</code></pre><p>这里，为了可以直接使用Kotlin的库函数split来实现算式的分割，我使用了一种<strong>数据预处理</strong>的办法。你可以看到，在上面代码的注释处，<code>replace("-", "+-")</code> 的作用是将算式当中的所有“-”替换成“<code>+-</code>”，这就是预处理。经过这个预处理后，我们就可以直接使用 <code>split("+")</code> 来分割算式了。</p><p>为了体现这个细节，我这里也做了一个动图，你可以看看：</p><p><img src="https://static001.geekbang.org/resource/image/b5/e9/b54e8c509be711cea6d3a0c1f22617e9.gif?wh=1080x425" alt="图片"></p><p>这样一来，我们得到的leftList、rightList其实就是干净的、独立的数字和x式子了。以“x+5-3+x=6+x-2”为例，<code>leftList=["x","5","-3","x"]</code>，而<code>rightList=["6","x","-2"]</code>。</p><p>既然它们两者都是普通的集合，那么我们接下来，就完全可以借助Kotlin强大的库函数来做剩下的事情了。我们只需要将所有x的式子挪到左边，所有数字挪到右边，然后合并，最后系数化为一即可。大致代码如下：</p><pre><code class="language-plain">leftList\n    .filter { it.hasX() }\n    .map { xToInt(it) } // ①\n    .toMutableList() \n    .apply {\n        rightList\n            .filter { it.hasX() }\n            .map { xToInt(it).times(-1) } // ②\n            .let { addAll(it) } \n    }.sum() // ③\n    .let { leftSum = it }\n\nrightList\n    .filter { it.isNumber() }\n    .map { it.toInt() } // ④\n    .toMutableList()\n    .apply {\n        leftList\n            .filter { it.isNumber() }\n            .map { it.toInt().times(-1) } // ⑤\n            .let { addAll(it) } \n    }.sum() // ⑥\n    .let { rightSum = it }\n\n// 返回结果\nreturn when {\n    leftSum == 0 &amp;&amp; rightSum == 0 -&gt; "Infinite solutions"\n    leftSum == 0 &amp;&amp; rightSum != 0 -&gt; "No solution"\n    else -&gt; "x=${rightSum / leftSum}" // ⑦\n}\n</code></pre><p>上面这段代码中，一共有6个注释，我们一个个看：</p><ul>\n<li>注释①，我们提取出了左边式子里所有x的系数，这里不需要移项，因为它本来就在左边。</li>\n<li>注释②，我们提取了右边式子里所有x的系数，由于这里涉及到移项，因此需要变号，这里我们通过乘以一个“-1”来实现的。</li>\n<li>注释③，我们将所有x的系数合并到了一起，得到了左边x的系数之和。</li>\n<li>注释④，我们收集了右边式子里所有的数字，这里也不需要移项，因为它本来就在右边。</li>\n<li>注释⑤，我们收集了左边式子里所有的数字，这里要移项，所以要变号。</li>\n<li>注释⑥，我们将所有数字求和了。</li>\n<li>注释⑦，如果方程有解的话，我们通过“rightSum / leftSum”就可以计算出来了。</li>\n</ul><p>另外，以上代码其实还涉及到三个辅助的函数，需要我们自己实现，它们的逻辑都很简单：</p><pre><code class="language-plain">private fun String.isNumber(): Boolean =\n    this != "" &amp;&amp; !this.contains("x")\n\nprivate fun String.hasX(): Boolean =\n    this != "" &amp;&amp; this.contains("x")\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        "x" -&gt; 1\n        "-x" -&gt; -1\n        else -&gt; x.replace("x", "").toInt()\n    }\n</code></pre><p>xToInt()这个函数和之前的逻辑是相似的，isNumber()和hasX()这两个扩展函数，它们是用来判断式子是纯数字、还是含有x的，这是因为我们要把x放到等式左边，而数字要放到等式右边。</p><p>最后，我们再来看看整体的代码：</p><pre><code class="language-plain">fun solveEquation(equation: String): String {\n    val leftSum: Int\n    val rightSum: Int\n\n    val list = equation\n        .replace("-", "+-") // 预处理数据\n        .split("=")\n\n    val leftList = list[0].split("+")\n    val rightList = list[1].split("+")\n\n    // 求出所有x的系数之和\n    leftList\n        .filter { it.hasX() }\n        .map { xToInt(it) }\n        .toMutableList()\n        .apply {\n            rightList\n                .filter { it.hasX() }\n                .map { xToInt(it).times(-1) }\n                .let { addAll(it) }\n        }.sum()\n        .let { leftSum = it }\n\n    // 求出所有数字之和\n    rightList\n        .filter { it.isNumber() }\n        .map { it.toInt() }\n        .toMutableList()\n        .apply {\n            leftList\n                .filter { it.isNumber() }\n                .map { it.toInt().times(-1) }\n                .let { addAll(it) }\n        }.sum()\n        .let { rightSum = it }\n\n    // 返回结果\n    return when {\n        leftSum == 0 &amp;&amp; rightSum == 0 -&gt; "Infinite solutions"\n        leftSum == 0 &amp;&amp; rightSum != 0 -&gt; "No solution"\n        else -&gt; "x=${rightSum / leftSum}"\n    }\n}\n\nprivate fun String.isNumber(): Boolean =\n    this != "" &amp;&amp; !this.contains("x")\n\nprivate fun String.hasX(): Boolean =\n    this != "" &amp;&amp; this.contains("x")\n\n// 提取x的系数：“-2x” -&gt;“-2”\nprivate fun xToInt(x: String) =\n    when (x) {\n        "x" -&gt; 1\n        "-x" -&gt; -1\n        else -&gt; x.replace("x", "").toInt()\n    }\n</code></pre><h2>小结</h2><p>这节课，我们用两种方式实现了<a href="https://leetcode-cn.com/problems/solve-the-equation/">LeetCode的640号题《求解方程》</a>。这两种解法的核心思路其实是一致的，不过前者是偏命令式的，后者是偏函数式的。而你要清楚，即使它们是用的一种思路，也仍然是各有优劣的。</p><ul>\n<li>解法一，命令式的代码，它的时间复杂度和空间复杂度要稍微好一些，但总体差距不大，所以不一定能体现出运行时的差异。这种方式的劣势在于，逻辑相对复杂，可读性稍差，且编码过程中容易出错。</li>\n<li>解法二，偏函数式的代码，它的优势在于，代码逻辑相对清晰，并且，由于运用了大量Kotlin库函数，没那么容易出错。</li>\n</ul><h2>小作业</h2><p>好，最后，我还是给你留一个小作业，请你用Kotlin来完成 <a href="https://leetcode-cn.com/problems/fraction-addition-and-subtraction/">LeetCode的592号题《分数加减运算》</a>，下节课我也会给出我的答案。</p>',
        article_title: "春节刷题计划（三）| 一题双解，搞定求解方程",
      },
      {
        title: "春节刷题计划（四）| 一题三解，搞定分式加减法",
        id: 484369,
        content:
          '<p>你好，我是朱涛。今天是初四了，在过年的节日氛围里你还能来坚持学习，这里也跟优秀的你说声感谢。</p><p>在上节课里呢，我给你留了一个作业：用Kotlin来完成 <a href="https://leetcode-cn.com/problems/fraction-addition-and-subtraction/">LeetCode的592号题《分数加减运算》</a>。那么今天这节课，我们就一起来看看它的解题思路吧。</p><p>这其实也是一道典型的模拟题，分式的加减法这样的题目，我们小学就知道怎么做了，核心解题思路主要是这几步：</p><ul>\n<li>第一步，求出分母的<strong>最小公倍数</strong>。比如，2和3的最小公倍数就是6。</li>\n<li>第二步，根据计算出来的最小公倍数，将分数进行<strong>通分</strong>。举个例子：“1/2-1/6”，如果把它们两个通分，就会变成“3/6-1/6”。</li>\n<li>第三步，将<strong>分子进行加减法</strong>，计算出分子的结果。比如，“3/6-1/6”计算过后，就会变成“2/6”。</li>\n<li>最后一步，将计算结果转换成“<strong>最简分数</strong>”，比如“2/6”化成最简分数以后，应该是“1/3”。</li>\n</ul><p>经过这四个步骤，我们就可以计算出“1/2-1/6=1/3”。不过呢，这道题里，我们除了要计算分数的加减法以外，还要先完成分数的解析。程序的输入是字符串“1/2-1/6”，但它是不会帮我们自动解析的，所以，解析这一步也需要我们来做。</p><p>所以，自然而然地，我们就会定义一个分数的<strong>数据类Expression</strong>。</p><!-- [[[read_end]]] --><pre><code class="language-plain">data class Expression(val numerator: Int, val denominator: Int) {\n    override fun toString(): String {\n        return "$numerator/$denominator"\n    }\n}\n</code></pre><p>在这个数据类Expression当中，一共有两个属性，<strong>numerator</strong>代表了分子，<strong>denominator</strong>代表了分母，它们的类型都是Int。另外，分数都是带有符号的，这里我们按照约定俗成来处理：分子可能是正数或负数，分母则一定是正整数。比如“1/2”，我们就用Expression(1,2)来表示；而“-1/2”，我们就用Expression(-1,2)来表示，而不会使用Expression(1,-2)表示。</p><p>另外在正式开始做题之前，还有一些额外的条件是需要我们弄清楚的：</p><ul>\n<li>第一，只需要支持分数的加减法，乘除法不需要考虑；</li>\n<li>第二，输入的式子中间不会有空格，且式子也一定是正确的，这就意味着，我们的输入只会包含“0-9”、“/”，“+”、“-”这些字符，不会出现其他的字符；</li>\n<li>第三，整数也会用分数来表示，比如说“2”，会用“2/1”来表示；</li>\n<li>第四，计算结果保证不会整型溢出。</li>\n</ul><p>好，问题的细节我们弄清楚了，大致思路也有了，接下来，我们就用三种解法来搞定这道题。</p><h2>解法一：命令式</h2><p>命令式的代码是最符合编程直觉的，我们的思路大致如下：</p><ul>\n<li>第一步，将式子当中的“-”统一替换成“<code>+-</code>”，然后再用<code>split("+")</code>将式子分割成一个个独立分数。这种技巧我们在上节课就已经用过了。</li>\n<li>第二步，解析出独立的分数以后，我们就要将每一个分数解析成对应的Expression了。这里具体做法也很简单，我们可以用“/”来分割分数，前面的就是分子，后面的就是分母。比如“-1/2”，我们就可以解析出Expression(-1,2)。</li>\n<li>第三步，就是根据解析出来的所有分母，计算出所有分母的最小公倍数。比如，“1/2+1/3+1/4”，我们就把分母都提取出来“2，3，4”，而它们的最小公倍数应该是12。</li>\n<li>第四步，就是将所有的分数都通分。比如“1/2+1/3+1/4”，就会变成“6/12+4/12+3/12”。</li>\n<li>后面的步骤就简单了，我们只需要将分子都相加起来，确保结果是“最简分数”即可。</li>\n</ul><p>整个过程如下图：</p><p><img src="https://static001.geekbang.org/resource/image/8d/75/8d56a2f3f4c07946417863810cf16275.gif?wh=1080x608" alt="图片"></p><p>所以，我们就可以把代码分为以下几个步骤：</p><pre><code class="language-plain">fun fractionAddition(expression: String): String {\n    // ①，分割式子\n    // ②，解析分数成Expression\n    // ③，计算所有分母的最小公倍数\n    // ④，将所有的分数都通分\n    // ⑤，将所有分子加起来进行计算，得到结果\n    // ⑥，将结果化为“最简分数”\n    // ⑦，最后，返回toString()的结果\n}\n</code></pre><p>把编码步骤梳理清楚了以后，其实我们每一个步骤都不难实现了：</p><pre><code class="language-plain">fun fractionAddition(expression: String): String {\n    // ①，分割式子\n    val list = expression.replace("-", "+-")\n    val fractionList = list.split("+")\n    val expressionList = mutableListOf&lt;Expression&gt;()\n\n    // ②，解析分数成Expression\n    for (item in fractionList) {\n        if (item.trim() != "") {\n            expressionList.add(parseExpression(item))\n        }\n    }\n\n    // ③，计算所有分母的最小公倍数\n    var lcm = 1\n    for (exp in expressionList) {\n        lcm = lcm(lcm, exp.denominator)\n    }\n\n    // ④，将所有的分数都通分\n    val commonDenominatorFractions = mutableListOf&lt;Expression&gt;()\n    for (exp in expressionList) {\n        commonDenominatorFractions.add(toCommonDenominatorExp(exp, lcm))\n    }\n\n    // ⑤，将所有分子加起来进行计算，得到结果\n    var numerator = 0\n    for (fraction in commonDenominatorFractions) {\n        numerator += fraction.numerator\n\n    }\n\n    // ⑥，将结果化为“最简分数”\n    val result = Expression(numerator, lcm)\n    val reducedFraction = result.reducedFraction()\n\n    // ⑦，最后，返回toString()的结果\n    return reducedFraction.toString()\n}\n</code></pre><p>在上面的代码当中，还涉及到几个辅助函数，它们的实现也很简单。</p><pre><code class="language-plain">// 解析分数，“1/2” -&gt; Expression(1,2)\nprivate fun parseExpression(expression: String): Expression {\n    val list = expression.trim().split("/")\n\n    if (list.size != 2) {\n        throw IllegalArgumentException()\n    }\n\n    return Expression(list[0].toInt(), list[1].toInt())\n}\n\n// 通分\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression {\n    return Expression(\n        numerator = expression.numerator * lcm / expression.denominator,\n        denominator = lcm\n    )\n}\n\n// 最简化分数\nprivate fun Expression.reducedFraction(): Expression {\n    val gcd = gcd(Math.abs(numerator), denominator)\n    return Expression(numerator / gcd, denominator / gcd)\n}\n\n// 求两个数的最小公倍数，Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// 求两个数的最大公约数，Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><p>这几个辅助函数，需要注意的是 <strong>reducedFraction()</strong>，它的作用是计算最简分数，计算过程，其实就是计算出分子、分母的最大公约数，然后同时除以最大公约数。而最大公约数 <strong>gcd()</strong> 这个方法，本质上就是我们小学学过的<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>。而最小公倍数 <strong>lcm()</strong> 这个方法，则是通过两数相乘，然后除以最大公约数求出来的。</p><p>至此，我们的第一种解法就完成了。</p><h2>解法二：函数式</h2><p>其实，利用同样的思想，我们还可以写出函数式的解法。如果你足够细心的话，你会发现解法一的代码可读性并不是很好，而如果用函数式思想重构上面的代码的话，可读性将会得到很大改善。</p><pre><code class="language-plain">fun fractionAddition(expression: String): String {\n    var lcm: Int\n    return expression\n        .replace("-", "+-")\n        .split("+")\n        .filter { it.trim() != "" }\n        .map(::parseExpression)\n        .also { lcm = getCommonDenominator(it) }\n        .map { toCommonDenominatorExp(it, lcm) }\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n}\n</code></pre><p>这段代码，我们从上读到下，就跟读英语文本一样：</p><ul>\n<li>首先，使用“<code>+-</code>”替代“-”；</li>\n<li>接着，将其用“+”分割；</li>\n<li>之后，过滤无效的字符；</li>\n<li>然后，将字符串解析成Expression；</li>\n<li>这时候，我们根据所有的分母，计算出所有分母的最小公倍数；</li>\n<li>接着，我们就可以对所有的分数进行通分；</li>\n<li>然后，就可以将所有的分子相加，得到计算结果；</li>\n<li>最后，就是将结果化为“最简分数”，再返回toString()的结果。</li>\n</ul><p>那么，要写出上面这样的代码，我们仍然是需要一些辅助函数的，它们的逻辑跟解法一是一样的，只是换了种写法。</p><pre><code class="language-plain">private fun parseExpression(expression: String) =\n    expression.trim()\n        .split("/")\n        .takeIf { it.size == 2 }\n        ?.let { Expression(it[0].toInt(), it[1].toInt()) }\n        ?: throw IllegalArgumentException()\n\nprivate fun getCommonDenominator(list: List&lt;Expression&gt;) =\n    list.map { it.denominator }.reduce(::lcm)\n\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression =\n    expression.let {\n        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)\n    }\n\nprivate fun calculateExp(acc: Expression, expression: Expression): Expression =\n    Expression(acc.numerator + expression.numerator, acc.denominator)\n\nprivate fun Expression.reducedFraction(): Expression =\n    gcd(Math.abs(numerator), denominator)\n        .let { Expression(numerator / it, denominator / it) }\n\n// Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><p>可以发现，对于复杂一些的方法来说，如果以函数式的思路来重构的话，可读性会有比较明显的提升。而对于原本就很简单的方法，重构之后，可读性反而会下降。所以，<strong>我们在写Kotlin的时候，不能一味追求所谓的范式正确，哪种范式更合适，我们就应该用哪个。</strong></p><h2>解法三：稳定性优化</h2><p>好，前面的这两种解法的思路都是一样的，不过这两种解法其实还是会有一个问题，那就是当分数很多，并且分母很大的情况下，我们一次性计算所有分母的最小公倍数时，是可能导致溢出的（当然，我们前面已经明确讲过不需要考虑溢出）。</p><p>所以，前面两种解法的思路还可以再进一步优化，同时也可以避免溢出的问题。它整体的思路没有什么大的变化，只是在计算的时候不会采取一次性将所有分数通分的策略，而是选择一次计算两个相邻的分数，得到结果以后再计算下一个。</p><p>这里我制作了一个动图，方便你理解它的整体过程：</p><p><img src="https://static001.geekbang.org/resource/image/8e/a7/8e30b6e8f7c196f0068f2835ec8e51a7.gif?wh=1080x608" alt="图片"></p><p>可以看到，这种思路的唯一区别就在于，它会先计算“1/3-1/2”的结果，将结果化为最简分数以后，再拿结果进行下一步计算“-1/6+1/4”，最终才会得到结果“1/12”。</p><p>这样，我们在解法二的基础上，稍作改动就能实现：</p><pre><code class="language-plain">fun fractionAddition(expression: String): String =\n    expression\n        .replace("-", "+-")\n        .split("+")\n        .filter { it.trim() != "" }\n        .map(::parseExpression)\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n</code></pre><p>其实，我们也就是通过reduce(::calculateExp)这行代码，来计算相邻的分数的。</p><p>下面，我们具体来看看calculateExp()这个方法。</p><pre><code class="language-plain">private fun calculateExp(acc: Expression, expression: Expression): Expression {\n    val lcm = lcm(acc.denominator, expression.denominator)\n    val exp1 = toCommonDenominatorExp(acc, lcm)\n    val exp2 = toCommonDenominatorExp(expression, lcm)\n    return Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()\n}\n</code></pre><p>calculateExp()方法的实现也很简单，它的作用是计算两个分数的结果。总体流程就是：</p><ul>\n<li>第一步，计算两个分数分母的最小公倍数lcm；</li>\n<li>第二步，根据lcm，将两个分数都通分；</li>\n<li>第三步，将分数的分子都相加，然后化简为“最简分数”。</li>\n</ul><p>至此，解法三的代码就完成了，除了calculateExp()这个方法的实现之外，其他代码跟解法二是一样的。我们来看看它整体的代码吧。</p><pre><code class="language-plain">fun fractionAddition(expression: String): String =\n    expression\n        .replace("-", "+-")\n        .split("+")\n        .filter { it.trim() != "" }\n        .map(::parseExpression)\n        .reduce(::calculateExp)\n        .reducedFraction()\n        .toString()\n\n\nprivate fun parseExpression(expression: String) =\n    expression.trim()\n        .split("/")\n        .takeIf { it.size == 2 }\n        ?.let { Expression(it[0].toInt(), it[1].toInt()) }\n        ?: throw IllegalArgumentException()\n\nprivate fun toCommonDenominatorExp(expression: Expression, lcm: Int): Expression =\n    expression.let {\n        Expression(numerator = it.numerator * lcm / it.denominator, denominator = lcm)\n    }\n\nprivate fun calculateExp(acc: Expression, expression: Expression): Expression {\n    val lcm = lcm(acc.denominator, expression.denominator)\n    val exp1 = toCommonDenominatorExp(acc, lcm)\n    val exp2 = toCommonDenominatorExp(expression, lcm)\n    return Expression(exp1.numerator + exp2.numerator, lcm).reducedFraction()\n}\n\nprivate fun Expression.reducedFraction(): Expression =\n    gcd(Math.abs(numerator), denominator)\n        .let { Expression(numerator / it, denominator / it) }\n\n// Least Common Multiple\nprivate fun lcm(a: Int, b: Int) = a * b / gcd(a, b)\n\n// Greatest Common Divisor\nprivate fun gcd(a: Int, b: Int): Int {\n    var (big, small) = if (a &gt; b) a to b else b to a\n\n    while (small != 0) {\n        val temp = small\n        small = big % small\n        big = temp\n    }\n    return big\n}\n</code></pre><h2>小结</h2><p>这节课，我们一共用了三种解法来实现 <a href="https://leetcode-cn.com/problems/fraction-addition-and-subtraction/">LeetCode的592号题《分数加减运算》</a>这道题。解法一和二，它们的思路是一致的，只是前者是命令式，后者是函数式。而解法三，则是在解法二的基础上做的优化。我们可以来对比一下这三种解法。</p><ul>\n<li>解法一，可读性差，时间复杂度、空间复杂度稍差，复杂的情况下可能会出现溢出。</li>\n<li>解法二，类似解法一，只是可读性要好很多。</li>\n<li>解法三，类似解法二，优势在于不容易出现溢出。</li>\n</ul><p>不知不觉，春节假期就快要过去了。在这一周里，我们体验了一把用Kotlin刷题的感觉。总体来说，用Kotlin来刷算法题还是比较愉快的，对比起Java，它能提供丰富API的同时，还能提供多样的编程范式。对于不同的问题，我们可以灵活选择编程范式来解决。</p><p>在这一周里，我故意在使用多种范式来刷题，目的就是让你可以体会到Kotlin在面对不同问题的时候，它在不同编程范式上的不同表现。</p><ul>\n<li>比如，对于“版本号判断”这个题目来说，命令式的代码明显会更加的简洁，而函数式的代码则有些丑陋。</li>\n<li>比如，对于“求解方程”这个题目来说，函数式与命令式之间各有优劣。</li>\n<li>而对于今天这个“分数加减法”的题目来说，函数式的解法则是在各方面都要优于命令式的。</li>\n</ul><p>那么，在最后，我希望你不要把这节课当作Kotlin刷题的终点，而是要把这节课当作一个起点。因为，用Kotlin刷算法题，真的是个一举多得的好办法！我们何乐而不为呢？</p><h2>小作业</h2><p>好，还是给你留一个小作业吧，请你写出“解法三”对应的命令式代码吧。</p><blockquote>\n<p>提示：在解法一的基础上做一些修改就能轻松实现了。</p>\n</blockquote>',
        article_title: "春节刷题计划（四）| 一题三解，搞定分式加减法",
      },
    ],
  },
  {
    chapterTitle: "协程篇",
    children: [
      {
        title: "13 | 什么是“协程思维模型”？",
        id: 485632,
        content:
          '<p>你好，我是朱涛。</p><p>学完基础篇以后，相信现在你对Kotlin的基础语法和特性都有了全面的认识。那么从今天开始，我们就要进入一个新的模块，一起来学习Kotlin当中<strong>最重要、最难学</strong>，也是最受期待的特性——协程。</p><h2>为什么协程如此重要？</h2><p><strong>协程是Kotlin对比Java的最大优势</strong>，这也是我说协程是Kotlin中最重要特性的主要原因。虽说Java也在计划着实现自己的协程：<a href="https://openjdk.java.net/projects/loom/">Loom</a>，不过这个毕竟还处于相当初级的阶段。而Kotlin的协程，可以帮我们极大地<strong>简化异步、并发编程、优化软件架构</strong>。通过协程，我们不仅可以提高开发效率，还能提高代码的可读性，由此也就可以降低代码出错的概率。</p><p>不过，遗憾的是，Kotlin协程在业界的普及率并不高。因为，你如果对协程没有足够的认识，贸然在生产环境里使用协程，一定会遇到各种各样的问题，并要为之付出昂贵的代价（典型的反面例子就是滥用GlobalScope，导致大量的计算资源浪费以及出现生命周期错乱的问题）。</p><p>Kotlin的协程就是这样，表面上看，它的语法很简单，但行为模式却让人难以捉摸。举个简单的例子，同样是5行代码，普通的程序，这5行代码的运行顺序一般会是1、2、3、4、5；但对于协程来说，代码执行顺序可能会是1、4、5、3、2这样错乱的。如果我们不能在脑子里建立协程的思维模型，那我们将很难理解协程的行为模式。</p><!-- [[[read_end]]] --><p>所以说，协程也是一个典型的“<strong>易学难精</strong>”的框架。</p><p>如果你之前尝试过自学Kotlin协程，你一定会跟我有相似的体会：要记住协程的几个API很容易，困难的是形成一套完整的协程知识体系。不过，我想告诉你的是：形成知识体系也不算什么，更难的是建立一个具体的协程思维模型，来辅助自己理解协程背后的运行机制；甚至，建立协程思维模型也没什么了不起，更难的是理解协程背后的设计理念。</p><p>换句话说，如果我们能站在Kotlin协程设计者的角度，去评判、欣赏它背后的设计理念，并且能体会到协程设计的精妙之处，那才算是达到了最高的境界。</p><p>那么，学习Kotlin协程，到底意味着什么呢？</p><p>其实，学习协程，相当于一次<strong>编程思维的升级</strong>。协程思维，它与我们常见的线程思维迥然不同，当我们能够用协程的思维来分析问题以后，<strong>线程当中某些棘手的问题在协程面前都会变成小菜一碟</strong>。因此，我们相当于多了一种解决问题的手段。</p><p>另外，学习Kotlin协程，也相当于为我们打开了一扇新世界的大门，当我们对Kotlin协程有了透彻的认识以后，再去看C#、Python、Dart、JS、Golang、Rust、C++20、Java Loom当中的“类协程”概念，就会觉得无比亲切。这时候我们就会发现：<strong>原来协程的世界是如此广阔</strong>。</p><p>到这里，相信你已经认识到了Kotlin协程的重要性，也知道了学习协程的好处了。</p><p>不过，在正式开始学习Kotlin协程之前，我想先给你打一剂“预防针”：这个部分的学习难度会比前面基础篇更大，虽然我还是会尽量用简单直白的方式来向你介绍协程，但由于它本身是一种颠覆性的技术，因此，刚开始肯定是会有些难以接受的。在这里，我也建议你在遇到问题的时候多思考，并去反复琢磨和理解课程当中的知识点与示例代码。</p><p>好，接下来，我们先来了解一下协程的发展史，这会有助于我们理解协程到底是个什么东西。</p><h2>什么是协程？</h2><p>Kotlin的协程，是2017年初在1.1版本加入进来的，那时协程还只是实验性的（Experimental）；等到2018年底，Kotlin更新到1.3版本的时候，协程才成为Kotlin的正式特性；接着又过了一年，到2019年Kotlin协程才推出Flow相关的API。我们常说Kotlin是一门年轻的语言，那么Kotlin协程这个特性，就更加显得年轻了。毕竟从它正式推出到现在，也才三年多。</p><p>虽然Kotlin协程很年轻，但“协程”这个概念本身并不年轻。早在1967年的 <a href="https://zh.wikipedia.org/wiki/Simula">Simula语言</a>当中，就已经出现了协程。不过，在之后的几十年里，协程并没有被推广开，后续涌现出的C、C++、Java之类的语言，更多的是使用线程来进行异步和并发。直到2012年左右，C#重新拾起了协程这个特性，实现了async、await、yield。之后，JavaScript、Python、Kotlin等语言才继续跟进实现了对应的协程。</p><p><img src="https://static001.geekbang.org/resource/image/55/4e/5570b21ba1cd63103ae5bfaf579a434e.jpg?wh=2000x900" alt=""></p><p>很多人在刚开始接触协程的时候，都觉得协程很难学，因为从学校一路学习C、Java过来以后，我们只知道线程是什么，对协程根本没有任何概念。</p><p>其实，如果要用简单的语言来描述协程的话，我们可以将其称为：“互相<strong>协</strong>作的<strong>程</strong>序”。</p><p><img src="https://static001.geekbang.org/resource/image/12/6a/121f70df4206972e88de427ef5157f6a.jpg?wh=2000x448" alt=""></p><p>为了帮你弄清楚普通的程序（Routine）与协程（Coroutine）之间的差异，我们来看一个具体的例子。</p><pre><code class="language-plain">fun main() {\n    val list = getList()\n    printList(list)\n}\n\nfun getList(): List&lt;Int&gt; {\n    val list = mutableListOf&lt;Int&gt;()\n    println("Add 1")\n    list.add(1)\n    println("Add 2")\n    list.add(2)\n    println("Add 3")\n    list.add(3)\n    println("Add 4")\n    list.add(4)\n\n    return list\n}\n\nfun printList(list: List&lt;Int&gt;) {\n    val i = list[0]\n    println("Get$i")\n    val j = list[1]\n    println("Get$j")\n    val k = list[2]\n    println("Get$k")\n    val m = list[3]\n    println("Get$m")\n}\n\n/* 运行结果：\nAdd 1\nAdd 2\nAdd 3\nAdd 4\nGet1\nGet2\nGet3\nGet4\n*/\n</code></pre><p>以上代码非常简单，程序会先运行getList()，然后再运行printList()。从运行的结果我们可以看出来，程序是按照顺序执行的，这没什么特别的。这就是一个典型的<strong>普通程序</strong>的例子。</p><p>下面让我们来看一个<strong>协程</strong>的例子。</p><pre><code class="language-plain">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果\nfun main() = runBlocking {\n    val sequence = getSequence()\n    printSequence(sequence)\n}\n\nfun getSequence() = sequence {\n    println("Add 1")\n    yield(1)\n    println("Add 2")\n    yield(2)\n    println("Add 3")\n    yield(3)\n    println("Add 4")\n    yield(4)\n}\n\nfun printSequence(sequence: Sequence&lt;Int&gt;) {\n    val iterator = sequence.iterator()\n    val i = iterator.next()\n    println("Get$i")\n    val j = iterator.next()\n    println("Get$j")\n    val k = iterator.next()\n    println("Get$k")\n    val m = iterator.next()\n    println("Get$m")\n}\n\n/*\n输出结果：\nAdd 1\nGet1\nAdd 2\nGet2\nAdd 3\nGet3\nAdd 4\nGet4\n*/\n</code></pre><p>这段代码做的事情和前面的代码其实差不多，只是我们是借助了Kotlin当中的Sequence来实现的。这次，我们从程序的运行结果会发现，getSequence()与printSequence()这两个函数，它们是交替执行的。为了方便你理解，我用一张图来描述它们之间的调用顺序。</p><p><img src="https://static001.geekbang.org/resource/image/a3/2c/a3caffed1ced7663c0595c9ce2800a2c.png?wh=1287x418" alt="图片"></p><p>这段程序，给人的感觉就像是两位彬彬有礼的绅士，每个人执行一会代码以后，就会<strong>让出执行权</strong>给对方，让对方执行一会。这样的运行模式，就好像两个人在<strong>协作</strong>一样。</p><p>而对应的，前面的getList()和printList()的执行流程则完全不一样，getList()执行完以后，才会轮到printList()来执行。</p><p><img src="https://static001.geekbang.org/resource/image/a1/7d/a1052f9ce56bb228e82da4cc4218137d.png?wh=1271x732" alt="图片"></p><p>这两种迥然不同的代码运行方式，其实就是协程与普通程序之间最大的差异。</p><ul>\n<li>普通程序在被调用以后，只会在末尾的地方返回，并且只会返回一次，比如前面的getList()函数；而协程则不受此限制，协程的代码可以在任意yield的地方挂起（Suspend）让出执行权，然后等到合适的时机再恢复（Resume）。在这个情况下，yield是代表了“让步”的意思。</li>\n<li>普通程序需要一次性收集完所有的值，然后统一返回；而协程则可以每次只返回（yield）一个值，比如我们前面写的getSequence()方法。在这个情况下，yield既有“让步”的意思，也有“<strong>产出</strong>”的意思。它不仅能让出执行权，还同时产生一个值，比如前面的yield(1)，就代表产出的值为1。</li>\n</ul><p>除了yield以外，我们也可以借助Kotlin协程当中的Channel来实现类似的代码模式：</p><pre><code class="language-plain">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果\nfun main() = runBlocking {\n    val channel = getProducer(this)\n    testConsumer(channel)\n}\n\nfun getProducer(scope: CoroutineScope) = scope.produce {\n    println("Send:1")\n    send(1)\n    println("Send:2")\n    send(2)\n    println("Send:3")\n    send(3)\n    println("Send:4")\n    send(4)\n}\n\nsuspend fun testConsumer(channel: ReceiveChannel&lt;Int&gt;) {\n    delay(100)\n    val i = channel.receive()\n    println("Receive$i")\n    delay(100)\n    val j = channel.receive()\n    println("Receive$j")\n    delay(100)\n    val k = channel.receive()\n    println("Receive$k")\n    delay(100)\n    val m = channel.receive()\n    println("Receive$m")\n}\n\n/*\n输出结果：\nSend:1\nReceive1\nSend:2\nReceive2\nSend:3\nReceive3\nSend:4\nReceive4\n*/\n</code></pre><p>可见，以上代码中的getProducer()和testConsumer()之间，它们也是交替执行的。</p><p>所以，<strong>从广义上来讲，协程就代表了“互相协作的程序”。</strong>这样的标准，几乎适用于所有语言的协程。不管是Python的协程还是C#的协程，还是其他语言的协程，它们都是以这样的模式来实现的。而且，很多语言的协程都支持yield。理解了这一点以后，将来不管你是遇到Python的协程，还是其他语言的协程也好，相信你也可以很快地把Kotlin协程当中的概念迁移过去。</p><p>聊完广义的协程以后，我们再来看看Kotlin协程的另外两个概念：协程、协程框架。<strong>注意</strong>，这是两个不一样的概念，前者是代表了程序当中被创建的协程；后者，则是一个整体的框架。</p><h2>如何理解Kotlin的协程？</h2><p>在Kotlin当中，协程是一个独立的框架。跟Kotlin的反射库类似，协程并不是直接集成在标准库当中的。如果我们想要使用Kotlin的协程，就必须手动进行依赖：</p><pre><code class="language-groovy">implementation \'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0\'\n</code></pre><p>Kotlin官方之所以将协程作为一个单独的框架独立出来，也是为了减小标准库的体积，给开发者更多的灵活性。另外，Kotlin协程框架也是开源的，我们可以去GitHub上去浏览它的<a href="https://github.com/Kotlin/kotlinx.coroutines">源代码</a>。在这里，我们可以找到许多前沿的信息，也可以跟世界顶级的开发者交流。</p><p>业界一直有一种说法：<strong>Kotlin协程其实就是一个封装的线程框架</strong>。如果我们站在框架的层面来看的话，这种说法也有一定道理：协程框架将线程池进一步封装，对开发者暴露出统一的协程API。</p><p>不过，这种说法无法解释另一个语境下的问题，让我们来看一个代码例子。</p><pre><code class="language-plain">// 代码中一共启动了两个线程\nfun main() {\n    println(Thread.currentThread().name)\n    thread {\n        println(Thread.currentThread().name)\n        Thread.sleep(100)\n    }\n    Thread.sleep(1000L)\n}\n\n/*\n输出结果：\nmain\nThread-0\n*/\n</code></pre><p>上面这段代码的逻辑很简单，就是在main函数当中启动了一个新的线程。“代码中一共启动了两个线程”，这句话的意思也很容易理解：main()函数本身会启动一个主线程main，然后在 <code>thread{}</code> 当中，又启动了一个新的线程“Thread-0”。所以，以上代码一共会启动两个线程。这没什么问题，关键是下一个例子：</p><pre><code class="language-plain">// 代码中一共启动了两个协程\nfun main() = runBlocking {\n    println(Thread.currentThread().name)\n\n    launch {\n        println(Thread.currentThread().name)\n        delay(100L)\n    }\n\n    Thread.sleep(1000L)\n}\n\n/*\n输出结果：\nmain @coroutine#1\nmain @coroutine#2\n\n这里要配置特殊的VM参数：-Dkotlinx.coroutines.debug\n这样一来，Thread.currentThread().name就能会包含：协程的名字@coroutine#1\n*/\n</code></pre><p>在这段代码的注释当中，有这样一句话：<strong>代码中一共启动了两个协程</strong>。请问，这个语境下的“两个协程”，到底是什么？通过程序的输出结果，我们可以看到，main函数当中出现了两个协程，一个是“coroutine#1”，一个是“coroutine#2”。</p><p>那么，这里的“协程”，到底是什么呢？它看起来好像跟Java的线程有点类似，但又好像是两个完全不一样的东西。这其实就是很多初学者会困扰的地方。</p><p>Kotlin的协程，它要比线程更加抽象，因为Java的线程，我们起码可以找到Thread的源代码，同时，线程也是操作系统当中的一个概念，所以理解起来并不困难。而Kotlin的协程则没有类似的知识点可以建立关联。所以，我自己在学习Kotlin协程的时候，做法就是建立起<strong>协程的思维模型</strong>（Mental Model）。</p><p>很多人可能不太理解思维模型到底是什么，它在有些语境下，也被称为<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B">心智模型</a>。人为了理解真实世界的运作规律，会自然而然地在脑子里建立起对应的模型。举个例子，我们为了理解公司内部的组织架构，经常会在脑子里建立一个类似这样的树状思维模型：</p><p><img src="https://static001.geekbang.org/resource/image/38/a1/38d10ff8262caacae94733d77a6f88a1.jpg?wh=2000x1055" alt=""></p><p>那么，我们该如何为Kotlin的协程建立思维模型呢？其实，Kotlin的协程，我们可以将其想象成一个“更加轻量的线程”。</p><p><img src="https://static001.geekbang.org/resource/image/df/62/dfab62d3f0c8558de5768e359fcb0462.png?wh=1920x1080" alt="图片"></p><p>从包含关系上看，协程跟线程的关系，有点像线程与进程的关系，毕竟协程不可能脱离线程运行。所以，协程可以理解为<strong>运行在线程当中的、更加轻量的Task</strong>。</p><h3>协程的轻量</h3><p>那么，协程的轻量，到底意味着什么呢？我们可以先来看一段这样的代码：</p><pre><code class="language-plain">// 仅用作研究，工作中别这么写\nfun main() {\n    repeat(1000_000_000) {\n        thread {\n            Thread.sleep(1000000)\n        }\n    }\n\n    Thread.sleep(10000L)\n}\n\n/*\n输出结果：\nException in thread "main" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at kotlin.concurrent.ThreadsKt.thread(Thread.kt:42)\n    at kotlin.concurrent.ThreadsKt.thread$default(Thread.kt:20)\n*/\n</code></pre><p>在上面的代码中，我们尝试启动10亿个线程，这样的代码运行在大部分的机器上都是会因为内存不足等原因而异常退出的。而如果我们将代码改用协程来实现的话，结果会怎样呢？</p><pre><code class="language-plain">// 仅用作研究，工作中别这么写\nfun main() = runBlocking {\n    repeat(1000_000_000) {\n        launch {\n            delay(1000000)\n        }\n    }\n\n    delay(10000L)\n}\n\n/*\n运行结果：\n正常\n*/\n</code></pre><p>在这段代码中，我们启动了10亿个协程。由于协程是非常轻量的，所以代码不会因为内存不足而异常退出。</p><blockquote>\n<p>注意：虽然协程非常轻量，但在工作当中，我们也应该尽量避免写出类似上面这样的代码。</p>\n</blockquote><p>另外，协程虽然运行在线程之上，但协程并不会和某个线程绑定，在某些情况下，协程是可以在不同的线程之间切换的。我们可以来看看下面的代码：</p><pre><code class="language-plain">fun main() = runBlocking(Dispatchers.IO) {\n    repeat(3) {\n        launch {\n            repeat(3) {\n                println(Thread.currentThread().name)\n                delay(100)\n            }\n        }\n    }\n\n    delay(5000L)\n}\n\n/*\n输出结果：\nDefaultDispatcher-worker-3 @coroutine#2\nDefaultDispatcher-worker-2 @coroutine#3\nDefaultDispatcher-worker-4 @coroutine#4\nDefaultDispatcher-worker-1 @coroutine#2 // 线程切换了\nDefaultDispatcher-worker-4 @coroutine#4\nDefaultDispatcher-worker-2 @coroutine#3\nDefaultDispatcher-worker-2 @coroutine#2 // 线程切换了\nDefaultDispatcher-worker-1 @coroutine#4\nDefaultDispatcher-worker-4 @coroutine#3\n\n*/\n</code></pre><p>以上代码的运行结果是随机的，这里以我运行的结果来分析的话，可以看到，“coroutine#2”的三次执行，每一次都在不同的线程上。第一次，它在“worker-3”执行，第二次在“worker-1”执行，第三次在“worker-2”执行。</p><p>这时候，我们就可以进一步更新脑海中的思维模型了。</p><p><img src="https://static001.geekbang.org/resource/image/d8/a9/d89e8744663d45635a5125829a9037a9.gif?wh=1080x608" alt="图片"></p><p>让我们来做个小结：</p><ul>\n<li>协程，可以理解为更加轻量的线程，成千上万个协程可以同时运行在一个线程当中；</li>\n<li>协程，其实是运行在线程当中的轻量的Task；</li>\n<li>协程，不会与特定的线程绑定，它可以在不同的线程之间灵活切换。</li>\n</ul><h3>协程的“非阻塞”</h3><p>另外，协程对比线程还有一个特点，那就是<strong>非阻塞</strong>（Non Blocking），而线程则往往是阻塞式的。这个概念有点抽象，我们来看个具体的例子：</p><pre><code class="language-plain">fun main() {\n    repeat(3) {\n        Thread.sleep(1000L)\n        println("Print-1:${Thread.currentThread().name}")\n    }\n\n    repeat(3) {\n        Thread.sleep(900L)\n        println("Print-2:${Thread.currentThread().name}")\n    }\n}\n\n/*\n输出结果：\nPrint-1:main\nPrint-1:main\nPrint-1:main\nPrint-2:main\nPrint-2:main\nPrint-2:main\n*/\n</code></pre><p>在上面的代码里有两个repeat，第一个repeat当中，我们每次调用sleep()方法，让线程休眠1秒钟，而第二个repeat当中，我们每次只休眠0.9秒。由于线程的sleep()方法是阻塞式的，所以程序的执行流程是线性的。也就是说，“Print-1”会连续输出三次，然后“Print-2”会连续输出三次。即使Print-2休眠的时间更短。</p><p>让我们来看看协程代码的表现有哪些不一样：</p><pre><code class="language-plain">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            delay(1000L)\n            println("Print-1:${Thread.currentThread().name}")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            delay(900L)\n            println("Print-2:${Thread.currentThread().name}")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\n*/\n</code></pre><p>在上面的代码中，我们用协程实现了类似的逻辑，但这次的执行结果却完全不一样。可以看到，Print-2和Print-1是交替输出的，“coroutine#2”、“coroutine#3”这两个协程是并行的（Concurrent）。同时，由于协程的delay()方法是非阻塞的，所以，即使Print-1会先执行delay(1000L)，但它也并不会阻塞Print-2的delay(900L)的运行。</p><p>而如果我们将代码中的delay修改成sleep，程序的运行结果就会不一样。</p><pre><code class="language-plain">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            Thread.sleep(1000L)\n            println("Print-1:${Thread.currentThread().name}")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            Thread.sleep(900L)\n            println("Print-2:${Thread.currentThread().name}")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-1:main @coroutine#2\nPrint-1:main @coroutine#2\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-2:main @coroutine#3\nPrint-2:main @coroutine#3\n*/\n</code></pre><p>由此可见，Kotlin协程的“非阻塞”其实<strong>只是语言层面</strong>的，当我们调用JVM层面的Thread.sleep()的时候，它仍然会变成阻塞式的。与此同时，这也意味着我们在协程当中应该尽量避免出现阻塞式的行为。尽量使用delay，而不是sleep。</p><p>那么，我们该如何理解Kotlin协程的“非阻塞”？答案是：<strong>挂起和恢复</strong>。这两个能力也是协程才拥有的特殊能力，普通的程序是不具备的。</p><p>挂起和恢复，初学者看到这两个概念可能会比较陌生。它俩的字面意思我们都能看懂，但当发生在程序世界里之后，就无法理解了，因为我们根本就看不见，也摸不着。那怎么办呢？</p><p>我的做法还是：<strong>建立思维模型</strong>。</p><p>对于执行在普通线程当中的程序来说，如果我们站在CPU的角度上看，最终它会以类似这样的方式执行：</p><p><img src="https://static001.geekbang.org/resource/image/dd/bc/dd4cfa1246e6141262a9de48d31dbcbc.gif?wh=1080x358" alt="图片"></p><p>这时候，当某个任务发生了阻塞行为的时候，比如sleep，当前执行的Task就会阻塞后面所有任务的执行。就像下面这张动图所展示的一样：</p><p><img src="https://static001.geekbang.org/resource/image/e8/41/e862e19363f44c56a01709643791ee41.gif?wh=1080x346" alt="图片"></p><p><strong>那么，协程是如何通过挂起和恢复来实现非阻塞的呢？</strong></p><p>大部分的语言当中都会存在一个类似“调度中心”的东西，它会来实现Task任务的执行和调度。如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/f2/f9/f28fa6fb2ba6d147de33ccb649969cf9.png?wh=1920x937" alt="图片"></p><p>而协程除了拥有“调度中心”以外，对于每个协程的Task，还会多出一个类似“抓手”“挂钩”的东西，可以方便我们对它进行“挂起和恢复”。协程任务的总体执行流程，大致会像下图描述的这样：</p><p><img src="https://static001.geekbang.org/resource/image/50/26/50ayycf2b8d015cf8cef7dcde541ae26.gif?wh=1080x499" alt="图片"></p><p>通过对比可以看出，线程的sleep之所以是阻塞式的，是因为它会阻挡后续Task的执行。而协程之所以是非阻塞式的，是因为它可以支持挂起和恢复。当Task由于某种原因被挂起后，后续的Task并不会因此被阻塞。</p><p>这时候，如果我们回过头再来看之前的代码，相信也会有新的体会：</p><pre><code class="language-plain">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            delay(1000L)\n            println("Print-1:${Thread.currentThread().name}")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            delay(900L)\n            println("Print-2:${Thread.currentThread().name}")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\n*/\n</code></pre><h2>小结</h2><p>好了，到这里，我们今天的内容就差不多结束了。这节课我并没有给你介绍任何具体的协程API，而是先带你建立协程的思维模型，目的就是让你在这个过程中，真正理解协程的核心概念，并建立起一个清晰的认知，从而为后面API的学习打下基础。毕竟，磨刀不误砍柴工嘛！</p><p>那么在学完这节课之后，你也需要掌握以下几个要点：</p><ul>\n<li>广义的协程，可以理解为“互相协作的程序”，也就是“Cooperative-routine”。</li>\n<li>协程框架，是独立于Kotlin标准库的一套框架，它封装了Java的线程，对开发者暴露了协程的API。</li>\n<li>程序当中运行的“协程”，可以理解为<strong>轻量的线程</strong>；</li>\n<li>一个线程当中，可以运行成千上万个协程；</li>\n<li>协程，也可以理解为运行在线程当中的<strong>非阻塞的Task</strong>；</li>\n<li>协程，通过<strong>挂起和恢复</strong>的能力，实现了“非阻塞”；</li>\n<li>协程不会与特定的线程绑定，它可以在不同的线程之间灵活切换，而这其实也是通过“挂起和恢复”来实现的。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/bd/9d/bd90de594f1209631cec647a876eee9d.jpg?wh=2000x716" alt=""></p><p>说实话，学习协程，真的不是一件容易的事情。如果这节课我不介绍协程的思维模型，一上来就介绍协程的API，你一定会觉得云里雾里、找不着方向。所以，也请你不要轻视这节课的重要性，一定要充分理解本节课的内容，再去学习后面的知识点。</p><p>下节课开始，我会正式介绍Kotlin协程相关的API，同时，也会进一步完善我们的协程思维模型。</p><h2>思考题</h2><p>有人说：协程会比线程更加高效，请问你认同这种说法吗？为什么？ 欢迎在留言区分享你的看法和见解，也欢迎你把今天的内容分享给更多的朋友，我们一起交流探讨。</p>',
        article_title: "13 | 什么是“协程思维模型”？",
      },
      {
        title: "14 | 如何启动协程？",
        id: 486305,
        content:
          '<p>你好，我是朱涛。</p><p>从今天开始，咱们正式进入协程API的学习，一起来攻克Kotlin当中最关键的部分。这节课呢，我会给你介绍下如何启动协程，主要包括协程的调试技巧、启动协程的三种方式。这些都是学习协程最基本的概念，也是后续学习更多高阶概念的基础。</p><p>注意，在这节课当中，我会使用协程API编写大量的案例。我也希望你能够打开IDE，跟着我一起来运行对应的代码。通过这样的方式，你一定会有更多的收获。</p><p>好，接下来，让我们直接开始学习吧！</p><h2>协程调试</h2><p>想要学好Kotlin协程，掌握它的调试技巧很重要。一般来说，我们可以通过两种手段来进行调试：设置VM参数、断点调试。</p><h3>协程VM参数</h3><p>我们先来看第一种。具体的做法呢，其实很简单，我们只需要将VM参数设置成“-Dkotlinx.coroutines.debug”。</p><p><img src="https://static001.geekbang.org/resource/image/27/51/2722a0409f4709c6e8f63a77e4de3751.gif?wh=1254x832" alt="图片"></p><p>完成这个设置后，当我们在log当中打印“Thread.currentThread().name”的时候，如果当前代码是运行在协程当中的，那么它就会带上协程的相关信息。具体我们可以看个代码的例子：</p><pre><code class="language-plain">// 不必关心代码逻辑，关心输出结果即可\nfun main() {\n    GlobalScope.launch(Dispatchers.IO) {\n        println("Coroutine started:${Thread.currentThread().name}")\n        delay(1000L)\n        println("Hello World!")\n    }\n\n    println("After launch:${Thread.currentThread().name}")\n    Thread.sleep(2000L)\n}\n\n/*\n输出结果：\nAfter launch:main\nCoroutine started:DefaultDispatcher-worker-1 @coroutine#1\n*/\n</code></pre><!-- [[[read_end]]] --><p>可以看到，当代码处于协程当中的时候，“Thread.currentThread().name”是会带上协程相关的信息的，这里的“@coroutine#1”就代表了launch创建的协程。</p><h3>断点调试协程</h3><p>除了设置VM参数之外，我们还可以直接使用IDE的调试功能，直接以<strong>打断点</strong>的形式来调试协程。具体来说，主要有这样几个注意事项。</p><p>第一步，将IntelliJ升级到最新版本，目前我使用的版本是2021.3.2版本。</p><p>第二步，确保IDE自带的Kotlin编译器插件版本号大于1.4，目前我使用的是1.6.10。具体做法你可以参考下面的动图：</p><p><img src="https://static001.geekbang.org/resource/image/fb/59/fba508f160e7cce0e5fd16afaea72159.gif?wh=1156x900" alt="图片"></p><p>第三步，为协程代码打断点，并且右击断点处，勾选suspend、All，这代表了我们的断点将会对协程生效。具体可以参考我下面的截图：</p><p><img src="https://static001.geekbang.org/resource/image/9c/8a/9ce7c7f7f4a5cc6cda7439cc9201ab8a.png?wh=526x299" alt="图片"></p><p>第四步，直接进行调试，当程序停留到断点处以后，我们就需要确保协程调试窗口已经被开启了。具体可以参考这个动图：</p><p><img src="https://static001.geekbang.org/resource/image/bf/y5/bf997189170645abc1586af534782yy5.gif?wh=1392x878" alt="图片"></p><p>让我们来单独看看最后出现的那个协程调试窗口：</p><p><img src="https://static001.geekbang.org/resource/image/c0/8c/c0a913989f27986f1044865d7f5db88c.png?wh=1095x830" alt="图片"></p><p>在这个专属的协程调试窗口当中，我们可以看到很多有用的协程信息，包括：</p><ul>\n<li>当前协程的名字，这里是“coroutine#1”；</li>\n<li>当前协程运行在哪个线程之上，这里是“DefaultDispatcher-worker-1”；</li>\n<li>当前协程的运行状态，这里是“RUNNING”；</li>\n<li>当前协程的“创建调用栈”。</li>\n</ul><p>通过调试，我们可以真真切切地看到，我们用launch创建了一个协程，“coroutine#1”，这个协程是运行在“DefaultDispatcher-worker-1”这个线程之上的。而通过这样调试的手段，我们也进一步验证了上节课提到的协程思维模型。</p><p>接下来，我们就一起来学习启动协程的三种方式。</p><h2>launch启动协程</h2><p>上节课我们讲到协程思维模型的时候，其实是把协程想象成了<strong>更加轻量的线程</strong>。线程的启动方式我们都知道，也就是new Thread()、或者是thread{}。那么，如何才能启动一个真正的协程呢？如果你之前看过一些协程的教程，一定见过类似这样的代码：</p><pre><code class="language-plain">/* delay 函数的定义\n     注意这个关键字\n          ↓                                            */\npublic suspend fun delay(timeMillis: Long) { ... }\n\n// 仅用于研究，生产环境不建议使用GlobalScope\nfun main() {\n    // ①\n    GlobalScope.launch {\n        // ②\n        delay(1000L)\n        println("Hello World!")\n    }\n\n    // ③\n    Thread.sleep(2000L)\n}\n\n/*\n输出结果；\nHello World!\n*/\n</code></pre><p>这段代码的逻辑很简单，核心代码只有三行，我已经用注释标记了，我们一个个看。</p><p>注释①，GlobalScope.launch{}，它是一个高阶函数，它的作用就是启动一个协程。GlobalScope是Kotlin官方为我们提供的“协程作用域”，这涉及到协程的“结构化并发”理念，我们会在后面的第16、17讲里解释。</p><p>注释②，delay()，它的作用就是字面上的意思，“延迟”。以上代码中，我们是延迟了1秒。从delay()的函数签名这里可以发现，它的定义跟普通的函数不太一样，它多了一个“suspend”关键字，这代表了它是一个<strong>挂起函数</strong>。而这也就意味着，delay将会拥有“<strong>挂起和恢复</strong>”的能力。</p><p>在上节课我们提到过，delay()是<strong>非阻塞</strong>，那现在我们应该就终于明白了，既然它拥有“挂起和恢复”的能力，那么它肯定能实现非阻塞（如果你无法理解这句话，一定要回过头去看上节课的思维模型）。关于挂起函数的更多知识点，我们会在下节课介绍。</p><p>注释③，它的作用是让当前线程休眠2秒钟。</p><p>我们暂时先将注意力放在注释③这行代码上，很多协程的初学者都会很好奇，为什么上面的代码当中需要一个Thread.sleep(2000L)呢？它的作用是什么？</p><p>现在我们把它删掉，看看到底会发生什么。</p><pre><code class="language-plain">fun main() {\n    GlobalScope.launch {\n        delay(1000L)\n        println("Hello World!")\n    }\n}\n\n/*\n输出结果；\n无\n*/\n</code></pre><p>很奇怪，当我们删掉线程休眠的代码以后，协程代码就无法正常工作了。这是为什么？为了弄清楚这个问题，其实，我们可以做一个类比，暂时先将协程代码改成线程代码。</p><pre><code class="language-plain">fun main() {\n    //              守护线程\n    //                 ↓\n    thread(isDaemon = true) {\n        Thread.sleep(1000L)\n        println("Hello World!")\n    }\n}\n\n/*\n输出结果；\n无\n*/\n</code></pre><p>可以看到，当我们将代码改为线程以后，程序仍然没有输出任何结果。而这里，我们创建的Thread其实是一个“守护线程”。守护线程，就意味着当主线程结束的时候，它也会跟着被销毁。所以这样，相信你应该就能明白了，我们前面用GlobalScope创建的协程之所以不会正常运行，也是因为类似的原因。</p><p>那么，为了让问题能够更明确地暴露出来，我们可以为之前的代码增加一些日志。</p><pre><code class="language-plain">fun main() {\n    GlobalScope.launch {\n        println("Coroutine started!")\n\n        delay(1000L)\n        println("Hello World!")\n    }\n\n    println("Process end!")\n}\n/*\n输出结果；\nProcess end!\n*/\n</code></pre><p>根据输出结果，我们可以推测出：<strong>通过launch创建的协程还没来得及开始执行，整个程序就已经结束了</strong>。相应的，我们也就能推测出，之前案例中Thread.sleep(2000)的作用了，其实，它就是为了不让我们的主线程退出。</p><p>这里，你还会发现一个协程代码特殊的行为模式，那就是：<strong>它的代码不是按照顺序执行的</strong>。为了让这一点更加明显，我们再增加一些日志：</p><pre><code class="language-plain">fun main() {\n    GlobalScope.launch {                // 1\n        println("Coroutine started!")   // 2\n        delay(1000L)                    // 3\n        println("Hello World!")         // 4\n    }\n\n    println("After launch!")            // 5\n    Thread.sleep(2000L)                 // 6\n    println("Process end!")             // 7\n}\n\n/*\n输出结果：\nAfter launch!\nCoroutine started!\nHello World!\nProcess end!\n*/\n</code></pre><p>根据这个程序运行结果，我们发现，以上的协程代码运行顺序是1、5、6、2、3、4、7。也就是说，launch并不会阻塞线程的执行，甚至，我们可以认为launch()当中Lambda一定就是在函数调用之后才执行的。当然，在特殊情况下，这种行为模式也是可以打破的，这一点我们会在第17讲中详细探讨。</p><p>那么，如果你足够细心，你会发现，我们通过launch启动一个协程以后，并没有让协程为我们返回一个执行结果，这其实就是典型的 <a href="https://en.wikipedia.org/wiki/Fire-and-forget">Fire-and-forget</a> 的应用场景。打个比方，launch一个协程任务，就像猎人射箭一样。</p><p><img src="https://static001.geekbang.org/resource/image/7y/27/7yy0yy571c7ebfc3ba9e173024a44f27.png?wh=1920x1099" alt="图片"></p><p>launch和射箭，有几个共同点：</p><ul>\n<li>箭一旦射出去了，目标就无法再被改变；协程一旦被launch，那么它当中执行的任务也不会被中途改变。</li>\n<li>箭如果命中了猎物，猎物也不会自动送到我们手上来；launch的协程任务一旦完成了，即使有了结果，也没办法直接返回给调用方。</li>\n</ul><p>那么，<strong>launch为什么无法将结果返回给调用方呢？</strong>如果你去看launch函数的源代码，你就会发现，这个函数的返回值是一个Job，它其实代表的是协程的<a href="https://en.wikipedia.org/wiki/Handle_(computing)">句柄</a>（Handle），它并不能为我们返回协程的执行结果。</p><pre><code class="language-plain">public fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job { ... }\n</code></pre><p>不过，从launch的函数签名这里，我们还是可以得到很多有用的信息的，我们一个个看。</p><p>首先是 <strong>CoroutineScope.launch()</strong>，代表了launch其实是一个扩展函数，而它的“扩展接收者类型”是CoroutineScope。这就意味着，我们的launch()会等价于CoroutineScope的成员方法。而如果我们要调用launch()来启动协程，就必须要先拿到CoroutineScope的对象。前面的案例，我们使用的GlobalScope，其实就是Kotlin官方为我们提供的一个CoroutineScope对象，方便我们开发者直接启动协程。</p><p>接着是第一个参数：<strong>CoroutineContext</strong>，它代表了我们协程的上下文，它的默认值是EmptyCoroutineContext，如果我们不传这个参数，默认就会使用EmptyCoroutineContext。一般来说，我们也可以传入Kotlin官方为我们提供的Dispatchers，来指定协程运行的线程池。协程上下文，是协程当中非常关键的元素，具体细节我会在17节课的时候再探讨。</p><p>然后是第二个参数：<strong>CoroutineStart</strong>，它代表了协程的启动模式。如果我们不传这个参数，它会默认使用CoroutineStart.DEFAULT。CoroutineStart其实是一个枚举类，一共有：DEFAULT、LAZY、ATOMIC、UNDISPATCHED。我们最常使用的就是DEFAULT、LAZY，它们分别代表：立即执行、懒加载执行。</p><p>最后一个参数，是一个函数类型的block，它的类型是“<strong>suspend CoroutineScope.() -&gt; Unit</strong>”。这个类型看起来有点复杂，不过不要担心，我们可以一步步来推理，让我们先以“(Int) -&gt; Double”这个函数类型开始：</p><pre><code class="language-plain">fun func1(num: Int): Double {\n    return num.toDouble()\n}\n\nval f1: (Int) -&gt; Double = ::func1\n</code></pre><p>上面的代码很好理解，“(Int) -&gt; Double”代表了参数类型是Int，返回值类型是Double的函数，::func1这里，我们使用了<strong>函数引用</strong>的语法。接下来，我们再来看看“CoroutineScope.(Int) -&gt; Double”意味着什么：</p><pre><code class="language-plain">fun CoroutineScope.func2(num: Int): Double {\n    return num.toDouble()\n}\n\nval f2: CoroutineScope.(Int) -&gt; Double = CoroutineScope::func2\n</code></pre><p>很明显，当我们在函数类型前面增加了一个接收者类型后，它的含义就变成了：这个函数应该是CoroutineScope类的<strong>成员方法</strong>或是<strong>扩展方法</strong>，并且，它的参数类型必须是Int，返回值类型必须是Double。</p><p>那么，“suspend (Int) -&gt; Double”这个类型代表了什么呢？我们来看个例子：</p><pre><code class="language-plain">suspend fun func3(num: Int): Double {\n    delay(100L)\n    return num.toDouble()\n}\n\nval f3: suspend (Int) -&gt; Double = ::func3\n</code></pre><p>有了前面的基础，相信你很容易就能理解了，“suspend (Int) -&gt; Double”，其实就代表了一个“挂起函数”，同时它的参数类型是Int，返回值类型是Double。</p><p>到这里，我们还可以再做一次推理，请看下面的代码：</p><pre><code class="language-plain">suspend fun CoroutineScope.func4(num: Int): Double {\n    delay(100L)\n    return num.toDouble()\n}\n\nval f4: suspend CoroutineScope.(Int) -&gt; Double = CoroutineScope::func4\n</code></pre><p>这时候，对于“suspend CoroutineScope.(Int) -&gt; Double”这个函数类型，你应该也能轻松解释了。首先，它应该是一个“挂起函数”，同时，它还应该是CoroutineScope类的成员方法或是扩展方法，并且，它的参数类型必须是Int，返回值类型必须是Double。</p><p>那么现在，我们回过头再来看看launch()函数的第三个参数“suspend CoroutineScope.() -&gt; Unit”，其实就能轻松分析出它的类型了。所以，当我们遇到复杂的函数类型的时候，一定不能害怕，只要我们一步步来拆解、推理，就一定能分析清楚了。</p><p>到这里，我们就弄清楚launch的作用了。我们通过调用launch()可以创建一个新的协程。那么，除了launch以外，还有其他办法启动协程吗？有的，那就是runBlocking。</p><h2>runBlocking启动协程</h2><p>runBlocking跟我们前面学的launch的行为模式不太一样，通过它的名字，我们就可以看出来，它是存在某种阻塞行为的。让我们将前面launch的代码直接改为runBlocking，看看运行结果是否有差异。</p><pre><code class="language-plain">fun main() {\n    runBlocking {                       // 1\n        println("Coroutine started!")   // 2\n        delay(1000L)                    // 3\n        println("Hello World!")         // 4\n    }\n\n    println("After launch!")            // 5\n    Thread.sleep(2000L)                 // 6\n    println("Process end!")             // 7\n}\n\n/*\n输出结果：\nCoroutine started!\nHello World!\nAfter launch!\nProcess end!\n*/\n</code></pre><p>通过分析上面的运行结果，我们可以发现，使用runBlocking启动的协程会阻塞当前线程的执行，这样一来，所有的代码就<strong>变成了顺序执行</strong>：1、2、3、4、5、6、7。这其实就是runBlocking与launch的最大差异。</p><p>为了验证这一点，我们可以将上面的例子再改造一下：</p><pre><code class="language-plain">fun main() {\n    runBlocking {\n        println("First:${Thread.currentThread().name}")\n        delay(1000L)\n        println("Hello First!")\n    }\n\n    runBlocking {\n        println("Second:${Thread.currentThread().name}")\n        delay(1000L)\n        println("Hello Second!")\n    }\n\n    runBlocking {\n        println("Third:${Thread.currentThread().name}")\n        delay(1000L)\n        println("Hello Third!")\n    }\n\n    // 删掉了 Thread.sleep\n    println("Process end!")\n}\n\n/*\n输出结果：\nFirst:main @coroutine#1\nHello First!\nSecond:main @coroutine#2\nHello Second!\nThird:main @coroutine#3\nHello Third!\nProcess end!\n*/\n</code></pre><p>请注意这里的输出结果，我们调用三次runBlocking，对应地，程序就启动了三个协程。另外还有一点：以上代码中，我们删掉了末尾的“Thread.sleep(2000L)”，而程序仍然按照顺序执行了。这就进一步说明，runBlocking确实会阻塞当前线程的执行。对于这一点，Kotlin官方也强调了：runBlocking只推荐用于<strong>连接线程与协程</strong>，并且，大部分情况下，都只应该用于编写Demo或是测试代码。</p><p>所以，<strong>请不要在生产环境当中使用runBlocking</strong>。</p><p>另外，相信你也注意到了，当我们调用runBlocking的时候，并不需要GlobalScope，这也是它跟launch之间的一大差异，具体，让我们来看看runBlocking的函数签名：</p><pre><code class="language-plain">public actual fun &lt;T&gt; runBlocking(\n    context: CoroutineContext,\n    block: suspend CoroutineScope.() -&gt; T): T {\n...\n}\n</code></pre><p>可以看到，runBlocking就是一个普通的<strong>顶层函数</strong>，它并不是CoroutineScope的扩展函数，因此，我们调用它的时候，不需要CoroutineScope的对象。前面我们提到过，GlobalScope是不建议使用的，因此，<strong>后面的案例我们将不再使用GlobalScope</strong>。</p><p>另外，你可以注意到它的第二个参数“suspend CoroutineScope.() -&gt; T”，这个函数类型是有返回值类型T的，而它刚好跟runBlocking的返回值类型是一样的。因此，我们可以推测，runBlocking其实是可以从协程当中返回执行结果的。让我们来试试：</p><pre><code class="language-plain">fun main() {\n    val result = runBlocking {\n        delay(1000L)\n        // return@runBlocking 可写可不写\n        return@runBlocking "Coroutine done!" \n    }\n\n    println("Result is: $result")\n}\n/*\n输出结果：\nResult is: Coroutine done!\n*/\n</code></pre><p>所以，从表面上看，runBlocking是对launch的一种补充，但由于它是阻塞式的，因此，runBlocking并不适用于实际的工作当中。那么，还有什么办法可以让我们拿到协程当中的执行结果吗？</p><p>答案就是：async。</p><h2>async启动协程</h2><p>async，是在很多其他编程语言都存在的一种协程模式，比如C#。在Kotlin当中，我们可以使用async{} 创建协程，并且还能通过它返回的<strong>句柄</strong>拿到协程的执行结果。让我们看个简单的例子：</p><pre><code class="language-plain">fun main() = runBlocking {\n    println("In runBlocking:${Thread.currentThread().name}")\n\n    val deferred: Deferred&lt;String&gt; = async {\n        println("In async:${Thread.currentThread().name}")\n        delay(1000L) // 模拟耗时操作\n        return@async "Task completed!"\n    }\n\n    println("After async:${Thread.currentThread().name}")\n\n    val result = deferred.await()\n    println("Result is: $result")\n}\n/*\n输出结果：\nIn runBlocking:main @coroutine#1\nAfter async:main @coroutine#1 // 注意，它比“In async”先输出\nIn async:main @coroutine#2\nResult is: Task completed!\n*/\n</code></pre><p>上面的代码中，我们直接使用runBlocking来实现了main函数。注意，由于runBlocking的最后一个参数的类型是“suspend CoroutineScope.() -&gt; T”，因此在Lambda当中已经有了CoroutineScope，所以我们可以直接在runBlocking当中，用async启动一个协程。从程序的输出结果，我们也可以看到，确实存在两个协程，runBlocking启动的叫做“coroutine#1”；async启动的叫做“coroutine#2”。</p><p>另外，你应该还注意到了一个细节，那就是async启动协程以后，它也不会阻塞当前程序的执行流程，因为：“After async”在“In async”的前面就已经输出了。</p><blockquote>\n<p>这种行为模式在特殊情况下也是可以打破的，我们在第17讲的时候会介绍。</p>\n</blockquote><p>还有，请注意async{}的返回值，它是一个Deferred对象，我们通过调用它的await()方法，就可以拿到协程的执行结果。对比前面launch我们举的“射箭”的例子，这里的async，就更加像是“钓鱼”：</p><p><img src="https://static001.geekbang.org/resource/image/0e/a0/0ece33218501d08238cbab30a3ccaaa0.png?wh=1920x1159" alt="图片"></p><p>在我们钓鱼的时候，我们手里的鱼竿，就有点像是async当中的 <strong>Deferred对象</strong>。只要我们手里有这根鱼竿，<strong>一旦有鱼儿上钩了，我们就可以直接拿到结果</strong>。</p><p>这里，我们再来看看async的函数签名，顺便对比一下它跟launch之间的差异：</p><pre><code class="language-plain">public fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit // 不同点1\n): Job {} // 不同点2\n\npublic fun &lt;T&gt; CoroutineScope.async(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; T // 不同点1\n): Deferred&lt;T&gt; {} // 不同点2\n</code></pre><p>从上面的代码中，我们可以发现launch和async的两个不同点，一个是 <strong>block的函数类型</strong>，前者的返回值类型是Unit，后者则是泛型T；另外一个不同点在<strong>返回值</strong>上，前者返回值类型是Job，后者返回值类型是Deferred。而async可以返回协程执行结果的原因也在于此。关于Job与Deferred的更多细节，我们会在第16讲讨论。</p><p>这里，我制作了一张动图，来演示程序整体的执行流程：</p><p><img src="https://static001.geekbang.org/resource/image/ec/ee/ec5b7e1f88ac38391f9503102yyee6ee.gif?wh=720x405" alt="图片"></p><h2>小结</h2><p>由于协程是一个非常抽象的概念，因此，它的<strong>调试手段就显得尤为重要</strong>，我们研究协程的时候，通常有两种手段，一种是设置VM参数：-Dkotlinx.coroutines.debug。另一种是直接在IDE当中打断点，不过协程调试是在Kotlin 1.4之后才支持的新特性，因此我们要确保IDE和Kotlin的版本都更新到最新。</p><p>另外，我们还学到了三种启动协程的方式，分别是launch、runBlocking、async。</p><ul>\n<li><strong>launch</strong>，是典型的“Fire-and-forget”场景，它不会阻塞当前程序的执行流程，使用这种方式的时候，我们无法直接获取协程的执行结果。它有点像是生活中的<strong>射箭</strong>。</li>\n<li><strong>runBlocking</strong>，我们可以获取协程的执行结果，但这种方式会阻塞代码的执行流程，因为它一般用于测试用途，生产环境当中是不推荐使用的。</li>\n<li><strong>async</strong>，则是很多编程语言当中普遍存在的协程模式。它像是结合了launch和runBlocking两者的优点。它既不会阻塞当前的执行流程，还可以直接获取协程的执行结果。它有点像是生活中的<strong>钓鱼</strong>。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/9b/4a/9b116c03897214c6d899177d459e354a.jpg?wh=2000x904" alt=""></p><h2>思考题</h2><p>下面这段代码是我在当面试官时，问过其他候选人的，你能推测出这段代码的执行结果吗？</p><pre><code class="language-plain">fun main() = runBlocking {\n    val deferred: Deferred&lt;String&gt; = async {\n        println("In async:${Thread.currentThread().name}")\n        delay(1000L) // 模拟耗时操作\n        println("In async after delay!")\n        return@async "Task completed!"\n    }\n\n    // 不再调用 deferred.await()\n    delay(2000L)\n}\n</code></pre>',
        article_title: "14 | 如何启动协程？",
      },
      {
        title: "15 | 挂起函数：Kotlin协程的核心",
        id: 487085,
        content:
          '<p>你好，我是朱涛。这节课，我们来学习协程的挂起函数。</p><p>挂起函数，是Kotlin协程当中最基础、最重要的知识点。如果对协程的挂起函数没有足够的认识，我们后续的学习将会困难重重。如果不理解挂起函数，我们将无法理解协程的非阻塞；如果不了解挂起函数，我们将无法掌握Channel、Flow等API；如果不理解挂起函数，我们写出来的代码也会漏洞百出，就更别提优化软件架构了。</p><p>相反，如果能将挂起函数理解透彻，我们后面的学习也会更加轻松一些。所以这节课，我会从应用和原理两个角度，来带你理解挂起函数，包括如何使用挂起函数来优化异步任务，以及挂起函数的CPS当中的Continuation到底是什么。通过对这两个维度的学习，你在更轻易地掌握挂起函数应用场景的同时，对它的底层原理也会有一定认识。</p><p>那么接下来，你一定要打起精神，我们一起来攻克这个关键的知识点！</p><h2>挂起函数：Kotlin协程的优势</h2><p>通过前面课程的学习，我们已经知道了：协程就像是轻量级的线程一样。用线程能实现的功能，我们借助launch和async也同样可以做到。</p><p>不过你可能会好奇，如果只是把thread{} 替换成launch{}，那协程比起线程也没什么特殊的优势吧？<strong>仅仅只是因为“轻量”“非阻塞”，我们就应该放弃线程，拥抱协程吗？</strong></p><!-- [[[read_end]]] --><p>其实，Kotlin协程最大的优势，就在于它的挂起函数。虽然很多编程语言都有协程的特性，但目前为止，只有Kotlin独树一帜，引入了“挂起函数”的概念。另外尽管有些语言的协程底层，也存在“挂起恢复”的概念，但是将这一概念直接暴露给开发者，直接用于修饰一个函数的，Kotlin算是做了一种创新。</p><p>那么，挂起函数到底有什么神奇的呢？我们先来看一段简单的Java代码：</p><pre><code class="language-java">// 代码段1\n\ngetUserInfo(new CallBack() {\n    @Override\n    public void onSuccess(String response) {\n        if (response != null) {\n            System.out.println(response);\n        }\n    }\n});\n</code></pre><p>在这段代码中，我们发起了一个异步请求，从服务端查询用户的信息，通过CallBack返回response。这样的代码看起来没什么问题，平时我们写代码的时候也经常写类似的代码。不过实际的商业项目不可能这么简单，有的时候，我们可能需要连续执行几个异步任务，比如说，查询用户信息 --&gt; 查找该用户的好友列表 --&gt;拿到好友列表后，查找该好友的动态。</p><p>这样一来，我们的代码就难免会往下面这个方向发展：</p><pre><code class="language-plain">// 代码段2\n\ngetUserInfo(new CallBack() {\n    @Override\n    public void onSuccess(String user) {\n        if (user != null) {\n            System.out.println(user);\n            getFriendList(user, new CallBack() {\n                @Override\n                public void onSuccess(String friendList) {\n                    if (friendList != null) {\n                        System.out.println(friendList);\n                        getFeedList(friendList, new CallBack() {\n                            @Override\n                            public void onSuccess(String feed) {\n                                if (feed != null) {\n                                    System.out.println(feed);\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    }\n});\n</code></pre><p>只要你参与过大型软件的开发，不管你用的是什么编程语言，你大概率都见到过类似上面的代码模式：<strong>回调地狱</strong>。</p><p>我们给它取这个名字是有原因的，以上代码存在诸多缺陷：<strong>可读性差、扩展性差、维护性差，极易出错</strong>！想象一下，如果让你基于以上代码再扩展出“超时取消”“出错重试”“进度展示”等相关功能，你会不会觉得头疼？</p><p>所以这时候，就该轮到Kotlin协程出场了。让我们用协程的挂起函数，来重构上面的代码：</p><pre><code class="language-plain">// 代码段3\n\nval user = getUserInfo()\nval friendList = getFriendList(user)\nval feedList = getFeedList(friendList)\n</code></pre><p>你看，是不是简洁到了极致？这就是Kotlin协程的魅力：<strong>以同步的方式完成异步任务</strong>。<br>\n注意，以上代码之所以能写成类似同步的方式，关键还是在于getUserInfo()、getFriendList()、getFeedList()这三个请求函数的定义。</p><pre><code class="language-plain">// 代码段4\n\n// delay(1000L)用于模拟网络请求\n\n//挂起函数\n// ↓\nsuspend fun getUserInfo(): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "BoyCoder"\n}\n\n//挂起函数\n// ↓\nsuspend fun getFriendList(user: String): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "Tom, Jack"\n}\n\n//挂起函数\n// ↓\nsuspend fun getFeedList(list: String): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "{FeedList..}"\n}\n</code></pre><p>从以上代码中，我们可以看到，<strong>所谓的挂起函数，其实就是比普通的函数多了一个suspend关键字而已</strong>。如果去掉这个suspend关键字，所有的函数都会变成普通函数。</p><blockquote>\n<p>代码中的withContext(Dispatchers.IO)，作用是控制协程执行的线程池，具体细节我们会在第17讲中介绍。</p>\n</blockquote><p>既然如此，那么这个suspend关键字的作用是啥呢？挂起函数到底特别在哪呢？</p><p>实际上，挂起函数最神奇的地方，就在于它的挂起和恢复功能。从字面上看，suspend这个词就是“挂起”的意思，而它既然能被<strong>挂起</strong>，自然就还可以被<strong>恢复</strong>。它们两个一般是成对出现的。</p><blockquote>\n<p>还记得我们在讲<a href="https://time.geekbang.org/column/article/485632">协程思维模型</a>的时候提到的“非阻塞”概念吗？这主要就归功于Kotlin协程的挂起函数的能力。</p>\n</blockquote><p>不过，我单纯用文字告诉你Kotlin协程支持挂起和恢复，你一定没有什么概念，我做了一个小动画，描述了挂起函数整体的执行流程，同时也展示了其背后更多的细节。需要注意的是，动画当中出现的“闪烁”，模拟的是请求网络。<strong>你一定要多看几遍，确保没有遗漏其中的细节。</strong></p><p><video poster="https://media001.geekbang.org/10b5350f78f449eb87ac16990d70a654/snapshots/d2a4912d2a9a40d28f19c9e02e2edc70-00003.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/3164eee7-17efcb599ef-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/d9f1c79e558b4dd7a3f3bdca3dca8595/96dad61fb19940d5b29f0bd13d114e60-c6276f52ec7c29bbaf6944275b932cfc-sd.m3u8" type="application/x-mpegURL"></video></p><p>然后，我也再给你重点解释下其中的关键点：</p><ul>\n<li>在IntelliJ当中，挂起函数会有一个特殊的箭头标记，这样就便于我们分辨出当前调用的函数是否是普通函数。调用挂起函数的位置，我们叫做是<strong>挂起点</strong>。</li>\n<li>另外，表面上看起来是同步的代码，实际上也涉及到了线程切换，一行代码，切换了两个线程。\n<ul>\n<li>比如“val user = getUserInfo()”，其中“=”左边的代码运行在主线程，而“=”右边的代码运行在IO线程。</li>\n<li>每一次从主线程到IO线程，都是一次协程挂起。</li>\n<li>每一次从IO线程到主线程，都是一次协程恢复。</li>\n</ul>\n</li>\n<li>挂起和恢复，这是挂起函数<strong>特有的能力</strong>，普通函数是不具备的。</li>\n<li>挂起，只是将程序执行流程转移到了其他线程，主线程不会被阻塞。如果以上代码运行在Android系统，我们的App仍然可以响应用户的操作，主线程并不繁忙。相信现在，你对协程思维模型又会有更加深刻的体会了。</li>\n</ul><p>好，挂起函数的执行流程我们已经很清楚了。借助挂起函数，我们可以用同步的方式来写异步代码，对比起前面“回调地狱”式的代码，挂起函数写出来的代码可读性更好、扩展性更好、维护性更好，并且更难出错。</p><p>这个时候，你也许会感慨：挂起函数真的是太神奇了！简直就跟魔法一样！<strong>那么，Kotlin协程到底是如何做到一行代码切换两个线程的呢？</strong></p><p>其实，Kotlin协程当中并不存在什么“魔法”。这一切的细节，都藏在了挂起函数的 <strong>suspend</strong> 关键字里。</p><h2>深入理解suspend</h2><p>到目前为止，我们已经知道了：suspend，是Kotlin当中的一个关键字，它主要的作用是用于定义“挂起函数”。不过如果你有仔细留意上节课当中的一段代码，你就会发现，同样的一个函数，加上suspend修饰以后，它的<strong>函数类型</strong>就会发生改变。</p><p>我们来回忆一下上节课的那段代码：</p><pre><code class="language-plain">// 代码段5\n\nfun func1(num: Int): Double {\n    return num.toDouble()\n}\n/*\nfunc1与func3唯一的区别\n   ↓                         */\nsuspend fun func3(num: Int): Double {\n    delay(100L)\n    return num.toDouble()\n}\n\nval f1: (Int) -&gt; Double = ::func1\nval f2: suspend (Int) -&gt; Double = ::func3\n\nval f3: (Int) -&gt; Double = ::func3 // 报错\nval f4: suspend (Int) -&gt; Double = ::func1 // 报错\n</code></pre><p>可见，同样是Int作为参数，Double作为返回值，有没有suspend修饰，它们两者的函数类型是不一样的。“suspend (Int) -&gt; Double”与“(Int) -&gt; Double”并不能互相赋值。</p><p>在讲<a href="https://time.geekbang.org/column/article/476637">高阶函数</a>的时候，我提到过Kotlin的函数类型，其实只跟参数、返回值、接收者相关，不过现在又加了一条：还跟suspend相关。</p><blockquote>\n<p>补充：如果你接触过<a href="https://github.com/JetBrains/compose-jb">Compose</a>，你会发现其中的@Composable跟suspend一样，也可以改变一个函数的类型，不过这个并不是我们要了解的重点，这里只是帮助你建立一个知识连接，如果你将来遇到了Compose，你就可以快速理解了。</p>\n</blockquote><p><strong>那么，suspend修饰的函数，到底会变成什么类型？</strong>如果你将挂起函数与前面“回调地狱的代码”放在一起对比，再结合我们<a href="https://time.geekbang.org/column/article/473529">第3讲</a>学过的Kotlin原理，应该就会找到一些头绪了：</p><p><img src="https://static001.geekbang.org/resource/image/08/68/08c49bd12047359fc8cea409fc6a2568.png?wh=1442x811" alt="图片"></p><p>其实，<strong>挂起函数的本质，就是Callback</strong>。</p><p>别忘了，我们还有Kotlin编译器这个“幕后的翻译官”啊！虽然我们写出来的挂起函数并没有任何Callback的逻辑，但是，当Kotlin编译器检测到suspend关键字修饰的函数以后，就会自动将挂起函数转换成带有CallBack的函数。</p><p>如果我们将上面的挂起函数反编译成Java，结果会是这样：</p><pre><code class="language-java">// 代码段6\n\n//                              Continuation 等价于 CallBack\n//                                         ↓         \npublic static final Object getUserInfo(Continuation $completion) {\n  ...\n  return "BoyCoder";\n}\n</code></pre><p>从反编译的结果来看，挂起函数确实变成了一个带有CallBack的函数，只是这个CallBack换了个名字，叫做Continuation。我们来看看Continuation在Kotlin中的定义：</p><pre><code class="language-plain">// 代码段7\n\npublic interface Continuation&lt;in T&gt; {\n// ...\n\n//      相当于 CallBack的onSuccess   结果   \n//                 ↓                 ↓\n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n\ninterface CallBack {\n    void onSuccess(String response);\n}\n</code></pre><p>根据以上定义我们其实能发现，<strong>Continuation本质上也就是一个带有泛型参数的CallBack</strong>，只是它的名字看起来有点吓人而已。这个“从挂起函数转换成CallBack函数”的过程，被叫做是CPS转换（Continuation-Passing-Style Transformation）。</p><p>看，Kotlin官方要将CallBack命名为Continuation的原因也出来了：Continuation道出了它的实现原理。当然，为了理解挂起函数，我们用CallBack会更加简明易懂。</p><p>下面我用动画来演示一下挂起函数在CPS转换过程中，函数签名的变化：</p><p><img src="https://static001.geekbang.org/resource/image/37/92/3732f7a3473e82c5a5d109a18d87f992.gif?wh=720x405" alt="图片"></p><blockquote>\n<p><strong>注意</strong>：挂起函数CPS转换后的内部逻辑，其实要远比演示的复杂，这个我们到源码篇再深究，我们暂时只关注它<strong>函数签名</strong>的变化。</p>\n</blockquote><p>你能看到，在上面CPS转换的过程中，函数的类型发生了变化：“suspend ()-&gt;String” 变成了 “(Continuation)-&gt; Any?”。</p><p>而这就意味着，如果你在Java中访问一个Kotlin挂起函数getUserInfo()，会看到Java里的getUserInfo()的类型是“(Continuation)-&gt; Object”（即接收Continuation为参数，返回值是Object）。</p><p><img src="https://static001.geekbang.org/resource/image/5b/90/5b81e4a51acaafa1ce56f7a888037790.png?wh=792x286" alt="图片"></p><p>到这里，我们就只剩下最后一个问题需要搞清楚了，那就是：<strong>Continuation到底是什么</strong>？如果你查<a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD/continuation">词典</a>和<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E7%BB%AD%E4%BD%93">维基百科</a>，可能会一头雾水，因为这个词太抽象了。</p><p>让我结合前面的代码案例，用更加通俗的语言解释给你听。</p><p>首先，我们只需要把握住Continuation的词源Continue即可。Continue是“继续”的意思，Continuation则是“接下来要做的事情”。放到程序中，Continuation就代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是“剩下的代码”。</p><p>就以上面的代码为例，当程序运行getUserInfo()这个挂起函数的时候，它的“Continuation”则是下图红框的代码：</p><p><img src="https://static001.geekbang.org/resource/image/06/yb/060c08db5f586ed8e189cfa26eaa6yyb.png?wh=960x376" alt="图片"></p><p>这样理解了Continuation以后，CPS也就容易理解了，它其实就是<strong>将程序接下来要执行的代码进行传递的一种模式</strong>。</p><p>而CPS转换，就是<strong>将原本的同步挂起函数转换成CallBack异步代码</strong>的过程。这个转换是编译器在背后做的，我们程序员对此并无感知。</p><p><img src="https://static001.geekbang.org/resource/image/03/22/03d156ec6a31d650c6634f486dc06222.gif?wh=720x405" alt="图片"></p><p>根据这个动图，可以看到当程序执行到getUserInfo()的时候，剩下的未执行代码都被一起打包了起来，以Continuation的形式，传递给了getUserInfo()的Callback回调当中。当然，这种方式其实只是大致模拟了挂起函数的CPS转换过程，实际细节要远比这个复杂。但这对于现阶段的学习来说，已经完全够用了。</p><p>以上就是Kotlin挂起函数的核心原理，它的挂起和恢复，其实也是通过CPS转换来实现的。在后面学习源码篇的时候，我们还会继续跟Continuation继续打交道。现在我们看着CPS的过程好像很简单，等到深入底层的时候，你会发现Continuation是多么的复杂和精妙。</p><p>这里，我们再来看看之前的协程思维模型：</p><p><img src="https://static001.geekbang.org/resource/image/c6/1b/c6e735653c09f05ea94f5478d5e0d61b.gif?wh=1080x492" alt="图片"></p><p>所以，现在我们可以理出一条线索了：<strong>协程之所以是非阻塞，是因为它支持“挂起和恢复”；而挂起和恢复的能力，主要是源自于“挂起函数”；而挂起函数是由CPS实现的，其中的Continuation，本质上就是Callback</strong>。</p><p>读完上面的这段话，也许你会忍不住好奇：<strong>协程跟挂起函数之间是什么关系？</strong></p><h2>协程与挂起函数</h2><p>你可能觉得，既然协程和挂起函数都是支持挂起和恢复的，那它们两个是不是同一个东西呢？</p><p>答案当然是<strong>否定</strong>的。</p><p>关于协程和挂起函数的关系，我们暂时还不适合深入源码层面去做探讨。不过，从我们目前已有的信息，就可以直接推断出，它们之间肯定是有着千丝万缕的联系的。让我们来看个简单的例子：</p><pre><code class="language-plain">// 代码段8\n\nfun main() {\n    getUserInfo() // 报错\n}\n\nsuspend fun getUserInfo(): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "BoyCoder"\n}\n</code></pre><p>在上面的代码中，我们直接在main函数当中调用了getUserInfo()这个挂起函数，这时候，我们发现IDE会报错，报错的具体内容是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/68/aa/68010f8b8bd5de8d58dd8576828d92aa.png?wh=945x247" alt="图片"></p><p>这个报错信息的意思是：<strong>挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用</strong>。这个意思也很好理解，对于这样的要求，我们很容易就能写出下面的代码：</p><pre><code class="language-plain">// 代码段9\n\n// 在协程中调用getUserInfo()\nfun main() = runBlocking {\n    val user = getUserInfo()\n}\n\n// 在另一个挂起函数中调用getUserInfo()\nsuspend fun anotherSuspendFunc() {\n    val user = getUserInfo()\n}\n</code></pre><p>代码写到这里，很多人都会满足于这样的结果。但实际上，以上两种方式，它们之间是可以继续深入并且挖掘出共性的。</p><p>让我们回过头来看看runBlocking的函数签名：</p><pre><code class="language-plain">// 代码段10\n\npublic actual fun &lt;T&gt; runBlocking(\n    context: CoroutineContext, \n    block: suspend CoroutineScope.() -&gt; T\n): T {\n}\n</code></pre><p>我们重点关注它的第二个参数block的类型“suspend CoroutineScope.() -&gt; T”，看到其中的suspend关键字了吗？<strong>原来block也是一个挂起函数的类型</strong>！那么，在block当中可以调用挂起函数，就一点也不奇怪了！</p><p>所以说，虽然“协程和挂起函数”都可以调用“挂起函数”，但是协程的Lambda，也是挂起函数。所以，它们本质上都是因为“挂起函数可以调用挂起函数”。</p><p>也就是说，站在目前的阶段来看，我们可以认为：<strong>挂起和恢复，是协程的一种底层能力；而挂起函数，是这种底层能力的一种表现形式，通过暴露出来的suspend关键字，我们开发者可以在上层，非常方便地使用这种底层能力。</strong></p><h2>小结</h2><p>这节课，我们主要学习了Kotlin协程当中的最核心的特性：<strong>挂起函数</strong>。</p><p>挂起函数可以极大地简化异步编程，让我们能够<strong>以同步的方式写异步代码</strong>。相比“回调地狱”式的代码，挂起函数写出来的代码<strong>可读性更好、扩展性更好、维护性更好，也更难出错</strong>。而除此之外，你也需要牢记以下这些核心要点，来更好地掌握挂起函数。</p><ul>\n<li>要定义挂起函数，我们只需在普通函数的基础上，增加一个<strong>suspend关键字</strong>。suspend这个关键字，是会改变函数类型的，“suspend (Int) -&gt; Double”与“(Int) -&gt; Double”并不是同一个类型。</li>\n<li>挂起函数，由于它拥有<strong>挂起和恢复</strong>的能力，因此对于同一行代码来说，“=”左右两边的代码分别可以执行在不同的线程之上。而这一切，都是因为Kotlin编译器这个幕后的翻译官在起作用。</li>\n<li><strong>挂起函数的本质，就是Callback</strong>。只是说，Kotlin底层用了一个更加高大上的名字，叫Continuation。而Kotlin编译器将suspend翻译成Continuation的过程，则是CPS转换。这里的Continuation是代表了，“程序继续运行下去需要执行的代码”，“接下来要执行的代码”，或者是 “剩下的代码”。</li>\n</ul><p>最后，我们还探索了协程与挂起函数之间的关系。我们发现：<strong>挂起函数，只能在协程当中被调用，或者是被其他挂起函数调用</strong>。但协程中的block，本质上仍然是挂起函数。</p><p>所以，我们可以认为：挂起和恢复是协程的一种底层能力；而挂起函数则是一种上层的表现形式。</p><p><img src="https://static001.geekbang.org/resource/image/19/bd/19591ff06ebc553ca6fa695a3914bdbd.jpg?wh=2000x1279" alt=""></p><h2>思考题</h2><p>前面我们提到“挂起函数只能在协程当中被调用，或者是被其他挂起函数调用”，而本质上，还是因为“挂起函数可以调用挂起函数”。那么，你能找出更加底层的证据吗？</p><p>换个方式理解就是：凭什么挂起函数可以调用挂起函数，而普通函数不能调用挂起函数？它的底层逻辑到底什么？</p><pre><code class="language-plain">// 代码段11\n\nfun normalFunc() {\n    val user = getUserInfo() // 报错\n}\n\nsuspend fun anotherSuspendFunc() {\n    val user = getUserInfo() // 通过\n}\n</code></pre><p>欢迎在留言区分享你的思考和答案，也欢迎你把今天的内容分享给更多的朋友，我们一起探讨和进步。</p>',
        article_title: "15 | 挂起函数：Kotlin协程的核心",
      },
      {
        title: "16 | Job：协程也有生命周期吗？",
        id: 487930,
        content:
          '<p>你好，我是朱涛。今天我们来学习Kotlin协程的Job。</p><p>Job其实就是协程的句柄。从某种程度上讲，当我们用launch和async创建一个协程以后，同时也会创建一个对应的Job对象。另外，Job也是我们理解<strong>协程生命周期</strong>、<strong>结构化并发</strong>的关键知识点。通过Job暴露的API，我们还可以让不同的协程之间互相配合，从而实现更加复杂的功能。</p><p>虽然前面已经解释过，Job就是协程的句柄，但你可能还是不清楚它到底是什么，因为句柄本身就是一个比较“虚”的概念。所以在这节课中，我们会从使用的角度入手，来看看Job到底能干什么。在充分理解了Job的用法以后，我们再来结合它的源代码进一步分析，这样对Job也会有一个更加清晰的认知。</p><h2>Job生命周期</h2><p>在上节课我们学习launch、async的时候，我们知道它们两个返回值类型分别是Job和Deferred。</p><pre><code class="language-plain">// 代码段1\n\npublic interface Deferred&lt;out T&gt; : Job {\n    public suspend fun await(): T\n}\n</code></pre><p>而如果你去看Deferred的源代码，你会发现，它其实也是继承自Job的。对应的，它只是多了一个泛型参数T，还多了一个返回类型为T的await()方法。所以，不管是launch还是async，<strong>它们本质上都会返回一个Job对象</strong>。</p><!-- [[[read_end]]] --><p>通过Job对象，我们主要可以做两件事情：</p><ul>\n<li>使用Job <strong>监测</strong>协程的生命周期状态；</li>\n<li>使用Job <strong>操控</strong>协程。</li>\n</ul><p>让我们来看一个具体的例子：</p><pre><code class="language-plain">// 代码段2\n\nfun main() = runBlocking {\n    val job = launch {\n        delay(1000L)\n    }\n    job.log()       // ①\n    job.cancel()    // ②\n    job.log()       // ③\n    delay(1500L)\n}\n\n/**\n * 打印Job的状态信息\n */\nfun Job.log() {\n    logX("""\n        isActive = $isActive\n        isCancelled = $isCancelled\n        isCompleted = $isCompleted\n    """.trimIndent())\n}\n\n/**\n * 控制台输出带协程信息的log\n */\nfun logX(any: Any?) {\n    println("""\n================================\n$any\nThread:${Thread.currentThread().name}\n================================""".trimIndent())\n}\n\n\n/*\n输出结果：\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nisActive = false\nisCancelled = true\nisCompleted = false\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>在这段代码当中，我们定义了一个Job.log()扩展函数，它的作用就是打印Job的生命周期状态。通过调用这个函数，我们就可以知道对应的协程处于什么状态。</p><p>注释①处的调用结果，“isActive = true”，这代表了当前的协程处于活跃状态。注释②，我们调用了job.cancel()以后，协程任务就会被取消。因此，注释③处的调用结果就会变成“isCancelled = true”，这代表了协程任务处于取消状态。</p><p>所以从上面的代码中，我们可以看到：job.log()，其实就是在<strong>监测协程</strong>；job.cancel()，其实就是在<strong>操控协程</strong>。</p><p>而除了job.cancel()可以操控协程以外，我们还经常使用job.start()来启动协程任务，一般来说，它都是搭配“CoroutineStart.LAZY”来使用的。</p><pre><code class="language-plain">// 代码段3\n\nfun main() = runBlocking {\n    //                  变化在这里\n    //                      ↓\n    val job = launch(start = CoroutineStart.LAZY) {\n        logX("Coroutine start!")\n        delay(1000L)\n    }\n    delay(500L)     \n    job.log()       \n    job.start()     // 变化在这里\n    job.log()\n    delay(500L)\n    job.cancel()\n    delay(500L)\n    job.log()\n    delay(2000L)\n    logX("Process end!")\n}\n\n/*\n输出结果：\n================================\nisActive = false\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nCoroutine start!\nThread:main @coroutine#2\n================================\n================================\nisActive = false\nisCancelled = true\nisCompleted = true\nThread:main @coroutine#1\n================================\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>根据以上代码的运行结果，可以发现，当我们使用CoroutineStart.LAZY作为启动模式的时候，协程任务被launch以后，并不会立即执行，即使我们在代码中delay了500毫秒，launch内部的<code>"Coroutine start!"</code>也仍然没有输出。这是典型的<strong>懒加载</strong>行为模式。</p><p>当我们在外部调用了job.start()以后，job的状态才变成了Active活跃。而当调用了cancel以后，job的状态才变成isCancelled、isCompleted。</p><p>到这里，我们基本上就可以想象出Job整个的生命周期了。请参考下面这张图：</p><p><img src="https://static001.geekbang.org/resource/image/c1/52/c1d2515fcb7c3fa4130fcf85e9dd2852.jpg?wh=2000x846" alt=""></p><p>从图中，我们可以看到，对于协程的Job来说，它有两种初始状态，如果Job是以<strong>懒加载</strong>的方式创建的，那么它的初始状态将会是New；而如果一个协程是以<strong>非懒加载</strong>的方式创建的，那么它的初始状态就会是Active。</p><p>另外如果你仔细分析了上面代码的输出结果，你会发现，当调用cancel以后，会出现一个奇怪的现象：isCancelled = true、isCompleted = true。也就是说，当协程任务被取消以后，isCancelled和isCompleted同时都是true。但这跟上面的流程图并不一致啊！这是为什么呢？</p><p>这是因为，协程认为由于某种原因取消的协程，也仍然是一种“<strong>结束状态</strong>”，这其实也就对应了流程图中的“最终状态”。</p><p>换句话说，流程图当中的New、Active、Completing、Cancelling、Completed、Cancelled这些状态，都是Job内部私有的状态。而Job对外暴露出的isCompleted并不是与其一一对应的。Job内部私有的Completed、Cancelled状态，都会认为是外部的isCompleted状态。</p><p>测试了协程cancel()方法以后，我们再来看看协程正常执行完毕的情况：</p><pre><code class="language-plain">// 代码段4\n\nfun main() = runBlocking {\n    val job = launch(start = CoroutineStart.LAZY) {\n        logX("Coroutine start!")\n        delay(1000L)\n    }\n    delay(500L)\n    job.log()\n    job.start()\n    job.log()\n    delay(1100L)    // ①\n    job.log()\n    delay(2000L)    // ②\n    logX("Process end!")\n}\n\n================================\nisActive = false\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nCoroutine start!\nThread:main @coroutine#2\n================================\n================================\nisActive = false\nisCancelled = false\nisCompleted = true\nThread:main @coroutine#1\n================================\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n</code></pre><p>在这段代码中，我们可以清晰地看到，协程的状态从Start到Active，最后到Completed，这很好理解。</p><p>不过，需要注意的是注释①处，为了等待job任务执行完毕，我们在外面等待了1100毫秒，这种方式其实并不好，因为大部分情况下，<strong>我们很难从外部判断协程需要多长的时间才能结束</strong>（比如网络请求任务、下载任务）。</p><p>另外，请留意上面的注释②处，我们使用delay(2000L)的方式，希望在job执行完毕以后输出“Process end!”，这样的代码，也是建立在“我们知道Job只需要1000毫秒就能执行完毕”的前提。如果协程内部的delay远大于外部的delay，以上的运行结果就会完全不一样：</p><pre><code class="language-plain">// 代码段5\n\nfun main() = runBlocking {\n    val job = launch(start = CoroutineStart.LAZY) {\n        logX("Coroutine start!")\n        delay(4000L) // 变化在这里\n    }\n    delay(500L)\n    job.log()\n    job.start()\n    job.log()\n    delay(1100L)    \n    job.log()\n    delay(2000L)    \n    logX("Process end!")\n}\n\n/*\n输出结果：\n================================\nisActive = false\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nCoroutine start!\nThread:main @coroutine#2\n================================\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n到这里，job仍然还在delay，整个程序并没有完全退出。\n*/\n</code></pre><p>可以看到，当我们将job内部的delay改为4000毫秒以后，执行结果就完全不一样了，我们无法监测到isCompleted状态。</p><p>另外，如果你实际运行了上面的代码，你会发现“Process end!”输出以后，程序并没有立即结束，而是等待了大约900毫秒才结束，这是因为runBlocking会一直阻塞，等到job任务执行完毕以后才真正退出。</p><p>所以，为了更加灵活地<strong>等待和监听</strong>协程的结束事件，我们可以用job.join()以及 <code>invokeOnCompletion {}</code> 来优化上面的代码。</p><pre><code class="language-plain">// 代码段6\n\nfun main() = runBlocking {\n    suspend fun download() {\n        // 模拟下载任务\n        val time = (Random.nextDouble() * 1000).toLong()\n        logX("Delay time: = $time")\n        delay(time)\n    }\n    val job = launch(start = CoroutineStart.LAZY) {\n        logX("Coroutine start!")\n        download()\n        logX("Coroutine end!")\n    }\n    delay(500L)\n    job.log()\n    job.start()\n    job.log()\n    job.invokeOnCompletion {\n        job.log() // 协程结束以后就会调用这里的代码\n    }\n    job.join()      // 等待协程执行完毕\n    logX("Process end!")\n}\n\n/*\n运行结果：\n================================\nisActive = false\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nisActive = true\nisCancelled = false\nisCompleted = false\nThread:main @coroutine#1\n================================\n================================\nCoroutine start!\nThread:main @coroutine#2\n================================\n================================\nDelay time: = 252\nThread:main @coroutine#2\n================================\n================================\nCoroutine end!\nThread:main @coroutine#2\n================================\n================================\nisActive = false\nisCancelled = false\nisCompleted = true\nThread:main @coroutine#2\n================================\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>这里我们可以看到，<code>invokeOnCompletion {}</code> 的作用，其实就是监听协程结束的事件。需要注意的是，它和前面的isCompleted类似，如果job被取消了，<code>invokeOnCompletion {}</code> 这个回调仍然会被调用。</p><p>而job.join()其实是一个“挂起函数”，它的作用就是：<strong>挂起当前的程序执行流程，等待job当中的协程任务执行完毕，然后再恢复当前的程序执行流程</strong>。可以看到，上节课学的“挂起函数”的概念再一次出现了，它对我们后续理解协程的API非常重要，如果你无法理解上面那句话的意思，一定要去重新回顾上节课的内容。</p><p>至此，我们就对Job的两种使用场景都已经有了充分认识了。我们来大概看看Job的源代码：</p><pre><code class="language-plain">// 代码段7\n\npublic interface Job : CoroutineContext.Element {\n\n    // 省略部分代码\n\n    // ------------ 状态查询API ------------\n\n    public val isActive: Boolean\n\n    public val isCompleted: Boolean\n\n    public val isCancelled: Boolean\n\n    public fun getCancellationException(): CancellationException\n\n    // ------------ 操控状态API ------------\n\n    public fun start(): Boolean\n\n    public fun cancel(cause: CancellationException? = null)\n\n    public fun cancel(): Unit = cancel(null)\n\n    public fun cancel(cause: Throwable? = null): Boolean\n\n    // ------------ 等待状态API ------------\n\n    public suspend fun join()\n\n    public val onJoin: SelectClause0\n\n    // ------------ 完成状态回调API ------------\n\n    public fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle\n\n    public fun invokeOnCompletion(\n        onCancelling: Boolean = false,\n        invokeImmediately: Boolean = true,\n        handler: CompletionHandler): DisposableHandle\n\n}\n</code></pre><p>可见，Kotlin官方对Job的API做了更加详细的划分，但实际上来说都属于“<strong>监测状态</strong>”“<strong>操控状态</strong>”这两个大的范畴。</p><p>现在我们对Job也有了更加深入的认识了，不过到底该如何理解“<strong>Job是协程的句柄</strong>”这句话呢？</p><p>这里，我们还是可以从现实生活中找例子，来建立大致的思维模型。Job和协程的关系，就有点像“遥控器和空调的关系”。</p><ul>\n<li>空调遥控器可以<strong>监测</strong>空调的运行状态；Job也可以监测协程的运行状态；</li>\n<li>空调遥控器可以<strong>操控</strong>空调的运行状态，Job也可以简单操控协程的运行状态。</li>\n</ul><p>所以，从某种程度来讲，遥控器也是空调对外暴露的一个“句柄”。</p><p>好，充分理解了Job以后，我们来看看Deferred。</p><h2>Deferred</h2><p>前面我们介绍过Deferred其实就是继承自Job的一个接口，它并没有在Job的基础上扩展出很多其他功能，最重要的就是await()这个方法。让我们来看一个简单的例子：</p><pre><code class="language-plain">// 代码段8\n\nfun main() = runBlocking {\n    val deferred = async {\n        logX("Coroutine start!")\n        delay(1000L)\n        logX("Coroutine end!")\n        "Coroutine result!"\n    }\n    val result = deferred.await()\n    println("Result = $result")\n    logX("Process end!")\n}\n\n/*\n输出结果：\n================================\nCoroutine start!\nThread:main @coroutine#2\n================================\n================================\nCoroutine end!\nThread:main @coroutine#2\n================================\nResult = Coroutine result!\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>从代码的执行结果中，我们可以发现，deferred.await()这个方法，不仅可以帮助我们获取协程的执行结果，它还会阻塞当前协程的执行流程，直到协程任务执行完毕。在这一点的行为上，await()和join()是类似的。</p><p>我们也来看看await()的函数签名：</p><pre><code class="language-plain">// 代码段9\n\npublic interface Deferred&lt;out T&gt; : Job {\n//          注意这里\n//            ↓\n    public suspend fun await(): T\n}\n</code></pre><p>可以看到，await()这个方法其实是一个挂起函数，这也就意味着，这个方法拥有挂起和恢复的能力。如果当前的Deferred任务还没执行完毕，那么，await()就会挂起当前的协程执行流程，等待Deferred任务执行完毕，再恢复执行后面剩下的代码。</p><p>看到这里，也许你会觉得奇怪，<strong>挂起函数不是非阻塞的吗？怎么这里又出现了阻塞？</strong>注意，这里其实只是看起来像是阻塞了，但它实际上是将剩下的代码存了起来，留在后面才执行了。</p><p>为了让你更加透彻地理解await()挂起函数背后的细节，我进一步完善了之前<a href="https://time.geekbang.org/column/article/485632">协程思维模型</a>的动图。</p><p><img src="https://static001.geekbang.org/resource/image/e3/37/e30c901b79682faaa00fd0d978521b37.gif?wh=1080x517" alt=""></p><p>所以，这里await()后面的代码，虽然看起来是阻塞了，但它只是执行流程被挂起和恢复的一种表现。而且如果你仔细思考的话，你会发现上面这个动图，同样也描述了之前job.join()的行为模式，在协程执行完毕之前，后面的协程代码都被暂时挂起了，等到协程执行完毕，才有机会继续执行。</p><p>所以，总的来说，Deferred只是比Job多了一个await()挂起函数而已，通过这个挂起函数，我们可以等待协程执行完毕的同时，还可以直接拿到协程的执行结果。</p><p>至此，我们就已经把Job和Deferred的生命周期讲清楚了。对于Job，我们了解了<strong>监测生命周期状态</strong>、<strong>操控生命周期状态</strong>；对于Deferred，我们也明白了如何拿到它的<strong>执行结果</strong>。</p><p>那么接下来，就只剩下一个话题了：<strong>结构化并发</strong>。</p><h2>Job与结构化并发</h2><p>也许你会经常看到类似这样的话：协程的优势在于结构化并发。在我看来，Kotlin协程的结构化并发，它的重要性，是仅次于“挂起函数”的。</p><p>也就是说，<strong>“结构化并发”是Kotlin协程的第二大优势</strong>。那么，到底什么是结构化并发呢？其实，这是一个非常大的话题，三言两语真的很难讲清楚。“结构化并发”会贯穿我们整个课程，随着课程的进展，你会发现，它跟很多其他协程概念都会发生牵连。</p><p>简单来说，“结构化并发”就是：<strong>带有结构和层级的并发</strong>。</p><p>说实话，在抽象的概念面前，语言和文字总会显得苍白无力。所以，我们还是来看一个具体的例子吧。</p><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    val parentJob: Job\n    var job1: Job? = null\n    var job2: Job? = null\n    var job3: Job? = null\n\n    parentJob = launch {\n        job1 = launch {\n            delay(1000L)\n        }\n\n        job2 = launch {\n            delay(3000L)\n        }\n\n        job3 = launch {\n            delay(5000L)\n        }\n    }\n\n    delay(500L)\n\n    parentJob.children.forEachIndexed { index, job -&gt;\n        when (index) {\n            0 -&gt; println("job1 === job is ${job1 === job}")\n            1 -&gt; println("job2 === job is ${job2 === job}")\n            2 -&gt; println("job3 === job is ${job3 === job}")\n        }\n    }\n\n    parentJob.join() // 这里会挂起大约5秒钟\n    logX("Process end!")\n}\n\n/*\n输出结果：\njob1 === job is true\njob2 === job is true\njob3 === job is true\n// 等待大约5秒钟\n================================\nProcess end!\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>在上面的代码中，我们一共定义了4个Job，parentJob是最外层的launch返回的对象，而在这个launch的内部，还额外嵌套了三个launch，它们的Job对象分别赋值给了job1、job2、job3。<br>\n接着，我们对“parentJob.children”进行了遍历，然后逐一对比了它们与job1、job2、job3的引用是否相等（“===”代表了引用相等，即是否是同一个对象）。</p><p>通过这样的方式，我们可以确定，job1、job2、job3其实就是parentJob的children。也就是说，我们使用launch创建出来的协程，是存在<strong>父子关系</strong>的。</p><p>如果你去看Job的源代码，你会发现它还有两个API是用来描述父子关系的。</p><pre><code class="language-plain">// 代码段11\n\npublic interface Job : CoroutineContext.Element {\n    // 省略部分代码\n\n    // ------------ parent-child ------------\n\n    public val children: Sequence&lt;Job&gt;\n\n    @InternalCoroutinesApi\n    public fun attachChild(child: ChildJob): ChildHandle\n}\n</code></pre><p>可以看到，每个Job对象，都会有一个children属性，它的类型是Sequence，它是一个惰性的集合，我们可以对它进行遍历。而attachChild()则是一个协程内部的API，用于绑定ChildJob的，这个我们到源码篇的时候再深入了解。</p><p>所以，我们其实可以用一个简单的结构图来描述上面4个Job之间的关系：</p><p><img src="https://static001.geekbang.org/resource/image/b0/4c/b03c8e45f00bf7276c988e7038fcc44c.png?wh=1436x776" alt="图片"></p><p>那么，这样的父子关系到底意味着什么呢？如果你实际运行这里的代码，你就会注意到：“parentJob.join()”这行代码会被挂起大约5秒钟。</p><p>注意了，我们调用的是parentJob的join()方法，但是，它会等待其内部的job1、job2、job3全部执行完毕，才会恢复执行。换句话说，只有当job1、job2、job3全部执行完毕，parentJob才算是执行完毕了。</p><p><img src="https://static001.geekbang.org/resource/image/83/a0/838728245b22e99c7900ba50968dcba0.gif?wh=1080x608" alt="图片"></p><p>所以到这里，也许你就已经可以理解前面的那句话了：<strong>结构化并发就是带有结构和层级的并发。</strong></p><p>实际上，协程不像我们之前学过的线程，线程之间是不存在父子关系的，但协程之间是会存在父子关系的。不过要命的是，协程的这种父子关系并不明显，如果我们不深入Job的源码，就无法意识到这一点。这也是很多人无法理解协程运行模式的原因所在。</p><p>毕竟，如果你将上面的4个launch都割裂来看，那么无论如何，你都无法理解上面代码的运行顺序，可是一旦你建立了协程Job父子关系的思维模型，你就可以轻而易举地理解以上的代码。</p><p>现在，我们将上面的代码做一些修改，我相信你也可以马上弄明白它的运行模式！</p><pre><code class="language-plain">// 代码段12\n\nfun main() = runBlocking {\n    val parentJob: Job\n    var job1: Job? = null\n    var job2: Job? = null\n    var job3: Job? = null\n\n    parentJob = launch {\n        job1 = launch {\n            logX("Job1 start!")\n            delay(1000L)\n            logX("Job1 done!") // ①，不会执行\n        }\n\n        job2 = launch {\n            logX("Job2 start!")\n            delay(3000L)\n            logX("Job2 done!") // ②，不会执行\n        }\n\n        job3 = launch {\n            logX("Job3 start!")\n            delay(5000L)\n            logX("Job3 done!")// ③，不会执行\n        }\n    }\n\n    delay(500L)\n\n    parentJob.children.forEachIndexed { index, job -&gt;\n        when (index) {\n            0 -&gt; println("job1 === job is ${job1 === job}")\n            1 -&gt; println("job2 === job is ${job2 === job}")\n            2 -&gt; println("job3 === job is ${job3 === job}")\n        }\n    }\n\n    parentJob.cancel() // 变化在这里\n    logX("Process end!")\n}\n\n/*\n输出结果：\n================================\nJob1 start!\nThread:main @coroutine#3\n================================\n================================\nJob2 start!\nThread:main @coroutine#4\n================================\n================================\nJob3 start!\nThread:main @coroutine#5\n================================\njob1 === job is true\njob2 === job is true\njob3 === job is true\n================================\n// 这里不会等待5秒钟\nProcess end!\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>这段代码，最大的改变就在于我们将“parentJob.join”改为了“parentJob.cancel()”。从运行结果中我们可以看到，即使我们调用的只是parentJob的cancel()方法，并没有碰过job1、job2、job3，但是它们内部的协程任务也全都被取消了。</p><p>这里，我们也可以用一个简单的动图来描述它们之间的关系：</p><p><img src="https://static001.geekbang.org/resource/image/26/7a/269a6130578ed243e436469ac75c4d7a.gif?wh=1080x484" alt="图片"></p><p>所以，当我们以<strong>结构化</strong>的方式构建协程以后，我们的join()、cancel()等操作，也会以结构化的模式来执行。</p><h2>思考与实战</h2><p>在学完Job和Deferred以后，也许你已经可以非常明确地判断出什么场景该用launch，什么场景该用async了。那么，这是不是就意味着你已经完成了学习的目标呢？</p><p>当然不是！理论学得再多，如果不能结合实际落地场景来分析，那终究都是一场空。接下来，我们来看一个常见的代码模式：</p><pre><code class="language-plain">// 代码段13\n\nfun main() = runBlocking {\n    suspend fun getResult1(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result1"\n    }\n\n    suspend fun getResult2(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result2"\n    }\n\n    suspend fun getResult3(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result3"\n    }\n\n    val results = mutableListOf&lt;String&gt;()\n\n    val time = measureTimeMillis {\n        results.add(getResult1())\n        results.add(getResult2())\n        results.add(getResult3())\n    }\n    println("Time: $time")\n    println(results)\n}\n\n/*\n输出结果：\nTime: 3018\n[Result1, Result2, Result3]\n*/\n</code></pre><p>这段代码里，我们在内部定义了三个挂起函数getResult1()、getResult2()、getResult3()，它们各自都会耗时1000毫秒，而且它们之间的运行结果也互不相干。代码逻辑也很简单，也是我们平时在工作中会经常遇到的业务场景。</p><p>不过请问，你知道该如何优化上面的代码吗？</p><p>我们进一步来分析一下。当我们直接调用这三个挂起函数，并且拿到结果以后，整个过程大约需要消耗3000毫秒，也就是这几个函数耗时的总和。对于这样的情况，我们其实完全可以使用async来优化：</p><pre><code class="language-plain">// 代码段14\n\nfun main() = runBlocking {\n    suspend fun getResult1(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result1"\n    }\n\n    suspend fun getResult2(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result2"\n    }\n\n    suspend fun getResult3(): String {\n        delay(1000L) // 模拟耗时操作\n        return "Result3"\n    }\n\n    val results: List&lt;String&gt;\n\n    val time = measureTimeMillis {\n        val result1 = async { getResult1() }\n        val result2 = async { getResult2() }\n        val result3 = async { getResult3() }\n\n        results = listOf(result1.await(), result2.await(), result3.await())\n    }\n\n    println("Time: $time")\n    println(results)\n}\n\n/*\n输出结果：\nTime: 1032\n[Result1, Result2, Result3]\n*/\n</code></pre><p>所以，当我们总是拿launch和async来做对比的时候，就会不自觉地认为async是用来替代launch的。但实际上，async最常见的使用场景是：<strong>与挂起函数结合，优化并发</strong>。</p><p>请不要小看这个场景，在实际工作中，如果你仔细去分析嵌套的异步代码，你会发现，很多异步任务之间都是没有互相依赖的，这样的代码结合挂起函数后，再通过async并发来执行，是可以大大提升代码运行效率的。</p><p>换句话说，如果我们的任务是IO密集型的，代码运行效率是可以实现成倍提升的。一个简单的改造，能极大地提升运行效率，何乐而不为呢？</p><p>那么，万一我们的任务在某些场景下，并发反而会降低效率呢？这也很简单，我们也完全可以使用CoroutineStart来控制它的启动模式。所以，这种方式的<strong>扩展性和灵活性</strong>都很好。</p><h2>小结</h2><p>这节课，我们主要学习了Job、Deferred，通过对它们两者的学习，我们知道了，<strong>协程是有生命周期的</strong>，同时也发现，<strong>协程其实是结构化的</strong>。</p><p>具体来说，有以下几个要点我们需要好好掌握：</p><ul>\n<li>Job，相当于协程的句柄，Job与协程的关系，有点像“遥控器与空调的关系”。</li>\n<li>Job，在它的内部，维护了一系列的生命周期状态，它也对应着协程的生命周期状态。</li>\n<li>通过Job，我们可以<strong>监测</strong>协程的状态，比如isActive、isCancelled、isCompleted；另外，我们也可以一定程度地<strong>操控</strong>协程的状态，比如start()、cancel()。</li>\n<li>除此之外，我们还可以通过 <code>Job.invokeOnCompletion {}</code> 来监听协程执行完毕的事件；通过Job.join()这个挂起函数，我们可以<strong>挂起</strong>当前协程的执行流程，等到协程执行完毕以后，再<strong>恢复</strong>执行后面的代码。</li>\n<li>而对于Deferred.await()，它的行为模式和Job.join()类似，只是它还会返回协程的执行结果。</li>\n<li>另外，<strong>协程是结构化的并发</strong>，这是它的第二大优势。通过分析Job的源码，我们发现，一个Job可以拥有多个ChildJob；对应的，协程也可拥有多个“子协程”。</li>\n<li>那么结构化并发带来的最大优势就在于，我们可以实现只控制“父协程”，从而达到控制一堆子协程的目的。在前面的例子中，parentJob.join()不仅仅只会等待它自身执行完毕，还会等待它内部的job1、job2、job3执行完毕。parentJob.cancel()同理。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/5b/50/5bb335f24e87237067ed78a67ee2eb50.jpg?wh=2000x1240" alt=""></p><p>最后呢，我也想跟你分享一下我学习协程的一些方法论。</p><p>其实，人学习新知识最快的方式，就是<strong>与旧的知识建立关联</strong>。举个例子，第一门计算机语言往往是最难学的，因为这是一个无中生有的过程；但当你掌握C、C++以后，再去学习Java、Python就会简单很多，因为你可以用脑子里的旧知识与其建立关联。</p><p>所以，虽然我在学习协程的时候也走了很多弯路，但总的来说，我做对了以下几件事，这里我也把经验分享给你。</p><p>第一，<strong>横向对比</strong>。在初次学习Kotlin协程失败以后，我去粗略学习了其他语言的协程，在那个时候，C#之类的协程学习资源更加丰富。通过对比C#、Go等语言的协程后，<strong>我理解了“广义协程”的概念</strong>，并且也知道yield、async、await只是一种广泛存在的协程模式。而当我理解了广义协程这个旧的知识之后，我突然发现Kotlin的协程就不难理解了。</p><p>第二，<strong>建立思维模型</strong>。这是我的一个“习惯”，不管是计算机网络、操作系统、数据结构、设计模式，还是其他领域，比如说高中的电磁学、大学的线性代数，在学习抽象知识的时候，我都喜欢虚构一些思维模型，来模拟它们内部的运行机制。</p><p>协程，就是一门非常抽象的技术，我喜欢用协程API编写一些简单的Demo来分析它们的行为模式，同时为其建立思维模型。这样一来，我脑海里的知识既不容易遗忘，也更成体系。比如，launch就像射箭；async就像钓鱼，这既是思维模型，同时也是在<strong>用旧知识学新知识</strong>。</p><p>第三，<strong>纵向深入</strong>。当我通过建立思维模型，对协程有了全面认识之后，我开始深入研究协程的源码。这时候，我从源码当中找到了更多的细节，来完善、支撑我脑子里的思维模型，从此，它们就不再是我凭空编造出来的东西了，因为证据都在源码里。这是一个<strong>自顶向下、逐渐深入</strong>的过程，反之则行不通。</p><p>所以，现在回过头来看，其实最重要的，还是用旧知识学新知识<strong>。</strong>希望我的方法能对你有所启发。</p><h2>思考题</h2><p>请问下面这段代码的执行结果是什么？你能分析出原因吗？</p><pre><code class="language-plain">// 代码段15\n\nfun main() = runBlocking {\n    val job = launch {\n        logX("First coroutine start!")\n        delay(1000L)\n        logX("First coroutine end!")\n    }\n\n    job.join()      \n    val job2 = launch(job) {\n        logX("Second coroutine start!")\n        delay(1000L)\n        logX("Second coroutine end!")\n    }\n    job2.join()\n    logX("Process end!")\n}\n</code></pre><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "16 | Job：协程也有生命周期吗？",
      },
      {
        title: "17 | Context：万物皆为Context？",
        id: 488571,
        content:
          '<p>你好，我是朱涛。今天我们来学习Kotlin协程的Context。</p><p>协程的Context，在Kotlin当中有一个具体的名字，叫做CoroutineContext。它是我们理解Kotlin协程非常关键的一环。</p><p>从概念上讲，CoroutineContext很容易理解，它只是个<a href="https://zh.wikipedia.org/zh-hans/%E4%B8%8A%E4%B8%8B%E6%96%87_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">上下文</a>而已，实际开发中它最常见的用处就是切换线程池。不过，CoroutineContext背后的代码设计其实比较复杂，如果不能深入理解它的设计思想，那我们在后面阅读协程源码，并进一步建立复杂并发结构的时候，都将会困难重重。</p><p>所以这节课，我将会从应用的角度出发，带你了解CoroutineContext的使用场景，并会对照源码带你理解它的设计思路。另外，知识点之间的串联也是很重要的，所以我还会带你分析它跟我们前面学的Job、Deferred、launch、async有什么联系，让你能真正理解和掌握协程的上下文，并建立一个<strong>基于CoroutineContext的协程知识体系</strong>。</p><h2>Context的应用</h2><p>前面说过，CoroutineContext就是协程的上下文。你在前面的第14~16讲里其实就已经见过它了。在<a href="https://time.geekbang.org/column/article/486305">第14讲</a>我介绍launch源码的时候，CoroutineContext其实就是函数的第一个参数：</p><!-- [[[read_end]]] --><pre><code class="language-plain">// 代码段1\n\npublic fun CoroutineScope.launch(\n//                这里\n//                 ↓\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {}\n</code></pre><p>这里我先说一下，之前我们在调用launch的时候，都没有传context这个参数，因此它会使用默认值EmptyCoroutineContext，顾名思义，这就是一个空的上下文对象。而如果我们想要指定launch工作的线程池的话，就需要自己传context这个参数了。</p><p>另外，在<a href="https://time.geekbang.org/column/article/487085">第15讲</a>里，我们在挂起函数getUserInfo()当中，也用到了withContext()这个函数，当时我们传入的是“Dispatchers.IO”，这就是Kotlin官方提供的一个CoroutineContext对象。让我们来回顾一下：</p><pre><code class="language-plain">// 代码段2\n\nfun main() = runBlocking {\n    val user = getUserInfo()\n    logX(user)\n}\n\nsuspend fun getUserInfo(): String {\n    logX("Before IO Context.")\n    withContext(Dispatchers.IO) {\n        logX("In IO Context.")\n        delay(1000L)\n    }\n    logX("After IO Context.")\n    return "BoyCoder"\n}\n\n/*\n输出结果：\n================================\nBefore IO Context.\nThread:main @coroutine#1\n================================\n================================\nIn IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nAfter IO Context.\nThread:main @coroutine#1\n================================\n================================\nBoyCoder\nThread:main @coroutine#1\n================================\n*/\n</code></pre><p>可以看到，当我们在withContext()这里指定线程池以后，Lambda当中的代码就会被分发到DefaultDispatcher线程池中去执行，而它外部的所有代码仍然还是运行在main之上。</p><p>其实，Kotlin官方还提供了挂起函数版本的main()函数，所以我们的代码也可以改成这样：</p><pre><code class="language-plain">// 代码段3\n\nsuspend fun main() {\n    val user = getUserInfo()\n    logX(user)\n}\n</code></pre><p>不过，你要注意的是：挂起函数版本的main()的底层做了很多封装，虽然它可以帮我们省去写runBlocking的麻烦，但不利于我们学习阶段的探索和研究。因此，后续的Demo我们仍然以runBlocking为主，你只需要知道Kotlin有这么一个东西，等到你深入理解协程以后，就可以直接用“suspend main()”写Demo了。</p><p>我们说回runBlocking这个函数，第14讲里我们介绍过，它的第一个参数也是CoroutineContext，所以，我们也可以传入一个Dispatcher对象作为参数：</p><pre><code class="language-plain">// 代码段4\n\n//                          变化在这里\n//                             ↓\nfun main() = runBlocking(Dispatchers.IO) {\n    val user = getUserInfo()\n    logX(user)\n}\n\n/*\n输出结果：\n================================\nBefore IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nIn IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nAfter IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nBoyCoder\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n*/\n</code></pre><p>这时候，我们会发现，所有的代码都运行在DefaultDispatcher这个线程池当中了。而Kotlin官方除了提供了Dispatchers.IO以外，还提供了Dispatchers.Main、Dispatchers.Unconfined、Dispatchers.Default这几种内置Dispatcher。我来分别给你介绍一下：</p><ul>\n<li><strong>Dispatchers.Main</strong>，它只在UI编程平台才有意义，在Android、Swing之类的平台上，一般只有Main线程才能用于UI绘制。这个Dispatcher在普通的JVM工程当中，是无法直接使用的。</li>\n<li><strong>Dispatchers.Unconfined</strong>，代表无所谓，当前协程可能运行在任意线程之上。</li>\n<li><strong>Dispatchers.Default</strong>，它是用于CPU密集型任务的线程池。一般来说，它内部的线程个数是与机器CPU核心数量保持一致的，不过它有一个最小限制2。</li>\n<li><strong>Dispatchers.IO</strong>，它是用于IO密集型任务的线程池。它内部的线程数量一般会更多一些（比如64个），具体线程的数量我们可以通过参数来配置：kotlinx.coroutines.io.parallelism。</li>\n</ul><p>需要特别注意的是，Dispatchers.IO底层是可能复用Dispatchers.Default当中的线程的。如果你足够细心的话，会发现前面我们用的都是Dispatchers.IO，但实际运行的线程却是DefaultDispatcher这个线程池。</p><p>为了让这个问题更加清晰，我们可以把上面的例子再改一下：</p><pre><code class="language-plain">// 代码段5\n\n//                          变化在这里\n//                             ↓\nfun main() = runBlocking(Dispatchers.Default) {\n    val user = getUserInfo()\n    logX(user)\n}\n\n/*\n输出结果：\n================================\nBefore IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nIn IO Context.\nThread:DefaultDispatcher-worker-2 @coroutine#1\n================================\n================================\nAfter IO Context.\nThread:DefaultDispatcher-worker-2 @coroutine#1\n================================\n================================\nBoyCoder\nThread:DefaultDispatcher-worker-2 @coroutine#1\n================================\n*/\n</code></pre><p>当Dispatchers.Default线程池当中有富余线程的时候，它是可以被IO线程池复用的。可以看到，后面三个结果的输出都是在同一个线程之上的，这就是因为Dispatchers.Default被Dispatchers.IO复用线程导致的。如果我们换成自定义的Dispatcher，结果就会不一样了。</p><pre><code class="language-plain">// 代码段6\n\nval mySingleDispatcher = Executors.newSingleThreadExecutor {\n    Thread(it, "MySingleThread").apply { isDaemon = true }\n}.asCoroutineDispatcher()\n\n//                          变化在这里\n//                             ↓\nfun main() = runBlocking(mySingleDispatcher) {\n    val user = getUserInfo()\n    logX(user)\n}\n\npublic fun ExecutorService.asCoroutineDispatcher(): ExecutorCoroutineDispatcher =\n    ExecutorCoroutineDispatcherImpl(this)\n\n/*\n输出结果：\n================================\nBefore IO Context.\nThread:MySingleThread @coroutine#1\n================================\n================================\nIn IO Context.\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nAfter IO Context.\nThread:MySingleThread @coroutine#1\n================================\n================================\nBoyCoder\nThread:MySingleThread @coroutine#1\n================================\n*/\n</code></pre><p>在上面的代码中，我们是通过asCoroutineDispatcher()这个扩展函数，创建了一个Dispatcher。从这里我们也能看到，Dispatcher的本质仍然还是线程。这也再次验证了我们<a href="https://time.geekbang.org/column/article/485632">之前的说法</a>：<strong>协程运行在线程之上</strong>。</p><p>然后在这里，当我们为runBlocking传入自定义的mySingleDispatcher以后，程序运行的结果就不一样了，由于它底层并没有复用线程，因此只有“In IO Context”是运行在DefaultDispatcher这个线程池的，其他代码都运行在mySingleDispatcher之上。</p><p>另外，前面提到的<strong>Dispatchers.Unconfined</strong>，我们也要额外注意。还记得之前学习launch的时候，我们遇到的例子吗？请问下面4行代码，它们的执行顺序是怎样的？</p><pre><code class="language-plain">// 代码段7\n\nfun main() = runBlocking {\n    logX("Before launch.") // 1\n    launch {\n        logX("In launch.") // 2\n        delay(1000L)\n        logX("End launch.") // 3\n    }\n    logX("After launch")   // 4\n}\n</code></pre><p>如果你理解了第14讲的内容，那你一定能分析出它们的运行顺序应该是：1、4、2、3。</p><p>但你要注意，同样的代码模式在特殊的环境下，结果可能会不一样。比如在Android平台，或者是如果我们指定了Dispatchers.Unconfined这个特殊的Dispatcher，它的这种行为模式也会被打破。比如像这样：</p><pre><code class="language-plain">// 代码段8\n\nfun main() = runBlocking {\n    logX("Before launch.")  // 1\n//               变化在这里\n//                  ↓\n    launch(Dispatchers.Unconfined) {\n        logX("In launch.")  // 2\n        delay(1000L)\n        logX("End launch.") // 3\n    }\n    logX("After launch")    // 4\n}\n\n/*\n输出结果：\n================================\nBefore launch.\nThread:main @coroutine#1\n================================\n================================\nIn launch.\nThread:main @coroutine#2\n================================\n================================\nAfter launch\nThread:main @coroutine#1\n================================\n================================\nEnd launch.\nThread:kotlinx.coroutines.DefaultExecutor @coroutine#2\n================================\n*/\n</code></pre><p>以上代码的运行顺序就变成了：1、2、4、3。这一点，就再一次说明了Kotlin协程的难学。传了一个不同的参数进来，整个代码的执行顺序都变了，这谁不头疼呢？最要命的是，Dispatchers.Unconfined设计的本意，也并不是用来改变代码执行顺序的。</p><p>请你留意“End launch”运行的线程“DefaultExecutor”，是不是觉得很乱？其实Unconfined代表的意思就是，<strong>当前协程可能运行在任何线程之上，不作强制要求</strong>。</p><p>由此可见，Dispatchers.Unconfined其实是很危险的。所以，<strong>我们不应该随意使用Dispatchers.Unconfined</strong>。</p><p>好，现在我们也了解了CoroutineContext的常见应用场景。不过，我们还没解释这节课的标题，什么是“万物皆为Context”？</p><h2>万物皆有Context</h2><p>所谓的“万物皆为Context”，当然是一种夸张的说法，我们换成“万物皆有Context”可能更加准确。</p><p>在Kotlin协程当中，但凡是重要的概念，都或多或少跟CoroutineContext有关系：Job、Dispatcher、CoroutineExceptionHandler、CoroutineScope，甚至挂起函数，它们都跟CoroutineContext有着密切的联系。甚至，它们之中的Job、Dispatcher、CoroutineExceptionHandler本身，就是Context。</p><p>我这么一股脑地告诉你，你肯定觉得晕乎乎，所以下面我们就一个个来看。</p><h3>CoroutineScope</h3><p>在学习launch的时候，我提到过如果要调用launch，就必须先有“协程作用域”，也就是CoroutineScope。</p><pre><code class="language-plain">// 代码段9\n\n//            注意这里\n//               ↓\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {}\n\n// CoroutineScope 源码\npublic interface CoroutineScope {\n    public val coroutineContext: CoroutineContext\n}\n</code></pre><p>如果你去看CoroutineScope的源码，你会发现，它其实就是一个简单的接口，而这个接口只有唯一的成员，就是CoroutineContext。所以，CoroutineScope只是对CoroutineContext做了一层封装而已，它的核心能力其实都来自于CoroutineContext。</p><p>而CoroutineScope最大的作用，就是可以方便我们批量控制协程。</p><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    // 仅用于测试，生成环境不要使用这么简易的CoroutineScope\n    val scope = CoroutineScope(Job())\n\n    scope.launch {\n        logX("First start!")\n        delay(1000L)\n        logX("First end!") // 不会执行\n    }\n\n    scope.launch {\n        logX("Second start!")\n        delay(1000L)\n        logX("Second end!") // 不会执行\n    }\n\n    scope.launch {\n        logX("Third start!")\n        delay(1000L)\n        logX("Third end!") // 不会执行\n    }\n\n    delay(500L)\n\n    scope.cancel()\n\n    delay(1000L)\n}\n\n/*\n输出结果：\n================================\nFirst start!\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nThird start!\nThread:DefaultDispatcher-worker-3 @coroutine#4\n================================\n================================\nSecond start!\nThread:DefaultDispatcher-worker-2 @coroutine#3\n================================\n*/\n</code></pre><p>在上面的代码中，我们自己创建了一个简单的CoroutineScope，接着，我们使用这个scope连续创建了三个协程，在500毫秒以后，我们就调用了scope.cancel()，这样一来，代码中每个协程的“end”日志就不会输出了。</p><p>这同样体现了协程<strong>结构化并发</strong>的理念，相同的功能，我们借助Job也同样可以实现。关于CoroutineScope更多的底层细节，我们会在源码篇的时候深入学习。</p><p>那么接下来，我们就看看Job跟CoroutineContext的关系。</p><h3>Job和Dispatcher</h3><p>如果说CoroutineScope是封装了CoroutineContext，那么Job就是一个真正的CoroutineContext了。</p><pre><code class="language-plain">// 代码段11\n\npublic interface Job : CoroutineContext.Element {}\n\npublic interface CoroutineContext {\n    public interface Element : CoroutineContext {}\n}\n</code></pre><p>上面这段代码很有意思，Job继承自CoroutineContext.Element，而CoroutineContext.Element仍然继承自CoroutineContext，这就意味着Job是间接继承自CoroutineContext的。所以说，Job确实是一个真正的CoroutineContext。</p><p>所以，我们写这样的代码也完全没问题：</p><pre><code class="language-plain">// 代码段12\n\nfun main() = runBlocking {\n    val job: CoroutineContext = Job()\n}\n</code></pre><p>不过，更有趣的是CoroutineContext本身的接口设计。</p><pre><code class="language-plain">// 代码段13\n\npublic interface CoroutineContext {\n\n    public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E?\n\n    public operator fun plus(context: CoroutineContext): CoroutineContext {}\n\n    public fun minusKey(key: Key&lt;*&gt;): CoroutineContext\n\n    public fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R\n\n    public interface Key&lt;E : Element&gt;\n}\n</code></pre><p>从上面代码中的get()、plus()、minusKey()、fold()这几个方法，我们可以看到CoroutineContext的接口设计，就跟集合API一样。准确来说，它的API设计和Map十分类似。</p><p><img src="https://static001.geekbang.org/resource/image/a6/26/a611d29c307f953ebb099554a06a5d26.png?wh=1429x627" alt="图片"></p><p>所以，我们完全可以<strong>把CoroutineContext当作Map来用</strong>。</p><pre><code class="language-plain">// 代码段14\n\n@OptIn(ExperimentalStdlibApi::class)\nfun main() = runBlocking {\n    // 注意这里\n    val scope = CoroutineScope(Job() + mySingleDispatcher)\n\n    scope.launch {\n        // 注意这里\n        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)\n        delay(1000L)\n        logX("First end!")  // 不会执行\n    }\n\n    delay(500L)\n    scope.cancel()\n    delay(1000L)\n}\n/*\n输出结果：\n================================\ntrue\nThread:MySingleThread @coroutine#2\n================================\n*/\n</code></pre><p>在上面的代码中，我们使用了“Job() + mySingleDispatcher”这样的方式创建CoroutineScope，代码之所以这么写，是因为CoroutineContext的plus()进行了<strong>操作符重载</strong>。</p><pre><code class="language-plain">// 代码段15\n\n//     操作符重载\n//        ↓\npublic operator fun &lt;E : Element&gt; plus(key: Key&lt;E&gt;): E?\n</code></pre><p>你注意这里代码中的<strong>operator关键字</strong>，如果少了它，我们就得换一种方式了：mySingleDispatcher.plus(Job())。因为，当我们用operator修饰plus()方法以后，就可以用“+”来重载这个方法，类似的，List和Map都支持这样的写法：list3 = list1+list2、map3 = map1 + map2，这代表集合之间的合并。</p><p>另外，我们还使用了“coroutineContext[CoroutineDispatcher]”这样的方式，访问当前协程所对应的Dispatcher。这也是因为CoroutineContext的get()，支持了<strong>操作符重载</strong>。</p><pre><code class="language-plain">// 代码段16\n\n//     操作符重载\n//        ↓\npublic operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E?\n</code></pre><p>实际上，在Kotlin当中很多集合也是支持get()方法重载的，比如List、Map，我们都可以使用这样的语法：list[0]、map[key]，以数组下标的方式来访问集合元素。</p><p>还记得我们在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>提到的“集合与数组的访问方式一致”这个知识点吗？现在我们知道了，这都要归功于操作符重载。实际上，Kotlin官方的源代码当中大量使用了操作符重载来简化代码逻辑，而CoroutineContext就是一个最典型的例子。</p><p>如果你足够细心的话，这时候你应该也发现了：Dispatcher本身也是CoroutineContext，不然它怎么可以实现“Job() + mySingleDispatcher”这样的写法呢？最重要的是，当我们以这样的方式创建出scope以后，后续创建的协程就全部都运行在mySingleDispatcher这个线程之上了。</p><p>那么，<strong>Dispatcher到底是如何跟CoroutineContext建立关系的呢？</strong>让我们来看看它的源码吧。</p><pre><code class="language-plain">// 代码段17\n\npublic actual object Dispatchers {\n\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n\n    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher\n\n    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined\n\n    public val IO: CoroutineDispatcher = DefaultIoScheduler\n\n    public fun shutdown() {    }\n}\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}\n\npublic interface ContinuationInterceptor : CoroutineContext.Element {}\n</code></pre><p>可以看到，Dispatchers其实是一个object单例，它的内部成员的类型是CoroutineDispatcher，而它又是继承自ContinuationInterceptor，这个类则是实现了CoroutineContext.Element接口。由此可见，Dispatcher确实就是CoroutineContext。</p><h3>其他CoroutineContext</h3><p>除了上面几个重要的CoroutineContext之外，协程其实还有一些上下文是我们还没提到的。比如<strong>CoroutineName</strong>，当我们创建协程的时候，可以传入指定的名称。比如：</p><pre><code class="language-plain">// 代码段18\n\n@OptIn(ExperimentalStdlibApi::class)\nfun main() = runBlocking {\n    val scope = CoroutineScope(Job() + mySingleDispatcher)\n    // 注意这里\n    scope.launch(CoroutineName("MyFirstCoroutine!")) {\n        logX(coroutineContext[CoroutineDispatcher] == mySingleDispatcher)\n        delay(1000L)\n        logX("First end!")\n    }\n\n    delay(500L)\n    scope.cancel()\n    delay(1000L)\n}\n\n/*\n输出结果：\n\n================================\ntrue\nThread:MySingleThread @MyFirstCoroutine!#2  // 注意这里\n================================\n*/\n</code></pre><p>在上面的代码中，我们调用launch的时候，传入了“CoroutineName(“MyFirstCoroutine!”)”作为协程的名字。在后面输出的结果中，我们得到了“@MyFirstCoroutine!#2”这样的输出。由此可见，其中的数字“2”，其实是一个自增的唯一ID。</p><p>CoroutineContext当中，还有一个重要成员是<strong>CoroutineExceptionHandler</strong>，它主要负责处理协程当中的异常。</p><pre><code class="language-plain">// 代码段19\n\npublic interface CoroutineExceptionHandler : CoroutineContext.Element {\n\n    public companion object Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt;\n\n    public fun handleException(context: CoroutineContext, exception: Throwable)\n}\n</code></pre><p>可以看到，CoroutineExceptionHandler的接口定义其实很简单，我们基本上一眼就能看懂。CoroutineExceptionHandler真正重要的，其实只有handleException()这个方法，如果我们要自定义异常处理器，我们就只需要实现该方法即可。</p><pre><code class="language-plain">// 代码段20\n\n//&nbsp; 这里使用了挂起函数版本的main()\nsuspend fun main() {\n&nbsp; &nbsp; val myExceptionHandler = CoroutineExceptionHandler { _, throwable -&gt;\n&nbsp; &nbsp; &nbsp; &nbsp; println("Catch exception:&nbsp;$throwable")\n&nbsp; &nbsp; }\n&nbsp; &nbsp; val scope = CoroutineScope(Job() + mySingleDispatcher)\n\n&nbsp; &nbsp; val job = scope.launch(myExceptionHandler) {\n&nbsp; &nbsp; &nbsp; &nbsp; val s: String? = null\n&nbsp; &nbsp; &nbsp; &nbsp; s!!.length // 空指针异常\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; job.join()\n}\n/*\n输出结果：\nCatch exception: java.lang.NullPointerException\n*/\n</code></pre><p>不过，虽然CoroutineExceptionHandler的用法看起来很简单，但当它跟协程“结构化并发”理念相结合以后，内部的异常处理逻辑是很复杂的。关于协程异常处理的机制，我们会在第23讲详细介绍。</p><h2>小结</h2><p>这节课的内容到这里就结束了，我们来总结一下吧。</p><ul>\n<li>CoroutineContext，是Kotlin协程当中非常关键的一个概念。它本身是一个接口，但它的接口设计与Map的API极为相似，我们在使用的过程中，也可以把它<strong>当作Map来用</strong>。</li>\n<li>协程里很多重要的类，它们本身都是CoroutineContext。比如Job、Deferred、Dispatcher、ContinuationInterceptor、CoroutineName、CoroutineExceptionHandler，它们都继承自CoroutineContext这个接口。也正因为它们都继承了CoroutineContext接口，所以我们可以通过<strong>操作符重载</strong>的方式，写出更加灵活的代码，比如“Job() + mySingleDispatcher+CoroutineName(“MyFirstCoroutine!”)”。</li>\n<li>协程当中的CoroutineScope，本质上也是CoroutineContext的一层<strong>简单封装</strong>。</li>\n<li>另外，协程里极其重要的“挂起函数”，它与CoroutineContext之间也有着非常紧密的联系。</li>\n</ul><p>另外我也画了一张结构图，来描述CoroutineContext元素之间的关系，方便你建立完整的知识体系。</p><p><img src="https://static001.geekbang.org/resource/image/eb/76/eb225787718e0d2cff8a55bcba86yy76.jpg?wh=2000x1125" alt=""></p><p>所以总的来说，我们前面学习的Job、Dispatcher、CoroutineName，它们本质上只是CoroutieContext这个集合当中的一种数据类型，只是恰好Kotlin官方让它们都继承了CoroutineContext这个接口。而CoroutineScope则是对CoroutineContext的进一步封装，它的核心能力，全部都是源自于CoroutineContext。</p><h2>思考题</h2><p>课程里，我提到了“挂起函数”与CoroutineContext也有着紧密的联系，请问，你能找到具体的证据吗？或者，你觉得下面的代码能成功运行吗？为什么？</p><pre><code>// 代码段21\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.coroutineContext\n\n//                        挂起函数能可以访问协程上下文吗？\n//                                 ↓                              \nsuspend fun testContext() = coroutineContext\n\nfun main() = runBlocking {\n    println(testContext())\n}\n</code></pre><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "17 | Context：万物皆为Context？",
      },
      {
        title: "18 | 实战：让KtHttp支持挂起函数",
        id: 488985,
        content:
          '<p>你好，我是朱涛。今天这节实战课，我们接着前面<a href="https://time.geekbang.org/column/article/481787">第12讲</a>里实现的网络请求框架，来进一步完善这个KtHttp，让它支持挂起函数。</p><p>在上一次实战课当中，我们已经开发出了两个版本的KtHttp，1.0版本的是基于命令式风格的，2.0版本的是基于函数式风格的。其中2.0版本的代码风格，跟我们平时工作写的代码风格很不一样，之前我也说了，这主要是因为业界对Kotlin函数式编程接纳度并不高，所以这节课的代码，我们将基于1.0版本的代码继续改造。这样，也能让课程的内容更接地气一些，甚至你都可以借鉴今天写代码的思路，复用到实际的Android或者后端开发中去。</p><p>跟往常一样，这节课的代码还是会分为两个版本：</p><ul>\n<li>3.0 版本，在之前1.0版本的基础上，扩展出<strong>异步请求</strong>的能力。</li>\n<li>4.0 版本，进一步扩展异步请求的能力，让它<strong>支持挂起函数</strong>。</li>\n</ul><p>好，接下来就正式开始吧！</p><h2>3.0 版本：支持异步（Call）</h2><p>有了上一次实战课的基础，这节课就会轻松一些了。关于动态代理、注解、反射之类的知识不会牵涉太多，我们今天主要把精力都集中在协程上来。不过，在正式开始写协程代码之前，我们需要先让KtHttp支持异步请求，也就是Callback请求。</p><p>这是为什么呢？别忘了<a href="https://time.geekbang.org/column/article/487085">第15讲</a>的内容：<strong>挂起函数本质就是Callback！</strong>所以，为了让KtHttp支持挂起函数，我们可以采用迂回的策略，让它先支持Callback。在之前1.0、2.0版本的代码中，KtHttp是只支持同步请求的，你可能对异步同步还有些懵，我带你来看个例子吧。</p><!-- [[[read_end]]] --><p>首先，这个是同步代码：</p><pre><code class="language-plain">fun main() {\n    // 同步代码\n    val api: ApiService = KtHttpV1.create(ApiService::class.java)\n    val data: RepoList = api.repos(lang = "Kotlin", since = "weekly")\n    println(data)\n}\n</code></pre><p>可以看到，在main函数当中，我们调用了KtHttp 1.0的代码，其中3行代码的运行顺序是1、2、3，这就是典型的同步代码。它的另一个特点就是：所有代码都会在一个线程中执行，因此这样的代码如果运行在Android、Swing之类的UI编程平台上，是会导致主线程卡死的。</p><p>那么，异步代码又是长什么样的呢？</p><pre><code class="language-plain">private fun testAsync() {\n    // 异步代码\n    KtHttpV3.create(ApiServiceV3::class.java).repos(\n        lang = "Kotlin",\n        since = "weekly"\n    ).call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>上面的testAsync()方法当中的代码，就是典型的异步代码，它跟同步代码最大的差异就是，有了一个Callback，而且代码不再是按照顺序执行的了。你可以参考下面这个动图：</p><p><img src="https://static001.geekbang.org/resource/image/a8/ff/a8d0c46d74a17d0ddfb683e0ac7468ff.gif?wh=1080x608" alt="图片"></p><p>所以，在3.0版本的开发中，我们就是要实现类似上面testAsync()的请求方式。为此，我们首先需要创建一个<strong>Callback接口</strong>，在这个Callback当中，我们可以拿到API请求的结果。</p><pre><code class="language-plain">interface Callback&lt;T: Any&gt; {\n    fun onSuccess(data: T)\n    fun onFail(throwable: Throwable)\n}\n</code></pre><p>在Callback这个接口里，有一个泛型参数T，还有两个回调，分别是onSuccess代表接口请求成功、onFail代表接口请求失败。需要特别注意的是，这里我们运用了<a href="https://time.geekbang.org/column/article/484921">空安全思维</a>当中的<strong>泛型边界“T: Any”</strong>，这样一来，我们就可以保证T类型一定是非空的。</p><p>除此之外，我们还需要一个<strong>KtCall类</strong>，它的作用是承载Callback，或者说，它是用来调用Callback的。</p><pre><code class="language-plain">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        // TODO\n    }\n}\n</code></pre><p>KtCall这个类仍然使用了泛型边界“T: Any”，另外，它还有几个关键的成员分别是：OkHttp的Call对象、JSON解析的Gson对象，以及反射类型Type。然后还有一个call()方法，它接收的是前面我们定义的Callback对象，返回的是OkHttp的Call对象。所以总的来说，call()方法当中的逻辑会分为三个步骤。</p><pre><code class="language-plain">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        // 步骤1， 使用call请求API\n        // 步骤2， 根据请求结果，调用callback.onSuccess()或者是callback.onFail()\n        // 步骤3， 返回OkHttp的Call对象\n    }\n}\n</code></pre><p>我们一步步来分析这三个步骤：</p><ul>\n<li>步骤1，使用OkHttp的call对象请求API，这里需要注意的是，为了将请求任务派发到异步线程，我们需要使用OkHttp的异步请求方法enqueue()。</li>\n<li>步骤2，根据请求结果，调用callback.onSuccess()或者是callback.onFail()。如果请求成功了，我们在调用onSuccess()之前，还需要用Gson将请求结果进行解析，然后才返回。</li>\n<li>步骤3，返回OkHttp的Call对象。</li>\n</ul><p>接下来，我们看看具体代码是怎么样的：</p><pre><code class="language-plain">class KtCall&lt;T: Any&gt;(\n    private val call: Call,\n    private val gson: Gson,\n    private val type: Type\n) {\n    fun call(callback: Callback&lt;T&gt;): Call {\n        call.enqueue(object : okhttp3.Callback {\n            override fun onFailure(call: Call, e: IOException) {\n                callback.onFail(e)\n            }\n\n            override fun onResponse(call: Call, response: Response) {\n                try { // ①\n                    val t = gson.fromJson&lt;T&gt;(response.body?.string(), type)\n                    callback.onSuccess(t)\n                } catch (e: Exception) {\n                    callback.onFail(e)\n                }\n            }\n        })\n        return call\n    }\n}\n</code></pre><p>经过前面的解释，这段代码就很好理解了，唯一需要注意的是注释①处，由于API返回的结果并不可靠，即使请求成功了，其中的JSON数据也不一定合法，所以这里我们一般还需要进行额外的判断。在实际的商业项目当中，我们可能还需要根据当中的状态码，进行进一步区分和封装，这里为了便于理解，我就简单处理了。</p><p>那么在实现了KtCall以后，我们就只差<strong>ApiService</strong>这个接口了，这里我们定义ApiServiceV3，以作区分。</p><pre><code class="language-plain">interface ApiServiceV3 {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): KtCall&lt;RepoList&gt; // ①\n}\n</code></pre><p>我们需要格外留意以上代码中的注释①，这其实就是<strong>3.0和1.0之间的最大区别</strong>。由于repo()方法的返回值类型是KtCall，为了支持这种写法，我们的invoke方法就需要跟着做一些小的改动：</p><pre><code class="language-plain">// 这里也同样使用了泛型边界\nprivate fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    if (method.parameterAnnotations.size != args.size) return null\n\n    var url = path\n    val parameterAnnotations = method.parameterAnnotations\n    for (i in parameterAnnotations.indices) {\n        for (parameterAnnotation in parameterAnnotations[i]) {\n            if (parameterAnnotation is Field) {\n                val key = parameterAnnotation.value\n                val value = args[i].toString()\n                if (!url.contains("?")) {\n                    url += "?$key=$value"\n                } else {\n                    url += "&amp;$key=$value"\n                }\n\n            }\n        }\n    }\n\n    val request = Request.Builder()\n        .url(url)\n        .build()\n\n    val call = okHttpClient.newCall(request)\n    val genericReturnType = getTypeArgument(method)\n    \n    // 变化在这里\n    return KtCall&lt;T&gt;(call, gson, genericReturnType)\n}\n\n// 拿到 KtCall&lt;RepoList&gt; 当中的 RepoList类型\nprivate fun getTypeArgument(method: Method) =\n    (method.genericReturnType as ParameterizedType).actualTypeArguments[0]\n</code></pre><p>在上面的代码中，大部分代码和1.0版本的一样的，只是在最后封装了一个KtCall对象，直接返回。所以在后续调用它的时候，我们就可以这么写了：ktCall.call()。</p><pre><code class="language-plain">private fun testAsync() {\n    // 创建api对象\n    val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java)\n\n    // 获取ktCall\n    val ktCall: KtCall&lt;RepoList&gt; = api.repos(\n        lang = "Kotlin",\n        since = "weekly"\n    )\n\n    // 发起call异步请求\n    ktCall.call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>以上代码很好理解，我们一步步创建API对象、ktCall对象，最后发起请求。不过，在工作中一般是不会这么写代码的，因为创建太多一次性临时对象了。我们完全可以用<strong>链式调用</strong>的方式来做：</p><pre><code class="language-plain">private fun testAsync() {\n    KtHttpV3.create(ApiServiceV3::class.java)\n    .repos(\n        lang = "Kotlin",\n        since = "weekly"\n    ).call(object : Callback&lt;RepoList&gt; {\n        override fun onSuccess(data: RepoList) {\n            println(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            println(throwable)\n        }\n    })\n}\n</code></pre><p>如果你没有很多编程经验，那你可能会对这种方式不太适应，但在实际写代码的过程中，你会发现这种模式写起来会比上一种舒服很多，因为<strong>你再也不用为临时变量取名字伤脑筋了</strong>。</p><p>总的来说，到这里的话，我们的异步请求接口就已经完成了。而且，由于我们的实际请求已经通过OkHttp派发（enqueue）到统一的线程池当中去了，并不会阻塞主线程，所以这样的代码模式执行在Android、Swing之类的UI编程平台，也不会引起UI界面卡死的问题。</p><p>那么，3.0版本是不是到这里就结束了呢？其实并没有，因为我们还有一种情况没有考虑。我们来看看下面这段代码示例：</p><pre><code class="language-plain">interface ApiServiceV3 {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): KtCall&lt;RepoList&gt;\n\n    @GET("/repo")\n    fun reposSync(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): RepoList // 注意这里\n}\n\nprivate fun testSync() {\n    val api: ApiServiceV3 = KtHttpV3.create(ApiServiceV3::class.java)\n    val data: RepoList = api.reposSync(lang = "Kotlin", since = "weekly")\n    println(data)\n}\n</code></pre><p>请留意注释的地方，repoSync()的返回值类型是RepoList，而不是KtCall类型，这其实是我们1.0版本的写法。看到这，你是不是发现问题了？虽然KtHttp支持了异步请求，但原本的同步请求反而不支持了。</p><p>所以，为了让KtHttp同时支持两种请求方式，我们只需要增加一个 <strong>if判断</strong>即可：</p><pre><code class="language-plain">private fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 省略其他代码\n\n    return if (isKtCallReturn(method)) {\n        val genericReturnType = getTypeArgument(method)\n        KtCall&lt;T&gt;(call, gson, genericReturnType)\n    } else {\n        // 注意这里\n        val response = okHttpClient.newCall(request).execute()\n\n        val genericReturnType = method.genericReturnType\n        val json = response.body?.string()\n        gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n    }\n}\n\n// 判断当前接口的返回值类型是不是KtCall\nprivate fun isKtCallReturn(method: Method) =\n    getRawType(method.genericReturnType) == KtCall::class.java\n</code></pre><p>在上面的代码中，我们定义了一个方法isKtCallReturn()，它的作用是判断当前接口方法的返回值类型是不是KtCall，如果是的话，我们就认为它是一个异步接口，这时候返回KtCall对象；如果不是，我们就认为它是同步接口。这样我们只需要将1.0的逻辑挪到else分支，就可以实现兼容了。</p><p>那么到这里，我们3.0版本的开发就算是完成了。接下来，我们进入4.0版本的开发。</p><h2>4.0 版本：支持挂起函数</h2><p>终于来到协程实战的部分了。在日常的开发工作当中，你也许经常会面临这样的一个问题：虽然很想用Kotlin的协程来简化异步开发，但公司的底层框架全部都是Callback写的，根本不支持挂起函数，我一个上层的业务开发工程师，能有什么办法呢？</p><p>其实，我们当前的KtHttp就面临着类似的问题：3.0版本只支持Callback异步调用，现在我们想要扩展出挂起函数的功能。这其实就是大部分Kotlin开发者会遇到的场景。</p><p>就我这几年架构迁移的实践经验来看，针对这个问题，我们主要有两种解法：</p><ul>\n<li>第一种解法，不改动SDK内部的实现，直接在SDK的基础上扩展出协程的能力。</li>\n<li>第二种解法，改动SDK内部，让SDK直接支持挂起函数。</li>\n</ul><p>下面我们先来看看第一种解法。至于第二种解法，其实还可以细分出好几种思路，由于它涉及到挂起函数更底层的一些知识，具体方案我会在源码篇的第27讲介绍。</p><h3>解法一：扩展KtCall</h3><p>这种方式有一个优势，那就是我们不需要改动3.0版本的任何代码。这种场景在工作中也是十分常见的，比如说，项目中用到的SDK是开源的，或者SDK是公司其他部门开发的，我们无法改动SDK。</p><p>具体的做法，就是为KtCall这个类扩展出一个挂起函数。</p><pre><code class="language-plain">/*\n注意这里                   函数名称\n   ↓                        ↓        */\nsuspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = TODO()\n</code></pre><p>在上面的代码中，我们定义了一个扩展函数await()。首先，它是一个挂起函数，其次，它的扩展接收者类型是KtCall，其中带着一个泛型T，挂起函数的返回值也是泛型T。</p><p>而由于它是一个挂起函数，所以，我们的代码就可以换成这样的方式来写了。</p><pre><code class="language-plain">fun main() = runBlocking {\n    val ktCall = KtHttpV3.create(ApiServiceV3::class.java)\n        .repos(lang = "Kotlin", since = "weekly")\n\n    val result = ktCall.await() // 调用挂起函数\n    println(result)\n}\n</code></pre><p>那么，现在我们就只剩下一个问题了：<strong>await()具体该如何实现？</strong></p><p>在这里，我们需要用到Kotlin官方提供的一个顶层函数：suspendCoroutine{}，它的函数签名是这样的：</p><pre><code class="language-plain">public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T {\n    // 省略细节\n}\n</code></pre><p>从它的函数签名，我们可以发现，它是一个挂起函数，也是一个高阶函数，参数类型是“(Continuation) -&gt; Unit”，如果你还记得第15讲当中的内容，你应该就已经发现了，<strong>它其实就等价于挂起函数类型！</strong></p><p>所以，我们可以使用suspendCoroutine{} 来实现await()方法：</p><pre><code class="language-plain">/*\n注意这里                   \n   ↓                                */\nsuspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T = suspendCoroutine{\n    continuation -&gt;\n    //   ↑\n    // 注意这里 \n}\n</code></pre><p>如果你仔细分析这段代码的话，会发现suspendCoroutine{} 的作用，其实就是<strong>将挂起函数当中的continuation暴露出来</strong>。</p><p>那么，suspendCoroutine{} 当中的代码具体该怎么写呢？答案应该也很明显了，当然是要用这个被暴露出来的continuation来做文章啦！</p><p>这里我们再来回顾一下Continuation这个接口：</p><pre><code class="language-plain">public interface Continuation&lt;in T&gt; {\n    public val context: CoroutineContext\n    // 关键在于这个方法\n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n</code></pre><p>通过定义可以看到，整个Continuation只有一个方法，那就是resumeWith()，根据它的名字我们就可以推测出，它是用于“恢复”的，参数类型是Result<t>。所以很明显，这就是一个带有泛型的“结果”，它的作用就是承载协程执行的结果。</t></p><p>所以，综合来看，我们就可以进一步写出这样的代码了：</p><pre><code class="language-plain">suspend fun &lt;T: Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                continuation.resumeWith(Result.success(data))\n            }\n\n            override fun onFail(throwable: Throwable) {\n                continuation.resumeWith(Result.failure(throwable))\n            }\n        })\n    }\n</code></pre><p>以上代码也很容易理解，当网络请求执行成功以后，我们就调用resumeWith()，同时传入Result.success(data)；如果请求失败，我们就传入Result.failure(throwable)，将对应的异常信息传进去。</p><p>不过，也许你会觉得创建Result的写法太繁琐了，没关系，你可以借助Kotlin官方提供的扩展函数提升代码可读性。</p><pre><code class="language-plain">suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                continuation.resumeWithException(throwable)\n            }\n        })\n    }\n</code></pre><p>到目前为止，await()这个扩展函数其实就已经实现了。这时候，如果我们在协程当中调用await()方法的话，代码是可以正常执行的。不过，这种做法其实还有一点瑕疵，那就是<strong>不支持取消</strong>。</p><p>让我们来写一个简单的例子：</p><pre><code class="language-plain">fun main() = runBlocking {\n    val start = System.currentTimeMillis()\n    val deferred = async {\n        KtHttpV3.create(ApiServiceV3::class.java)\n            .repos(lang = "Kotlin", since = "weekly")\n            .await()\n    }\n\n    deferred.invokeOnCompletion {\n        println("invokeOnCompletion!")\n    }\n    delay(50L)\n\n    deferred.cancel()\n    println("Time cancel: ${System.currentTimeMillis() - start}")\n\n    try {\n        println(deferred.await())\n    } catch (e: Exception) {\n        println("Time exception: ${System.currentTimeMillis() - start}")\n        println("Catch exception:$e")\n    } finally {\n        println("Time total: ${System.currentTimeMillis() - start}")\n    }\n}\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCoroutine { continuation -&gt;\n        call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println("Request success!") // ①\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println("Request fail!：$throwable")\n                continuation.resumeWithException(throwable)\n            }\n        })\n    }\n\n/*\n输出结果：\nTime cancel: 536   // ②\nRequest success!   // ③\ninvokeOnCompletion!\nTime exception: 3612  // ④\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 3612\n*/\n</code></pre><p>在main函数当中，我们在async里调用了挂起函数，接着50ms过去后，我们就去尝试取消协程。这段代码中一共有三处地方需要注意，我们来分析一下：</p><ul>\n<li>结合注释①、③一起分析，我们发现，即使调用了deferred.cancel()，网络请求仍然会继续执行。根据“Catch exception:”输出的异常信息，我们也发现，当deferred被取消以后我们还去调用await()的时候，会抛出异常。</li>\n<li>对比注释②、④，我们还能发现，deferred.await()虽然会抛出异常，但是它却耗时3000ms。虽然deferred被取消了，但是当我们调用await()的时候，它并不会马上就抛出异常，而是会等到内部的网络请求执行结束以后，才抛出异常，在此之前都会被挂起。</li>\n</ul><p>综上所述，当我们使用suspendCoroutine{} 来实现挂起函数的时候，默认情况下是不支持取消的。那么，具体该怎么做呢？其实也很简单，就是使用Kotlin官方提供的另一个API：<strong>suspendCancellableCoroutine{}</strong>。</p><pre><code class="language-plain">suspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n//            变化1\n//              ↓\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println("Request success!")\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println("Request fail!：$throwable")\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n//            变化2\n//              ↓\n        continuation.invokeOnCancellation {\n            println("Call cancelled!")\n            call.cancel()\n        }\n    }\n</code></pre><p>当我们使用suspendCancellableCoroutine{} 的时候，可以往continuation对象上面设置一个监听：invokeOnCancellation{}，它代表当前的协程被取消了，这时候，我们只需要将OkHttp的call取消即可。</p><p>这样一来，main()函数就能保持不变，得到的输出结果却大不相同。</p><pre><code class="language-plain">/*\nsuspendCoroutine结果：\n\nTime cancel: 536   \nRequest success!   \ninvokeOnCompletion!\nTime exception: 3612  // ①\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 3612\n*/\n\n/*\nsuspendCancellableCoroutine结果：\n\nCall cancelled!\nTime cancel: 464\ninvokeOnCompletion!\nTime exception: 466  // ②\nCatch exception:kotlinx.coroutines.JobCancellationException: DeferredCoroutine was cancelled; job=DeferredCoroutine{Cancelled}@6043cd28\nTime total: 466\nRequest fail!：java.io.IOException: Canceled  // ③\n*/\n</code></pre><p>对比注释①、②，可以发现，后者是会立即响应协程取消事件的，所以当代码执行到deferred.await()的时候，会立即抛出异常，而不会挂起很长时间。另外，通过注释③这里的结果，我们也可以发现，OkHttp的网络请求确实被取消了。</p><p>所以，我们可以得出一个结论，使用suspendCancellableCoroutine{}，我们可以避免不必要的挂起，比如例子中的deferred.await()；另外也可以节省计算机资源，因为这样可以避免不必要的协程任务，比如这里被成功取消的网络请求。</p><p>到这里，我们的解法一就已经完成了。这种方式并没有改动KtHttp的源代码，而是以扩展函数来实现的。所以，从严格意义上来讲，KtHttp 4.0版本并没有开发完毕，等到第27讲我们深入理解了挂起函数的底层原理后，我们再来完成解法二的代码。</p><h2>小结</h2><p>这节课，我们在KtHttp 1.0版本的基础上，扩展出了异步请求的功能，完成了3.0版本的开发；接着，我们又在3.0版本的基础上，让KtHttp支持了挂起函数，这里我们是用的外部扩展的思路，并没有碰KtHttp内部的代码。</p><p>这里主要涉及以下几个知识点：</p><ul>\n<li>在3.0版本开发中，我们运用了泛型边界“T: Any”，落实对泛型的非空限制，同时通过封装KtCall，为下一个版本打下了基础。</li>\n<li>接着，在4.0版本中，我们借助扩展函数的特性，为KtCall扩展了await()方法。</li>\n<li>在实现await()的过程中，我们使用了两个协程API，分别是suspendCoroutine{}、suspendCancellableCoroutine{}，在Kotlin协程当中，我们<strong>永远都要优先使用后者</strong>。</li>\n<li>suspendCancellableCoroutine{} 主要有两大优势：第一，它可以避免不必要的挂起，提升运行效率；第二，它可以避免不必要的资源浪费，改善软件的综合指标。</li>\n</ul><h2>思考题</h2><p>你能分析出下面的代码执行结果吗？为什么会是这样的结果？它能给你带来什么启发？欢迎给我留言，也欢迎你把今天的内容分享给更多的朋友。</p><pre><code class="language-plain">fun main() = runBlocking {\n    val start = System.currentTimeMillis()\n    val deferred = async {\n        KtHttpV3.create(ApiServiceV3::class.java)\n            .repos(lang = "Kotlin", since = "weekly")\n            .await()\n    }\n\n    deferred.invokeOnCompletion {\n        println("invokeOnCompletion!")\n    }\n    delay(50L)\n\n    deferred.cancel()\n    println("Time cancel: ${System.currentTimeMillis() - start}")\n\n    try {\n        println(deferred.await())\n    } catch (e: Exception) {\n        println("Time exception: ${System.currentTimeMillis() - start}")\n        println("Catch exception:$e")\n    } finally {\n        println("Time total: ${System.currentTimeMillis() - start}")\n    }\n}\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println("Request success!")\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println("Request fail!：$throwable")\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n// 注意这里\n//        continuation.invokeOnCancellation {\n//            println("Call cancelled!")\n//            call.cancel()\n//        }\n    }\n</code></pre>',
        article_title: "18 | 实战：让KtHttp支持挂起函数",
      },
      {
        title: "期中考试 | 用Kotlin实现图片处理程序",
        id: 489708,
        content:
          '<p>你好，我是朱涛。不知不觉间，咱们的课程就已经进行一半了，我们已经学完很多内容：</p><ul>\n<li>基础篇，我们学完了所有Kotlin基础语法和重要特性。</li>\n<li>加餐篇，我们学习了Kotlin编程的5大编程思维：函数式思维、表达式思维、不变性思维、空安全思维、协程思维。</li>\n<li>协程篇，我们也已经学完了所有基础的协程概念。</li>\n</ul><p>所以现在，是时候来一次阶段性的验收了。这次，我们一起来做一个<strong>图片处理程序</strong>，来考察一下自己对于Kotlin编程知识的理解和应用掌握情况。初始化工程的代码在这里<a href="https://github.com/chaxiu/ImageProcessor.git">GitHub</a>，你可以像往常那样，将其clone下来，然后用IntelliJ打开即可。</p><p>我们仍然会分为两个版本1.0、2.0，不过，这一次要轮到你亲自动手写代码了！</p><h2>1.0版本：处理本地图片</h2><p>当你将初始化工程打开以后，你会发现“src/main/resources/images/”这个目录下有一张图片：android.png，它就是我们要处理的图片对象。</p><p><img src="https://static001.geekbang.org/resource/image/0d/64/0de4da2977353d97631d88531feff464.png?wh=1817x704" alt="图片"></p><p>一般来说，我们想要处理图片，会第一时间想到Photoshop，但其实简单的图片处理任务，我们完全可以通过代码来实现，比如图片横向翻转、图片纵向翻转、图片裁切。</p><p><img src="https://static001.geekbang.org/resource/image/45/c6/456e395f69c12b20e095959046fccac6.png?wh=1128x424" alt="图片"></p><p>关于图片的底层定义，Java SDK已经提供了很好的支持，我们在Kotlin代码当中可以直接使用相关的类。为了防止你对JDK不熟悉，我在初始化工程当中，已经为你做好了前期准备工作：</p><!-- [[[read_end]]] --><pre><code class="language-plain">class Image(private val pixels: Array&lt;Array&lt;Color&gt;&gt;) {\n\n    fun height(): Int {\n        return pixels.size\n    }\n\n    fun width(): Int {\n        return pixels[0].size\n    }\n\n    /**\n     * 底层不处理越界\n     */\n    fun getPixel(y: Int, x: Int): Color {\n        return pixels[y][x]\n    }\n}\n</code></pre><p>这是我定义的一个Image类，它的作用就是封装图片的内存对象。我们都知道，图片的本质是一堆像素点（Pixel），而每个像素点，都可以用RGB来表示，这里我们用Java SDK当中的Color来表示。</p><p>当我们把图片放大到足够倍数的时候，我们就可以看到其中的<strong>正方形像素点</strong>了。</p><p><img src="https://static001.geekbang.org/resource/image/4a/a2/4a833f282d7f56e6c10707f9b36yy4a2.png?wh=1489x862" alt="图片"></p><p>所以，最终我们就可以用“<code>Array&lt;Array&lt;Color&gt;&gt;</code>”这样一个二维数组来表示一张图片。</p><p>另外，从本地加载图片到内存的代码，我也帮你写好了：</p><pre><code class="language-plain">const val BASE_PATH = "./src/main/resources/images/"\n\nfun main() {\n    val image = loadImage(File("${BASE_PATH}android.png"))\n    println("Width = ${image.width()};Height = ${image.height()}")\n}\n\n/**\n * 加载本地图片到内存中\n */\nfun loadImage(imageFile: File) =\n    ImageIO.read(imageFile)\n        .let {\n            Array(it.height) { y -&gt;\n                Array(it.width) { x -&gt;\n                    Color(it.getRGB(x, y))\n                }\n            }\n        }.let {\n            Image(it)\n        }\n</code></pre><p>那么，唯一需要你做的，就是实现这几个函数的功能：<strong>图片横向翻转、图片纵向翻转、图片裁切</strong>。</p><pre><code class="language-plain">/**\n * 横向翻转图片\n * 待实现\n */\nfun Image.flipHorizontal(): Image = TODO()\n\n/**\n * 纵向翻转图片\n * 待实现\n */\nfun Image.flipVertical(): Image = TODO()\n\n/**\n * 图片裁切\n * 待实现\n */\nfun Image.crop(startY: Int, startX: Int, width: Int, height: Int): Image = TODO()\n</code></pre><p>另外，如果你有兴趣的话，还可以去实现对应的单元测试代码：</p><pre><code class="language-plain">class TestImageProcessor {\n\n    /**\n     * 待实现的单元测试\n     */\n    @Test\n    fun testFlipHorizontal() {\n\n    }\n\n    /**\n     * 待实现的单元测试\n     */\n    @Test\n    fun testFlipVertical() {\n\n    }\n\n    /**\n     * 待实现的单元测试\n     */\n    @Test\n    fun testCrop() {\n\n    }\n}\n</code></pre><p>这样一来，我们1.0版本的代码就算完成了。不过，我们还没用上协程的知识啊！</p><p>请看2.0版本。</p><h2>2.0版本：增加图片下载功能</h2><p>在上个版本中，我们的代码仅支持本地图片的处理，但有的时候，我们想要处理网络上的图片该怎么办呢？所以这时候，我们可以增加一个<strong>下载网络图片的功能</strong>。</p><p>这个版本，你只需要实现一个函数：</p><pre><code class="language-plain">/**\n * 挂起函数，以http的方式下载图片，保存到本地\n * 待实现\n */\nsuspend fun downloadImage(url: String, outputFile: File): Boolean = TODO()\n</code></pre><p>需要注意的是，由于下载网络图片比较耗时，我们需要将其定义成一个<strong>挂起函数</strong>，这样一来，我们后续在使用它的时候就可以更得心应手了。</p><pre><code class="language-plain">fun main() = runBlocking {\n    // 不一定非要下载我提供的链接\n    val url = "https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png"\n    val path = "${BASE_PATH}downloaded.png"\n\n    // 调用挂起函数\n    downloadImage(url, File(path))\n\n    val image = loadImage(File(path))\n    println("Width = ${image.width()};Height = ${image.height()}")\n}\n</code></pre><p>在上面的代码中，我是以“<a href="https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png%E2%80%9D">https://raw.githubusercontent.com/chaxiu/ImageProcessor/main/src/main/resources/images/android.png”</a> 这个链接为例，这是一个HTTPS的链接，你在实际开发的时候，也可以随便去找一个普通的HTTP图片链接，这样就不必处理SSL的问题了。</p><p>程序实际运行效果会是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/e7/71/e7b549e6e97cffdd67e8379004773171.gif?wh=1026x764" alt="图片"></p><p>在下节课里，我会给出我的代码参考，不过在看我的代码之前，记得先要自己动手啊。</p><p>其实，以我们这个工程为基础，再加上一些图形学算法，我们完全可以做出Photoshop当中的一些高级功能，比如图片缩放、图片参数调节、图片滤镜、抠像，甚至图片识别，等等。如果你本身就有图形学方面的知识储备，也欢迎你在此基础上实现更复杂的功能！</p><p>好了，我们下节课再见！</p>',
        article_title: "期中考试 | 用Kotlin实现图片处理程序",
      },
      {
        title: "题目解答 | 期中考试版本参考实现",
        id: 490408,
        content:
          '<p>你好，我是朱涛。上节课我给你布置了一份考试题，你完成得怎么样了呢？这节课呢，我会来告诉你我是如何用Kotlin来做这个图片处理程序的，供你参考。</p><p>由于上节课我们已经做好了前期准备，所以这里我们直接写代码就行了。</p><h2>1.0版本</h2><p>对于图片反转和裁切的这个问题，如果一开始你就去想象一个大图片，里面有几万个像素点，那你可能会被吓到。但是，如果你将数据规模缩小，再来分析的话，你会发现这个问题其实很简单。</p><p>这里，我们就以一张4X4像素的照片为例来分析一下。</p><p><img src="https://static001.geekbang.org/resource/image/2f/20/2f31e490e0b973c9511e4aaa921f0520.jpg?wh=1498x646" alt=""></p><p>这其实就相当于一个抽象的模型，如果我们基于这张4X4的照片，继续分析翻转和裁切，就会容易很多。我们可以来画一个简单的图形：</p><p><img src="https://static001.geekbang.org/resource/image/b6/8d/b6a1a1f3b70b9b1a8132c51a92660d8d.jpg?wh=2000x814" alt=""></p><p>上面这张图，从左到右分别是原图、横向翻转、纵向翻转、裁切。其中，翻转看起来是要复杂一些，而裁切是最简单的。</p><p><img src="https://static001.geekbang.org/resource/image/64/c3/64001cb039dbcff66c4e9eec48dcf6c3.jpg?wh=2000x789" alt=""></p><p>我们先来处理裁切。对于裁切，其实只需要将图片当中某个部分的像素拷贝到内存，然后存储成为一张新图片就行了。</p><pre><code class="language-plain">/**\n * 图片裁切\n */\nfun Image.crop(startY: Int, startX: Int, width: Int, height: Int): Image {\n    val pixels = Array(height) { y -&gt;\n        Array(width) { x -&gt;\n            getPixel(startY + y, startX + x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><!-- [[[read_end]]] --><p>以上代码中，我们创建了一个新数组pixels，它的创建方式是通过Lambda来实现的，而Lambda当中最关键的逻辑，就是 <code>getPixel(startY + y, startX + x)</code>，也就是从原图当中取像素点。</p><p>这代码是不是比你想象中简单很多？其实，图片的翻转也是一样的。只要我们能<strong>找出坐标的对应关系</strong>，代码也非常简单。</p><p><img src="https://static001.geekbang.org/resource/image/7a/c8/7aeeb78bb0a4a6f8cb4a3308e2842fc8.jpg?wh=1633x880" alt=""></p><p>可以看到，对于原图的(1, 0)这个像素点来说，它横向翻转以后就变成了(2, 0)。所以，对于(x, y)坐标来说，横向翻转以后，就应该变成(width-1-x, y)。找到这个对应关系以后，我们就直接抄代码了！</p><pre><code class="language-plain">/**\n * 横向翻转图片\n */\nfun Image.flipHorizontal(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(y, width() - 1 - x)\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>可见，以上这段代码几乎跟裁切是一模一样的，只是说，裁切要限制宽高，而翻转则是跟原图保持一致。</p><p>看到这里，相信你也马上就能想明白纵向翻转的代码该如何写了！</p><p><img src="https://static001.geekbang.org/resource/image/2e/1e/2e7ae2ec91856141ff2881ec2cdb441e.jpg?wh=1671x899" alt=""></p><p>我们还是以(1, 0)这个像素点为例，在纵向翻转以后就变成了(1, 3)，它们的转换规则是(x, height-1-y)。</p><pre><code class="language-plain">/**\n * 纵向翻转图片\n */\nfun Image.flipVertical(): Image {\n    val pixels = Array(height()) { y -&gt;\n        Array(width()) { x -&gt;\n            getPixel(height() - 1 - y, x) // 改动这里\n        }\n    }\n    return Image(pixels)\n}\n</code></pre><p>所以说，只要我们能找到中间的转换关系，纵向翻转的代码，只需要在横向翻转的基础上，改动一行即可。</p><h3>单元测试</h3><p>其实针对图像算法的单元测试，我们最好的方式，就是准备一些现有的图片案例。比如说，我们随便找一张图，用其他的软件工具，对它进行翻转、裁切，然后存储起来。比如还是这四张图：</p><p><img src="https://static001.geekbang.org/resource/image/85/d8/85f71d3914e23b7ed8664ae57f0e9fd8.png?wh=1128x424" alt="图片"></p><p>我们可以把处理后的图片保存在单元测试的文件夹下，方便我们写对应的测试用例。</p><p><img src="https://static001.geekbang.org/resource/image/47/d2/47ff01b7fd65dcf6e99e298be6e104d2.png?wh=478x327" alt="图片"></p><p>那么，有了这些图片之后，我想你应该就能想到要怎么办了。这时候，你只需要写一个图片像素对比的方法checkImageSame()就好办了。</p><pre><code class="language-plain">private fun checkImageSame(picture: Image, expected: Image) {\n    assertEquals(picture.height(), expected.height())\n    assertEquals(picture.width(), expected.width())\n    for (row in 0 until picture.height()) {\n        for (column in 0 until picture.width()) {\n            val actualPixel = picture.getPixel(row, column)\n            val expectedPixel = expected.getPixel(row, column)\n            assertEquals(actualPixel, expectedPixel)\n        }\n    }\n}\n</code></pre><p>其实，这个函数的思路也很简单，就是逐个对比两张图片之间的像素，看看它们是不是一样的，如果两张图所有的像素都一样，那肯定就是一样的。</p><p>有了这个方法以后，我们就可以快速实现单元测试代码了。整体流程大致如下：</p><p><img src="https://static001.geekbang.org/resource/image/d3/a6/d37e162b313258fa01ed4f1a99d7d0a6.png?wh=1114x394" alt="图片"></p><pre><code class="language-plain">@Test\nfun testCrop() {\n    val image = loadImage(File("${TEST_BASE_PATH}android.png"))\n    val height = image.height() / 2\n    val width = image.width() / 2\n    val target = loadImage(File("${TEST_BASE_PATH}android_half_crop.png"))\n\n    val crop = image.crop(0, 0, width, height)\n    checkImageSame(crop, target)\n}\n\n@Test\nfun testFlipVertical() {\n    val origin = loadImage(File("${TEST_BASE_PATH}android.png"))\n    val target = loadImage(File("${TEST_BASE_PATH}android_up_side_down.png"))\n    val flipped = origin.flipVertical()\n    checkImageSame(flipped, target)\n}\n\n@Test\nfun testFlipHorizontal() {\n    val origin = loadImage(File("${TEST_BASE_PATH}android.png"))\n    val target = loadImage(File("${TEST_BASE_PATH}android_flipped.png"))\n    val flipped = origin.flipHorizontal()\n    checkImageSame(flipped, target)\n}\n</code></pre><p>有了单元测试，我们就再也不用担心以后改代码的时候，不小心改出问题了。</p><p>好，那么到这里，1.0版本就算是完成了。我们接着来看看2.0版本。</p><h2>2.0版本</h2><p>2.0版本的任务，我们需要支持下载网络上面的图片，并且还要能够存起来。由于这是一个比较耗时的操作，我们希望它是一个挂起函数。</p><p>关于下载HTTP的图片，其实，我们借助OkHttp就可以简单实现。下面我们来看看代码。</p><blockquote>\n<p>补充：为了不偏离主题，我们不考虑HTTPS的问题。</p>\n</blockquote><pre><code class="language-plain">fun downloadSync() {\n    logX("Download start!")\n    val okHttpClient = OkHttpClient().newBuilder()\n        .connectTimeout(10L, TimeUnit.SECONDS)\n        .readTimeout(10L, TimeUnit.SECONDS)\n        .build()\n\n    val request = Request.Builder().url(url).build()\n    val response = okHttpClient.newCall(request).execute()\n\n    val body = response.body\n    val responseCode = response.code\n\n    if (responseCode &gt;= HttpURLConnection.HTTP_OK &amp;&amp;\n        responseCode &lt; HttpURLConnection.HTTP_MULT_CHOICE &amp;&amp;\n        body != null\n    ) {\n        // 1， 注意这里\n        body.byteStream().apply {\n            outputFile.outputStream().use { fileOut -&gt;\n                copyTo(fileOut)\n            }\n        }\n    }\n    logX("Download finish!")\n}\n</code></pre><p>以上代码中，有一个地方是需要注意的，我用注释标记了。也就是当我们想要把网络流中的数据存起来的时候，我们可以借助Kotlin提供的 <strong>IO扩展函数</strong>快速实现，这样不仅方便，而且还不用担心FileOutputStream调用close()的问题。这个部分的代码，在Java当中，是要写一堆模板代码的。</p><p>下载本身的功能实现以后，挂起函数的封装也就容易了。</p><pre><code class="language-plain">suspend fun downloadImage(url: String, outputFile: File): Boolean {\n    return withContext(Dispatchers.IO) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            // return@withContext  不可省略\n            return@withContext false\n        }\n        // return@withContext 可省略\n        return@withContext true\n    }\n}\n</code></pre><p>这里，我们可以直接用 <strong>withContext</strong>，让下载的任务直接分发到IO线程。</p><p>代码写到这里，2.0版本要求的功能基本上就算是完成了。这样一来，我们就可以在main函数当中去调用它了。</p><pre><code class="language-plain">fun main() = runBlocking {\n    val url = "http://xxxx.jpg"\n    val path = "${BASE_PATH}downloaded.png"\n\n    downloadImage(url, File(path))\n\n    loadImage(File(path))\n        .flipVertical()\n        .writeToFile(File("${BASE_PATH}download_flip_vertical.png"))\n\n    logX("Done")\n}\n\n// 将内存图片保存到硬盘\nfun Image.writeToFile(outputFile: File): Boolean {\n    return try {\n        val width = width()\n        val height = height()\n        val image = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)\n        for (x in 0 until width) {\n            for (y in 0 until height) {\n                val awtColor = getPixel(y, x)\n                image.setRGB(x, y, awtColor.rgb)\n            }\n        }\n        ImageIO.write(image, "png", outputFile)\n        true\n    } catch (e: Exception) {\n        println(e)\n        false\n    }\n}\n\n/*\n输出结果：\n================================\nDownload start!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDownload finish!\nThread:DefaultDispatcher-worker-1\n================================\n================================\nDone\nThread:main\n================================\n*/\n</code></pre><p>通过运行结果，我们会发现图片下载的任务，已经被分发到IO线程池了，而其他的代码仍然在主线程之上。</p><h2>小结</h2><p>其实，课程进行到这里，你就会发现，Kotlin和Java、C之类的语言的编程方式是完全不一样的。Kotlin提供了丰富的扩展函数，在很多业务场景下，Kotlin是可以大大减少代码量的。</p><p>另外，你也会发现，当你熟悉Kotlin协程以后，它的使用一点都不难。对于上面的代码，我们通过withContext(Dispatchers.IO)就能切换线程，之后，我们就可以在协程作用域当中随意调用了！</p><h2>思考题</h2><p>你觉得，我们在downloadImage()这个挂起函数内部，直接写死Dispatchers.IO的方式好吗？如果换成下面这种写法，会不会更好？为什么？</p><pre><code class="language-plain">suspend fun downloadImage(\n    coroutineContext: CoroutineContext = Dispatchers.IO,\n    url: String,\n    outputFile: File\n): Boolean {\n\n    return withContext(coroutineContext) {\n        try {\n            downloadSync()\n        } catch (e: Exception) {\n            println(e)\n            return@withContext false\n        }\n        return@withContext true\n    }\n}\n</code></pre>',
        article_title: "题目解答 | 期中考试版本参考实现",
      },
      {
        title: "19 | Channel：为什么说Channel是“热”的？",
        id: 491021,
        content:
          '<p>你好，我是朱涛。</p><p>前面我们学习的挂起函数、async，它们一次都只能返回一个结果。但在某些业务场景下，我们往往需要协程返回多个结果，比如微信等软件的IM通道接收的消息，或者是手机GPS定位返回的经纬度坐标需要实时更新。那么，在这些场景下，我们之前学习的协程知识就无法直接解决了。</p><p>而今天我要讲解的Kotlin协程中的Channel，就是专门用来做这种事情的。类似的需求，如果我们不使用Channel而是用其他的并发手段配合集合来做的话，其实也能实现，但复杂度会大大增加。那么接下来，我们就一起来学习下Channel。</p><h2>Channel就是管道</h2><p>顾名思义，Channel就是一个管道。我们可以用这个概念，先来建立一个思维模型：</p><p><img src="https://static001.geekbang.org/resource/image/6e/e7/6e3884f46932e80f080191d20cc26be7.gif?wh=1080x270" alt=""></p><p>Channel这个管道的其中一端，是发送方；管道的另一端是接收方。而管道本身，则可以用来传输数据。</p><p>所以，我们根据上面的思维模型，很容易就能写出下面的代码。</p><pre><code class="language-plain">// 代码段1\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel = Channel&lt;Int&gt;()\n\n    launch {\n        // 2，在一个单独的协程当中发送管道消息\n        (1..3).forEach {\n            channel.send(it) // 挂起函数\n            logX("Send: $it")\n        }\n    }\n\n    launch {\n        // 3，在一个单独的协程当中接收管道消息\n        for (i in channel) {  // 挂起函数\n            logX("Receive: $i")\n        }\n    }\n\n    logX("end")\n}\n\n/*\n================================\nend\nThread:main @coroutine#1\n================================\n================================\nReceive: 1\nThread:main @coroutine#3\n================================\n================================\nSend: 1\nThread:main @coroutine#2\n================================\n================================\nSend: 2\nThread:main @coroutine#2\n================================\n================================\nReceive: 2\nThread:main @coroutine#3\n================================\n================================\nReceive: 3\nThread:main @coroutine#3\n================================\n================================\nSend: 3\nThread:main @coroutine#2\n================================\n// 4，程序不会退出\n*/\n</code></pre><!-- [[[read_end]]] --><p>通过运行的结果，我们首先可以看到的就是：coroutine#2、coroutine#3，这两个协程是交替执行的。这段代码，其实和我们<a href="https://time.geekbang.org/column/article/485632">第13讲</a>当中提到的“互相协作”的模式是类似的，两个协程会轮流执行。</p><p>我们还可以看出来，Channel可以跨越不同的协程进行通信。我们是在“coroutine#1”当中创建的Channel，然后分别在coroutine#2、coroutine#3当中使用Channel来传递数据。</p><p>另外在代码中，还有四个注释，我们一个个来看：</p><ul>\n<li>注释1，我们通过“Channel()”这样的方式，就可以创建一个管道。其中传入的泛型Int，就代表了这个管道里面传递的数据类型。也就是说这里创建的Channel，就是用于传递Int数据的。</li>\n<li>注释2，我们创建了一个新的协程，然后在协程当中调用了send()方法，发送数据到管道里。其中的send()方法是一个挂起函数。</li>\n<li>注释3，在另一个协程当中，我们通过遍历channel，将管道当中的数据都取了出来。这里，我们使用的是for循环。</li>\n<li>注释4，通过运行结果，我们还可以发现一个细节，那就是程序在输出完所有的结果以后，并不会退出。主线程不会结束，整个程序还会处于运行状态。</li>\n</ul><p>而如果要解决上面的问题，其实也不难，只需要加上一行代码即可：</p><pre><code class="language-plain">// 代码段2\n\nfun main() = runBlocking {\n    val channel = Channel&lt;Int&gt;()\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            logX("Send: $it")\n        }\n\n        channel.close() // 变化在这里\n    }\n\n    launch {\n        for (i in channel) {\n            logX("Receive: $i")\n        }\n    }\n\n    logX("end")\n}\n</code></pre><p>所以，channel其实也是一种<strong>协程资源</strong>，在用完channel以后，如果我们不去主动关闭它的话，是会造成不必要的资源浪费的。在上面的案例中，如果我们忘记调用“channel.close()”，程序将永远不会停下来。</p><p>现在，我们来看看创建Channel的源代码。</p><pre><code class="language-plain">// 代码段3\n\npublic fun &lt;E&gt; Channel(\n    capacity: Int = RENDEZVOUS,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    onUndeliveredElement: ((E) -&gt; Unit)? = null\n): Channel&lt;E&gt; {}\n</code></pre><p>可以看到，当我们调用“Channel()”的时候，感觉像是在调用一个构造函数，但实际上它却只是一个普通的顶层函数。这个函数带有一个泛型参数E，另外还有三个参数。</p><p>第一个参数，<strong>capacity</strong>，代表了管道的容量。这个也很好理解，我们日常生活中的管道，自身也是有容量的，即使接收方不将数据取走，管道本身也可以存储一些数据。而Kotlin的Channel，在默认情况下是“RENDEZVOUS”，也就代表了Channel的容量为0。</p><blockquote>\n<p>题外话：RENDEZVOUS这个单词源自法语。它有约会、碰面的意思，我们可以理解为“发送方、接收方，不见不散”。</p>\n</blockquote><p>除此之外，capacity还有其他几种情况，比如说：</p><ul>\n<li>UNLIMITED，代表了无限容量；</li>\n<li>CONFLATED，代表了容量为1，新的数据会替代旧的数据；</li>\n<li>BUFFERED，代表了具备一定的缓存容量，默认情况下是64，具体容量由这个VM参数决定 <code>"kotlinx.coroutines.channels.defaultBuffer"</code>。</li>\n</ul><p>第二个参数，<strong>onBufferOverflow</strong>，也就是指当我们指定了capacity的容量，等管道的容量满了时，Channel的应对策略是怎么样的。这里，它主要有三种做法：</p><ul>\n<li>SUSPEND，当管道的容量满了以后，如果发送方还要继续发送，我们就会挂起当前的send()方法。由于它是一个挂起函数，所以我们可以以非阻塞的方式，将发送方的执行流程<strong>挂起</strong>，等管道中有了空闲位置以后再<strong>恢复</strong>。</li>\n<li>DROP_OLDEST，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据；</li>\n<li>DROP_LATEST，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。</li>\n</ul><p>由于这部分有点抽象，我画了一张图，来描述上面的几种模式，你可以看看。</p><p><img src="https://static001.geekbang.org/resource/image/7f/9a/7f3e49c72caf6e12cafb79fb6affc69a.jpg?wh=2000x1125" alt=""></p><p>在创建Channel的方法中，还有第三个参数，<strong>onUndeliveredElement</strong>，它其实相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。</p><p>这里，为了让你对这三个参数有个更具体的认识，我们来看几个代码的案例。</p><p>案例1：capacity = UNLIMITED</p><pre><code class="language-plain">// 代码段4\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.UNLIMITED)\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println("Send: $it")\n        }\n        channel.close() // 变化在这里\n    }\n    launch {\n        for (i in channel) {\n            println("Receive: $i")\n        }\n    }\n    println("end")\n}}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>以上代码对比代码段1，其实只改动了一点点。我们在创建Channel的时候，设置了 <code>capacity = Channel.Factory.UNLIMITED</code>。不过，通过分析运行的结果，可以发现代码的运行顺序就跟之前完全不一样了。</p><p>对于发送方来说，由于Channel的容量是无限大的，所以发送方可以一直往管道当中塞入数据，等数据都塞完以后，接收方才开始接收。这跟之前的交替执行是不一样的。</p><p>好，接下来我们看看capacity = CONFLATED的情况。</p><pre><code class="language-plain">// 代码段5\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.CONFLATED)\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println("Send: $it")\n        }\n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println("Receive: $i")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 3\n*/\n</code></pre><p>可以看到，当设置capacity = CONFLATED的时候，发送方也会一直发送数据，而且，对于接收方来说，它永远只能接收到最后一条数据。</p><p>我们再来看看onBufferOverflow的用法。其实，我们可以运用onBufferOverflow与capacity，来实现CONFLATED的效果。</p><pre><code class="language-plain">// 代码段6\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(\n        capacity = 1,\n        onBufferOverflow = BufferOverflow.DROP_OLDEST\n    )\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println("Send: $it")\n        }\n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println("Receive: $i")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 3\n*/\n</code></pre><p>从这个运行结果里，我们就可以看出来，其实 <code>capacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST</code>，就代表了capacity = CONFLATED。</p><p>对应的，我们再来看看 <code>onBufferOverflow = BufferOverflow.DROP_LATEST</code> 的情况。</p><pre><code class="language-plain">// 代码段7\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(\n        capacity = 3,\n        onBufferOverflow = BufferOverflow.DROP_LATEST\n    )\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println("Send: $it")\n        }\n\n        channel.send(4) // 被丢弃\n        println("Send: 4")\n        channel.send(5) // 被丢弃\n        println("Send: 5") \n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println("Receive: $i")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nSend: 4\nSend: 5\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>由此可见，<code>onBufferOverflow = BufferOverflow.DROP_LATEST</code> 就意味着，当Channel容量满了以后，之后再继续发送的内容，就会直接被丢弃。</p><p>最后，我们来看看onUndeliveredElement这个参数的作用。</p><pre><code class="language-plain">// 代码段8\n\nfun main() = runBlocking {\n    // 无限容量的管道\n    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED) {\n        println("onUndeliveredElement = $it")\n    }\n\n    // 等价这种写法\n//    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = { println("onUndeliveredElement = $it") })\n\n    // 放入三个数据\n    (1..3).forEach {\n        channel.send(it)\n    }\n\n    // 取出一个，剩下两个\n    channel.receive()\n\n    // 取消当前channel\n    channel.cancel()\n}\n\n/*\n输出结果：\nonUndeliveredElement = 2\nonUndeliveredElement = 3\n*/\n</code></pre><p>可以看到，onUndeliveredElement的作用，就是一个回调，当我们发送出去的Channel数据无法被接收方处理的时候，就可以通过onUndeliveredElement这个回调，来进行监听。</p><p>它的使用场景一般都是用于“接收方对数据是否被消费特别关心的场景”。比如说，我发送出去的消息，接收方是不是真的收到了？对于接收方没收到的信息，发送方就可以灵活处理了，比如针对这些没收到的消息，发送方可以先记录下来，等下次重新发送。</p><h2>Channel关闭引发的问题</h2><p>在前面提到的代码段1里，由于我们忘记调用了close()，所以会导致程序一直运行无法终止。这个问题其实是很严重的。我们有没有办法避免这个问题呢？</p><p>当然是有的。Kotlin官方其实还为我们提供了另一种创建Channel的方式，也就是 <strong>produce{} 高阶函数</strong>。</p><pre><code class="language-plain">// 代码段9\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        (1..3).forEach {\n            send(it)\n            logX("Send: $it")\n        }\n    }\n\n    launch {\n        // 3，接收数据\n        for (i in channel) {\n            logX("Receive: $i")\n        }\n    }\n\n    logX("end")\n}\n</code></pre><p>以上代码中，我们使用produce{} 以后，就不用再去调用close()方法了，因为produce{} 会自动帮我们去调用close()方法。具体的源码，我们会在源码篇的时候再去深入分析。不过，现在我们也可以通过代码来验证这一点。</p><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        // 发送3条数据\n        (1..3).forEach {\n            send(it)\n        }\n    }\n\n    // 调用4次receive()\n    channel.receive() // 1\n    channel.receive() // 2\n    channel.receive() // 3\n    channel.receive() // 异常\n\n    logX("end")\n}\n\n/*\n输出结果：\nClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>在前面所有的代码当中，我们都是以for循环来迭代channel当中的元素的，但实际上，channel还有一个 <strong>receive()方法</strong>，它是与send(it)对应的。在上面代码中，我们只调用了3次send()，却调用4次receive()。</p><p>当我们第4次调用receive()的时候，代码会抛出异常“ClosedReceiveChannelException”，这其实也代表：我们的Channel已经被关闭了。所以这也就说明了，produce {}确实会帮我们调用close()方法。不然的话，第4次receive()会被挂起，而不是抛出异常。</p><p>我们可以再写一段代码来验证下：</p><pre><code class="language-plain">// 代码段11\n\nfun main() = runBlocking {\n    val channel: Channel&lt;Int&gt; = Channel()\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n        }\n    }\n\n    // 调用4次receive()\n    channel.receive()       // 1\n    println("Receive: 1")\n    channel.receive()       // 2\n    println("Receive: 2")\n    channel.receive()       // 3\n    println("Receive: 3")\n    channel.receive()       // 永远挂起\n\n    logX("end")\n}\n\n/*\n输出结果\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>可见，第4次调用receive()，就会导致程序被永久挂起，后面的 <code>logX("end")</code> 是没有机会继续执行的。也就是说，我们<strong>直接使用receive()是很容易出问题的</strong>。这也是我在前面的代码中一直使用for循环，而没有用receive()的原因。</p><p>那么，有没有办法解决这个问题呢？如果你足够细心的话，你会发现Channel其实还有两个属性：isClosedForReceive、isClosedForSend。</p><p>这两个属性，就可以用来判断当前的Channel是否已经被关闭。由于Channel分为发送方和接收方，所以这两个参数也是针对这两者的。也就是说，对于发送方，我们可以使用“isClosedForSend”来判断当前的Channel是否关闭；对于接收方来说，我们可以用“isClosedForReceive”来判断当前的Channel是否关闭。</p><p>这时候，你也许就会想到用它们来改造前面的代码段10。</p><pre><code class="language-plain">// 代码段12\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        // 发送3条数据\n        (1..3).forEach {\n            send(it)\n            println("Send $it")\n        }\n    }\n\n    // 使用while循环判断isClosedForReceive\n    while (!channel.isClosedForReceive) {\n        val i = channel.receive()\n        println("Receive $i")\n    }\n\n    println("end")\n}\n\n/*\n输出结果\nSend 1\nReceive 1\nReceive 2\nSend 2\nSend 3\nReceive 3\nend\n*/\n</code></pre><p>以上代码看起来是可以正常工作了。但是，我仍然不建议你用这种方式。<strong>因为，当你为管道指定了capacity以后，以上的判断方式将会变得不可靠</strong>！原因是目前的1.6.0版本的协程库，运行这样的代码会崩溃，如下所示：</p><pre><code class="language-plain">// 代码段13\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) {\n        // 变化在这里\n        (1..300).forEach {\n            send(it)\n            println("Send $it")\n        }\n    }\n\n\n\n    while (!channel.isClosedForReceive) {\n        val i = channel.receive()\n        println("Receive $i")\n    }\n\n    logX("end")\n}\n\n/*\n输出结果\n// 省略部分\nReceive 300\nSend 300\nClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>所以，<strong>最好不要用channel.receive()</strong>。即使配合isClosedForReceive这个判断条件，我们直接调用channel.receive()仍然是一件非常危险的事情！</p><p>实际上，以上代码除了可以使用for循环以外，还可以使用Kotlin为我们提供的另一个高阶函数：<strong>channel.consumeEach {}</strong>。我们再来看一个例子：</p><pre><code class="language-plain">// 代码段14\n\nfun main() = runBlocking {\n    val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) {\n        (1..300).forEach {\n            send(it)\n            println("Send $it")\n        }\n    }\n\n    // 变化在这里\n    channel.consumeEach {\n        println("Receive $it")\n    }\n\n    logX("end")\n}\n\n/*\n输出结果：\n\n正常\n*/\n</code></pre><p>所以，当我们想要读取Channel当中的数据时，我们一定要使用for循环，或者是channel.consumeEach {}，千万不要直接调用channel.receive()。</p><blockquote>\n<p>补充：在某些特殊场景下，如果我们必须要自己来调用channel.receive()，那么可以考虑使用receiveCatching()，它可以防止异常发生。</p>\n</blockquote><h2>为什么说Channel是“热”的？</h2><p>我们现在已经知道了，Channel其实就是用来传递“数据流”的。注意，这里的数据流，指的是<strong>多个数据组合形成的流</strong>。前面挂起函数、async返回的数据，就像是水滴一样，而Channel则像是自来水管当中的水流一样。</p><p>在业界一直有一种说法：Channel是“热”的。也是因为这句话，在Kotlin当中，我们也经常把Channel称为“热数据流”。</p><p>这话我们乍一听，可能会有点懵。我们能直接把Channel想象成“热的自来水”吗？当然不能了。所以，为了对Channel的“热”有一个更具体的概念，我们可以来看一段代码：</p><pre><code class="language-plain">// 代码段15\n\nfun main() = runBlocking {\n    // 只发送不接受\n    val channel = produce&lt;Int&gt;(capacity = 10) {\n        (1..3).forEach {\n            send(it)\n            println("Send $it")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nSend 1\nSend 2\nSend 3\n程序结束\n*/\n</code></pre><p>在上面的代码中，我们定义了一个Channel，管道的容量是10，然后我们发送了3个数据。但你是否注意到了，在代码中并没有消费Channel当中的数据。所以，这种“<strong>不管有没有接收方，发送方都会工作</strong>”的模式，就是我们将其认定为“热”的原因。</p><p>这就有点像是一个热心的饭店服务员，不管你有没有提要求，服务员都会给你端茶送水，把茶水摆在你的饭桌上。当你想要喝水的时候，就可以直接从饭桌上拿了（当你想要数据的时候，就可以直接从管道里取出来了）。</p><p>又或者，你可以接着前面的水龙头的思维模型去思考，Channel的发送方，其实就像是“自来水厂”，不管你是不是要用水，自来水厂都会把水送到你家门口的管道当中来。这样当你想要用水的时候，打开水龙头就会马上有水了。</p><p><img src="https://static001.geekbang.org/resource/image/df/bf/dfe483ec08baa56c7f5cf937fb93b7bf.jpg?wh=2000x646" alt=""></p><p>不过，也许你会想，是不是因为前面的代码中，设置了“capacity = 10”的原因？如果设置成“capacity = 0”，那Channel的发送方是不是就不会主动工作了？让我们来试试。</p><pre><code class="language-plain">// 代码段16\n\nfun main() = runBlocking {\n    val channel = produce&lt;Int&gt;(capacity = 0) {\n        (1..3).forEach {\n            println("Before send $it")\n            send(it)\n            println("Send $it")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nBefour send 1\n程序将无法退出\n*/\n</code></pre><p>当我们把capacity改成0以后，可以看到Channel的发送方仍然是会工作的，只是说，在它调用send()方法的时候，由于接收方还未就绪，且管道容量为0，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：<strong>这个程序将无法退出，一直运行下去</strong>。这个后果是不是更加严重？</p><p>但是，总的来说，不管接收方是否存在，Channel的发送方一定会工作。对应的，你可以想象成：虽然你的饭桌已经没有空间了，但服务员还是端来了茶水站在了你旁边，只是没有把茶水放在你桌上，等饭桌有了空间，或者你想喝水了，你就能马上喝到。</p><p>至于自来水的那个场景，你可以想象成，你家就在自来水厂的门口，你们之间的管道容量为0，但这并不意味着自来水厂没有工作。</p><h2>思考与实战</h2><p>其实，如果你去看Channel的源代码定义，你会发现，Channel本身只是一个接口。</p><pre><code class="language-plain">// 代码段17\n\npublic interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {}\n</code></pre><p>而且，Channel本身并没有什么方法和属性，它其实只是SendChannel、ReceiveChannel这两个接口的组合。也就是说，Channel的所有能力，都是来自于SendChannel、ReceiveChannel这两个接口。</p><pre><code class="language-plain">// 代码段18\n\npublic interface SendChannel&lt;in E&gt; \n    public val isClosedForSend: Boolean\n\n    public suspend fun send(element: E)\n\n    // 1，select相关\n    public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;\n\n    // 2，非挂起函数的接收\n    public fun trySend(element: E): ChannelResult&lt;Unit&gt;\n\n    public fun close(cause: Throwable? = null): Boolean\n\n    public fun invokeOnClose(handler: (cause: Throwable?) -&gt; Unit)\n\n}\n\npublic interface ReceiveChannel&lt;out E&gt; {\n\n    public val isClosedForReceive: Boolean\n\n    public val isEmpty: Boolean\n\n    public suspend fun receive(): E\n\n    public suspend fun receiveCatching(): ChannelResult&lt;E&gt;\n    // 3，select相关\n    public val onReceive: SelectClause1&lt;E&gt;\n    // 4，select相关\n    public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;\n\n    // 5，非挂起函数的接收\n    public fun tryReceive(): ChannelResult&lt;E&gt;\n\n    public operator fun iterator(): ChannelIterator&lt;E&gt;\n\n    public fun cancel(cause: CancellationException? = null)\n}\n</code></pre><p>在上面的源码中，大部分的接口我们其实已经见过了。只有5个我们还没见过：</p><ul>\n<li>注释1、3、4，它们是跟select相关的，我们会在第21讲介绍。</li>\n<li>注释2、5，是专门为非协程环境提供的API，也就是说，当我们不在协程作用域的时候，也可以调用这两个方法来操作Channel。不过大部分情况下，我们都应该优先使用挂起函数版本的API。</li>\n</ul><p>所以，如果说Channel是一个管道，那么SendChannel、ReceiveChannel就是组成这个管道的两个零件。</p><p><img src="https://static001.geekbang.org/resource/image/80/6c/8033b2962552e1f49b2c46e38a94256c.jpg?wh=2000x768" alt=""></p><p>还记得我们在之前<a href="https://time.geekbang.org/column/article/484631">不变性思维</a>当中提到的，对外暴露不变性集合的思路吗？其实对于Channel来说，我们也可以做到类似的事情。</p><pre><code class="language-plain">// 代码段19\n\nclass ChannelModel {\n    // 对外只提供读取功能\n    val channel: ReceiveChannel&lt;Int&gt; by ::_channel\n    private val _channel: Channel&lt;Int&gt; = Channel()\n\n    suspend fun init() {\n        (1..3).forEach {\n            _channel.send(it)\n        }\n    }\n}\n\nfun main() = runBlocking {\n    val model = ChannelModel()\n    launch {\n        model.init()\n    }\n\n    model.channel.consumeEach {\n        println(it)\n    }\n}\n</code></pre><p>也就是对于Channel来说，它的send()就相当于集合的写入API，当我们想要做到“对写入封闭，对读取开放”的时候，就可以用之前学过的知识轻松做到。</p><p><img src="https://static001.geekbang.org/resource/image/6d/53/6dfd13fb26053246662abeb692b00d53.jpg?wh=2000x1125" alt=""></p><p>而这一切，都得益于Channel的能力都是通过“组合”得来的。</p><h2>小结</h2><p>这节课的内容就到这里，我们来总结一下。</p><ul>\n<li>Channel是一个<strong>管道</strong>，当我们想要用协程传递多个数据组成的流的话，就没办法通过挂起函数、async来实现了。这时候，Channel是一个不错的选择。</li>\n<li>我们可以通过<strong>Channel()</strong>这个顶层函数来创建Channel管道。在创建Channel的时候，有三个重要参数：capacity代表了容量；onBufferOverflow代表容量满了以后的应对策略；onUndeliveredElement则是一个异常回调。在某些场景下，比如“<strong>发送方对于数据是否被接收方十分关心</strong>”的情况下，可以注册这个回调。</li>\n<li>Channel有两个关键的方法：send()、receive()，前者用于发送管道数据，后者用于接收管道数据。但是，由于Channel是存在关闭状态的，如果我们直接使用receive()，就会导致各种问题。因此，对于管道数据的接收方来说，我们应该尽可能地使用for循环、consumeEach {}。</li>\n<li>Channel是“热”的。这是因为“<strong>不管有没有接收方，发送方都会工作</strong>”。</li>\n<li>最后，我们也分析了Channel的源码定义，发现它其实是SendChannel、ReceiveChannel这两个接口的组合。而我们也可以借助它的这个特点，实现“对读取开放，对写入封闭”的设计。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/89/6f/893c15a694f0ce2b467b9a3220ef446f.jpg?wh=2000x1253" alt=""></p><p>其实Channel也不是Kotlin独创的概念，在某些其他编程语言当中，也有这样的组件，最典型的就是Go语言。所以，当你学会Kotlin的Channel，以后在别的语言中再遇到Channel，或者是基于Channel的Actor，你也就能快速地把Kotlin的知识迁移过去。</p><p>另外，学到这里相信你也发现了：编程语言里面的概念都是互通的。为什么有些人学习一门新的编程语言，可以特别快，还学得特别好？</p><p>原因往往就是，人家早已掌握了编程语言当中所有互通的概念。这就是所谓的<strong>触类旁通</strong>。学完这门课程以后，我相信，你也可以做到。</p><h2>思考题</h2><p>请问，Channel是“热”的，这一特点有什么坏处吗？为什么？ 欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "19 | Channel：为什么说Channel是“热”的？",
      },
      {
        title: "20 | Flow：为什么说Flow是“冷”的？",
        id: 491632,
        content:
          '<p>你好，我是朱涛。今天我们来学习Kotlin协程Flow的基础知识。</p><p>Flow，可以说是在Kotlin协程当中自成体系的知识点。<strong>Flow极其强大、极其灵活</strong>，在它出现之前，业界还有很多质疑Kotlin协程的声音，认为Kotlin的挂起函数、结构化并发，并不足以形成核心竞争力，在异步、并发任务的领域，RxJava可以做得更好。</p><p>但是，随着2019年Kotlin推出Flow以后，这样的质疑声就渐渐没有了。有了Flow以后，Kotlin的协程已经没有明显的短板了。简单的异步场景，我们可以直接使用挂起函数、launch、async；至于复杂的异步场景，我们就可以使用Flow。</p><p>实际上，在很多技术领域，Flow已经开始占领RxJava原本的领地，在Android领域，Flow甚至还要取代原本LiveData的地位。因为，Flow是真的香啊！</p><p>接下来，我们就一起来学习Flow。</p><h2>Flow就是“数据流”</h2><p>Flow这个单词有“流”的意思，比如Cash Flow代表了“现金流”；Traffic Flow代表了“车流”；Flow在Kotlin协程当中，其实就是“数据流”的意思。因为Flow当中“流淌”的，都是数据。</p><p>为了帮你建立思维模型，我做了一个动图，来描述Flow的行为模式。</p><!-- [[[read_end]]] --><p><img src="https://static001.geekbang.org/resource/image/d3/81/d3138d1386ef7c863086fe9fdcbc0a81.gif?wh=1080x495" alt=""></p><p>可以看到，Flow和我们上节课学习的Channel不一样，Flow并不是只有“发送”“接收”两个行为，它当中流淌的数据是<strong>可以在中途改变</strong>的。</p><p>Flow的数据发送方，我们称之为“上游”；数据接收方称之为“下游”。跟现实生活中一样，上下游其实也是相对的概念。比如我们可以看到下面的图，对于中转站2来说，中转站1就相当于它的上游。</p><p><img src="https://static001.geekbang.org/resource/image/ff/31/ffb1b4f8256ae249108d60600947c031.jpg?wh=2000x1125" alt=""></p><p>另外我们也可以看到，在发送方、接收方的中间，是可以有多个“中转站”的。在这些中转站里，我们就可以对数据进行一些处理了。</p><p>其实，Flow这样的数据模型，在现实生活中也存在，比如说长江，它有发源地和下游，中间还有很多大坝、水电站，甚至还有一些污水净化厂。</p><p>好，相信你现在对Flow已经有比较清晰的概念了。下面我们来看一段代码：</p><pre><code class="language-plain">// 代码段1\n\nfun main() = runBlocking {\n    flow {                  // 上游，发源地\n        emit(1)             // 挂起函数\n        emit(2)\n        emit(3)\n        emit(4)\n        emit(5)\n    }.filter { it &gt; 2 }     // 中转站1\n        .map { it * 2 }     // 中转站2\n        .take(2)            // 中转站3\n        .collect{           // 下游\n            println(it)\n        }\n}\n\n/*\n输出结果：                       \n6\n8\n*/\n</code></pre><p>如果你结合着之前的图片来分析这段代码的话，相信马上就能分析出它的执行结果。因为Flow的这种<strong>链式调用</strong>的API，本身就非常符合人的阅读习惯。</p><p>而且，Flow写出来的代码非常清晰易懂，我们可以对照前面的示意图来看一下：</p><p><img src="https://static001.geekbang.org/resource/image/a0/f6/a0a912dfffebb66f428d2b8789a914f6.jpg?wh=2000x1125" alt=""></p><p>说实话，Flow这样代码模式，谁不爱呢？我们可以来简单分析一下：</p><ul>\n<li><strong>flow{}</strong>，是一个高阶函数，它的作用就是创建一个新的Flow。在它的Lambda当中，我们可以使用 <strong>emit()</strong> 这个挂起函数往下游发送数据，这里的emit其实就是“发射”“发送”的意思。上游创建了一个“数据流”，同时也要负责发送数据。这跟现实生活也是一样的：长江里的水从上游产生，这是天经地义的。所以，对于上游而言，只需要创建Flow，然后发送数据即可，其他的都交给中转站和下游。</li>\n<li><strong>filter{}、map{}、take(2)</strong>，它们是<strong>中间操作符</strong>，就像中转站一样，它们的作用就是对数据进行处理，这很好理解。Flow最大的优势，就是它的操作符跟集合操作符高度一致。只要你会用List、Sequence，那你就可以快速上手Flow的操作符，这中间几乎没有额外的学习成本。</li>\n<li><strong>collect{}</strong>，也被称为<strong>终止操作符</strong>或者<strong>末端操作符</strong>，它的作用其实只有一个：终止Flow数据流，并且接收这些数据。</li>\n</ul><p>除了使用flow{} 创建Flow以外，我们还可以使用 <strong>flowOf()</strong> 这个函数。所以，从某种程度上讲，Flow跟Kotlin的集合其实也是有一些相似之处的。</p><pre><code class="language-plain">// 代码段2\n\nfun main() = runBlocking {\n    flowOf(1, 2, 3, 4, 5).filter { it &gt; 2 }\n        .map { it * 2 }\n        .take(2)\n        .collect {\n            println(it)\n        }\n\n    listOf(1, 2, 3, 4, 5).filter { it &gt; 2 }\n        .map { it * 2 }\n        .take(2)\n        .forEach {\n            println(it)\n        }\n}\n\n/*\n输出结果\n6\n8\n6\n8\n*/\n</code></pre><p>从上面的代码中，我们可以看到Flow API与集合API之间的共性。listOf创建List，flowOf创建Flow。遍历List，我们使用forEach{}；遍历Flow，我们使用collect{}。</p><p>在某些场景下，我们甚至可以把Flow当做集合来使用，或者反过来，把集合当做Flow来用。</p><pre><code class="language-plain">// 代码段3\n\nfun main() = runBlocking {\n    // Flow转List\n    flowOf(1, 2, 3, 4, 5)\n        .toList()\n        .filter { it &gt; 2 }\n        .map { it * 2 }\n        .take(2)\n        .forEach {\n            println(it)\n        }\n\n    // List转Flow\n    listOf(1, 2, 3, 4, 5)\n        .asFlow()\n        .filter { it &gt; 2 }\n        .map { it * 2 }\n        .take(2)\n        .collect {\n            println(it)\n        }\n}\n\n/*\n输出结果\n6\n8\n6\n8\n*/\n</code></pre><p>在这段代码中，我们使用了Flow.toList()、List.asFlow()这两个扩展函数，让数据在List、Flow之间来回转换，而其中的代码甚至不需要做多少改变。</p><p>到这里，我其实已经给你介绍了三种创建Flow的方式，我来帮你总结一下。</p><p><img src="https://static001.geekbang.org/resource/image/7a/2e/7a0a85927254e66e4847c17de49d052e.jpg?wh=2000x697" alt=""></p><p>好，现在我们就对Flow有一个整体的认识了，我们知道它的API总体分为三个部分：上游、中间操作、下游。其中对于上游来说，一般有三种创建方式，这些我们也都需要好好掌握。</p><p>那么接下来，我们重点看看中间操作符。</p><h2>中间操作符</h2><p>中间操作符（Intermediate Operators），除了之前提到的map、filter、take这种从集合那边“抄”来的操作符之外，还有一些特殊的操作符需要我们特别注意。这些操作符跟Kotlin集合API是没关系的，<strong>它们是专门为Flow设计的</strong>。我们一个个来看。</p><h3>Flow生命周期</h3><p>在Flow的中间操作符当中，<strong>onStart、onCompletion</strong>这两个是比较特殊的。它们是以操作符的形式存在，但实际上的作用，是监听生命周期回调。</p><p>onStart，它的作用是注册一个监听事件：当flow启动以后，它就会被回调。具体我们可以看下面这个例子：</p><pre><code class="language-plain">// 代码段4\nfun main() = runBlocking {\n    flowOf(1, 2, 3, 4, 5)\n        .filter {\n            println("filter: $it")\n            it &gt; 2\n        }\n        .map {\n            println("map: $it")\n            it * 2\n        }\n        .take(2)\n        .onStart { println("onStart") } // 注意这里\n        .collect {\n            println("collect: $it")\n        }\n}\n\n/*\n输出结果\nonStart\nfilter: 1\nfilter: 2\nfilter: 3\nmap: 3\ncollect: 6\nfilter: 4\nmap: 4\ncollect: 8\n*/\n</code></pre><p>可以看到，onStart的执行顺序，并不是严格按照上下游来执行的。虽然onStart的位置是处于下游，而filter、map、take是上游，但onStart是最先执行的。因为它本质上是一个回调，不是一个数据处理的中间站。</p><p>相应的，filter、map、take这类操作符，它们的执行顺序是跟它们的位置相关的。最终的执行结果，也会受到位置变化的影响。</p><pre><code class="language-plain">// 代码段5\nfun main() = runBlocking {\n    flowOf(1, 2, 3, 4, 5)\n        .take(2) // 注意这里\n        .filter {\n            println("filter: $it")\n            it &gt; 2\n        }\n        .map {\n            println("map: $it")\n            it * 2\n        }\n        .onStart { println("onStart") }\n        .collect {\n            println("collect: $it")\n        }\n}\n/*\n输出结果\nonStart\nfilter: 1\nfilter: 2\n*/\n</code></pre><p>可见，在以上代码中，我们将take(2)的位置挪到了上游的起始位置，这时候程序的执行结果就完全变了。</p><p>OK，理解了onStart以后，onCompletion也就很好理解了。</p><pre><code class="language-plain">// 代码段6\nfun main() = runBlocking {\n    flowOf(1, 2, 3, 4, 5)\n        .onCompletion { println("onCompletion") } // 注意这里\n        .filter {\n            println("filter: $it")\n            it &gt; 2\n        }\n        .take(2)\n        .collect {\n            println("collect: $it")\n        }\n}\n\n/*\n输出结果\nfilter: 1\nfilter: 2\nfilter: 3\ncollect: 3\nfilter: 4\ncollect: 4\nonCompletion\n*/\n</code></pre><p>和onStart类似，onCompletion的执行顺序，跟它在Flow当中的位置无关。onCompletion只会在Flow数据流执行完毕以后，才会回调。</p><p>还记得在<a href="https://time.geekbang.org/column/article/487930">第16讲</a>里，我们提到的Job.invokeOnCompletion{} 这个生命周期回调吗？在这里，Flow.onCompletion{} 也是类似的，onCompletion{} 在面对以下三种情况时都会进行回调：</p><ul>\n<li>情况1，Flow正常执行完毕；</li>\n<li>情况2，Flow当中出现异常；</li>\n<li>情况3，Flow被取消。</li>\n</ul><p>对于情况1，我们已经在上面的代码中验证过了。接下来，我们看看后面两种情况：</p><pre><code class="language-plain">// 代码段7\nfun main() = runBlocking {\n    launch {\n        flow {\n            emit(1)\n            emit(2)\n            emit(3)\n        }.onCompletion { println("onCompletion first: $it") }\n            .collect {\n                println("collect: $it")\n                if (it == 2) {\n                    cancel()            // 1\n                    println("cancel")\n                }\n            }\n    }\n\n    delay(100L)\n\n    flowOf(4, 5, 6)\n        .onCompletion { println("onCompletion second: $it") }\n        .collect {\n            println("collect: $it")\n            // 仅用于测试，生产环境不应该这么创建异常\n            throw IllegalStateException() // 2\n        }\n}\n\n/*\ncollect: 1\ncollect: 2\ncancel\nonCompletion first: JobCancellationException: // 3\ncollect: 4\nonCompletion second: IllegalStateException    // 4\n*/\n</code></pre><p>在上面的注释1当中，我们在collect{} 里调用了cancel方法，这会取消掉整个Flow，这时候，flow{} 当中剩下的代码将不会再被执行。最后，onCompletion也会被调用，同时，请你留意注释3，这里还会带上对应的异常信息JobCancellationException。</p><p>同样的，根据注释2、4，我们也能分析出一样的结果。</p><p>而且从上面的代码里，我们也可以看到，当Flow当中发生异常以后，Flow就会终止。那么对于这样的问题，我们该如何处理呢？</p><p>下面我就带你来看看，Flow当中如何处理异常。</p><h3>catch异常处理</h3><p>前面我已经介绍过，Flow主要有三个部分：上游、中间操作、下游。那么，Flow当中的异常，也可以根据这个标准来进行分类，也就是异常发生的位置。</p><p>对于发生在上游、中间操作这两个阶段的异常，我们可以直接使用 <strong>catch</strong> 这个操作符来进行捕获和进一步处理。如下所示：</p><pre><code class="language-plain">// 代码段8\nfun main() = runBlocking {\n    val flow = flow {\n        emit(1)\n        emit(2)\n        throw IllegalStateException()\n        emit(3)\n    }\n\n    flow.map { it * 2 }\n        .catch { println("catch: $it") } // 注意这里\n        .collect {\n            println(it)\n        }\n}\n/*\n输出结果：\n2\n4\ncatch: java.lang.IllegalStateException\n*/\n</code></pre><p>所以，catch这个操作符，其实就相当于我们平时使用的try-catch的意思。只是说，后者是用于普通的代码，而前者是用于Flow数据流的，两者的核心理念是一样的。不过，考虑到Flow具有上下游的特性，catch这个操作符的作用是<strong>和它的位置强相关</strong>的。</p><p><strong>catch的作用域，仅限于catch的上游。</strong>换句话说，发生在catch上游的异常，才会被捕获，发生在catch下游的异常，则不会被捕获。为此，我们可以换一个写法：</p><pre><code class="language-plain">// 代码段9\nfun main() = runBlocking {\n    val flow = flow {\n        emit(1)\n        emit(2)\n        emit(3)\n    }\n\n    flow.map { it * 2 }\n        .catch { println("catch: $it") }\n        .filter { it / 0 &gt; 1}  // 故意制造异常\n        .collect {\n            println(it)\n        }\n}\n\n/*\n输出结果\nException in thread "main" ArithmeticException: / by zero\n*/\n</code></pre><p>从上面代码的执行结果里，我们可以看到，catch对于发生在它下游的异常是无能为力的。这一点，借助我们之前的思维模型来思考，也是非常符合直觉的。比如说，长江上面的污水处理厂，当然只能处理它上游的水，而对于发生在下游的污染，是无能为力的。</p><p>那么，发生在上游源头，还有发生在中间操作的异常，处理起来其实很容易，我们只需要留意catch的作用域即可。最后就是发生在下游末尾处的异常了。</p><p>如果你回过头去看代码段7当中的异常，会发现它也是一个典型的“发生在下游的异常”，所以对于这种情况，我们就不能用catch操作符了。那么最简单的办法，其实是使用 <strong>try-catch</strong>，把collect{} 当中可能出现问题的代码包裹起来。比如像下面这样：</p><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    flowOf(4, 5, 6)\n        .onCompletion { println("onCompletion second: $it") }\n        .collect {\n            try {\n                println("collect: $it")\n                throw IllegalStateException()\n            } catch (e: Exception) {\n                println("Catch $e")\n            }\n        }\n}\n</code></pre><p>所以，针对Flow当中的异常处理，我们主要有两种手段：一个是catch操作符，它主要用于上游异常的捕获；而try-catch这种传统的方式，更多的是应用于下游异常的捕获。</p><blockquote>\n<p>提示：关于更多协程异常处理的话题，我们会在第23讲深入介绍。</p>\n</blockquote><h3>切换Context：flowOn、launchIn</h3><p>前面我们介绍过，Flow非常适合复杂的异步任务。在大部分的异步任务当中，我们都需要频繁切换工作的线程。对于耗时任务，我们需要线程池当中执行，对于UI任务，我们需要在主线程执行。</p><p>而在Flow当中，我们借助 <strong>flowOn</strong> 这一个操作符，就可以灵活实现以上的需求。</p><pre><code class="language-plain">// 代码段11\nfun main() = runBlocking {\n    val flow = flow {\n        logX("Start")\n        emit(1)\n        logX("Emit: 1")\n        emit(2)\n        logX("Emit: 2")\n        emit(3)\n        logX("Emit: 3")\n    }\n\n    flow.filter {\n            logX("Filter: $it")\n            it &gt; 2\n        }\n        .flowOn(Dispatchers.IO)  // 注意这里\n        .collect {\n            logX("Collect $it")\n        }\n}\n\n/*\n输出结果\n================================\nStart\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nFilter: 1\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nEmit: 1\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nFilter: 2\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nEmit: 2\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nFilter: 3\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nEmit: 3\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nCollect 3\nThread:main @coroutine#1\n================================\n</code></pre><p>flowOn操作符也是和它的位置强相关的。它的作用域跟前面的catch类似：<strong>flowOn仅限于它的上游。</strong></p><p>在上面的代码中，flowOn的上游，就是flow{}、filter{} 当中的代码，所以，它们的代码全都运行在DefaultDispatcher这个线程池当中。只有collect{} 当中的代码是运行在main线程当中的。</p><p>对应的，如果你挪动一下上面代码中flowOn的位置，会发现执行结果就会不一样，比如这样：</p><pre><code class="language-plain">// 代码段12\nflow.flowOn(Dispatchers.IO) // 注意这里\n    .filter {\n        logX("Filter: $it")\n        it &gt; 2\n    }\n    .collect {\n        logX("Collect $it")\n    }\n/*\n输出结果：\nfilter当中的代码会执行在main线程\n*/\n</code></pre><p>这里的代码执行结果，我们很容易就能推测出来，因为flowOn的作用域仅限于上游，所以它只会让flow{} 当中的代码运行在DefaultDispatcher当中，剩下的代码则执行在main线程。</p><p>但是到这里，我们就会遇到一个类似catch的困境：如果想要指定collect当中的Context，该怎么办呢？</p><p>我们能想到的最简单的办法，就是用前面学过的：<strong>withContext{}</strong>。</p><pre><code class="language-plain">// 代码段13\n\n// 不推荐\nflow.flowOn(Dispatchers.IO)\n    .filter {\n        logX("Filter: $it")\n        it &gt; 2\n    }\n    .collect {\n        withContext(mySingleDispatcher) {\n            logX("Collect $it")\n        }\n    }\n/*\n输出结果：\ncollect{}将运行在MySingleThread\nfilter{}运行在main\nflow{}运行在DefaultDispatcher\n*/\n</code></pre><p>在上面的代码中，我们直接在collect{} 里使用了withContext{}，所以它的执行就交给了MySingleThread。不过，有的时候，我们想要改变除了flowOn以外所有代码的Context。比如，我们希望collect{}、filter{} 都运行在MySingleThread。</p><p>那么这时候，我们可以考虑使用withContext{} <strong>进一步扩大包裹的范围</strong>，就像下面这样：</p><pre><code class="language-plain">// 代码段14\n\n// 不推荐\nwithContext(mySingleDispatcher) {\n    flow.flowOn(Dispatchers.IO)\n        .filter {\n            logX("Filter: $it")\n            it &gt; 2\n        }\n        .collect{\n            logX("Collect $it")\n        }\n}\n\n/*\n输出结果：\ncollect{}将运行在MySingleThread\nfilter{}运行在MySingleThread\nflow{}运行在DefaultDispatcher\n*/\n</code></pre><p>不过，这种写法终归是有些丑陋，因此，Kotlin官方还为我们提供了另一个操作符，<strong>launchIn</strong>。</p><p>我们来看看这个操作符是怎么用的：</p><pre><code class="language-plain">// 代码段15\nval scope = CoroutineScope(mySingleDispatcher)\nflow.flowOn(Dispatchers.IO)\n    .filter {\n        logX("Filter: $it")\n        it &gt; 2\n    }\n    .onEach {\n        logX("onEach $it")\n    }\n    .launchIn(scope)\n\n/*\n输出结果：\nonEach{}将运行在MySingleThread\nfilter{}运行在MySingleThread\nflow{}运行在DefaultDispatcher\n*/\n</code></pre><p>可以看到，在这段代码中，我们不再直接使用collect{}，而是借助了onEach{} 来实现类似collect{} 的功能。同时我们在最后使用了launchIn(scope)，把它上游的代码都分发到指定的线程当中。</p><p>如果你去看launchIn的源代码的话，你会发现它的定义极其简单：</p><pre><code class="language-plain">// 代码段16\npublic fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job = scope.launch {\n    collect() // tail-call\n}\n</code></pre><p>由此可见，launchIn从严格意义来讲，应该算是一个下游的终止操作符，因为它本质上是调用了collect()。</p><p>因此，上面的代码段16，也会等价于下面的写法：</p><pre><code class="language-plain">// 代码段17\nfun main() = runBlocking {\n    val scope = CoroutineScope(mySingleDispatcher)\n    val flow = flow {\n        logX("Start")\n        emit(1)\n        logX("Emit: 1")\n        emit(2)\n        logX("Emit: 2")\n        emit(3)\n        logX("Emit: 3")\n    }\n        .flowOn(Dispatchers.IO)\n        .filter {\n            logX("Filter: $it")\n            it &gt; 2\n        }\n        .onEach {\n            logX("onEach $it")\n        }\n        \n    scope.launch { // 注意这里\n        flow.collect()\n    }\n    \n    delay(100L)\n}\n</code></pre><p>所以，总的来说，对于Flow当中的线程切换，我们可以使用flowOn、launchIn、withContext，但其实，flowOn、launchIn就已经可以满足需求了。</p><p>另外，由于Flow当中直接使用withContext是很容易引发其他问题的，因此，<strong>withContext在Flow当中是不被推荐的，即使要用，也应该谨慎再谨慎</strong>。</p><blockquote>\n<p>提示：针对Flow当中withContext引发的问题，我会在这节课的思考题里给出具体案例。</p>\n</blockquote><h2>下游：终止操作符</h2><p>最后，我们就到了下游阶段，我们来看看终止操作符（Terminal Operators）的含义和使用。</p><blockquote>\n<p>这里的Terminal，其实有终止、末尾、终点的意思。</p>\n</blockquote><p>在Flow当中，终止操作符的意思就是终止整个Flow流程的操作符。这里的“终止”，其实是跟前面的“中间”操作符对应的。</p><p>具体来说，就是在filter操作符的后面，还可以继续添加其他的操作符，比如说map，因为filter本身就是一个“中间”操作符。但是，collect操作符之后，我们无法继续使用map之类的操作，因为collect是一个“终止”操作符，代表Flow数据流的终止。</p><p>Flow里面，最常见的终止操作符就是collect。除此之外，还有一些从集合当中“抄”过来的操作符，也是Flow的终止操作符。比如first()、single()、fold{}、reduce{}。</p><p>另外，当我们尝试将Flow转换成集合的时候，它本身也就意味着Flow数据流的终止。比如说，我们前面用过的toList：</p><pre><code class="language-plain">// 代码段18\nfun main() = runBlocking {\n    // Flow转List\n    flowOf(1, 2, 3, 4, 5)\n        .toList()           // 注意这里\n        .filter { it &gt; 2 }\n        .map { it * 2 }\n        .take(2)\n        .forEach {\n            println(it)\n        }\n}\n</code></pre><p>在上面的代码中，当我们调用了toList()以后，往后所有的操作符，都不再是Flow的API调用了，虽然它们的名字没有变，filter、map，这些都只是集合的API。所以，严格意义上讲，toList也算是一个终止操作符。</p><h2>为什么说Flow是“冷”的？</h2><p>现在我们就算是把Flow这个API给搞清楚了，但还有一个疑问我们没解决，就是这节课的标题：为什么说Flow是“冷”的？</p><p>实际上，如果你理解了上节课Channel为什么是“热”的，那你就一定可以理解Flow为什么是“冷”的。我们可以模仿上节课的Channel代码，写一段Flow的代码，两相对比之下其实马上就能发现它们之间的差异了。</p><pre><code class="language-plain">// 代码段19\n\nfun main() = runBlocking {\n    // 冷数据流\n    val flow = flow {\n        (1..3).forEach {\n            println("Before send $it")\n            emit(it)\n            println("Send $it")\n        }\n    }\n\n    // 热数据流\n    val channel = produce&lt;Int&gt;(capacity = 0) {\n        (1..3).forEach {\n            println("Before send $it")\n            send(it)\n            println("Send $it")\n        }\n    }\n\n    println("end")\n}\n\n/*\n输出结果：\nend\nBefore send 1\n// Flow 当中的代码并未执行\n*/\n</code></pre><p>我们知道，Channel之所以被认为是“热”的原因，是因为<strong>不管有没有接收方，发送方都会工作</strong>。那么对应的，Flow被认为是“冷”的原因，就是因为<strong>只有调用终止操作符之后，Flow才会开始工作。</strong></p><h3>Flow 还是“懒”的</h3><p>其实，如果你去仔细调试过代码段1的话，应该就已经发现了，Flow不仅是“冷”的，它还是“懒”的。为了暴露出它的这个特点，我们稍微改造一下代码段1，然后加一些日志进来。</p><pre><code class="language-plain">// 代码段20\n\nfun main() = runBlocking {\n    flow {\n        println("emit: 3")\n        emit(3)\n        println("emit: 4")\n        emit(4)\n        println("emit: 5")\n        emit(5)\n    }.filter {\n        println("filter: $it")\n        it &gt; 2\n    }.map {\n        println("map: $it")\n        it * 2\n    }.collect {\n        println("collect: $it")\n    }\n}\n/*\n输出结果：\nemit: 3\nfilter: 3\nmap: 3\ncollect: 6\nemit: 4\nfilter: 4\nmap: 4\ncollect: 8\nemit: 5\nfilter: 5\nmap: 5\ncollect: 10\n*/\n</code></pre><p>通过上面的运行结果，我们可以发现，Flow一次只会处理一条数据。虽然它也是Flow“冷”的一种表现，但这个特性准确来说是“懒”。</p><p>如果你结合上节课“服务员端茶送水”的场景来思考的话，Flow不仅是一个“冷淡”的服务员，还是一个“懒惰”的服务员：明明饭桌上有3个人需要喝水，但服务员偏偏不一次性上3杯水，而是要这3个人，每个人都叫服务员一次，服务员才会一杯一杯地送3杯水过来。</p><p>对比Channel的思维模型来看的话：</p><p><img src="https://static001.geekbang.org/resource/image/4a/59/4aaae2c6b5e14c7ae938b630d2794e59.jpg?wh=2000x762" alt=""></p><blockquote>\n<p>提示：Flow默认情况下是“懒惰”的，但也可以通过配置让它“勤快”起来。</p>\n</blockquote><h2>思考与实战</h2><p>我们都知道，Flow非常适合复杂的异步任务场景。借助它的flowOn、launchIn，我们可以写出非常灵活的代码。比如说，在Android、Swing之类的UI平台之上，我们可以这样写：</p><pre><code class="language-plain">// 代码段21\n\nfun main() = runBlocking {\n    fun loadData() = flow {\n        repeat(3){\n            delay(100L)\n            emit(it)\n            logX("emit $it")\n        }\n    }\n\n    // 模拟Android、Swing的UI\n    val uiScope = CoroutineScope(mySingleDispatcher)\n\n    loadData()\n        .map { it * 2 }\n        .flowOn(Dispatchers.IO) // 1，耗时任务\n        .onEach {\n            logX("onEach $it")\n        }\n        .launchIn(uiScope)      // 2，UI任务\n\n    delay(1000L)\n}\n</code></pre><p>这段代码很容易理解，我们让耗时任务在IO线程池执行，更新UI则在UI线程。</p><p>如果结合我们前面学过的Flow操作符，我们还可以设计出更加有意思的代码：</p><pre><code class="language-plain">// 代码段22\n\nfun main() = runBlocking {\n    fun loadData() = flow {\n        repeat(3) {\n            delay(100L)\n            emit(it)\n            logX("emit $it")\n        }\n    }\n    fun updateUI(it: Int) {}\n    fun showLoading() { println("Show loading") }\n    fun hideLoading() { println("Hide loading") }\n\n    val uiScope = CoroutineScope(mySingleDispatcher)\n\n    loadData()\n        .onStart { showLoading() }          // 显示加载弹窗\n        .map { it * 2 }\n        .flowOn(Dispatchers.IO)\n        .catch { throwable -&gt;\n            println(throwable)\n            hideLoading()                   // 隐藏加载弹窗\n            emit(-1)                   // 发生异常以后，指定默认值\n        }\n        .onEach { updateUI(it) }            // 更新UI界面 \n        .onCompletion { hideLoading() }     // 隐藏加载弹窗\n        .launchIn(uiScope)\n\n    delay(10000L)\n}\n</code></pre><p>在以上代码中，我们通过监听onStart、onCompletion的回调事件，就可以实现Loading弹窗的显示和隐藏。而对于出现异常的情况，我们也可以在catch{} 当中调用emit()，给出一个默认值，这样就可以有效防止UI界面出现空白。</p><p>不得不说，以上代码的可读性是非常好的。</p><h2>小结</h2><p>这节课的内容到这里就差不多结束了，我们来做一个简单的总结。</p><ul>\n<li>Flow，就是<strong>数据流</strong>。整个Flow的API设计，可以大致分为三个部分，上游的源头、中间操作符、下游终止操作符。</li>\n<li>对于<strong>上游源头</strong>来说，它主要负责：创建Flow，并且产生数据。而创建Flow，主要有三种方式：flow{}、flowOf()、asFlow()。</li>\n<li>对于<strong>中间操作符</strong>来说，它也分为几大类。第一类是从集合“抄”过来的操作符，比如map、filter；第二类是生命周期回调，比如onStart、onCompletion；第三类是功能型API，比如说flowOn切换Context、catch捕获上游的异常。</li>\n<li>对于<strong>下游的终止操作符</strong>，也是分为三大类。首先，就是collect这个最基础的终止操作符；其次，就是从集合API“抄”过来的操作符，比如fold、reduce；最后，就是Flow转换成集合的API，比如说flow.toList()。</li>\n</ul><p>你也要清楚为什么我们说“Flow是冷的”的原因，以及它对比Channel的优势和劣势。另外在课程里，我们还探索了Flow在Android里的实际应用场景，当我们将Flow与它的操作符灵活组合到一起的时候，就可以设计出可读性非常好的代码。</p><p><img src="https://static001.geekbang.org/resource/image/74/1a/747837c1b0657ae4042fbce9eae75f1a.jpg?wh=2000x1306" alt=""></p><p>其实，Flow本身就是一个非常大的话题，能讲的知识点实在太多了。但考虑到咱们课程学习需要循序渐进，现阶段我只是从中挑选一些最重要、最关键的知识点来讲。更多Flow的高阶用法，等我们学完协程篇、源码篇之后，我会再考虑增加一些更高阶的内容进来。</p><h2>思考题</h2><p>前面我曾提到过，Flow当中直接使用withContext{}，是很容易出现问题的，下面代码是其中的一种。请问你能解释其中的缘由吗？Kotlin官方为什么要这么设计？</p><pre><code class="language-plain">// 代码段23\n\nfun main() = runBlocking {\n    flow {\n        withContext(Dispatchers.IO) {\n            emit(1)\n        }\n    }.map { it * 2 }\n        .collect()\n}\n\n/*\n输出结果\nIllegalStateException: Flow invariant is violated\n*/\n</code></pre><p>这个问题的答案，我会在第32讲介绍Flow源码的时候给出详细的解释。</p>',
        article_title: "20 | Flow：为什么说Flow是“冷”的？",
      },
      {
        title: "21 | select：到底是在选择什么？",
        id: 492405,
        content:
          '<p>你好，我是朱涛。今天我们来学习Kotlin协程的select。</p><p>select，在目前的Kotlin 1.6当中，仍然是一个<strong>实验性的特性</strong>（Experimental）。但是，考虑到select具有较强的实用性，我决定还是来给你介绍一下它。</p><p>select可以说是软件架构当中非常重要的一个组件，在很多业务场景下，select与Deferred、Channel结合以后，在大大提升程序的响应速度的同时，还可以提高程序的灵活性、扩展性。</p><p>今天这节课，我会从select的<strong>使用角度</strong>着手，带你理解select的核心使用场景，之后也会通过源码帮你进一步分析select API的底层规律。学完这节课以后，你完全可以将select应用到自己的工作当中去。</p><p>好，接下来，我们就一起来学习select吧！</p><h2>select就是选择“更快的结果”</h2><p>由于select的工作机制比较抽象，我们先来假设一个场景，看看select适用于什么样的场景。</p><p>客户端，想要查询一个商品的详情。目前有两个服务：缓存服务，速度快但信息可能是旧的；网络服务，速度慢但信息一定是最新的。</p><p><img src="https://static001.geekbang.org/resource/image/50/86/50f7c90d8a01e42834500bb5yy705486.jpg?wh=1576x707" alt=""></p><p>对于这个场景，如果让我们来实现其中的逻辑的话，我们非常轻松地就能实现类似这样的代码逻辑：</p><!-- [[[read_end]]] --><pre><code class="language-plain">// 代码段1\nfun main() = runBlocking {\n    suspend fun getCacheInfo(productId: String): Product? {\n        delay(100L)\n        return Product(productId, 9.9)\n    }\n\n    suspend fun getNetworkInfo(productId: String): Product? {\n        delay(200L)\n        return Product(productId, 9.8)\n    }\n\n    fun updateUI(product: Product) {\n        println("${product.productId}==${product.price}")\n    }\n\n    val startTime = System.currentTimeMillis()\n\n    val productId = "xxxId"\n    // 查询缓存\n    val cacheInfo = getCacheInfo(productId)\n    if (cacheInfo != null) {\n        updateUI(cacheInfo)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n\n    // 查询网络\n    val latestInfo = getNetworkInfo(productId)\n    if (latestInfo != null) {\n        updateUI(latestInfo)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n}\n\ndata class Product(\n    val productId: String,\n    val price: Double\n)\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 112\nxxxId==9.8\nTime cost: 314\n*/\n</code></pre><p>考虑到缓存服务速度更快，我们自然而然会这么写，先去查询缓存服务，如果查询到了信息，我们就会去更新UI界面。之后去查询网络服务，拿到最新的信息之后，我们再来更新UI界面。也就是这样：</p><ul>\n<li>第一步：查询缓存信息；</li>\n<li>第二步：缓存服务返回信息，更新UI；</li>\n<li>第三步：查询网络服务；</li>\n<li>第四步：网络服务返回信息，更新UI。</li>\n</ul><p>这种做法的好处在于，用户可以第一时间看到商品的信息，虽然它暂时会展示旧的信息，但由于我们同时查询了网络服务，旧缓存信息也马上会被替代成新的信息。这样的做法，可以最大程度保证用户体验。</p><p>不过，以上整个流程都是建立在“缓存服务一定更快”的前提下的，万一我们的缓存服务出了问题，它的速度变慢了，甚至是超时、无响应呢？</p><p><img src="https://static001.geekbang.org/resource/image/12/b1/1267b73837eaa9370651e468c1c536b1.jpg?wh=1607x717" alt=""></p><p>这时候，如果你回过头来分析代码段1的话，你就会发现：程序执行流程会卡在第二步，迟迟无法进行第三步。具体来说，是因为getCacheInfo()它是一个挂起函数，只有这个程序执行成功以后，才可以继续执行后面的任务。你也可以把getCacheInfo()当中的delay时间修改成2000毫秒，去验证一下。</p><pre><code class="language-plain">/*\n执行结果：\nxxxId==9.9\nTime cost: 2013\nxxxId==9.8\nTime cost: 2214\n*/\n</code></pre><p>那么，面对这样的场景，我们其实需要一个可以<strong>灵活选择</strong>的语法：“两个挂起函数同时执行，谁返回的速度更快，我们就选择谁”。这其实就是select的典型使用场景。</p><h2>select和async</h2><p>上面的这个场景，我们可以用async搭配select来使用。async可以实现并发，select则可以选择最快的结果。</p><p>让我们来看看，代码具体该怎么写。</p><pre><code class="language-plain">// 代码段2\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val productId = "xxxId"\n    //          1，注意这里\n    //               ↓\n    val product = select&lt;Product?&gt; {\n        // 2，注意这里\n        async { getCacheInfo(productId) }\n            .onAwait { // 3，注意这里\n                it\n            }\n        // 4，注意这里\n        async { getNetworkInfo(productId) }\n            .onAwait {  // 5，注意这里\n                it\n            }\n    }\n\n    if (product != null) {\n        updateUI(product)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n}\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 127\n*/\n</code></pre><p>从上面的执行结果，我们可以看到，由于缓存的服务更快，所以，select确实帮我们选择了更快的那个结果。代码中一共有四个注释，我们一起来看看：</p><ul>\n<li>注释1，我们使用select这个高阶函数包裹了两次查询的服务，同时传入了泛型参数Product，代表我们要选择的数据类型是Product。</li>\n<li>注释2，4中，我们使用了async包裹了getCacheInfo()、getNetworkInfo()这两个挂起函数，这是为了让这两个查询实现并发执行。</li>\n<li>注释3，5中，我们使用onAwait{} 将执行结果传给了select{}，而select才能进一步将数据返回给product局部变量。<strong>注意了，这里我们用的onAwait{}，而不是await()。</strong></li>\n</ul><p>现在，假设，我们的缓存服务出现了问题，需要2000毫秒才能返回：</p><pre><code class="language-plain">// 代码段3\nsuspend fun getCacheInfo(productId: String): Product? {\n    // 注意这里\n    delay(2000L)\n    return Product(productId, 9.9)\n}\n\n/*\n输出结果\nxxxId==9.8\nTime cost: 226\n*/\n</code></pre><p>这时候，通过执行结果，我们可以发现，我们的select可以在缓存服务出现问题的时候，灵活选择网络服务的结果。从而避免用户等待太长的时间，得到糟糕的体验。</p><p>不过，你也许发现了，“代码段1”和“代码段2”其实并不是完全等价的。因为在代码段2当中，用户大概率是会展示旧的缓存信息。但实际场景下，我们是需要进一步更新最新信息的。</p><p>其实，在代码段2的基础上，我们也可以轻松实现，只是说，这里我们需要为Product这个数据类增加一个标记。</p><pre><code class="language-plain">// 代码段4\ndata class Product(\n    val productId: String,\n    val price: Double,\n    // 是不是缓存信息\n    val isCache: Boolean = false\n)\n</code></pre><p>然后，我们还需要对代码段2的逻辑进行一些提取：</p><pre><code class="language-plain">// 代码段5\nfun main() = runBlocking {\n    suspend fun getCacheInfo(productId: String): Product? {\n        delay(100L)\n        return Product(productId, 9.9)\n    }\n\n    suspend fun getNetworkInfo(productId: String): Product? {\n        delay(200L)\n        return Product(productId, 9.8)\n    }\n\n    fun updateUI(product: Product) {\n        println("${product.productId}==${product.price}")\n    }\n\n    val startTime = System.currentTimeMillis()\n    val productId = "xxxId"\n\n    // 1，缓存和网络，并发执行\n    val cacheDeferred = async { getCacheInfo(productId) }\n    val latestDeferred = async { getNetworkInfo(productId) }\n\n    // 2，在缓存和网络中间，选择最快的结果\n    val product = select&lt;Product?&gt; {\n        cacheDeferred.onAwait {\n                it?.copy(isCache = true)\n            }\n\n        latestDeferred.onAwait {\n                it?.copy(isCache = false)\n            }\n    }\n\n    // 3，更新UI\n    if (product != null) {\n        updateUI(product)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n\n    // 4，如果当前结果是缓存，那么再取最新的网络服务结果\n    if (product != null &amp;&amp; product.isCache) {\n        val latest = latestDeferred.await()?: return@runBlocking\n        updateUI(latest)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n}\n\n/*\n输出结果：\nxxxId==9.9\nTime cost: 120\nxxxId==9.8\nTime cost: 220\n*/\n</code></pre><p>如果你对比代码段1和代码段5的执行结果，会发现代码段5的总体耗时更短。</p><p>另外在上面的代码中，还有几个注释，我们一个个看：</p><ul>\n<li>首先看注释1，我们将getCacheInfo()、getNetworkInfo()提取到了select的外部，让它们通过async并发执行。如果你还记得第16讲思考题当中的逻辑，你一定可以理解这里的async并发。（如果你忘了，可以回过头去看看。）</li>\n<li>注释2，我们仍然是通过select选择最快的那个结果，接着在注释3这里我们第一时间更新UI界面。</li>\n<li>注释4，我们判断当前的product是不是来自于缓存，如果是的话，我们还需要用最新的信息更新UI。</li>\n</ul><p>然后在这里，假设我们的缓存服务出现了问题，需要2000毫秒才能返回：</p><pre><code class="language-plain">// 代码段6\nsuspend fun getCacheInfo(productId: String): Product? {\n    // 注意这里\n    delay(2000L)\n    return Product(productId, 9.9)\n}\n\n/*\n输出结果\nxxxId==9.8\nTime cost: 224\n*/\n</code></pre><p>可以看到，代码仍然可以正常执行。其实，当前的这个例子很简单，不使用select同样也可以实现。不过，select这样的代码模式的优势在于，<strong>扩展性非常好</strong>。</p><p>下面，我们可以再来假设一下，现在我们有了多个缓存服务。</p><p><img src="https://static001.geekbang.org/resource/image/dy/2b/dyydce7b6a709e2725bbffec9726312b.jpg?wh=1550x736" alt=""></p><p>对于这个问题，我们其实只需要稍微改动一下代码段3就行了。</p><pre><code class="language-plain">// 代码段7\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val productId = "xxxId"\n\n    val cacheDeferred = async { getCacheInfo(productId) }\n    // 变化在这里\n    val cacheDeferred2 = async { getCacheInfo2(productId) }\n    val latestDeferred = async { getNetworkInfo(productId) }\n\n    val product = select&lt;Product?&gt; {\n        cacheDeferred.onAwait {\n            it?.copy(isCache = true)\n        }\n\n        // 变化在这里\n        cacheDeferred2.onAwait {\n            it?.copy(isCache = true)\n        }\n\n        latestDeferred.onAwait {\n            it?.copy(isCache = false)\n        }\n    }\n\n    if (product != null) {\n        updateUI(product)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n\n    if (product != null &amp;&amp; product.isCache) {\n        val latest = latestDeferred.await() ?: return@runBlocking\n        updateUI(latest)\n        println("Time cost: ${System.currentTimeMillis() - startTime}")\n    }\n}\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 125\nxxxId==9.8\nTime cost: 232\n*/\n</code></pre><p>可以看到，当增加一个缓存服务进来的时候，我们的代码只需要做很小的改动，就可以实现。</p><p>所以，总的来说，对比传统的挂起函数串行的执行流程，select这样的代码模式，不仅可以提升程序的整体响应速度，还可以大大提升程序的<strong>灵活性、扩展性</strong>。</p><h2>select和Channel</h2><p>在前面的课程我们提到过，在协程中返回一个内容的时候，我们可以使用挂起函数、async，但如果要返回多个结果的话，就要用Channel和Flow。</p><p>那么，这里我们来看看select和Channel的搭配使用。这里，我们有两个管道，channel1、channel2，它们里面的内容分别是1、2、3；a、b、c，我们通过select，将它们当中的数据收集出来并打印。</p><p><img src="https://static001.geekbang.org/resource/image/d2/e4/d2d280yy62f88e03522a435b3abyy9e4.gif?wh=1080x608" alt="图片"></p><p>对于这个问题，如果我们不借助select来实现的话，其实可以大致做到，但结果不会令人满意。</p><pre><code class="language-plain">// 代码段8\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce {\n        send(1)\n        delay(200L)\n        send(2)\n        delay(200L)\n        send(3)\n        delay(150L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send("a")\n        delay(200L)\n        send("b")\n        delay(200L)\n        send("c")\n    }\n\n    channel1.consumeEach {\n        println(it)\n    }\n\n    channel2.consumeEach {\n        println(it)\n    }\n\n    println("Time cost: ${System.currentTimeMillis() - startTime}")\n}\n\n/*\n输出结果\n1\n2\n3\na\nb\nc\nTime cost: 989\n*/\n</code></pre><p>可以看到，通过普通的方式，我们的代码是串行执行的，执行结果并不符合预期。channel1执行完毕以后，才会执行channel2，程序总体的执行时间，也是两者的总和。最关键的是，如果channel1当中如果迟迟没有数据的话，我们的程序会一直卡着不执行。</p><p>当然，以上的问题，我们通过其他方式也可以解决，但最方便的解决方案，还是select。让我们来看看select与Channel搭配后，会带来什么样的好处。</p><pre><code class="language-plain">// 代码段9\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce {\n        send("1")\n        delay(200L)\n        send("2")\n        delay(200L)\n        send("3")\n        delay(150L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send("a")\n        delay(200L)\n        send("b")\n        delay(200L)\n        send("c")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; {\n        // 1， 选择channel1\n        channel1.onReceive{\n            it.also { println(it) }\n        }\n        // 2， 选择channel1\n        channel2.onReceive{\n            it.also { println(it) }\n        }\n    }\n\n    repeat(6){// 3， 选择6次结果\n        selectChannel(channel1, channel2)\n    }\n\n    println("Time cost: ${System.currentTimeMillis() - startTime}")\n}\n\n/*\n输出结果\n1\na\n2\nb\n3\nc\nTime cost: 540\n*/\n</code></pre><p>从程序的执行结果中，我们可以看到，程序的输出结果符合预期，同时它的执行耗时，也比代码段8要少很多。上面的代码中有几个注释，我们来看看：</p><ul>\n<li>注释1和2，onReceive{} 是Channel在select当中的语法，当Channel当中有数据以后，它就会被回调，通过这个Lambda，我们也可以将结果传出去。</li>\n<li>注释3，这里我们执行了6次select，目的是要把两个管道中的所有数据都消耗掉。管道1有3个数据、管道2有3个数据，所以加起来，我们需要选择6次。</li>\n</ul><p>这时候，假设channel1出了问题，它不再产生数据了，我们看看程序会怎么样执行。</p><pre><code class="language-plain">// 代码段10\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        // 变化在这里\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send("a")\n        delay(200L)\n        send("b")\n        delay(200L)\n        send("c")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; {\n        channel1.onReceive{\n            it.also { println(it) }\n        }\n        channel2.onReceive{\n            it.also { println(it) }\n        }\n    }\n\n    // 变化在这里\n    repeat(3){\n        selectChannel(channel1, channel2)\n    }\n\n    println("Time cost: ${System.currentTimeMillis() - startTime}")\n}\n\n/*\n输出结果\na\nb\nc\nTime cost: 533\n*/\n</code></pre><p>在上面的代码中，我们将channel1当中的send()都删除了，并且，repeat()的次数变成了3次，因为管道里只有三个数据了。</p><p>这时候，我们发现，select也是可以正常执行的。</p><p>不过，我们有时候可能并不清楚每个Channel当中有多少个数据，比如说，这里如果我们还是写repeat(6)的话，程序就会出问题了。</p><pre><code class="language-plain">// 代码段11\n\n// 仅改动这里\nrepeat(6){\n    selectChannel(channel1, channel2)\n}\n/*\n崩溃：\nException in thread "main" ClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>这时候，你应该就能反应过来了，由于我们的channel2当中只有3个数据，它发送完数据以后就会被关闭，而我们的select是会被调用6次的，所以就会触发上面的ClosedReceiveChannelException异常。</p><p>在19讲当中，我们学过receiveCatching()这个方法，它可以封装Channel的结果，防止出现ClosedReceiveChannelException。类似的，当Channel与select配合的时候，我们可以使用onReceiveCatching{} 这个高阶函数。</p><pre><code class="language-plain">// 代码段12\n\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send("a")\n        delay(200L)\n        send("b")\n        delay(200L)\n        send("c")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String =\n        select&lt;String&gt; {\n            channel1.onReceiveCatching {\n                it.getOrNull() ?: "channel1 is closed!"\n            }\n            channel2.onReceiveCatching {\n                it.getOrNull() ?: "channel2 is closed!"\n            }\n        }\n\n    repeat(6) {\n        val result = selectChannel(channel1, channel2)\n        println(result)\n    }\n\n    println("Time cost: ${System.currentTimeMillis() - startTime}")\n}\n\n/*\n输出结果\na\nb\nc\nchannel2 is closed!\nchannel2 is closed!\nchannel2 is closed!\nTime cost: 541\n程序不会立即退出\n*/\n</code></pre><p>这时候，即使我们不知道管道里有多少个数据，我们也不用担心崩溃的问题了。在onReceiveCatching{} 这个高阶函数当中，我们可以使用it.getOrNull()来获取管道里的数据，如果获取的结果是null，就代表管道已经被关闭了。</p><p>不过，上面的代码仍然还有一个问题，那就是，当我们得到所有结果以后，程序不会立即退出，因为我们的channel1一直在delay()。这时候，当我们完成6次repeat()调用以后，我们将channel1、channel2取消即可。</p><pre><code class="language-plain">// 代码段13\n\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send("a")\n        delay(200L)\n        send("b")\n        delay(200L)\n        send("c")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String =\n        select&lt;String&gt; {\n            channel1.onReceiveCatching {\n                it.getOrNull() ?: "channel1 is closed!"\n            }\n            channel2.onReceiveCatching {\n                it.getOrNull() ?: "channel2 is closed!"\n            }\n        }\n\n    repeat(6) {\n        val result = selectChannel(channel1, channel2)\n        println(result)\n    }\n\n    // 变化在这里\n    channel1.cancel()\n    channel2.cancel()\n\n    println("Time cost: ${System.currentTimeMillis() - startTime}")\n}\n</code></pre><p>这时候，我们对比一下代码段13和代码段10的话，就会发现程序的执行效率提升的同时，扩展性和灵活性也更好了。</p><blockquote>\n<p>提示：这种将多路数据以非阻塞的方式合并成一路数据的模式，在其他领域也有广泛的应用，比如说操作系统、Java NIO（Non-blocking I/O），等等。如果你能理解这个案例中的代码，相信你对操作系统、NIO之类的技术也会有一个新的认识。</p>\n</blockquote><h2>思考与实战</h2><p>如果你足够细心的话，你会发现，当我们的Deferred、Channel与select配合的时候，它们原本的API会多一个on前缀。</p><pre><code class="language-plain">public interface Deferred : CoroutineContext.Element {\n    public suspend fun join()\n    public suspend fun await(): T\n\n    // select相关  \n    public val onJoin: SelectClause0\n    public val onAwait: SelectClause1&lt;T&gt;\n}\n\npublic interface SendChannel&lt;in E&gt; \n    public suspend fun send(element: E)\n\n    // select相关\n    public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;\n\n}\n\npublic interface ReceiveChannel&lt;out E&gt; {\n    public suspend fun receive(): E\n\n    public suspend fun receiveCatching(): ChannelResult&lt;E&gt;\n    // select相关\n    public val onReceive: SelectClause1&lt;E&gt;\n    public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;\n}\n</code></pre><p>所以，只要你记住了Deferred、Channel的API，你是不需要额外记忆select的API的，只需要在原本的API的前面加上一个on就行了。</p><p>另外你要注意，当select与Deferred结合使用的时候，当并行的Deferred比较多的时候，你往往需要在得到一个最快的结果以后，去取消其他的Deferred。</p><p>比如说，对于Deferred1、Deferred2、Deferred3、Deferred4、Deferred5，其中Deferred2返回的结果最快，这时候，我们往往会希望取消其他的Deferred，以节省资源。那么在这个时候，我们可以使用类似这样的方式：</p><pre><code class="language-plain">fun main() = runBlocking {\n    suspend fun &lt;T&gt; fastest(vararg deferreds: Deferred&lt;T&gt;): T = select {\n        fun cancelAll() = deferreds.forEach { it.cancel() }\n\n        for (deferred in deferreds) {\n            deferred.onAwait {\n                cancelAll()\n                it\n            }\n        }\n    }\n\n    val deferred1 = async {\n        delay(100L)\n        println("done1")    // 没机会执行\n        "result1"\n    }\n\n    val deferred2 = async {\n        delay(50L)\n        println("done2")\n        "result2"\n    }\n\n    val deferred3 = async {\n        delay(10000L)\n        println("done3")    // 没机会执行\n        "result3"\n    }\n\n    val deferred4 = async {\n        delay(2000L)\n        println("done4")    // 没机会执行\n        "result4"\n    }\n\n    val deferred5 = async {\n        delay(14000L)\n        println("done5")    // 没机会执行\n        "result5"\n    }\n\n    val result = fastest(deferred1, deferred2, deferred3, deferred4, deferred5)\n    println(result)\n}\n\n/*\n输出结果\ndone2\nresult2\n*/\n</code></pre><p>所以，借助这样的方式，我们不仅可以通过async并发执行协程，也可以借助select得到最快的结果，而且，还可以避免不必要的资源浪费。</p><h2>小结</h2><p>好，这节课的内容就到这儿了，我们来做一个简单的总结。</p><ul>\n<li>select，就是选择“更快的结果”。</li>\n<li>当select与async、Channel搭配以后，我们可以并发执行协程任务，以此大大提升程序的执行效率甚至用户体验，并且还可以改善程序的扩展性、灵活性。</li>\n<li>关于select的API，我们完全不需要去刻意记忆，只需要在Deferred、Channel的API基础上加上on这个前缀即可。</li>\n<li>最后，我们还结合实战，分析了select与async产生太多并发协程的时候，还可以定义一个类似fastest()的方法，去统一取消剩余的协程任务。这样的做法，就可以大大节省计算资源，从而平衡性能与功耗。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/5c/5b/5c3e1e2b9e00c367e413428d40994f5b.jpg?wh=2000x853" alt=""></p><p>其实，和Kotlin的Channel一样，select并不是Kotlin独创的概念。select在很多编程语言当中都有类似的实现，比如Go、Rust，等等。在这些计算机语言当中，select的语法可能与Kotlin的不太一样，但背后的核心理念都是“选择更快的结果”。</p><p>所以，只要你掌握了Kotlin的select，今后学习其他编程语言的select，都不再是问题。</p><h2>思考题</h2><p>前面我们已经说过，select的API，只需要在Deferred、Channel原本API的基础上加一个on前缀即可。比如onAwait{}。那么，你有没有觉得它跟我们前面学的onStart{}、onCompletion{} 之类的回调API很像？</p><p>你能从中悟出select的实现原理吗？ 欢迎在留言区说说你的想法，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "21 | select：到底是在选择什么？",
      },
      {
        title: "22 | 并发：协程不需要处理同步吗？",
        id: 493069,
        content:
          '<p>你好，我是朱涛。今天我们来讲讲协程的并发。</p><p>在大型软件的架构当中，并发也是一个不可避免的问题。然而，在传统的Java编程当中，并发却是个令人生畏的话题。因为Java的线程模型、内存模型、同步机制太复杂了，而当复杂的业务逻辑与复杂的并发模型混合在一起的时候，情况就更糟糕了！如果你用Java做过中大型软件，对此一定会深有体会。</p><p>我们都知道，Kotlin的协程仍然是基于线程运行的。但是，经过一层封装以后，Kotlin协程面对并发问题的时候，它的处理手段其实跟Java就大不一样。所以这节课，我们就来看看协程在并发问题上的处理，一起来探究下Kotlin协程的并发思路，从而真正解决并发的难题。</p><h2>协程与并发</h2><p>在Java世界里，并发往往需要多个线程一起工作，而多线程往往就会有共享的状态，这时候程序就要处理同步问题了。很多初学者在这一步，都会把协程与线程的概念混淆在一起。比如你可以来看看下面这段代码，你觉得有多线程同步的问题吗？</p><pre><code class="language-plain">// 代码段1\n\nfun main() = runBlocking {\n    var i = 0\n\n    // Default 线程池\n    launch(Dispatchers.Default) {\n        repeat(1000) {\n            i++\n        }\n    }\n\n    delay(1000L)\n\n    println("i = $i")\n}\n</code></pre><!-- [[[read_end]]] --><p>在这段代码里，我是在Default线程池上创建了一个协程，然后对变量i进行了1000次自增操作，接着我又delay了一小会儿，防止程序退出，最后输出结果。</p><p>那么，在面对这段代码的时候，你也许会觉得，Default线程池内部是多个线程，因此就需要考虑多线程同步的问题。其实，这就是典型的把协程、线程混淆的例子。</p><p>如果你仔细分析上面的代码，会发现<strong>代码中压根就没有并发执行的任务</strong>，除了runBlocking，我只在launch当中创建了一个协程，所有的计算都发生在一个协程当中。所以，在这种情况下你根本就不需要考虑同步的问题。</p><p>我们再来看看多个协程并发执行的例子。</p><pre><code class="language-plain">// 代码段2\n\nfun main() = runBlocking {\n    var i = 0\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    // 重复十次\n    repeat(10){\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                i++\n            }\n        }\n        jobs.add(job)\n    }\n\n    // 等待计算完成\n    jobs.joinAll()\n\n    println("i = $i")\n}\n/*\n输出结果\ni = 9972\n*/\n</code></pre><p>在上面的代码中，我创建了10个协程任务，每个协程任务都会工作在Default线程池，这10个协程任务，都会分别对i进行1000次自增操作。如果一切正常的话，代码的输出结果应该是10000。但如果你实际运行这段代码，你会发现结果大概率不会是10000。</p><p>出现这个问题的原因也很简单，这10个协程分别运行在不同的线程之上，与此同时，这10个协程之间还共享着i这个变量，并且它们还会以并发的形式对i进行自增，所以自然就会产生同步的问题。</p><blockquote>\n<p>补充：为了不偏离主题，这里我们不去深究出现这个问题的底层原因。这涉及到Java内存模型之类的底层细节，如果你不熟悉Java并发相关的知识点，可以自行去做一些了解。</p>\n</blockquote><p>所以在这里，我们就可以回答这节课标题里的问题了：<strong>Kotlin协程也需要处理多线程同步的问题</strong>。</p><p>那么下面，我们就以这个简单的代码为例，一起来分析下Kotlin协程面对并发时，都有哪些可用的手段。</p><h2>借鉴Java的并发思路</h2><p>首先，由于Kotlin协程也是基于JVM的，所以，当我们面对并发问题的时候，脑子里第一时间想到的肯定是Java当中的同步手段，比如synchronized、Atomic、Lock，等等。</p><p>在Java当中，最简单的同步方式就是synchronized同步了。那么换到Kotlin里，我们就可以使用 <strong>@Synchronized注解</strong>来修饰函数，也可以使用 <strong>synchronized(){}</strong> 的方式来实现同步代码块。</p><p>让我们用synchronized来改造一下上面的代码段2：</p><pre><code class="language-plain">// 代码段3\n\nfun main() = runBlocking {\n    var i = 0\n    val lock = Any() // 变化在这里\n\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10){\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                // 变化在这里\n                synchronized(lock) {\n                    i++\n                }\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n\n/*\n输出结果\ni = 10000\n*/\n</code></pre><p>以上代码中，我们创建了一个lock对象，然后使用synchronized(){} 将“i++”包裹了起来。这样就可以确保在自增的过程中不会出现同步问题。这时候，如果你再来运行代码，就会发现结果已经是10000了。</p><p>不过，如果你在实际生产环境使用过协程的话，应该会感觉synchronized在协程当中也不是一直都很好用的。毕竟，<strong>synchronized是线程模型下的产物</strong>。</p><p>就比如说，假设我们这里的自增操作需要一些额外的操作，需要用到挂起函数prepare()。</p><pre><code class="language-plain">// 代码段4\n\nfun main() = runBlocking {\n    suspend fun prepare(){\n        // 模拟准备工作\n    }\n    var i = 0\n    val lock = Any()\n\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10){\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                synchronized(lock) {\n                    // 编译器报错！\n                    prepare()\n                    i++\n                }\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n</code></pre><p>这时候，你就不能天真地把协程看作是“Java线程池的封装”，然后继续照搬Java的同步手段了。你会发现：<strong>synchronized(){} 当中调用挂起函数，编译器会给你报错！</strong></p><p>这是为什么呢？其实，如果你理解了<a href="https://time.geekbang.org/column/article/487085">第15讲</a>当中“协程挂起恢复”的思维模型的话，那么编译器报错的原因你一定可以轻松理解。因为这里的挂起函数会被翻译成带有Continuation的异步函数，从而就造成了synchronid代码块无法正确处理同步。</p><p>另外从这个例子里，我们也可以看出：即使Kotlin协程是基于Java线程的，但它其实已经脱离Java原本的范畴了。所以，单纯使用Java的同步手段，是无法解决Kotlin协程里所有问题的。</p><p>那么接下来，我们就来看看Kotlin协程当中的并发思路。</p><h2>协程的并发思路</h2><p>前面我也提到过，由于Java的线程模型是阻塞式的，比如说Thread.sleep()，所以在Java当中，并发往往就意味着多线程，而多线程则往往会有状态共享，而状态共享就意味着要处理同步问题。</p><p>但是，因为Kotlin协程具备挂起、恢复的能力，而且还有非阻塞的特点，所以在使用协程处理并发问题的时候，我们的思路其实可以更宽。比如，我们可以使用<strong>单线程并发</strong>。</p><h3>单线程并发</h3><p>在Kotlin当中，单线程并发的实现其实非常轻松。不过如果你有Java经验的话，也许会对这个说法产生疑问，因为在Java当中，并发往往就意味着多线程。</p><p>实际上，在<a href="https://time.geekbang.org/column/article/487930">第16讲</a>里我们就涉及到“单线程并发”这个概念了。让我们回过头，重新看看那段并发的代码。</p><pre><code class="language-plain">// 代码段5\nfun main() = runBlocking {\n    suspend fun getResult1(): String {\n        logX("Start getResult1")\n        delay(1000L) // 模拟耗时操作\n        logX("End getResult1")\n        return "Result1"\n    }\n\n    suspend fun getResult2(): String {\n        logX("Start getResult2")\n        delay(1000L) // 模拟耗时操作\n        logX("End getResult2")\n        return "Result2"\n    }\n\n    suspend fun getResult3(): String {\n        logX("Start getResult3")\n        delay(1000L) // 模拟耗时操作\n        logX("End getResult3")\n        return "Result3"\n    }\n\n    val results: List&lt;String&gt;\n\n    val time = measureTimeMillis {\n        val result1 = async { getResult1() }\n        val result2 = async { getResult2() }\n        val result3 = async { getResult3() }\n\n        results = listOf(result1.await(), result2.await(), result3.await())\n    }\n\n    println("Time: $time")\n    println(results)\n}\n\n/*\n输出结果\n================================\nStart getResult1\nThread:main\n================================\n================================\nStart getResult2\nThread:main\n================================\n================================\nStart getResult3\nThread:main\n================================\n================================\nEnd getResult1\nThread:main\n================================\n================================\nEnd getResult2\nThread:main\n================================\n================================\nEnd getResult3\nThread:main\n================================\nTime: 1066\n[Result1, Result2, Result3]\n*/\n</code></pre><p>在上面的代码中启动了三个协程，它们之间是并发执行的，每个协程执行耗时是1000毫秒，程序总耗时也是接近1000毫秒。而且，这几个协程是运行在同一个线程main之上的。</p><p>所以，当我们在协程中面临并发问题的时候，首先可以考虑：<strong>是否真的需要多线程</strong>？如果不需要的话，其实是可以不考虑多线程同步问题的。</p><p>那么，对于前面代码段2的例子来说，我们则可以把计算的逻辑分发到单一的线程之上。</p><pre><code class="language-plain">// 代码段6\nfun main() = runBlocking {\n    val mySingleDispatcher = Executors.newSingleThreadExecutor {\n        Thread(it, "MySingleThread").apply { isDaemon = true }\n    }.asCoroutineDispatcher()\n\n    var i = 0\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10) {\n        val job = launch(mySingleDispatcher) {\n            repeat(1000) {\n                i++\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n\n/*\n输出结果\ni = 10000\n*/\n</code></pre><p>可见，在这段代码中，我们使用“launch(mySingleDispatcher)”，把所有的协程任务都分发到了单线程的Dispatcher当中，这样一来，我们就不必担心同步问题了。另外，如果仔细分析的话，上面创建的10个协程之间，其实仍然是并发执行的。</p><p>所以这时候，如果你运行上面的代码，就一定可以得到正确的结果了：i = 10000。</p><h3>Mutex</h3><p>在Java当中，其实还有Lock之类的同步锁。但由于Java的锁是阻塞式的，会大大影响协程的非阻塞式的特性。所以，在Kotlin协程当中，我们也是<strong>不推荐</strong>直接使用传统的同步锁的，甚至在某些场景下，在协程中使用Java的锁也会遇到意想不到的问题。</p><p>为此，Kotlin官方提供了“非阻塞式”的锁：Mutex。下面我们就来看看，如何用Mutex来改造代码段2。</p><pre><code class="language-plain">// 代码段7\n\nfun main() = runBlocking {\n    val mutex = Mutex()\n\n    var i = 0\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10) {\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                // 变化在这里\n                mutex.lock()\n                i++\n                mutex.unlock()\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n</code></pre><p>在上面的代码中，我们使用mutex.lock()、mutex.unlock()包裹了需要同步的计算逻辑，这样一来，代码就可以实现多线程同步了，程序的输出结果也会是10000。</p><p>实际上，Mutex对比JDK当中的锁，最大的优势就在于<strong>支持挂起和恢复</strong>。让我们来看看它的源码定义：</p><pre><code class="language-plain">// 代码段8\npublic interface Mutex {\n    public val isLocked: Boolean\n\n    //     注意这里\n    //        ↓\n    public suspend fun lock(owner: Any? = null)\n\n    public fun unlock(owner: Any? = null)\n}\n</code></pre><p>可以看到，Mutex是一个接口，它的lock()方法其实是一个挂起函数。而这就是实现非阻塞式同步锁的根本原因。</p><p>不过，在代码段7当中，我们对于Mutex的使用其实是<strong>错误</strong>的。因为这样的做法并不安全，我们可以来看一个场景：</p><pre><code class="language-plain">// 代码段9\nfun main() = runBlocking {\n    val mutex = Mutex()\n\n    var i = 0\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10) {\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                try {\n                    mutex.lock()\n                    i++\n                    i/0 // 故意制造异常\n                    mutex.unlock()\n                } catch (e: Exception) {\n                    println(e)\n                }\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n\n// 程序无法退出\n</code></pre><p>以上代码会在mutex.lock()、mutex.unlock()之间发生异常，从而导致mutex.unlock()无法被调用。这个时候，整个程序的执行流程就会一直卡住，无法结束。</p><p>所以，为了避免出现这样的问题，我们应该使用Kotlin提供的一个扩展函数：<strong>mutex.withLock{}</strong>。</p><pre><code class="language-plain">// 代码段10\nfun main() = runBlocking {\n    val mutex = Mutex()\n\n    var i = 0\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10) {\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                // 变化在这里\n                mutex.withLock {\n                    i++\n                }\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    println("i = $i")\n}\n\n// withLock的定义\npublic suspend inline fun &lt;T&gt; Mutex.withLock(owner: Any? = null, action: () -&gt; T): T {\n    lock(owner)\n    try {\n        return action()\n    } finally {\n        unlock(owner)\n    }\n}\n</code></pre><p>可以看到，withLock{} 的本质，其实是在finally{} 当中调用了unlock()。这样一来，我们就再也不必担心因为异常导致unlock()无法执行的问题了。</p><h3>Actor</h3><p>Actor，其实是在很多编程语言当中都存在的一个并发同步模型。在Kotlin当中，也同样存在这样的模型，它本质上是<strong>基于Channel管道消息实现</strong>的。下面我们还是来看一个例子：</p><pre><code class="language-plain">// 代码段11\n\nsealed class Msg\nobject AddMsg : Msg()\n\nclass ResultMsg(\n    val result: CompletableDeferred&lt;Int&gt;\n) : Msg()\n\nfun main() = runBlocking {\n\n    suspend fun addActor() = actor&lt;Msg&gt; {\n        var counter = 0\n        for (msg in channel) {\n            when (msg) {\n                is AddMsg -&gt; counter++\n                is ResultMsg -&gt; msg.result.complete(counter)\n            }\n        }\n    }\n\n    val actor = addActor()\n    val jobs = mutableListOf&lt;Job&gt;()\n\n    repeat(10) {\n        val job = launch(Dispatchers.Default) {\n            repeat(1000) {\n                actor.send(AddMsg)\n            }\n        }\n        jobs.add(job)\n    }\n\n    jobs.joinAll()\n\n    val deferred = CompletableDeferred&lt;Int&gt;()\n    actor.send(ResultMsg(deferred))\n\n    val result = deferred.await()\n    actor.close()\n\n    println("i = ${result}")\n}\n</code></pre><p>在这段代码中，我们定义了addActor()这个挂起函数，而它其实调用了actor()这个高阶函数。而这个函数的返回值类型其实是SendChannel。由此可见，<strong>Kotlin当中的Actor其实就是Channel的简单封装。</strong>Actor的多线程同步能力都源自于Channel。</p><p>这里，我们借助<strong>密封类</strong>定义了两种消息类型，AddMsg、ResultMsg，然后在 <strong>actor{} 内部</strong>，我们处理这两种消息类型，如果我们收到了AddMsg，则计算“i++”；如果收到了ResultMsg，则返回计算结果。</p><p>而在 <strong>actor{} 的外部</strong>，我们则只需要发送10000次的AddMsg消息，最后再发送一次ResultMsg，取回计算结果即可。</p><p>由于Actor的结构比较抽象，这里我做了一个小视频，帮你更好地理解它。</p><p><video poster="https://media001.geekbang.org/94a3b8083e7f428e817a7ecfeb8f2fb3/snapshots/170fe600563c4d4b85931d38f1104488-00003.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/25ef039e-17f6a52beb8-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/65bb9afd6425435cbab90453cdf2d3eb/6e571ecc5ba24ba7b17a1bfbf81062fc-0e76857a0db4b9466e7ae1f64e80426e-sd.m3u8" type="application/x-mpegURL"></video></p><p>需要注意的是，虽然在上面的演示视频中，AddMsg、ResultMsg是串行发送的，但实际上，它们是在多线程并行发送的，而Channel可以保证接收到的消息可以同步接收并处理。</p><p>这也就证明了我们前面的说法：Actor本质上是基于Channel管道消息实现的。</p><blockquote>\n<p>补充：Kotlin目前的Actor实现其实还比较简陋，在不远的将来，Kotlin官方会对Actor API进行重构，具体可以参考这个<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/87">链接</a>。虽然它的API可能会改变，但我相信它的核心理念是不会变的。</p>\n</blockquote><p>好，到现在为止，我们已经学习了三种协程并发的思路。不过我们还要反思一个问题：<strong>多线程并发，一定需要同步机制吗？</strong></p><h2>反思：可变状态</h2><p>前面我们提到过，多线程并发，往往会有共享的可变状态，而共享可变状态的时候，就需要考虑同步问题。</p><p>弄清楚这一点后，我们其实会找到一个新的思路：<strong>避免共享可变状态</strong>。有了这个思路以后，我们的代码其实就非常容易实现了：</p><pre><code class="language-plain">// 代码段12\n\nfun main() = runBlocking {\n    val deferreds = mutableListOf&lt;Deferred&lt;Int&gt;&gt;()\n\n    repeat(10) {\n        val deferred = async (Dispatchers.Default) {\n            var i = 0\n            repeat(1000) {\n                    i++\n            }\n            return@async i\n        }\n        deferreds.add(deferred)\n    }\n\n    var result = 0\n    deferreds.forEach {\n        result += it.await()\n    }\n\n    println("i = $result")\n}\n</code></pre><p>在上面的代码中，我们不再共享可变状态i，对应的，在每一个协程当中，都有一个局部的变量i，同时将launch都改为了async，让每一个协程都可以返回计算结果。</p><p>这种方式，相当于将10000次计算，平均分配给了10个协程，让它们各自计算1000次。这样一来，每个协程都可以进行独立的计算，然后我们将10个协程的结果汇总起来，最后累加在一起。</p><p>其实，我们上面的思路，也是借鉴自函数式编程的思想，因为在函数式编程当中，就是追求<strong>不变性、无副作用</strong>。不过，以上代码其实还是命令式的代码，如果我们用函数式风格来重构的话，代码会更加简洁。</p><pre><code class="language-plain">// 代码段13\n\nfun main() = runBlocking {\n    val result = (1..10).map {\n        async (Dispatchers.Default) {\n            var i = 0\n            repeat(1000) {\n                i++\n            }\n            return@async i\n        }\n    }.awaitAll()\n        .sum()\n\n    println("i = $result")\n}\n</code></pre><p>上面的代码中，我们使用函数式风格代码重构了代码段12，我们仍然创建了10个协程，并发了计算了10000次自增操作。</p><p>在加餐一当中，我曾提到过，函数式编程的一大优势就在于，它具有不变性、无副作用的特点，所以<strong>无惧并发编程</strong>。上面的这个代码案例，其实就体现出了Kotlin函数式编程的这个优势。</p><h2>小结</h2><p>这节课，我们学习了Kotlin协程解决并发的两大思路，分别是Java思路、协程思路。要注意，对于Java当中的同步手段，我们并不能直接照搬到Kotlin协程当中来，其中最大的问题，就是 <strong>synchronized不支持挂起函数。</strong></p><p>而对于协程并发手段，我也给你介绍了4种手段，这些你都需要掌握好。</p><ul>\n<li>第一种手段，<strong>单线程并发</strong>，在Java世界里，并发往往意味着多线程，但在Kotlin协程当中，我们可以轻松实现单线程并发，这时候我们就不用担心多线程同步的问题了。</li>\n<li>第二种手段，Kotlin官方提供的协程同步锁，<strong>Mutex</strong>，由于它的lock方法是挂起函数，所以它跟JDK当中的锁不一样，Mutex是非阻塞的。需要注意的是，我们在使用Mutex的时候，应该使用withLock{} 这个高阶函数，而不是直接使用lock()、unlock()。</li>\n<li>第三种手段，Kotlin官方提供的<strong>Actor</strong>，这是一种普遍存在的并发模型。在目前的版本当中，Kotlin的Actor只是Channel的简单封装，它的API会在未来的版本发生改变。</li>\n<li>第四种手段，借助<strong>函数式思维</strong>。我们之所以需要处理多线程同步问题，主要还是因为存在<strong>共享的可变状态</strong>。其实，共享可变状态，既不符合<strong>无副作用</strong>的特性，也不符合<strong>不变性</strong>的特性。当我们借助函数式编程思维，实现无副作用和不变性以后，并发代码也会随之变得安全。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/99/c2/99497ab151d77415c3fd2f5fc2fyy0c2.jpg?wh=2000x897" alt=""></p><h2>思考题</h2><p>Kotlin提供的Mutex，它会比JDK的锁性能更好吗？为什么？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "22 | 并发：协程不需要处理同步吗？",
      },
      {
        title: "24 | 实战：让KtHttp支持Flow",
        id: 494526,
        content:
          '<p>你好，我是朱涛。又到了熟悉的实战环节，这一次我们接着来改造KtHttp，让它能够支持协程的Flow API。</p><p>有了前面两次实战的基础，这次我们应该就轻车熟路了。在之前的<a href="https://time.geekbang.org/column/article/488985">4.0版本</a>中，为了让KtHttp支持挂起函数，我们有两种思路，一种是<strong>改造内部</strong>，另一种是<strong>扩展外部</strong>。同理，为了让KtHttp支持Flow，这次的实战也是这两种思路。</p><p>因此，这节课我们仍然会分为两个版本。</p><ul>\n<li>5.0版本，基于4.0版本的代码，从KtHttp的<strong>外部扩展</strong>出Flow的能力。</li>\n<li>6.0版本，<strong>修改KtHttp内部</strong>，让它支持Flow API。</li>\n</ul><p>其实在实际的工作中，我们往往没有权限修改第三方提供的SDK，那么这时候，如果想要让SDK获得Flow的能力，我们就只能借助Kotlin的扩展函数，为它<strong>扩展</strong>出Flow的能力。而对于工程内部的代码，我们希望某个功能模块获得Flow的能力，就可以<strong>直接修改它的源代码</strong>，让它直接支持Flow。</p><p>那么在这节课里，我会同时用这两种手段来扩展并改造KtHttp，为你演示其中的关键步骤。在这个过程中，我也会为你讲解其中的常见误区和陷阱，这样一来，你就可以放心地将Flow应用到你的实际工作中了。</p><p>OK，让我们正式开始吧！</p><h2>5.0版本：Callback转Flow</h2><!-- [[[read_end]]] --><p>在上次的实战课当中，我们在3.0版本里，实现了KtHttp的异步Callback请求。之后在4.0版本里，我们并没有改动KtHttp的源代码，而是直接在KtCall的基础上扩展了<strong>挂起函数</strong>的支持。让我们重新回顾一下之前的代码：</p><pre><code class="language-plain">// 代码段1\n\n// 扩展函数\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n//      暴露挂起函数的continuation\n//              ↓\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                println("Request success!")\n                continuation.resume(data)\n            }\n\n            override fun onFail(throwable: Throwable) {\n                println("Request fail!：$throwable")\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n//          响应取消事件\n//              ↓\n        continuation.invokeOnCancellation {\n            println("Call cancelled!")\n            call.cancel()\n        }\n    }\n</code></pre><p>我们知道，上面这种做法非常适合针对第三方SDK的扩展，而这一切，都要归功于Kotlin的<strong>扩展函数</strong>特性。那么这节课里，我们希望KtHttp支持Flow，其实也同样可以借助扩展函数来实现。Kotlin官方提供了一个API：<strong>callbackFlow</strong>，它就是专门用于将Callback转为Flow的。</p><p>Callback转Flow，用法跟Callback转挂起函数是差不多的。如果你去分析代码段1当中的代码模式，会发现Callback转挂起函数，主要有三个步骤。</p><ul>\n<li>第一步：使用suspendCancellableCoroutine执行Callback代码，等待Callback回调；</li>\n<li>第二步：将Callback回调结果传出去，onSuccess的情况就传结果，onFail的情况就传异常；</li>\n<li>第三步：响应协程取消事件invokeOnCancellation{}。</li>\n</ul><p>所以使用callbackFlow，也是这样三个步骤。如果你看过Google官方写的<a href="https://developer.android.com/kotlin/flow#callback">文档</a>，你可能会写出这样的代码：</p><pre><code class="language-plain">// 代码段2\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    // 调用Callback\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            // 1，传递成功数据，报错！\n            offer(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            // 2，传递失败数据\n            close(throwable)\n        }\n\n    })\n\n    // 3，响应协程取消\n    awaitClose {\n        call.cancel()\n    }\n}\n</code></pre><p>在这段代码里，callbackFlow的使用步骤也是分了三步。不过，由于Google官方写的文档已经有些过时了，如果你按照文档来写，会发现注释1处的代码其实会报错，IDE会提示应该使用trySend()替代offer()。</p><p>所以我们要再来改一改：</p><pre><code class="language-plain">// 代码段3\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            // 1\n            trySend(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            // 2\n            close(throwable)\n        }\n\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n</code></pre><p>那么从上面的代码中，你会发现，callbackFlow的底层用到了Channel，所以你才可以使用trySend()这样的API。这个API我在<a href="https://time.geekbang.org/column/article/491021">第19讲</a>里提到过，它其实就是Channel.send()的<strong>非挂起函数</strong>版本的API。</p><p>这样改完以后，我们的代码就已经没有明显报错了。但，它仍然还有优化空间，对应的地方我已经用注释标记出来了。</p><p>我们来看一下注释1，这里使用trySend()，虽然在这个案例当中用这个API确实没问题，但在大部分场景下，它其实是不够稳妥的。你可以查看一下它的源码文档，会看到它的返回值类型是<strong>ChannelResult</strong>，代表trySend()的执行结果是成功还是失败。</p><pre><code class="language-plain">// 代码段4\npublic fun trySend(element: E): ChannelResult&lt;Unit&gt;\n</code></pre><p>也就是说，如果我们往Channel当中成功地添加了元素，那么trySend()的返回值就是成功，如果当前的Channel管道已经满了，那么trySend()的返回值就是失败。</p><p>其实，当Channel管道容量已满的时候，我们更希望trySend()可以多等等，直到管道容量空闲以后再返回成功。所以这时候，我们可以使用 <strong>trySendBlocking()</strong> 来替代它。它是Kotlin协程1.5出现的一个新的API。</p><pre><code class="language-plain">// 代码段5\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            // 1，变化在这里\n            trySendBlocking(data)\n        }\n\n        override fun onFail(throwable: Throwable) {\n            // 2\n            close(throwable)\n        }\n\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n</code></pre><p>不过，这里我们仅仅只是改为trySendBlocking()仍然还不够，让我们来运行一下程序，看看问题出在哪里：</p><pre><code class="language-plain">// 代码段6\n\ninterface ApiServiceV5 {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): KtCall&lt;RepoList&gt;\n}\n\nfun main() = runBlocking {\n    testFlow()\n}\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .repos(lang = "Kotlin", since = "weekly")\n        .asFlow()\n        .catch { println("Catch: $it") }\n        .collect {\n        println(it)\n    }\n\n\n\n/*\n输出正常\n程序不会终止\n*/\n</code></pre><p>其实，问题的原因也很简单，由于callbackFlow的底层是Channel实现的，在我们用完它以后，应该主动将其关闭或者释放。不然的话，它就会一直<strong>占用计算机资源</strong>。所以这时候，我们可以进一步完善trySendBlocking()这部分的代码。</p><pre><code class="language-plain">// 代码段7\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            // 1，变化在这里\n            trySendBlocking(data)\n                .onSuccess { close() }\n                .onFailure { close(it) }\n        }\n\n        override fun onFail(throwable: Throwable) {\n            close(throwable)\n        }\n\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n\n/*\n输出结果\n输出正常\n程序等待一会后自动终止\n*/\n</code></pre><p>上面代码中的onSuccess、onFailure其实就相当于回调，在这里，不管是成功还是失败，我们都主动把callbackFlow当中的Channel关闭。这样一来，程序就可以正常终止了。</p><blockquote>\n<p>提示：在大部分场景下trySendBlocking()会比trySend()更稳妥一些，因为它会尽可能发送成功。但在某些特殊情况下，trySend()也有它的优势，因为它不会出现阻塞问题。</p>\n</blockquote><p>好，现在，5.0版本的代码其实就已经算是合格了。不过，我还想给你介绍下callbackFlow的一些使用细节：<strong>close()与close(throwable)</strong>。</p><p>close()这个方法，我们既可以传入异常，也可以不传入。不过，这两者在callbackFlow当中是有差异的。如果你将代码段7当中所有的close(throwable)都改为不传异常的话，程序代码也会出现问题。</p><pre><code class="language-plain">// 代码段8\n// 错误示范！错误示范！错误示范！\n\nfun main() = runBlocking {\n    testFlow()\n}\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .repos(lang = "Kotlin", since = "weekly")\n        .asFlow()\n        .catch { println("Catch: $it") }\n        .collect {\n            println(it)\n        }\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            trySendBlocking(data)\n                .onSuccess { close() }\n                .onFailure {\n                    // 变化在这里\n                    close()\n                }\n        }\n\n        override fun onFail(throwable: Throwable) {\n            // 变化在这里\n            close()\n        }\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n\n/*\n断网执行以上代码：\n不会有任何结果，连异常信息都没有\n*/\n</code></pre><p>在以上代码中，我们断网执行了这段程序，但在控制台上看不到任何异常的输出信息。这就是因为，我们调用close()的时候没有传入异常信息。</p><p>所以，在callbackFlow当中的异常分支里，我们如果使用close()，一定要<strong>带上对应的异常</strong>，就像代码段7的那样“close(throwable)”。或者，为了防止在开发的过程中忘记传入异常信息，我们可以使用 <strong>cancel()方法</strong>。就像下面这样：</p><pre><code class="language-plain">// 代码段9\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            trySendBlocking(data)\n                .onSuccess { close() }\n                .onFailure {\n                    // 变化在这里\n                    cancel(CancellationException("Send channel fail!", it))\n                }\n        }\n\n        override fun onFail(throwable: Throwable) {\n            // 变化在这里\n            cancel(CancellationException("Request fail!", throwable))\n        }\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n\n/*\n断网执行\nCatch: java.util.concurrent.CancellationException: Request fail!\n*/\n</code></pre><p>根据这里的运行结果，我们可以看到，把close()改成cancel()以后，程序运行结果也符合预期。而cancel其实还有一个优势：就算不小心忘记传throwable，我们还是可以看到一个CancellationException。</p><p>不过总的来说，只要我们可以记住传入异常信息，close()和cancel()两者的差别并不大。</p><p>另外还有一点，如果我们在callbackFlow当中还启动了其他的协程任务，close()和cancel()也同样可以取消对应的协程。如下所示：</p><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    testFlow()\n}\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .repos(lang = "Kotlin", since = "weekly")\n        .asFlow() // 注意这里\n        .catch { println("Catch: $it") }\n        .collect {\n        println(it)\n    }\n\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n\n    val job = launch {\n        println("Coroutine start")\n        delay(3000L)\n        println("Coroutine end") // 没有机会执行\n    }\n\n    job.invokeOnCompletion {\n        println("Coroutine completed $it")\n    }\n\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            trySendBlocking(data)\n                .onSuccess { close() }\n                .onFailure {\n                    cancel(CancellationException("Send channel fail!", it))\n                }\n        }\n\n        override fun onFail(throwable: Throwable) {\n            cancel(CancellationException("Request fail!", throwable))\n        }\n    })\n\n    awaitClose {\n        call.cancel()\n    }\n}\n\n/*\n断网执行\nCoroutine start\nCoroutine completed java.util.concurrent.CancellationException: Request fail!\nCatch: java.util.concurrent.CancellationException: Request fail!\n*/\n</code></pre><p>可以看到，由于协程是结构化的，所以，当我们取消callbackFlow的时候，在它内部创建的协程job，也会跟着被取消。而且，它的异常信息也是一样的。</p><p>不过，如果我们把上面的launch{} 改成了“launch(Job()){}”，那么，协程任务就不会跟随callbackFlow一起被取消了。我相信，如果你还记得上节课讲的第二条准则，那你一定可以轻松理解这句话。因为，<strong>它们的协程的父子关系已经被破坏了</strong>！</p><p>最后，我还想再提一下 <strong>awaitClose{}</strong> 这个挂起函数，它的作用其实就是监听callbackFlow的生命周期，当它被关闭或者取消的时候，我们应该同时把OkHttp当中的网络请求也取消掉。它的作用，跟代码段1当中的continuation.invokeOnCancellation{} 是类似的。</p><p>好，callbackFlow的用法我们就讲解完了，有了它，以后我们就可以轻松地把第三方SDK的Callback扩展成Flow了。</p><p>那么接下来，我们就进入6.0版本的开发吧！</p><h2>6.0版本：直接支持Flow</h2><p>实际上，对于KtHttp来说，4.0版本、5.0版本都只是外部扩展，我们对KtHttp的内部源代码并没有做改动。</p><p>而对于6.0版本的开发，我们其实是希望KtHttp可以直接支持返回Flow类型的数据，也就是这样：</p><pre><code class="language-plain">// 代码段11\n\ninterface ApiServiceV5 {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): KtCall&lt;RepoList&gt;\n\n    @GET("/repo")\n    fun reposFlow(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): Flow&lt;RepoList&gt; // 注意这里\n}\n</code></pre><p>请你留意上面的代码注释，在ApiServiceV5当中，我定义了一个接口方法reposFlow()，它的返回值类型是 <code>Flow&lt;RepoList&gt;</code>，而不是之前的 <code>KtCall&lt;RepoList&gt;</code>。这样一来，我们在main()函数当中使用它的时候，就不需要使用asFlow()这个扩展函数了。就像下面这样：</p><pre><code class="language-plain">// 代码段12\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .reposFlow(lang = "Kotlin", since = "weekly")\n        // 注意这里不需要asFlow，因为reposFlow()返回值类型就是Flow\n        .catch { println("Catch: $it") }\n        .collect {\n            println(it)\n        }\n\nfun main() = runBlocking {\n    testFlow()\n}\n</code></pre><p>可以看到，当我们把reposFlow()的返回值类型定义成 <code>Flow&lt;RepoList&gt;</code> 以后，就需要改动KtHttp的源代码了。因为，它的内部需要根据这种情况做一些特殊的判断。</p><p>其实，在前面3.0版本的开发中，我们就已经做过一次判断了。当时，我们特地判断了一下，返回值类型是 <code>KtCall&lt;T&gt;</code> 还是<code>T</code>。让我们来重新回顾一下当时的代码细节：</p><pre><code class="language-plain">// 代码段13\n\nprivate fun &lt;T: Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 省略部分代码\n    return if (isKtCallReturn(method)) {\n        // 返回值类型是KtCall&lt;RepoList&gt;\n\n        val genericReturnType = getTypeArgument(method)\n        KtCall&lt;T&gt;(call, gson, genericReturnType)\n    } else {\n        // 返回值类型是 RepoList\n\n        val response = okHttpClient.newCall(request).execute()\n        val genericReturnType = method.genericReturnType\n        val json = response.body?.string()\n        gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n    }\n}\n</code></pre><p>看到上面的代码，相信你马上就能想明白了，如果要支持Flow，我们只需要在这里判断一下，返回值类型是不是 <code>Flow&lt;T&gt;</code> 即可。比如说：</p><pre><code class="language-plain">// 代码段14\n\nprivate fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 省略部分代码\n    return when {\n        isKtCallReturn(method) -&gt; {\n            val genericReturnType = getTypeArgument(method)\n            KtCall&lt;T&gt;(call, gson, genericReturnType)\n        }\n        isFlowReturn(method) -&gt; {\n            // 直接返回Flow\n            flow&lt;T&gt; {\n                // 请求API\n                val genericReturnType = getTypeArgument(method)\n                val response = okHttpClient.newCall(request).execute()\n                val json = response.body?.string()\n                val result = gson.fromJson&lt;T&gt;(json, genericReturnType)\n\n                // 传出结果\n                emit(result)\n\n            }\n        }\n        else -&gt; {\n            val response = okHttpClient.newCall(request).execute()\n\n            val genericReturnType = method.genericReturnType\n            val json = response.body?.string()\n            gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n        }\n    }\n}\n\n// 判断返回值类型是不是 Flow&lt;T&gt;\nprivate fun isFlowReturn(method: Method) =\n        getRawType(method.genericReturnType) == Flow::class.java\n</code></pre><p>由于代码段13当中已经有了if、else两个条件分支了，再增加一个分支的话，我们选择了when表达式。这里，我们增加了一个isFlowReturn(method)的分支，意思就是判断返回值类型是不是Flow，如果是的话，我们就直接使用flow{} 创建一个Flow返回了。</p><p>至此，我们6.0版本的开发工作，其实就已经完成了。是不是觉得非常轻松？<strong>对比起Callback转Flow，让KtHttp直接支持Flow确实要简单很多</strong>。从这一点上，我们也可以看到Flow的强大和易用性。</p><p>那么在这时候，我们就可以写一些简单的测试代码，来验证我们的代码是否可靠了。</p><pre><code class="language-plain">// 代码段15\n\nprivate fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n    // 省略部分代码\n    return when {\n        isKtCallReturn(method) -&gt; {\n            val genericReturnType = getTypeArgument(method)\n            KtCall&lt;T&gt;(call, gson, genericReturnType)\n        }\n        isFlowReturn(method) -&gt; {\n            // 增加日志\n            logX("Start out")\n            flow&lt;T&gt; {\n                logX("Start in")\n                val genericReturnType = getTypeArgument(method)\n                val response = okHttpClient.newCall(request).execute()\n                val json = response.body?.string()\n                val result = gson.fromJson&lt;T&gt;(json, genericReturnType)\n                logX("Start emit")\n                emit(result)\n                logX("End emit")\n            }\n        }\n        else -&gt; {\n            val response = okHttpClient.newCall(request).execute()\n\n            val genericReturnType = method.genericReturnType\n            val json = response.body?.string()\n            gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n        }\n    }\n}\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .reposFlow(lang = "Kotlin", since = "weekly")\n        .flowOn(Dispatchers.IO) //切换线程\n        .catch { println("Catch: $it") }\n        .collect {\n            logX("${it.count}")\n        }\n/*\n输出结果\n================================\nStart out\nThread:main @coroutine#1\n================================\n================================\nStart in\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nStart emit\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\nEnd emit\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\n================================\n25\nThread:main @coroutine#1\n================================\n\n程序结束\n*/\n</code></pre><p>在上面的代码中，我们增加了一些日志，同时在调用处增加了“flowOn(Dispatchers.IO)”。可以看到，这样一来整个网络请求就执行在了DefaultDispatcher这个线程池当中，而其他部分的代码，仍然执行在main()线程。这也是符合预期的。</p><p>然后，我们可以通过断网来模拟出现异常的情况：</p><pre><code class="language-plain">// 代码段16\n\n/*\n输出结果：\n================================\nStart out\nThread:main @coroutine#1\n================================\n================================\nStart in\nThread:DefaultDispatcher-worker-1 @coroutine#2\n================================\nCatch: java.net.UnknownHostException:  nodename nor servname provided, or not known\n\n程序结束\n*/\n</code></pre><p>可以看到，程序的运行结果仍然是符合预期的。<br>\n下面，我们再来看看6.0完整的代码：</p><pre><code class="language-plain">// 代码段17\n\ninterface ApiServiceV5 {\n    @GET("/repo")\n    fun repos(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): KtCall&lt;RepoList&gt;\n\n    // 注释1\n    @GET("/repo")\n    fun reposFlow(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): Flow&lt;RepoList&gt;\n}\n\nobject KtHttpV5 {\n\n    private var okHttpClient: OkHttpClient = OkHttpClient()\n    private var gson: Gson = Gson()\n    var baseUrl = "https://baseUrl.com"\n\n    fun &lt;T : Any&gt; create(service: Class&lt;T&gt;): T {\n        return Proxy.newProxyInstance(\n            service.classLoader,\n            arrayOf&lt;Class&lt;*&gt;&gt;(service)\n        ) { proxy, method, args -&gt;\n            val annotations = method.annotations\n            for (annotation in annotations) {\n                if (annotation is GET) {\n                    val url = baseUrl + annotation.value\n                    return@newProxyInstance invoke&lt;T&gt;(url, method, args!!)\n                }\n            }\n            return@newProxyInstance null\n\n        } as T\n    }\n\n    private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        if (method.parameterAnnotations.size != args.size) return null\n\n        var url = path\n        val parameterAnnotations = method.parameterAnnotations\n        for (i in parameterAnnotations.indices) {\n            for (parameterAnnotation in parameterAnnotations[i]) {\n                if (parameterAnnotation is Field) {\n                    val key = parameterAnnotation.value\n                    val value = args[i].toString()\n                    if (!url.contains("?")) {\n                        url += "?$key=$value"\n                    } else {\n                        url += "&amp;$key=$value"\n                    }\n\n                }\n            }\n        }\n\n        val request = Request.Builder()\n            .url(url)\n            .build()\n\n        val call = okHttpClient.newCall(request)\n\n        return when {\n            isKtCallReturn(method) -&gt; {\n                val genericReturnType = getTypeArgument(method)\n                KtCall&lt;T&gt;(call, gson, genericReturnType)\n            }\n            isFlowReturn(method) -&gt; {\n                logX("Start out")\n\n                // 注释2\n                flow&lt;T&gt; {\n                    logX("Start in")\n                    val genericReturnType = getTypeArgument(method)\n                    val response = okHttpClient.newCall(request).execute()\n                    val json = response.body?.string()\n                    val result = gson.fromJson&lt;T&gt;(json, genericReturnType)\n                    logX("Start emit")\n                    emit(result)\n                    logX("End emit")\n                }\n            }\n            else -&gt; {\n                val response = okHttpClient.newCall(request).execute()\n\n                val genericReturnType = method.genericReturnType\n                val json = response.body?.string()\n                gson.fromJson&lt;Any?&gt;(json, genericReturnType)\n            }\n        }\n    }\n\n    private fun getTypeArgument(method: Method) =\n        (method.genericReturnType as ParameterizedType).actualTypeArguments[0]\n\n    private fun isKtCallReturn(method: Method) =\n        getRawType(method.genericReturnType) == KtCall::class.java\n\n    private fun isFlowReturn(method: Method) =\n        getRawType(method.genericReturnType) == Flow::class.java\n\n}\n\nfun main() = runBlocking {\n    testFlow()\n}\n\nprivate suspend fun testFlow() =\n    KtHttpV5.create(ApiServiceV5::class.java)\n        .reposFlow(lang = "Kotlin", since = "weekly")\n        .flowOn(Dispatchers.IO)\n        .catch { println("Catch: $it") }\n        .collect {\n            logX("${it.count}")\n        }\n</code></pre><p>最后，我们也再来分析一下，为什么6.0的代码可以这么简单。这里有两个关键的地方，我也分别用注释标记了。</p><p>请你留意注释1处的 <strong>reposFlow()</strong> 方法的定义，它其实是一个普通的函数，并不是挂起函数。换言之，虽然它的返回值类型是Flow，但我们并不要求它在协程当中被调用。</p><p>另外，请留意注释2处，<strong>flow{}</strong> 这个高阶函数，它也只是一个普通函数，同样也不是挂起函数，这就意味着，它可以在普通函数里面直接调用。我们可以看看flow{} 的定义：</p><pre><code class="language-plain">// 代码段18\n\n// 不是挂起函数\npublic fun &lt;T&gt; flow(@BuilderInference block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; = SafeFlow(block)\n</code></pre><p>所以，正因为以上这两点，就使得Flow的易用性非常高，还记得我们在<a href="https://time.geekbang.org/column/article/491632">第20讲</a>当中看过的那张Flow“上游、下游”的示意图吗？我们其实可以进一步完善它：</p><p><img src="https://static001.geekbang.org/resource/image/37/20/370553ac768913a0702fda89a85b8120.jpg?wh=2000x1125" alt=""></p><p>也就是说，对于Flow的<strong>上游、中间操作符</strong>而言，它们其实根本就不需要协程作用域，只有在下游调用collect{} 的时候，才需要协程作用域。</p><p>因此，我们前面在写main()函数的时候，也可以换成这样的写法：</p><pre><code class="language-plain">// 代码段19\nfun main() {\n    // 协程作用域外\n    val flow = KtHttpV5.create(ApiServiceV5::class.java)\n        .reposFlow(lang = "Kotlin", since = "weekly")\n        .flowOn(Dispatchers.IO)\n        .catch { println("Catch: $it") }\n\n    runBlocking {\n        // 协程作用域内\n        flow.collect {\n            logX("${it.count}")\n        }\n    }\n}\n</code></pre><p>可见，正因为Flow的上游不需要协程作用域，我们才可以轻松完成6.0版本的代码。</p><h2>小结</h2><p>这节实战课，为了让KtHttp支持Flow API，我们使用了两种方法。第一种，是从KtHttp的外部进行扩展，用这种思路，我们完成了5.0版本的开发；第二种，是修改KtHttp的内部，让ApiService当中的方法可以直接以Flow作为返回值类型，利用这种思路，我们完成了6.0的开发。</p><p>具体来说，我们是用到了这几个知识点，你可以重点关注一下：</p><ul>\n<li><strong>callbackFlow{}</strong>，它的作用就是把Callback转换成Flow。它的底层其实用到了Channel，因此，我们可以在callbackFlow{} 当中调用trySend()、trySendBlocking()，这两个方法都是Channel当中的“非挂起函数”的方法。需要注意的是，这里我们不能直接使用Channel的挂起函数send()，因为它必须要在协程体当中执行。</li>\n<li>在callbackFlow{} 里，出现异常的逻辑分支当中，如果我们需要关闭callbackFlow，那么在调用close()的时候，一定要传入对应的异常参数 <strong>close(throwable)</strong>。不然的话，Flow的下游就无法收到任何的异常信息。</li>\n<li>在callbackFlow{} 当中创建的<strong>协程任务</strong>，也可以跟随callbackFlow一同被取消，只要我们不打破它原有的协程父子关系。</li>\n<li>由于<strong>Flow的上游、中间操作符不需要协程作用域</strong>，因此，我们可以在非协程当中执行创建Flow。这就导致我们6.0版本的代码轻松就可以实现。</li>\n</ul><h2>思考题</h2><p>在5.0版本的代码中，awaitClose{} 的作用是响应协程的取消，同时取消OkHttp的请求。其实，它除了这个作用以外，还有另外一个作用。</p><p>你可以把5.0版本代码中的awaitClose删掉，看看会发生什么。对于这样的现象，你能想到awaitClose{} 的另一个作用吗？</p><pre><code class="language-plain">// 代码段20\nfun &lt;T : Any&gt; KtCall&lt;T&gt;.asFlow(): Flow&lt;T&gt; = callbackFlow {\n    val call = call(object : Callback&lt;T&gt; {\n        override fun onSuccess(data: T) {\n            trySendBlocking(data)\n                .onSuccess { close() }\n                .onFailure {\n                    cancel(CancellationException("Send channel fail!", it))\n                }\n        }\n\n        override fun onFail(throwable: Throwable) {\n            cancel(CancellationException("Request fail!", throwable))\n        }\n    })\n\n    // 注意这里\n    // awaitClose {\n    //     call.cancel()\n    // }\n}\n</code></pre>',
        article_title: "24 | 实战：让KtHttp支持Flow",
      },
    ],
  },
  {
    chapterTitle: "答疑篇",
    children: [
      {
        title: "答疑（一）| Java和Kotlin到底谁好谁坏？",
        id: 498437,
        content:
          '<p>你好，我是朱涛。</p><p>由于咱们课程的设计理念是简单易懂、贴近实际工作，所以我在课程内容的讲述上也会有一些侧重点，进而也会忽略一些细枝末节的知识点。不过，我看到很多同学都在留言区分享了自己的见解，算是对课程内容进行了很好的补充，这里给同学们点个赞，感谢你的仔细思考和认真学习。</p><p>另外，我看到不少同学提出的很多问题也都非常有价值，有些问题非常有深度，有些问题非常有实用性，有些问题则非常有代表性，这些问题也值得我们再一起探讨下。因此，这一次，我们来一次集中答疑。</p><h2>Java和Kotlin到底谁好谁坏？</h2><p>很多同学看完<a href="https://time.geekbang.org/column/article/472129">开篇词</a>以后，可能会留下一种印象，就是貌似Java就是坏的，Kotlin就是好的。但其实在我看来，语言之间是不存在明确的优劣之分的。“XX是世界上最好的编程语言”这种说法，也是没有任何意义的。</p><p>不过，虽然语言之间没有优劣之分，但在特定场景下，还是会有更优选择的。比如说，站在Android开发的角度上看，Kotlin就的确要比Java强很多；但如果换一个角度，服务端开发，Kotlin的优势则并不明显，因为Spring Boot之类的框架对Java的支持已经足够好了；甚至，如果我们再换一个角度，站在性能、编译期耗时的视角上看，Kotlin在某些情况下其实是略逊于Java的。</p><!-- [[[read_end]]] --><p>如果用发展的眼光来看待这个问题的话，其实这个问题根本不重要。Kotlin是一门基于JVM的语言，它更像是站在了巨人的肩膀上。<strong>Kotlin的设计思路就是“扬长避短”。</strong>Java的优点，Kotlin都可以拿过来；Java的缺点，Kotlin尽量都把它扔掉！这就是为什么很多人会说：Kotlin是一门更好的Java语言（Better Java）。</p><p>在开篇词里，我曾经提到过Java的一些问题：语法表现力差、可读性差，难维护、易出错、并发难。而这并不是说Java有多么不好，我想表达的其实是这两点：</p><ul>\n<li><strong>Java太老了</strong>。Java为了自身的兼容性，它的语法很难发展和演进，这才导致它在几十年后的今天看起来“语法表现力差”。</li>\n<li><strong>不是Java变差了，而是Kotlin做得更好了</strong>。因为Kotlin的理念就是扬长避短，因此，在Java特别容易出错的领域，Kotlin做了足够多的优化，比如内部类默认静态，比如不允许隐式的类型转换，比如挂起函数优化异步逻辑，等等。</li>\n</ul><p>所以，Kotlin一定就比Java好吗？结论是并不一定。但在大部分场景下，我会愿意选Kotlin。</p><h2>Double类型字面量</h2><p>在Java当中，我们会习惯性使用“1F”代表Float类型，“1D”代表Double类型。但是这一行为在Kotlin当中其实会略有不同，而我发现，很多同学都会下意识地把Java当中的经验带入到Kotlin（当然也包括我）。</p><pre><code class="language-plain">// 代码段1\n\nval i = 1F   // Float 类型\nval j = 1.0  // Double 类型\nval k = 1D   // 报错！！\n</code></pre><p>实际上，在Kotlin当中，要代表Double类型的字面量，我们只需要<strong>在数字末尾加上小数位</strong>即可。“1D”这种写法，在Kotlin当中是不被支持的，我们需要特别注意一下。</p><h2>逆序区间</h2><p>在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>里，我曾提到过：如果我们想要逆序迭代一个区间，不能使用“6…0”这种写法，因为这种写法的区间要求是：右边的数字大于等于左边的数字。</p><pre><code class="language-plain">// 代码段2\n\nfun main() {\n    for (i in 6..0) {\n        println(i) // 无法执行\n    }\n}\n</code></pre><p>在我们实际工作中，我们也许不会直接写出类似代码段2这样的逻辑，但是，当我们的区间范围变成变量以后，这个问题就没那么容易被发现了。比如我们可以看看下面这个例子：</p><pre><code class="language-plain">// 代码段3\n\nfun main() {\n    val start = calculateStart() // 6\n    val end = calculateEnd()     // 0\n    for (i in start..end) {\n        println(i)\n    }\n}\n</code></pre><p>在这段代码中，如果end小于start，我们就很难通过读代码发现问题了。所以在实际的开发工作中，我们其实应该慎重使用“start…end”的写法。如果我们不管是正序还是逆序都需要迭代的话，这时候，我们可以考虑封装一个全局的顶层函数：</p><pre><code class="language-plain">// 代码段4\n\nfun main() {\n    fun calculateStart(): Int = 6\n    fun calculateEnd(): Int = 0\n\n    val start = calculateStart()\n    val end = calculateEnd()\n    for (i in fromTo(start, end)) {\n        println(i) // end 小于start，无法执行\n    }\n}\n\nfun fromTo(start: Int, end: Int) =\n    if (start &lt;= end) start..end else start downTo end\n</code></pre><p>在上面的fromTo()当中，我们对区间的边界进行了简单的判断，如果左边界小于右边界，我们就使用逆序的方式迭代。</p><h2>密封类优势</h2><p>在<a href="https://time.geekbang.org/column/article/473349">第2讲</a>中，有不少同学觉得密封类不是特别好理解。在课程里，我们是拿密封类与枚举类进行对比来说明讲解的。我们知道，<strong>所谓枚举，就是一组有限数量的值</strong>。枚举的使用场景往往是某种事物的某些状态，比如，电视机有开关的状态，人类有女性和男性，等等。在Kotlin当中，同一个枚举，在内存当中是同一份引用。</p><pre><code class="language-plain">enum class Human {\n    MAN, WOMAN\n}\n\nfun main() {\n    println(Human.MAN == Human.MAN)\n    println(Human.MAN === Human.MAN)\n}\n\n输出\ntrue\ntrue\n</code></pre><p>那么<strong>密封类，其实是对枚举的一种补充</strong>。枚举类能做的事情，密封类也能做到：</p><pre><code class="language-plain">sealed class Human {\n    object MAN: Human()\n    object WOMAN: Human()\n}\n\nfun main() {\n    println(Human.MAN == Human.MAN)\n    println(Human.WOMAN === Human.WOMAN)\n}\n\n输出\ntrue\ntrue\n</code></pre><p>所以，密封类，也算是用了枚举的思想。但它跟枚举不一样的地方是：<strong>同一个父类的所有子类</strong>。举个例子，我们在IM消息当中，就可以定义一个BaseMsg，然后剩下的就是具体的消息子类型，比如文字消息TextMsg、图片消息ImageMsg、视频消息VideoMsg，这些子类消息的种类肯定是有限的。</p><p>而密封类的好处就在于，对于每一种消息类型，它们都可以携带各自的数据。</p><pre><code class="language-plain">// 代码段5\n\nsealed class BaseMsg {\n    //                密封类可以携带数据\n    //                       ↓\n    data class TextMsg(val text: String) : BaseMsg()\n    data class ImageMsg(val url: String) : BaseMsg()\n    data class VideoMsg(val url: String) : BaseMsg()\n}\n</code></pre><p>所以我们可以说：<strong>密封类，就是一组有限数量的子类</strong>。针对这里的子类，我们可以让它们创建不同的对象，这一点是枚举类无法做到的。</p><p>那么，<strong>使用密封类的第一个优势，</strong>就是如果我们哪天扩充了密封类的子类数量，所有密封类的使用处都会智能检测到，并且给出报错：</p><pre><code class="language-plain">// 代码段6\n\nsealed class BaseMsg {\n    data class TextMsg(val text: String) : BaseMsg()\n    data class ImageMsg(val url: String) : BaseMsg()\n    data class VideoMsg(val url: String) : BaseMsg()\n\n    // 增加了一个Gif消息\n    data class GisMsg(val url: String): BaseMsg()\n}\n\n// 报错！！\nfun display(data: BaseMsg): Unit = when(data) {\n    is BaseMsg.TextMsg -&gt; TODO()\n    is BaseMsg.ImageMsg -&gt; TODO()\n    is BaseMsg.VideoMsg -&gt; TODO()\n}\n</code></pre><p>上面的代码会报错，因为BaseMsg已经有4种子类型了，而when表达式当中只枚举了3种情况，所以它会报错。</p><p><strong>使用密封类的第二个优势</strong>在于，当我们扩充了子类型以后，IDE可以帮我们快速补充分支类型：</p><p><img src="https://static001.geekbang.org/resource/image/24/e6/24c3b78cd2e208f669f2804e7e9362e6.gif?wh=2088x1268" alt="图片"></p><p>不过，还有一点需要特别注意，那就是else分支。一旦我们在枚举密封类的时候使用了else分支，那我们前面提到的两个密封类的优势就会不复存在！</p><pre><code class="language-plain">sealed class BaseMsg {\n    data class TextMsg(val text: String) : BaseMsg()\n    data class ImageMsg(val url: String) : BaseMsg()\n    data class VideoMsg(val url: String) : BaseMsg()\n\n    // 增加了一个Gif消息\n    data class GisMsg(val url: String): BaseMsg()\n}\n\n// 不会报错\nfun display(data: BaseMsg): Unit = when(data) {\n    is BaseMsg.TextMsg -&gt; TODO()\n    is BaseMsg.ImageMsg -&gt; TODO()\n    // 注意这里\n    else -&gt; TODO()\n}\n</code></pre><p>请留意这里的display()方法，当我们只有三种消息类型的时候，我们可以在枚举了TextMsg、ImageMsg以后，使得else就代表VideoMsg。不过，一旦后续增加了GifMsg消息类型，这里的逻辑就会出错。而且，在这种情况下，我们的编译器还不会提示报错！</p><p>因此，<strong>在我们使用枚举或者密封类的时候，一定要慎重使用else分支。</strong></p><h2>枚举类的valueOf()</h2><p>另外，在使用Kotlin枚举类的时候，还有一个坑需要我们特别注意。在<a href="https://time.geekbang.org/column/article/473656">第4讲</a>实现的第一个版本的计算器里，我们使用了valueOf()尝试解析了操作符枚举类。而这只是理想状态下的代码，实际上，正确的方式应该使用2.0版本当中的方式。</p><pre><code class="language-plain">val help = """\n--------------------------------------\n使用说明：\n1. 输入 1 + 1，按回车，即可使用计算器；\n2. 注意：数字与符号之间要有空格；\n3. 想要退出程序，请输入：exit\n--------------------------------------""".trimIndent()\n\nfun main() {\n    while (true) {\n        println(help)\n\n        val input = readLine() ?: continue\n        if (input == "exit") exitProcess(0)\n\n        val inputList = input.split(" ")\n        val result = calculate(inputList)\n\n        if (result == null) {\n            println("输入格式不对")\n            continue\n        } else {\n            println("$input = $result")\n        }\n    }\n}\n\nprivate fun calculate(inputList: List&lt;String&gt;): Int? {\n    if (inputList.size != 3) return null\n\n    val left = inputList[0].toInt()\n    //                        注意这里\n    //                           ↓\n    val operation = Operation.valueOf(inputList[1])?: return null\n    val right = inputList[2].toInt()\n\n    return when (operation) {\n        Operation.ADD -&gt; left + right\n        Operation.MINUS -&gt; left - right\n        Operation.MULTI -&gt; left * right\n        Operation.DIVI -&gt; left / right\n    }\n}\n\nenum class Operation(val value: String) {\n    ADD("+"),\n    MINUS("-"),\n    MULTI("*"),\n    DIVI("/")\n}\n</code></pre><p>请留意上面的代码注释，这个valueOf()是无法正常工作的。Kotlin为我们提供的这个方法，并不能为我们解析枚举类的value。</p><pre><code class="language-plain">fun main() {\n    // 报错\n    val wrong = Operation.valueOf("+")\n    // 正确\n    val right = Operation.valueOf("ADD")\n}\n</code></pre><p>出现这个问题的原因就在于，<strong>Kotlin提供的valueOf()就是用于解析“枚举变量名称”的</strong>。</p><p>这是一个非常常见的使用误区，不得不说，Kotlin在这个方法的命名上并不是很好，导致开发者十分容易用错。Kotlin提供的valueOf()还不如说是nameOf()。</p><p>而如果我们希望可以根据value解析出枚举的状态，我们就需要自己动手。最简单的办法，就是使用<strong>伴生对象</strong>。在这里，我们只需要将2.0版本当中的逻辑挪进去即可：</p><pre><code class="language-plain">enum class Operation(val value: String) {\n    ADD("+"),\n    MINUS("-"),\n    MULTI("*"),\n    DIVI("/");\n\n    companion object {\n        fun realValueOf(value: String): Operation? {\n            values().forEach {\n                if (value == it.value) {\n                    return it\n                }\n            }\n            return null\n        }\n    }\n}\n</code></pre><p>对应的，在我们尝试解析操作符的时候，我们就不再使用Kotlin提供的valueOf()，而是使用自定义的realValueOf()了：</p><pre><code class="language-plain">val help = """\n--------------------------------------\n使用说明：\n1. 输入 1 + 1，按回车，即可使用计算器；\n2. 注意：数字与符号之间要有空格；\n3. 想要退出程序，请输入：exit\n--------------------------------------""".trimIndent()\n\nfun main() {\n    while (true) {\n        println(help)\n\n        val input = readLine() ?: continue\n        if (input == "exit") exitProcess(0)\n\n        val inputList = input.split(" ")\n        val result = calculate(inputList)\n\n        if (result == null) {\n            println("输入格式不对")\n            continue\n        } else {\n            println("$input = $result")\n        }\n    }\n}\n\nprivate fun calculate(inputList: List&lt;String&gt;): Int? {\n    if (inputList.size != 3) return null\n\n    val left = inputList[0].toInt()\n    //                        变化在这里\n    //                           ↓\n    val operation = Operation.realValueOf(inputList[1])?: return null\n    val right = inputList[2].toInt()\n\n    return when (operation) {\n        Operation.ADD -&gt; left + right\n        Operation.MINUS -&gt; left - right\n        Operation.MULTI -&gt; left * right\n        Operation.DIVI -&gt; left / right\n    }\n}\n</code></pre><p>因此，对于枚举，我们在使用valueOf()的时候一定要足够小心！因为它解析的根本就不是value，而是name。</p><h2>小结</h2><p>在我看来，专栏是“作者说，读者听”的过程，而留言区则是“读者说，作者听”的过程。这两者结合在一起之后，我们才能形成一个更好的沟通闭环。今天的这节答疑课，就是我在倾听了你的声音后，给到你的回应。</p><p>所以，如果你在学习的过程中遇到了什么问题，请一定要提出来，我们一起交流和探讨，共同进步。</p><h2>思考题</h2><p>请问你在使用Kotlin的过程中，还遇到过哪些问题？请在留言区提出来，我们一起交流。</p>',
        article_title: "答疑（一）| Java和Kotlin到底谁好谁坏？",
      },
    ],
  },
  {
    chapterTitle: "源码篇",
    children: [
      {
        title: "25 | 集合操作符：你也会“看完就忘”吗？",
        id: 495246,
        content:
          '<p>你好，我是朱涛。</p><p>从这节课开始，我们就正式进入源码篇的学习了。当我们学习一门知识的时候，总是离不开What、Why和How。在前面的基础篇、协程篇当中，我们已经弄清楚了 <strong>Kotlin是什么</strong>，以及<strong>为什么要用Kotlin</strong>。那么在这个模块里，我们主要是来解决How的问题，以此从根源上搞清楚Kotlin的底层实现原理。今天这节课，我们先来搞定集合操作符的用法与原理。</p><p>对于大部分Java、C开发者来说，可能都会对Kotlin的集合操作符感到头疼，因为它们实在太多、太乱了。即使通过Kotlin官方文档把那些操作符一个个过了一遍，但过一段时间在代码中遇到它们，又会觉得陌生。<strong>一看就会，看完就忘</strong>！</p><p>其实，Kotlin的集合API，本质上是一种<strong>数据处理的模式</strong>。</p><p>什么是数据处理模式？可以想象一下：对于1~10的数字来说，我们找出其中的偶数，那么这就是一种过滤的行为。我们计算出1~10的总和，那么这就是一种求和的行为。所以从数据操作的角度来看，Kotlin的操作符就可以分为几个大类：过滤、转换、分组、分割、求和。</p><p>那么接下来，我会根据一个统计学生成绩的案例，来带你分析Kotlin的集合API的使用场景，对于复杂的API，我还会深入源码分析它们是如何实现的。这样你也就知道，集合操作符的底层实现原理，也能懂得如何在工作中灵活运用它们来解决实际问题。</p><!-- [[[read_end]]] --><p>好，让我们开始吧！</p><h2>场景模拟：统计学生成绩</h2><p>为了研究Kotlin集合API的使用场景，我们先来模拟一个实际的生活场景：统计学生成绩。</p><pre><code class="language-plain">data class Student(\n    val name: String = "",\n    val score: Int = 0\n)\n\nval class1 = listOf(\n    Student("小明", 83),\n    Student("小红", 92),\n    Student("小李", 50),\n    Student("小白", 67),\n    Student("小琳", 72),\n    Student("小刚", 97),\n    Student("小强", 57),\n    Student("小林", 86)\n)\n\nval class2 = listOf(\n    Student("大明", 80),\n    Student("大红", 97),\n    Student("大李", 53),\n    Student("大白", 64),\n    Student("大琳", 76),\n    Student("大刚", 92),\n    Student("大强", 58),\n    Student("大林", 88)\n)\n</code></pre><p>这里我们定义了一个数据类Student，然后有一个集合，当中对应的就是学生的名字和成绩。<br>\n接下来，我们就以这个场景来研究Kotlin的集合API。</p><h2>过滤</h2><p>比如说，我们希望过滤1班里不及格的学生，我们就可以用 <strong>filter{}</strong> 这个操作符，这里的filter其实就是过滤的意思。</p><pre><code class="language-plain">private fun filterNotPass() {\n    val result = class1.filter { it.score &lt; 60 }\n    println(result)\n}\n\n/*\n[Student(name=小李, score=50), Student(name=小强, score=57)]\n*/\n</code></pre><p>以上代码段的逻辑很简单，读起来就像英语文本一样，这里我们重点来看看filter{} 的源代码：</p><pre><code class="language-plain">public inline fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; {\n    // 创建了新的ArrayList&lt;T&gt;()集合\n    return filterTo(ArrayList&lt;T&gt;(), predicate)\n}\n\npublic inline fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Iterable&lt;T&gt;.filterTo(destination: C, predicate: (T) -&gt; Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n</code></pre><p>可以看到filter{} 其实是一个高阶函数，它只有唯一的参数“predicate: (T) -&gt; Boolean”，这就是它的<strong>过滤条件及过滤标准</strong>，只有符合这个过滤条件的数据才会被保留下来。</p><p>而且，对于List.filter{} 来说，它的内部还会创建一个新的 <code>ArrayList&lt;T&gt;()</code>，然后将符合过滤条件的元素添加进去，再返回这个新的集合。</p><p>而除了filter{} 以外，Kotlin还提供了filterIndexed{}，它的作用其实和filter{} 一样，只是会额外带上集合元素的index，即它的参数类型是“predicate: (index: Int, T) -&gt; Boolean”。</p><p>还有一个是filterIsInstance()，这是我们在<a href="https://time.geekbang.org/column/article/481787">第12讲</a>当中使用过的API，它的作用是过滤集合当中特定类型的元素。如下所示：</p><pre><code class="language-plain">// 12讲当中的代码\ninline fun &lt;reified T&gt; create(): T {\n    return Proxy.newProxyInstance(\n        T::class.java.classLoader,\n        arrayOf(T::class.java)\n    ) { proxy, method, args -&gt;\n\n        return@newProxyInstance method.annotations\n            // 注意这里\n            .filterIsInstance&lt;GET&gt;()\n            .takeIf { it.size == 1 }\n            ?.let { invoke("$baseUrl${it[0].value}", method, args) }\n    } as T\n}\n\n//     inline    + reified = 类型实化\n//       ↓            ↓\npublic inline fun &lt;reified R&gt; Iterable&lt;*&gt;.filterIsInstance(): List&lt;@kotlin.internal.NoInfer R&gt; {\n    return filterIsInstanceTo(ArrayList&lt;R&gt;())\n}\n\n//     inline    + reified = 类型实化\n//       ↓            ↓\npublic inline fun &lt;reified R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;*&gt;.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n</code></pre><p>可以看到，filterIsInstance的源代码逻辑也非常简单，其中最关键的，就是它借助了inline、reified这两个关键字，实现了<strong>类型实化</strong>。这个知识点我们在12讲当中也介绍过，它的作用就是让Kotlin的“伪泛型”变成“真泛型”。</p><p>好，Kotlin集合API当中的过滤操作我们也就分析完了。接下来我们看看<strong>转换</strong>API。</p><h2>转换</h2><p>现在，我们还是基于学生成绩统计的场景。不过，这次的需求是要把学生的名字隐藏掉一部分，原本的“小明”“小红”，要统一变成“小某某”。</p><p>那么对于这样的需求，我们用 <strong>map{}</strong> 就可以实现了。</p><pre><code class="language-plain">private fun mapName() {\n    val result = class1.map { it.copy(name = "小某某") }\n    println(result)\n}\n\n/*\n[Student(name=小某某, score=83), \nStudent(name=小某某, score=92), \nStudent(name=小某某, score=50),\nStudent(name=小某某, score=67), \nStudent(name=小某某, score=72),\nStudent(name=小某某, score=97), \nStudent(name=小某某, score=57),\nStudent(name=小某某, score=86)]\n*/\n</code></pre><p>这里需要注意，虽然map这个单词的意思是“地图”，但在当前的语境下，map其实是<strong>转换、映射</strong>的意思，这时候，我们脑子要想到的是HashMap当中的map含义。</p><p>另外，map的源码也很简单：</p><pre><code class="language-plain">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {\n    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)\n}\n\npublic inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Iterable&lt;T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n</code></pre><p>本质上，map就是对每一个集合元素都进行一次transform()方法的调用，它的类型是“transform: (T) -&gt; R”。</p><p>除了map以外，还有一个比较有用的转换API，<strong>flatten</strong>。它的作用是将嵌套的集合“<strong>展开、铺平</strong>成为一个非嵌套的集合”。我们来看一个简单的例子：</p><pre><code class="language-plain">private fun testFlatten() {\n    val list = listOf(listOf(1, 2, 3), listOf(4, 5, 6))\n    val result = list.flatten()\n    println(result)\n}\n\n/*\n[1, 2, 3, 4, 5, 6]\n*/\n</code></pre><p>假设，我们现在想要过滤出1班、2班当中所有未及格的同学，我们就可以结合flatten、filter来实现。</p><pre><code class="language-plain">private fun filterAllNotPass() {\n    val result = listOf(class1, class2)\n        .flatten()\n        .filter { it.score &lt; 60 }\n\n    println(result)\n}\n\n// flatten 源代码\npublic fun &lt;T&gt; Iterable&lt;Iterable&lt;T&gt;&gt;.flatten(): List&lt;T&gt; {\n    val result = ArrayList&lt;T&gt;()\n    for (element in this) {\n        result.addAll(element) // 注意addAll()\n    }\n    return result\n}\n\n/*\n[Student(name=小李, score=50),\nStudent(name=小强, score=57),\nStudent(name=大李, score=53),\nStudent(name=大强, score=58)]\n*/\n</code></pre><p>在上面的代码中，我们首先将嵌套的集合用flatten展平，得到1班、2班所有同学的成绩，然后直接使用filter就完成了。</p><p>另外，如果你去看flatten的源代码，你也会发现它的代码非常简单。本质上，flatten就是一个for循环，然后对每一个内部集合进行addAll()。</p><p>下面我们接着来看看分组API。</p><h2>分组</h2><p>现在，我们还是基于学生成绩统计的场景。这次，我们希望把学生们按照成绩的分数段进行分组：50~59的学生为一组、60~69的学生为一组、70~79的学生为一组，以此类推。</p><p>对于这样的需求，我们可以使用Kotlin提供的 <strong>groupBy{}</strong>。比如说：</p><pre><code class="language-plain">private fun groupStudent() {\n    val result = class1.groupBy { "${it.score / 10}0分组" }\n    println(result)\n}\n\n/*\n{\n80分组=[Student(name=小明, score=83), Student(name=小林, score=86)], \n90分组=[Student(name=小红, score=92), Student(name=小刚, score=97)], \n50分组=[Student(name=小李, score=50), Student(name=小强, score=57)], \n60分组=[Student(name=小白, score=67)], \n70分组=[Student(name=小琳, score=72)]}\n*/\n</code></pre><p>groupBy{} 的意思就是<strong>以什么标准进行分组</strong>。在这段代码里，我们是以分数除以10得到的数字进行分组的，最终它的返回值类型其实是 <code>Map&lt;String, List&lt;Student&gt;&gt;</code>。</p><p>在<a href="https://time.geekbang.org/column/article/478106">加餐1</a>当中，其实我们也用过groupBy来完善那个单词频率统计程序：</p><pre><code class="language-plain">fun processText(text: String): List&lt;WordFreq&gt; {\n    return text\n        .clean()\n        .split(" ")\n        .filter { it != "" }\n        .groupBy { it } // 注意这里\n        .map { WordFreq(it.key, it.value.size) }\n        .sortedByDescending { it.frequency }\n}\n</code></pre><p>上面代码中的groupBy，作用就是将所有的单词按照单词本身进行分类，在这个阶段它的返回值是 <code>Map&lt;String, List&lt;String&gt;&gt;</code>。</p><p>我们也再来看看groupBy的源代码。</p><pre><code class="language-plain">public inline fun &lt;T, K&gt; Iterable&lt;T&gt;.groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt; {\n    return groupByTo(LinkedHashMap&lt;K, MutableList&lt;T&gt;&gt;(), keySelector)\n}\n\npublic inline fun &lt;T, K, M : MutableMap&lt;in K, MutableList&lt;T&gt;&gt;&gt; Iterable&lt;T&gt;.groupByTo(destination: M, keySelector: (T) -&gt; K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        // 注意这里\n        val list = destination.getOrPut(key) { ArrayList&lt;T&gt;() }\n        list.add(element)\n    }\n    return destination\n}\n\npublic inline fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.getOrPut(key: K, defaultValue: () -&gt; V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n</code></pre><p>从groupBy的源代码中我们可以看到，它的本质就是用for循环遍历元素，然后使用keySelector()计算出Map的Key，再把其中所有的元素添加到对应Key当中去。注意，在代码这里使用了一个 <code>getOrPut(key) { ArrayList&lt;T&gt;() }</code>，它的作用就是尝试获取对应的key的值，如果不存在的话，就将 <code>ArrayList&lt;T&gt;()</code> 存进去。</p><p>好，接下来，我们看看Kotlin的<strong>分割API</strong>。</p><h2>分割</h2><p>还是基于学生成绩统计的场景。这次，我们希望找出前三名和倒数后三名的学生。做法其实也很简单，我们使用 <strong>take()</strong> 就可以实现了。</p><pre><code class="language-plain">private fun takeStudent() {\n    val first3 = class1\n        .sortedByDescending { it.score }\n        .take(3)\n\n    val last3 = class1\n        .sortedByDescending { it.score }\n        .takeLast(3)\n\n    println(first3)\n    println(last3)\n}\n\n/*\n[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)]\n[Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]\n*/\n</code></pre><p>在上面的代码中，我们先按照分数进行了降序排序，然后使用了take、takeLast从列表当中取出前三个和后三个数据，它们分别代表了：成绩排在前三名、后三名的同学。</p><p>而除了take以外，还有drop、dropLast，它们的作用是<strong>剔除</strong>。</p><pre><code class="language-plain">private fun dropStudent() {\n    val middle = class1\n        .sortedByDescending { it.score }\n        .drop(3)\n        .dropLast(3)\n    // 剔除前三名、后三名，剩余的学生\n    println(middle)\n}\n\n/*\n[Student(name=小明, score=83), Student(name=小琳, score=72)]\n*/\n</code></pre><p>在上面的代码中，我们先把学生按照分数降序排序，然后剔除了前三名和后三名，得到了中间部分的学生。</p><p>另外Kotlin还提供了 <strong>slice</strong>，使用这个API，我们同样可以取出学生中的前三名、后三名。</p><pre><code class="language-plain">private fun sliceStudent() {\n    val first3 = class1\n        .sortedByDescending { it.score }\n        .slice(0..2)\n\n    val size = class1.size\n\n    val last3 = class1\n        .sortedByDescending { it.score }\n        .slice(size - 3 until size)\n\n    println(first3)\n    println(last3)\n}\n/*\n[Student(name=小刚, score=97), Student(name=小红, score=92), Student(name=小林, score=86)]\n[Student(name=小白, score=67), Student(name=小强, score=57), Student(name=小李, score=50)]\n*/\n</code></pre><p>可以看到，slice的作用是根据index来分割集合的，当它与Range（特定范围）相结合的时候，代码的可读性也是不错的。</p><h2>求和</h2><p>我们接着来看Kotlin的求和API。这一次还是基于学生成绩统计的场景，我们希望计算全班学生的总分。</p><p>我们可以使用Kotlin提供的<strong>sumOf、reduce、fold</strong>。</p><pre><code class="language-plain">private fun sumScore() {\n    val sum1 = class1.sumOf { it.score }\n\n    val sum2 = class1\n        .map { it.score }\n        .reduce { acc, score -&gt; acc + score }\n\n    val sum3 = class1\n        .map { it.score }\n        .fold(0) { acc, score -&gt; acc + score }\n\n    println(sum1)\n    println(sum2)\n    println(sum3)\n}\n\n\n\n/*\n604\n604\n604\n*/\n</code></pre><p>总的来说，sumOf能做到的事情，reduce可以想办法做；而reduce可以做到的事情，fold也可以做到。它们的使用场景是具备包含关系的。</p><ul>\n<li><strong>sumOf{}</strong> 仅可以用于数字类型的数据进行求和的场景。</li>\n<li><strong>reduce</strong>本质上是对数据进行遍历，然后进行某种“广义求和”的操作，这里不局限于数字类型。我们使用reduce，也可以进行字符串拼接。相当于说，这里的求和规则，是我们从外部传进来的。</li>\n<li><strong>fold</strong>对比reduce来说，只是多了一个初始值，其他都跟reduce一样。</li>\n</ul><p>比如，下面这段代码，我们就使用了reduce、fold进行了字符串拼接：</p><pre><code class="language-plain">private fun joinScore() {\n    val sum2 = class1\n        .map { it.score.toString() }\n        .reduce { acc, score -&gt; acc + score }\n\n    val sum3 = class1\n        .map { it.score.toString() }\n        .fold("Prefix=") { acc, score -&gt; acc + score }\n\n    println(sum2)\n    println(sum3)\n}\n\n/*\n8392506772975786\nPrefix=8392506772975786\n*/\n</code></pre><p>所以，reduce就是fold的一种特殊情况。也就是说，fold不需要初始值的时候，就是reduce。我们可以来看看它们的源码定义：</p><pre><code class="language-plain">public inline fun &lt;S, T : S&gt; Iterable&lt;T&gt;.reduce(operation: (acc: S, T) -&gt; S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException("Empty collection can\'t be reduced.")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\npublic inline fun &lt;T, R&gt; Iterable&lt;T&gt;.fold(initial: R, operation: (acc: R, T) -&gt; R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n</code></pre><p>根据以上定义，可以发现fold和reduce的名字虽然看起来很高大上，但它们的实现原理其实非常简单，就是一个简单的for循环。而reduce之所以看起来比fold要复杂一点的原因在于，<strong>reduce需要兼容集合为空的情况，fold不需要，因为fold具备初始值</strong>。</p><h2>小结</h2><p>好，这节课的内容就到这里了，我们来做一个简单的总结。</p><p>Kotlin的集合API，主要分为这几个大类：过滤、转换、分组、分割、求和。</p><ul>\n<li>过滤，filter、filterIsInstance，前者是以<strong>条件过滤</strong>，后者是以<strong>类型过滤</strong>，后者运用了Kotlin的<strong>类型实化</strong>。</li>\n<li>转换，map、flatten，前者是<strong>转换集合元素</strong>，后者是<strong>转换集合的嵌套层级</strong>，flatten会把嵌套的集合<strong>展平</strong>。</li>\n<li>分组，groupBy，即<strong>以什么标准进行分组</strong>，它的返回值类型往往会是 <code>Map&lt;K, List&lt;T&gt;&gt;</code>。</li>\n<li>分割，take、drop、slice。take代表从集合中<strong>提取</strong>，drop代表从集合中<strong>剔除</strong>，slice代表以<strong>特定范围</strong>（Range）进行切割。</li>\n<li>求和，sumOf、reduce、fold。sumOf只适用于数字类型的求和，reduce、fold则能够以特定规则对集合元素进行“广义的求和”，其中的“求和规则”我们可以灵活自定义，比如字符串拼接。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/ee/5e/ee951f5853d081ccc75d13cc49c29f5e.jpg?wh=2000x546" alt=""></p><p>其实，经过前面几十节课的学习，现在我们分析Kotlin集合的源代码，整个过程都是非常轻松的。因为它们无非就是<strong>高阶函数与for循环的简单结合</strong>。而你需要特别注意的是，以上所有的操作符，都不会修改原本的集合，它们返回的集合是一个全新的集合。这也体现出了Kotlin推崇的不变性和无副作用这两个特性。</p><p>另外正如我前面所讲的，Kotlin的集合API，不仅仅是Kotlin集合特有的API，而是一种广泛存在的<strong>数据处理的模式</strong>。所以你会发现，Kotlin的集合操作符跟Kotlin的Sequence、Flow里面的操作符也是高度重叠的。不仅如此，这些操作符跟Java 8、C#、Scala、Python等语言的API也高度重叠。</p><p>而这就意味着，通过这节课的学习，你不仅可以对Kotlin的Flow、Sequence有更全面的认识，将来你接触其他计算机语言的时候，也可以轻松上手。</p><h2>思考题</h2><p>前面我们提到过，Kotlin的集合操作符都不会修改原本的集合，它们返回的集合是一个全新的集合。这恰好就体现出了Kotlin推崇的不变性和无副作用的特点。那么请问，这样的方式是否存在劣势？我们平时该如何取舍？</p><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "25 | 集合操作符：你也会“看完就忘”吗？",
      },
      {
        title: "26 | 协程源码的地图：如何读源码才不会迷失？",
        id: 495862,
        content:
          '<p>你好，我是朱涛。</p><p>在前面学习协程的时候，我们说过协程是Kotlin里最重要、最难学的特性。之所以说协程重要，是因为它有千般万般的好：挂起函数、结构化并发、非阻塞、冷数据流，等等。不过协程也真的太抽象、太难学了。即使我们学完了前面的协程篇，知道了协程的用法，但也仍然远远不够，这种“知其然，不知其所以然”的感觉，总会让我们心里不踏实。</p><p>所以，我们必须搞懂Kotlin协程的源代码。</p><p>可问题是，协程的源码也非常复杂。如果你尝试研究过协程的源代码，那你对此一定深有体会。在Kotlin协程1.6.0版本中，仅仅是协程跟JVM相关的源代码，就有27789行。如果算上JavaScript平台、Native平台，以及单元测试相关的代码，Kotlin协程库当中的源代码有接近10万行。面对这么多的源代码，我们根本不可能一行一行去分析。</p><p>因此，我们在研究Kotlin协程的源代码的时候，要有一定的技巧。这里给你分享我的两个小技巧：</p><ul>\n<li><strong>理解Kotlin协程的源码结构</strong>。Kotlin协程的源代码分布在多个模块之中，每个模块都会包含特定的协程概念。相应的，它的各个概念也有特定的层级结构，只有弄清楚各个概念之间的关系，并且建立一个类似“地图”的知识结构，我们在研究源码的时候，才不会那么容易迷失。</li>\n<li><strong>明确研究源码的目标</strong>。正如我前面提到的，我们不可能一次性看完协程所有的源代码，所以我们在读源码的过程中，一定要有明确的目标。比如是想要了解挂起函数的原理，还是想学习协程的启动流程。</li>\n</ul><!-- [[[read_end]]] --><p>所以在接下来的课程中，我们会主要攻克Kotlin协程源代码中，常见知识点的实现原理，比如挂起函数、launch、Flow等，理解其中的代码逻辑，并掌握这些功能特性所涉及的关键技术和设计思想。</p><p>今天这节课，我们先来构建一个协程源码的知识地图，掌握了这张地图之后，我们再去学习协程的实现原理时，就可以在脑海中快速查找和定位相关模块对应的源代码，也不会迷失方向了。</p><p>不过，在正式开始学习之前，我还是要提前给你打一剂预防针。课程进行到这个阶段，学习难度也进一步提升了。<strong>不管是什么技术，研究它的底层原理永远不是一件容易的事情。</strong>因此，为了提高学习的效率，你一定要跟随课程的内容，去IDE里查看对应的源代码，一定要去实际运行、调试课程中给出的代码Demo。</p><p>好，我们正式开始吧！</p><h2>协程源码的结构</h2><p>在<a href="https://time.geekbang.org/column/article/485632">第13讲</a>当中我们提到过，Kotlin协程是一个独立的框架。如果想要使用Kotlin协程，我们需要单独进行依赖。</p><p>那么，要研究Kotlin协程，是不是只需研究这个协程框架的<a href="https://github.com/Kotlin/kotlinx.coroutines">GitHub仓库</a>的代码就够了呢？其实不然。因为Kotlin的协程源码分为了三个层级，自底向上分别是：</p><ul>\n<li><strong>基础层</strong>：Kotlin库当中定义的协程基础元素；</li>\n<li><strong>中间层</strong>：协程框架通用逻辑kotlinx.coroutines-common；</li>\n<li><strong>平台层</strong>：这个是指协程在特定平台的实现，比如说JVM、JS、Native。</li>\n</ul><p><img src="https://static001.geekbang.org/resource/image/1a/41/1aebcdcd079b531d39cc4c59ff799341.jpg?wh=2000x1125" alt=""></p><p>所以，我们需要分别从这三个层级来了解协程源码的目录结构、作用类别，以及对应的功能模块的源代码。也就是说，为了研究Kotlin协程的原理，我们不仅要读协程框架的源码，同时还要读Kotlin标准库的源码。接下来，我们一个个来看。</p><h3>基础层：协程基础元素</h3><p>Kotlin协程的基础元素，其实是定义在Kotlin标准库当中的。</p><p><img src="https://static001.geekbang.org/resource/image/d3/04/d3b94d0d28e467beyycb77a29af18f04.png?wh=769x629" alt="图片"></p><p>比如，像是协程当中的一些基础概念，Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics等等，这些概念都是定义在Kotlin标准库当中的。</p><p>那么，Kotlin官方为什么要这么做呢？这其实是一种<strong>解耦</strong>的思想。Kotlin标准库当中的基础元素，就像是构造协程框架的“<strong>砖块</strong>”一样。简单的几个基础概念，将它们组合到一起，就可以实现功能强大的协程框架。</p><p>实际上，现在的kotlinx.coroutines协程框架，就是基于以上几种协程基础元素构造出来的。如果哪天GitHub上突然冒出一款新的Kotlin协程框架，你也不要觉得意外，因为构造协程的砖块就在那里，每个人都可以借助这些基础元素来构建自己的协程框架。</p><p>不过就目前来说，还是Kotlin官方封装的协程框架功能最强大，所以开发者也都会选择kotlinx.coroutines。另外我们都知道，Kotlin是支持跨平台的，所以协程其实也存在跨平台的实现。在Kotlin官方的协程框架当中，大致分了两层：common中间层和平台层。</p><h3>中间层：kotlinx.coroutines-common</h3><p>kotlinx.coroutines源代码当中的common子模块，里面包含了Kotlin协程框架的通用逻辑。我们前面学过的大部分知识点，都来自于这个模块，比如launch、async、CoroutineScope、CoroutineDispatcher、Job、Deferred、Channel、Select、Flow等。</p><p><img src="https://static001.geekbang.org/resource/image/77/40/774cf52229bdd6c60a57fa04a4001040.png?wh=947x1252" alt="图片"></p><p>虽然说，我们开发者使用那些底层的协程基础元素，也能够写代码，但它们终归是不如Flow之类的API好用的。而kotlinx.coroutines-common这个模块，就是Kotlin官方提供的一个协程的中间层。借助这些封装过后的高级协程概念，我们就可以直接去解决工作中的实际问题了。</p><p>在这个common中间层里，<strong>只有纯粹的协程框架逻辑，不会包含任何特定的平台特性</strong>。而我们知道，Kotlin其实是支持3种平台的：JVM、JavaScript、Native。所以针对平台的支持逻辑，都在下面的平台层当中。</p><h3>平台层</h3><p>在core模块之下，有几个与common平级的子模块，即JVM、JavaScript、Native。这里面，才是Kotlin协程与某个平台产生关联的地方。</p><p><img src="https://static001.geekbang.org/resource/image/f6/7e/f63577b1723d647661875362cb54e97e.png?wh=925x529" alt="图片"></p><p>我们都知道，Kotlin的协程，最终都是运行在线程之上的。所以，当Kotlin在不同平台上运行的时候，最终还需要映射到对应的线程模型之上。这里我们就以JVM和JavaScript为例：</p><p><img src="https://static001.geekbang.org/resource/image/cd/78/cdc90a8ecf17aca946600c637ce13478.png?wh=946x1101" alt="图片"></p><p>可以看到，同样的协程概念，在JVM、JavaScript两个平台上会有不同的实现：</p><ul>\n<li>同样是线程，在JVM是线程池，而JavaScript则是JS线程；</li>\n<li>同样是事件循环，两者也会有不同的实现方式；</li>\n<li>同样是异步任务，JVM是Future，JavaScript则是Promise。</li>\n</ul><p>可见，虽然协程的“平台层”是建立在common层之上的，但它同时又为协程在特定平台上提供了对应的支持。</p><p>好，到这里，我们就已经弄清楚Kotlin协程的源码结构了。这个源码的结构，也就相当于协程知识点的<strong>地图</strong>。有了这个地图以后，我们在后面遇到问题的时候，才知道去哪里找答案。比如说，当我们想知道Kotlin的协程是如何运行在线程之上的，那么我们肯定要到平台层，去找JVM的具体实现。</p><h2>如何研究协程源码？</h2><p>读Kotlin协程的源代码，就像是一场原始森林里的探险一样。我们不仅要有一张清晰的地图，同时还要有<strong>明确的目标</strong>。</p><p>所以在接下来的源码篇当中，我们每一节课的学习目标都会非常明确，比如我们会来着重探究挂起函数的原理、协程启动原理、Dispatchers原理、CoroutineScope原理、Channel原理，还有Flow的原理。这些都是Kotlin协程当中最基础、最重要的知识点，掌握了它们的原理以后，我们在工作中使用协程时也会更有底气。就算遇到了问题，我们也可以通过读源码找到解决方案。</p><p>不过，即使有了探索的目标也还不够，在正式开始之前，我们还需要做一些额外的准备工作。</p><p>首先，<strong>我们要掌握好协程的调试技巧</strong>。在之后的课程当中，我们会编写一些简单的Demo，然后通过运行调试这些Demo，一步步去跟踪、分析协程的源代码。因此，如果你还没看过<a href="https://time.geekbang.org/column/article/486305">第14讲</a>的内容，一定要回过头去看一下其中关于协程调试的内容。</p><p>其次，<strong>我们要彻底弄懂协程的基础元素</strong>。前面我提到过，Kotlin标准库当中的协程基础元素就像是构建协程框架的砖块一样。如果我们对协程的基础元素一知半解的话，在后面分析协程框架的过程中，就会寸步难行。</p><p>所以接下来，面对协程源码的三层结构：基础层、中间层、平台层，我们必须<strong>自底向上</strong>，一步步进行分析。</p><p><img src="https://static001.geekbang.org/resource/image/c6/ae/c65bbb36321c7683ea6d17155d2ee2ae.jpg?wh=2000x1125" alt=""></p><h3>Kotlin源码编译细节</h3><p>另外，我们在平时用Kotlin协程的时候，一般只会使用依赖的方式：</p><pre><code class="language-groovy">    implementation "org.jetbrains.kotlin:kotlin-stdlib"\n    implementation \'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0\'\n</code></pre><p>不过使用这种方式，我们会经常遇到某些类看不到源代码实现的情况。比如，kotlin.coroutines.intrinsics这个包下的源代码：</p><p><img src="https://static001.geekbang.org/resource/image/19/78/19e41068d632a8e257e25f3823a5fe78.png?wh=548x309" alt="图片"></p><p>那么在这里，我也分享一下我读Kotlin源码的方式，给你作为参考。</p><p>首先，当遇到依赖包当中无法查看的类时，你可以去GitHub下载 <a href="https://github.com/JetBrains/kotlin">Kotlin</a> 和 <a href="https://github.com/Kotlin/kotlinx.coroutines">Coroutines</a> 的源代码，然后按照上面画的“协程源码地图”去找对应的源代码实现。</p><p>然后，在IDE当中导入这两个工程的时候，可能也会遇到各种各样的问题。这时候，你需要参考这两个链接里的内容：<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/CONTRIBUTING.md">Coroutine Contributing Guidelines</a>、<a href="https://github.com/JetBrains/kotlin#build-environment-requirements">Kotlin Build environment requirements</a>，来配置好Kotlin和Coroutines的编译环境。</p><p>完成了这两个工程的导入工作以后，你就可以看到Kotlin和协程所有的源代码了。这里不仅有它们的核心代码，还会有跨平台实现、编译器实现，以及对应的单元测试代码。这样后面你在读Kotlin源码的时候，才会有更大的自由度。</p><h2>小结</h2><p>这节课的内容到这里就差不多结束了。接下来，我们来做一个简单的总结。</p><p>研究Kotlin协程的源代码，我们要注意两个要点：<strong>理解Kotlin协程的源码结构</strong>、<strong>明确研究源码的目标</strong>。如果我们把读源码当做是一次原始森林的探险，那么前者就相当于我们手中的<strong>探险地图</strong>，后者就相当于地图上的<strong>探索目标和行进路线</strong>。</p><p>有了这两个保障以后，我们才不会轻易迷失在浩瀚的协程源码中。</p><p>那么，对于协程的源码结构来说，主要可以分为三层。</p><ul>\n<li><strong>基础层</strong>：Kotlin库当中定义的协程基础元素。如果说协程框架是一栋大楼，那么这些基础元素，就相当于一个个的砖块。</li>\n<li><strong>中间层</strong>：协程框架通用逻辑kotlinx.coroutines-common。协程框架里的Job、Deferred、Channel、Flow，它们都是通过协程基础元素组合出来的高级概念。这些概念跟平台无关，不管协程运行在JVM、JavaScript，还是Native上，这些概念都是不会变的。而这些概念的实现，全部都在协程的common中间层。</li>\n<li><strong>平台层</strong>：最后就是协程在特定平台的实现，比如说JVM、JavaScript、Native。当协程要在某个平台运行的时候，它总是免不了要跟这个平台打交道。比如JVM，协程并不能脱离线程运行，因此协程最终还是会运行在JVM的线程池当中。</li>\n</ul><p>这节课的作用跟前面第13讲的作用其实是差不多的。毕竟在探险之前，我们总要做一些准备工作。另外最后我也想再强调一点，就是我之所以先带你梳理协程源码的结构，也是因为如果我一上来就给你贴一大堆源代码，开始跟你分析代码的执行流程，一定会很难接受和消化吸收。</p><p>所以，也请你不要轻视这节课的作用，一定要做好充足的准备，再出发。</p><h2>思考题</h2><p>在Kotlin协程的基础元素当中，最重要的其实就是Continuation这个接口。不过，在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中，还有两个重要的扩展函数：</p><pre><code class="language-plain">public interface Continuation&lt;in T&gt; {\n\n    public val context: CoroutineContext\n\n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n\npublic fun &lt;T&gt; (suspend () -&gt; T).createCoroutine(\n    completion: Continuation&lt;T&gt;\n): Continuation&lt;Unit&gt; =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(\n    completion: Continuation&lt;T&gt;\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n</code></pre><p>请问你能猜到它们的作用是什么吗？这个问题的答案，我会在第28讲给出。</p>',
        article_title: "26 | 协程源码的地图：如何读源码才不会迷失？",
      },
      {
        title: "27 | 图解挂起函数：原来你就是个状态机？",
        id: 496883,
        content:
          '<p>你好，我是朱涛。今天我们来研究Kotlin挂起函数的实现原理。</p><p>挂起函数，是整个Kotlin协程的核心，它的重要性不言而喻。几乎所有协程里的知识点，都离不开挂起函数。而且也正是因为挂起函数的原因，我们才可以使用协程简化异步任务。</p><p>今天这节课，我会从这个CPS转换开始说起，带你进一步挖掘它背后的细节。在这个过程中，我们还会接触到Kotlin库当中的协程基础元素：Continuation、CoroutineContext与挂起函数的底层联系。最后，我会带你灵活运用下这些知识点，以此进一步完善我们的KtHttp，让它可以直接支持挂起函数。</p><p>好，接下来，我们就正式开始吧！</p><h2>CPS转换背后的细节</h2><p>在<a href="https://time.geekbang.org/column/article/487085">第15讲</a>当中，我们已经初步介绍过挂起函数的用法了：挂起函数，只是比普通的函数多了suspend关键字。有了这个suspend关键字以后，Kotlin编译器就会特殊对待这个函数，将其转换成一个带有Callback的函数，这里的Callback就是Continuation接口。</p><p>而这个过程，我们称之为CPS转换：</p><p><img src="https://static001.geekbang.org/resource/image/37/92/3732f7a3473e82c5a5d109a18d87f992.gif?wh=720x405" alt="图片"></p><p>以上的CPS 转换过程中，函数的类型发生了变化：<code>suspend ()-&gt;String</code>  变成了  <code>(Continuation)-&gt; Any?</code>。这意味着，如果你在Java里访问一个Kotlin挂起函数getUserInfo()，会看到 getUserInfo()的类型是 <code>(Continuation)-&gt; Object</code>，也就是：接收 Continuation 为参数，返回值是Object。</p><!-- [[[read_end]]] --><p>而在这里，函数签名的变化可以分为两个部分：<strong>函数参数</strong>的变化和<strong>函数返回值</strong>的变化。</p><h3>CPS参数变化</h3><p>我们先来看函数参数的变化，suspend()变成 (Continuation)的情况，这里我们以第15讲当中的代码为例：</p><pre><code class="language-plain">// 代码段1\n\nsuspend fun testCoroutine() {\n    val user = getUserInfo()\n    val friendList = getFriendList(user)\n    val feedList = getFeedList(user, friendList)\n    log(feedList)\n}\n\n//挂起函数\n// ↓\nsuspend fun getUserInfo(): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "BoyCoder"\n}\n\n//挂起函数\n// ↓\nsuspend fun getFriendList(user: String): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "Tom, Jack"\n}\n\n//挂起函数\n// ↓\nsuspend fun getFeedList(user: String, list: String): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "{FeedList..}"\n}\n</code></pre><p>上面这段代码，testCoroutine()是一个挂起函数，它的内部依次调用了三个挂起函数。而如果我们从Java的角度来看待testCoroutine()的话，代码中所有的参数都会发生变化。如下所示：</p><pre><code class="language-plain">// 代码段2\n\n//                 变化在这里\n//                     ↓\nfun testCoroutine(continuation: Continuation): Any? {\n//                          变化在这里\n//                              ↓\n    val user = getUserInfo(continuation)\n//                                        变化在这里\n//                                            ↓\n    val friendList = getFriendList(user, continuation)\n//                                          变化在这里\n//                                              ↓\n    val feedList = getFeedList(friendList, continuation)\n    log(feedList)\n}\n</code></pre><p>可见，在这里的testCoroutine()当中，每一次函数调用的时候，continuation都会作为最后一个参数传到挂起函数里。不过这一步是Kotlin编译器帮我们做的，我们开发者是无感知的。还记得第15讲我留下的思考题吗：<strong>为什么挂起函数可以调用挂起函数，普通函数则不能？</strong></p><p>其实，这个问题的答案，我们从代码段2就可以看出来。请想象一下，如果testCoroutine()只是一个普通函数，那它就不会有continuation这个参数了，这样getUserInfo()、getFriendList()、getFeedList()这几个挂起函数自然也就无法被调用了。</p><h3>CPS返回值变化</h3><p>好，接下来我们看看getUserInfo()的返回值类型的变化：</p><pre><code class="language-plain">// 代码段3\n\nsuspend fun getUserInfo(): String {}\n\n//                                  变化在这里\n//                                     ↓\nfun getUserInfo(cont: Continuation): Any? {}\n</code></pre><p>从上面的代码里，可以看到getUserInfo()的返回值类型从String变成“Any?”。你肯定会好奇，函数原本的String返回值难道丢失了吗？如果原本的返回值类型丢失了，那么程序执行难道不会出问题吗？</p><p>其实并不是这样。Kotlin官方之所以要弄这一套CPS转换规则，它必然是“<strong>等价转换</strong>”。也就是说，String这个原本的返回值类型肯定不会消失，而是会换一种形式存在。只是String存在的形式，经过Kotlin<strong>反编译成Java之后会丢失</strong>。如果你直接在Java当中调用getUserInfo()的话，就会发现String这个返回值类型成为了Continuation的泛型类型。</p><p><img src="https://static001.geekbang.org/resource/image/36/06/36eebc96c2dd6acf0c178068db0f4a06.png?wh=1582x426" alt="图片"></p><p>所以，对于getUserInfo()这个方法，经过CPS转换后，它完整的函数签名应该是这样的：</p><pre><code class="language-plain">// 代码段4\n\nsuspend fun getUserInfo(): String {}\n\n//                                变化在这里\n//                                    ↓\nfun getUserInfo(cont: Continuation&lt;String&gt;): Any? {}\n</code></pre><p>这时候，我们就可以更新第15讲当中的那个CPS动图了：</p><p><img src="https://static001.geekbang.org/resource/image/78/yy/784ce5776def5255e6d300cd5890a6yy.gif?wh=1080x608" alt="图片"></p><p>好，现在我们知道了，挂起函数原本的返回值类型String只是挪了个地方，所以，Kotlin编译器的CPS转换仍然是等价的转换。也就是：<code>suspend () -&gt; String</code> 转换成 <code>(Continuation&lt;String&gt;) -&gt; Any?</code>。不过，<strong>这里的“Any?”又是干什么的呢？</strong></p><p>其实，挂起函数经过 CPS 转换后，它的返回值有一个重要作用：<strong>标志该挂起函数有没有被挂起</strong>。这听起来有点绕：挂起函数，就是可以被挂起的函数，它还能不被挂起吗？</p><p>是的，挂起函数也能不被挂起。</p><p>让我们来理清几个概念。只要有suspend修饰的函数，它就是挂起函数，比如我们前面的例子：</p><pre><code class="language-plain">// 代码段5\n\nsuspend fun getUserInfo(): String {\n    withContext(Dispatchers.IO) {\n        delay(1000L)\n    }\n    return "BoyCoder"\n}\n</code></pre><p>当getUserInfo()执行到withContext{} 的时候，就会返回 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code> 表示函数被挂起了。</p><p>现在问题来了，请问下面这个函数是挂起函数吗？</p><pre><code class="language-plain">// 代码段6\n\n// suspend 修饰\n// ↓\nsuspend fun noSuspendFriendList(user: String): String{\n    // 函数体跟普通函数一样\n    return "Tom, Jack"\n}\n</code></pre><p>这个其实是 <strong>noSuspendFriendList()方法</strong>，它的方法体跟普通函数一样。它跟一般的挂起函数有个区别：在执行的时候，它并不会被挂起，因为它就是个普通函数。当你写出以下这样的代码后，IDE也会提示你，suspend是多余的：</p><p><img src="https://static001.geekbang.org/resource/image/35/d3/35de8c0f0bbabbce0ca8dee2840d33d3.png?wh=624x119" alt="图片"></p><p>也就是，当我们调用noSuspendFriendList()这个挂起函数的时候，它不会真正挂起，而是会直接返回String类型：<code>"no suspend"</code>。针对这样的挂起函数，你可以把它看作是<strong>伪挂起函数</strong>。</p><p>所以到这里，挂起函数经过CPS转换后，返回值变成“Any?”的原因也就清晰了：</p><p>由于suspend修饰的函数，既可能返回 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>，也可能返回实际结果 <code>"no suspend"</code>，甚至可能返回 null，为了适配所有的可能性，CPS 转换后的函数返回值类型就只能是 <code>Any?</code> 了。</p><p>可见我在第15讲当中给出的这个CPS动图，仅仅只是粗略模拟了协程的CPS流程，其中还有很多细节没有体现出来。</p><p><img src="https://static001.geekbang.org/resource/image/03/22/03d156ec6a31d650c6634f486dc06222.gif?wh=720x405" alt="图片"></p><p>那么，为了让你对挂起函数的底层实现原理有一个更加清晰的认识，接下来，我们来看看挂起函数反编译之后会变成什么样。</p><h2>挂起函数的反编译</h2><p>我们知道，通过查看Kotlin反编译后的字节码，可以帮助我们理解Kotlin的底层原理。不过，和往常不一样的是，这次我不会直接贴反编译后的代码，因为它的逻辑比较复杂。</p><p>所以，为了方便你理解，接下来我贴出的代码是我用Kotlin翻译后<strong>大致等价</strong>的代码，改善了可读性，抹掉了不必要的细节。当你理解其中的思想后，再去看反编译后的Java代码，会更轻松一些。</p><p>好，我们进入正题，这是我们即将研究的对象，testCoroutine()反编译前的代码：</p><pre><code class="language-plain">// 代码段7\n\nsuspend fun testCoroutine() {\n    log("start")\n    val user = getUserInfo()\n    log(user)\n    val friendList = getFriendList(user)\n    log(friendList)\n    val feedList = getFeedList(friendList)\n    log(feedList)\n}\n</code></pre><p>接下来我们来分析testCoroutine()的函数体，它相当复杂，涉及到三个挂起函数的调用。</p><p>首先，在 testCoroutine() 函数里，会多出一个 ContinuationImpl 的子类，它是整个协程挂起函数的核心。</p><pre><code class="language-plain">// 代码段8\n\nfun testCoroutine(completion: Continuation&lt;Any?&gt;): Any? {\n    // TestContinuation本质上是匿名内部类\n    class TestContinuation(completion: Continuation&lt;Any?&gt;?) : ContinuationImpl(completion) {\n        // 表示协程状态机当前的状态\n        var label: Int = 0\n        // 协程返回结果\n        var result: Any? = null\n\n        // 用于保存之前协程的计算结果\n        var mUser: Any? = null\n        var mFriendList: Any? = null\n\n        // invokeSuspend 是协程的关键\n        // 它最终会调用 testCoroutine(this) 开启协程状态机\n        // 状态机相关代码就是后面的 when 语句\n        // 协程的本质，可以说就是 CPS + 状态机\n        override fun invokeSuspend(_result: Result&lt;Any?&gt;): Any? {\n            result = _result\n            label = label or Int.Companion.MIN_VALUE\n            return testCoroutine(this)\n        }\n    }\n}\n</code></pre><p>代码中的这个TestContinuation类，是Kotlin编译器帮我们创建的匿名内部类，这里为了方便才用的TestContinuation这个名称。在这个类当中定义了几个成员变量：</p><ul>\n<li>label是用来代表协程状态机当中状态的；</li>\n<li>result是用来存储当前挂起函数执行结果的；</li>\n<li>mUser、mFriendList则是用来存储历史挂起函数执行结果的；</li>\n<li>invokeSuspend这个函数，是整个状态机的入口，它会将执行流程转交给testCoroutine()进行再次调用。</li>\n</ul><p>接下来是要判断 testCoroutine 是不是初次运行，如果是初次运行，我们就要创建一个 TestContinuation 的实例对象。</p><pre><code class="language-plain">// 代码段9\n\n//                    ↓\nfun testCoroutine(completion: Continuation&lt;Any?&gt;): Any? {\n    ...\n    val continuation = if (completion is TestContinuation) {\n        completion\n    } else {\n        //                作为参数\n        //                   ↓\n        TestContinuation(completion)\n    }\n}\n</code></pre><p>也就是：</p><ul>\n<li>invokeSuspend 最终会调用 testCoroutine，然后走到这个判断语句；</li>\n<li>如果是初次运行，会创建一个 TestContinuation 对象，completion 作为参数；</li>\n<li>这相当于用一个<strong>新的</strong> Continuation 包装了<strong>旧的</strong> Continuation；</li>\n<li>如果不是初次运行，直接将 completion 赋值给 continuation；</li>\n<li>这说明 continuation 在整个运行期间，只会产生一个实例，这能极大地节省内存开销（对比CallBack）。</li>\n</ul><p>接下来是几个变量的定义：</p><pre><code class="language-plain">// 代码段10\n\n// 三个变量，对应原函数的三个变量\nlateinit var user: String\nlateinit var friendList: String\nlateinit var feedList: String\n\n// result 接收协程的运行结果\nvar result = continuation.result\n\n// suspendReturn 接收挂起函数的返回值\nvar suspendReturn: Any? = null\n\n// CoroutineSingletons 是个枚举类\n// COROUTINE_SUSPENDED 代表当前函数被挂起了\nval sFlag = CoroutineSingletons.COROUTINE_SUSPENDED\n</code></pre><p>上面的代码，分别代表了函数当中的临时变量、挂起函数执行结果，以及是否挂起的标志位。接着，我们来看看协程状态机的核心逻辑：</p><pre><code class="language-plain">// 代码段11\n\nwhen (continuation.label) {\n    0 -&gt; {\n        // 检测异常\n        throwOnFailure(result)\n\n        log("start")\n        // 将 label 置为 1，准备进入下一次状态\n        continuation.label = 1\n\n        // 执行 getUserInfo\n        suspendReturn = getUserInfo(continuation)\n\n        // 判断是否挂起\n        if (suspendReturn == sFlag) {\n            return suspendReturn\n        } else {\n            result = suspendReturn\n            //go to next state\n        }\n    }\n\n    1 -&gt; {\n        throwOnFailure(result)\n\n        // 获取 user 值\n        user = result as String\n        log(user)\n        // 将协程结果存到 continuation 里\n        continuation.mUser = user\n        // 准备进入下一个状态\n        continuation.label = 2\n\n        // 执行 getFriendList\n        suspendReturn = getFriendList(user, continuation)\n\n        // 判断是否挂起\n        if (suspendReturn == sFlag) {\n            return suspendReturn\n        } else {\n            result = suspendReturn\n            //go to next state\n        }\n    }\n\n    2 -&gt; {\n        throwOnFailure(result)\n\n        user = continuation.mUser as String\n\n        // 获取 friendList 的值\n        friendList = result as String\n        log(friendList)\n\n        // 将协程结果存到 continuation 里\n        continuation.mUser = user\n        continuation.mFriendList = friendList\n\n        // 准备进入下一个状态\n        continuation.label = 3\n\n        // 执行 getFeedList\n        suspendReturn = getFeedList(user, friendList, continuation)\n\n        // 判断是否挂起\n        if (suspendReturn == sFlag) {\n            return suspendReturn\n        } else {\n            result = suspendReturn\n            //go to next state\n        }\n    }\n\n    3 -&gt; {\n        throwOnFailure(result)\n\n        user = continuation.mUser as String\n        friendList = continuation.mFriendList as String\n        feedList = continuation.result as String\n        log(feedList)\n        loop = false\n    }\n}\n</code></pre><p>在testCoroutine()这个方法体当中，一共调用了三个挂起函数，这三个挂起函数把整个方法体分割成了4个部分，这四个部分就是上面when表达式当中的4种情况。</p><ul>\n<li>when 表达式实现了协程状态机；</li>\n<li>continuation.label 是状态流转的关键，continuation.label 改变一次，就代表了挂起函数被调用了一次；</li>\n<li>每次挂起函数执行完后，都会检查是否发生异常；</li>\n<li>testCoroutine 里的原本的代码，被<strong>拆分</strong>到状态机里各个状态中，<strong>分开执行</strong>；</li>\n<li>getUserInfo(continuation)、getFriendList(user, continuation)、getFeedList(friendList, continuation) 三个函数调用的是同一个 continuation实例；</li>\n<li>如果一个函数被挂起了，它的返回值会是 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>；</li>\n<li>在挂起函数执行的过程中，状态机会把之前的结果以成员变量的方式保存在 continuation中。</li>\n</ul><p>上面这一大串文字和代码看着是不是有点晕？你可以再结合着来看看这个视频演示。</p><p><video poster="https://media001.geekbang.org/1023f2e30d344804a84cf88c172db7d3/snapshots/566ea25ac3d842afa19b84ad1cd528d6-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/53fcd64-17fa77f850f-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/748351c4bde24552a8930759afafd0e5/d2adc1d3d7214a54933c0b7873e5f261-b4083ddbe2eb4d44f622bd740429c2eb-sd.m3u8" type="application/x-mpegURL"></video></p><p>那到这里是不是就结束了呢？并不，因为这个动画仅演示了每个协程正常挂起的情况。如果协程并没有真正挂起呢？协程状态机会怎么运行？</p><h3>协程未挂起的情况</h3><p>要验证也很简单，我们将其中一个挂起函数改成<strong>伪挂起函数</strong>即可。</p><pre><code class="language-plain">// 代码段12\n\n// “伪”挂起函数\n// 虽然它有 suspend 修饰，但执行的时候并不会真正挂起，因为它函数体里没有其他挂起函数\n//  ↓\nsuspend fun noSuspendFriendList(user: String): String{\n    return "Tom, Jack"\n}\n\nsuspend fun testNoSuspend() {\n    log("start")\n    val user = getUserInfo()\n    log(user)                  \n    //                  变化在这里\n    //                      ↓\n    val friendList = noSuspendFriendList(user)\n    log(friendList)\n    val feedList = getFeedList(friendList)\n    log(feedList)\n}\n</code></pre><p>testNoSuspend()这样的一个函数体，它反编译后的代码逻辑是怎么样的？</p><p>答案其实很简单，<strong>它的结构跟前面的testCoroutine()是一致的，只是函数名字变了而已，Kotlin编译器CPS转换的逻辑只认suspend关键字</strong>。就算挂起函数内部并没有挂起的逻辑，Kotlin编译器也照样会进行CPS转换。</p><pre><code class="language-plain">// 代码段13\n\nwhen (continuation.label) {\n    0 -&gt; {\n        ...\n    }\n\n    1 -&gt; {\n        ...\n        //               变化在这里\n        //                   ↓\n        suspendReturn = noSuspendFriendList(user, continuation)\n\n        // 判断是否挂起\n        if (suspendReturn == sFlag) {\n            return suspendReturn\n        } else {\n            result = suspendReturn\n            //go to next state\n        }\n    }\n\n    2 -&gt; {\n        ...\n    }\n\n    3 -&gt; {\n        ...\n    }\n}\n</code></pre><p>那testNoSuspend()的协程状态机是怎么运行的呢？</p><p>其实我们也很容易能想到，continuation.label = 0, 2, 3的情况都是不变的，唯独在 label = 1 的时候，<code>suspendReturn == sFlag</code> 这里会有区别。</p><p>具体区别我们还是通过动画来看吧：</p><p><video poster="https://media001.geekbang.org/893cb12324fb4b5ab418ed52410dc3c1/snapshots/c5fa2b7ce0ae48bdb6de0259130ed0ae-00003.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2160bff8-17fa77f82ae-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/cf691fc051da4603b1ce16b8c7693d48/bba41ef7bff945a1a130687db44ba2d3-67697a33645339e10e966cd9b28a2d03-sd.m3u8" type="application/x-mpegURL"></video></p><p>通过动画我们很清楚地看到了，对于“<strong>伪挂起函数</strong>”，<code>suspendReturn == sFlag</code> 是会走 else 分支的，在 else 分支里，协程状态机会直接进入下一个状态。</p><p>现在只剩最后一个问题了：</p><pre><code class="language-plain">// 代码段14\n\nif (suspendReturn == sFlag) {\n} else {\n    // 具体代码是如何实现的？\n    //       ↓\n    //go to next state\n}\n</code></pre><p>答案其实也很简单：如果你去看协程状态机的字节码反编译后的 Java，会看到很多 <strong>label</strong>。协程状态机底层字节码，是通过 label来实现这个 <code>go to next state</code> 的。由于 Kotlin 没有类似 goto 的语法，下面我用伪代码来表示 <code>go to next state</code> 的逻辑。</p><pre><code class="language-plain">// 代码段15\n\n// 伪代码\n// Kotlin 没有这样的语法\n// ↓      ↓\nlabel: whenStart\nwhen (continuation.label) {\n    0 -&gt; {\n        ...\n    }\n\n    1 -&gt; {\n        ...\n        suspendReturn = noSuspendFriendList(user, continuation)\n        if (suspendReturn == sFlag) {\n            return suspendReturn\n        } else {\n            result = suspendReturn\n            // 让程序跳转到 label 标记的地方\n            // 从而再执行一次 when 表达式\n            goto: whenStart\n        }\n    }\n\n    2 -&gt; {\n        ...\n    }\n\n    3 -&gt; {\n        ...\n    }\n}\n</code></pre><p>需要注意的是：以上只是伪代码，它只是跟协程状态机字节码逻辑上“<strong>大致等价</strong>”。真实的字节码反编译出来的Java代码，它的可读性要差很多，也更难理解。</p><pre><code class="language-java">// 代码段16\n\n// 看不懂也没关系，有个印象即可\n\n@Nullable\npublic static final Object testCoroutine(@NotNull Continuation $completion) {\n&nbsp; &nbsp; Object $continuation;\n&nbsp; &nbsp; label37: {\n&nbsp; &nbsp; &nbsp; &nbsp; if ($completion instanceof &lt;TestSuspendKt$testCoroutine$1&gt;) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $continuation = (&lt;TestSuspendKt$testCoroutine$1&gt;)$completion;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if ((((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label &amp; Integer.MIN_VALUE) != 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label -= Integer.MIN_VALUE;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break label37;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; $continuation = new ContinuationImpl($completion) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // $FF: synthetic field\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int label;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object L$0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object L$1;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @Nullable\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public final Object invokeSuspend(@NotNull Object $result) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.result = $result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.label |= Integer.MIN_VALUE;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TestSuspendKt.testCoroutine(this);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; Object var10000;\n&nbsp; &nbsp; label31: {\n&nbsp; &nbsp; &nbsp; &nbsp; String user;\n&nbsp; &nbsp; &nbsp; &nbsp; String friendList;\n&nbsp; &nbsp; &nbsp; &nbsp; Object var6;\n&nbsp; &nbsp; &nbsp; &nbsp; label30: {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object $result = ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var6 = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch(((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 0:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultKt.throwOnFailure($result);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log("start");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 1;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var10000 = getUserInfo((Continuation)$continuation);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (var10000 == var6) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return var6;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 1:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultKt.throwOnFailure($result);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var10000 = $result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 2:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultKt.throwOnFailure($result);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var10000 = $result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break label30;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case 3:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; friendList = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$1;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user = (String)((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ResultKt.throwOnFailure($result);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var10000 = $result;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break label31;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new IllegalStateException("call to \'resume\' before \'invoke\' with coroutine");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user = (String)var10000;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log(user);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0 = user;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 2;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var10000 = getFriendList(user, (Continuation)$continuation);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (var10000 == var6) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return var6;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; friendList = (String)var10000;\n&nbsp; &nbsp; &nbsp; &nbsp; log(friendList);\n&nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$0 = user;\n&nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).L$1 = friendList;\n&nbsp; &nbsp; &nbsp; &nbsp; ((&lt;TestSuspendKt$testCoroutine$1&gt;)$continuation).label = 3;\n&nbsp; &nbsp; &nbsp; &nbsp; var10000 = getFeedList(friendList, (Continuation)$continuation);\n&nbsp; &nbsp; &nbsp; &nbsp; if (var10000 == var6) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return var6;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; String feedList = (String)var10000;\n&nbsp; &nbsp; log(feedList);\n&nbsp; &nbsp; return Unit.INSTANCE;\n}\n</code></pre><p>当然，对于上面反编译出来的Java代码，即使你看不懂也没关系，你只需要理解我们前面讲解的逻辑即可。<strong>本质上来说</strong>，Kotlin协程就是通过 label 代码段嵌套，配合 switch 巧妙构造出一个状态机结构，这种逻辑比较复杂，相对难懂一些。毕竟 Java 的 label 在实际开发中用的很少。</p><blockquote>\n<p>注意：Kotlin挂起函数反编译出来的Java代码，会因为实际开发环境的不同出现细微差异。随着Kotlin编译器的发展，将来可能会对这部分逻辑进一步优化，但它的核心状态机思想是不会轻易改变的。</p>\n</blockquote><p>好，到现在，我们就已经彻底弄懂挂起函数的实现原理了。接下来，我们就结合刚刚学习的内容，来进一步思考实战一下。</p><h2>思考与实战</h2><p>在上节课我曾提到过，Kotlin协程的源代码其实分为三层，其中基础层当中的“基础概念”尤为重要。那么，Kotlin官方为我们提供了哪些与挂起函数相关的基础元素呢？</p><p>我们首先想到的，肯定就是<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>，在这里面，确实也可以找到一些跟挂起函数相关的基础元素。</p><pre><code class="language-plain">// 代码段17\n\npublic interface Continuation&lt;in T&gt; {\n    public val context: CoroutineContext\n\n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n\n@Suppress("WRONG_MODIFIER_TARGET")\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError("Implemented as intrinsic")\n    }\n\n</code></pre><p>在上面的代码中，我们最熟悉的就是Continuation这个接口了，除此之外，还有一个顶层的变量值得我们注意：<strong>suspend inline val coroutineContext</strong>。要知道，我们从来都是用suspend修饰函数的，从未见过suspend修饰变量的情况。</p><p>如果我们依葫芦画瓢，创建一个类似的顶层变量的话，编译器甚至会报错：</p><pre><code class="language-plain">// 代码段18\n\n// 报错\npublic suspend inline val test: CoroutineContext\n    get() = TODO()\n</code></pre><p>由此可见，suspend的这种用法只是一种特殊用法。结合“public suspend inline val”这几个关键字来看，我们其实可以大致推测出它的作用：它是一个只有在挂起函数作用域下，才能访问的顶层的不可变的变量。这里的inline，意味着它的具体实现会被直接复制到代码的调用处。</p><h3>17讲思考题解答</h3><p>为了验证我们前面的猜测，我们可以回过头来看看<a href="https://time.geekbang.org/column/article/488571">第17讲</a>的思考题：</p><pre><code class="language-plain">// 代码段19\n\n\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.coroutineContext\n\n//                        挂起函数能可以访问协程上下文吗？\n//                                 ↓                              \nsuspend fun testContext() = coroutineContext\n</code></pre><p>如果你将上面的代码反编译成Java的话，它就会变成这样：</p><pre><code class="language-plain">// 代码段20\n\npublic static final Object testContext(Continuation $completion) {\n  return $completion.getContext();\n}\n</code></pre><p>由此可见，代码段17当中的“suspend inline val coroutineContext”，本质上就是Kotlin官方提供的一种方便开发者在挂起函数当中，获取协程上下文的手段。它的具体实现，其实是Kotlin编译器来完成的。</p><pre><code class="language-plain">// 代码段19\n\n\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.coroutineContext\n\n//                  Continuation当中的coroutineContext\n//                                 ↓                              \nsuspend fun testContext() = coroutineContext\n</code></pre><p>到这里，你就会发现一个有趣的现象：<strong>我们在挂起函数当中无法直接访问Continuation对象，但可以访问到Continuation当中的coroutineContext</strong>。要知道，正常情况下，我们想要访问Continuation.coroutineContext，首先是要拿到Continuation对象的。</p><p>但是，Kotlin官方通过“suspend inline val coroutineContext”这个顶层变量，让我们开发者能直接拿到coroutineContext，却对Continuation毫无感知。</p><p>所以到这里，我们其实也就可以回答第17节课思考题的问题了。</p><blockquote>\n<p>课程里，我提到了“挂起函数”与 CoroutineContext 也有着紧密的联系，请问，你能找到具体的证据吗？</p>\n</blockquote><p>解答：挂起函数与 CoroutineContext 确实有着紧密的联系。每个挂起函数当中都会有Continuation，而每个Continuation当中都会有coroutineContext。并且，我们在挂起函数当中，就可以直接访问当前的coroutineContext。</p><h3>KtHttp支持挂起函数</h3><p>在<a href="https://time.geekbang.org/column/article/488985">第18讲</a>当中，我们并没有让KtHttp直接支持挂起函数，当时我们的做法是给KtCall扩展了一个await()方法，从而实现挂起函数调用的。</p><p>那么，经过这节课的学习，我们就可以来尝试让KtHttp直接支持挂起函数了，也就是我们可以这样来写代码：</p><pre><code class="language-plain">interface ApiServiceV7 {\n\n    @GET("/repo")\n    // 1，挂起函数\n    suspend fun reposSuspend(\n        @Field("lang") lang: String,\n        @Field("since") since: String\n    ): RepoList\n}\n\n\n\nprivate fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n        return when {\n        isSuspend(method) -&gt; {\n            // 2，支持挂起函数\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n\n// 3，判断是不是挂起函数\nprivate fun isSuspend(method: Method) = method.kotlinFunction?.isSuspend ?: false\n\n\n// 4，真正执行网络请求的方法\nsuspend fun &lt;T: Any&gt; realCall(call: Call, gson: Gson, type: Type): T = suspendCancellableCoroutine { continuation -&gt;\n    call.enqueue(object : Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            continuation.resumeWithException(e)\n        }\n\n        override fun onResponse(call: Call, response: okhttp3.Response) {\n            try {\n                val t = gson.fromJson&lt;T&gt;(response.body?.string(), type)\n                continuation.resume(t)\n            } catch (e: Exception) {\n                continuation.resumeWithException(e)\n            }\n        }\n    })\n\n    continuation.invokeOnCancellation {\n        call.cancel()\n    }\n}\n</code></pre><p>这段代码一共有4个注释，我们一个个看：</p><ul>\n<li>注释1，这其实就是我们希望达到的效果，可以在ApiServiceV接口当中直接定义挂起函数。</li>\n<li>注释2，在KtHttp 6.0版本的基础上，我们在invoke()的when表达式里增加了一个分支：isSuspend()。</li>\n<li>注释3，isSuspend()的实现有一个细节，这里我们使用了“method.kotlinFunction”，将Java的method转换成了kotlinFunction，这样一来，它就变成了一个Kotlin反射的对象了。因此，我们就可以查询到一些Kotlin相关的信息，比如说，它是不是一个挂起函数。</li>\n<li>注释4，为了直接在挂起函数里执行网络请求，我们将KtCall当中的部分代码逻辑挪了进来。这个realCall()方法，它被定义成了一个挂起函数。</li>\n</ul><p>基于以上的分析，我们其实只需要借助反射，完成注释2处的代码逻辑，然后调用realCall()这个挂起函数就行了。</p><pre><code class="language-plain">private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n    return when {\n        isSuspend(method) -&gt; {\n            // 1，反射获取类型信息\n            // 2，调用realCall()\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n</code></pre><p>所以，接下来我们要做的事情大致可以分为两个部分。</p><p>第一个部分，获取类型信息，准备请求网络，这个部分其实很简单。但在第二个部分“支持挂起函数”这里会遇到问题：</p><pre><code class="language-plain">private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n    return when {\n        isSuspend(method) -&gt; {\n            // 支持挂起函数\n            val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException()\n            val call = okHttpClient!!.newCall(request)\n\n            // 报错！！\n            realCall&lt;T&gt;()\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n</code></pre><p>以上代码报错的原因也很容易理解，realCall()是一个挂起函数，它无法在普通函数里被调用！所以这里我们就面临了一个问题：<strong>如何在普通Kotlin函数当中调用挂起函数？</strong></p><p>那么，我们首先可以想到的解决办法，就是强制类型转换：</p><pre><code class="language-plain">private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n    return when {\n        isSuspend(method) -&gt; {\n            // 支持挂起函数\n            val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException()\n            val call = okHttpClient!!.newCall(request)\n\n            val continuation = args.last() as? Continuation&lt;T&gt;\n            // 1，将挂起函数类型转换成，带Continuation的类型，报错\n            val func = ::realCall as (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?\n            func.invoke(call, gson, genericReturnType, continuation)\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n</code></pre><p>请留意代码中的注释1，我们尝试使用“函数引用”的方式，将realCall()转换成了带有Continuation的函数类型，这样我们就可以通过传入Continuation，来调用realCall()这个挂起函数了。</p><p>不过，事与愿违，我们的方法并不能奏效，因为这行代码会报错，原因是realCall()带有泛型，而Kotlin暂时不支持“函数引用带泛型”的语法。</p><p>所以在这里，为了让这个Demo能运行起来，我们可以定义一个临时方法：</p><pre><code class="language-plain">private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n    return when {\n        isSuspend(method) -&gt; {\n            // 支持挂起函数\n            val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException()\n            val call = okHttpClient!!.newCall(request)\n\n            val continuation = args.last() as? Continuation&lt;T&gt;\n            // 1，使用临时方法消除泛型\n            val func = ::temp as (Call, Gson, Type, Continuation&lt;T&gt;?) -&gt; Any?\n            func.invoke(call, gson, genericReturnType, continuation)\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n\nsuspend fun temp(call: Call, gson: Gson, type: Type) = realCall&lt;RepoList&gt;(call, gson, type)\n</code></pre><p>在上面的代码中，我们使用了一个临时方法消除了泛型T，写死了返回值类型RepoList。这样的代码，在Demo当中是可以运行的，这从侧面也能印证我们上面代码中的类型转换是成功的。</p><pre><code class="language-plain">fun main() = runBlocking {\n    val data: RepoList = KtHttpV7.create(ApiServiceV7::class.java).reposSuspend(\n        lang = "Kotlin",\n        since = "weekly"\n    )\n\n    println(data)\n}\n/*\n输出结果\n正常\n*/\n</code></pre><p>不过，这种做法明显<strong>不具备普适性</strong>，为了让KtHttp支持所有类型的API请求，我们必须要想其他的办法。具体来说，我们可以这样做：</p><pre><code class="language-plain">private fun &lt;T : Any&gt; invoke(path: String, method: Method, args: Array&lt;Any&gt;): Any? {\n        // 省略\n    return when {\n        isSuspend(method) -&gt; {\n            // 支持挂起函数\n            val genericReturnType = method.kotlinFunction?.returnType?.javaType ?: throw IllegalStateException()\n            val call = okHttpClient!!.newCall(request)\n\n            val continuation = args.last() as? Continuation&lt;T&gt;\n\n            val func = KtHttpV7::class.getGenericFunction("realCall")\n            // 反射调用realCall()\n            func.call(this, call, gson, genericReturnType, continuation)\n        }\n        isKtCallReturn(method) -&gt; {\n            // 省略\n        }\n        isFlowReturn(method) -&gt; {\n            // 省略\n        }\n        else -&gt; {\n            // 省略\n        }\n    }\n}\n\n// 2，获取方法的反射对象\nfun KClass&lt;*&gt;.getGenericFunction(name: String): KFunction&lt;*&gt; {\n        return members.single { it.name == name } as KFunction&lt;*&gt;\n    }\n</code></pre><p>其实，这种思路跟前面的思路是类似的，我们仍然是对realCall()的类型进行了转换，只不过是通过<strong>反射</strong>来实现的而已。所以最重要的，我们还是要弄清楚Kotlin挂起函数CPS转换的细节。</p><h2>小结</h2><p>这节课，我们通过研究挂起函数的反编译代码，发现了<strong>Kotlin的挂起函数，本质上就是一个状态机</strong>。其中主要涉及到下面几个知识点，我们需要重点掌握好。</p><ul>\n<li>Kotlin挂起函数的CPS转换，它的函数签名变化主要分为两个部分，第一部分是<strong>参数的变化</strong>，挂起函数经过Kotlin编译器转换以后，它会多出一个Continuation类型的参数。第二部分是<strong>返回值类型的变化</strong>，挂起函数原本的返回值类型，会被挪到Continuation当中作为泛型参数，比如 <code>Continuation&lt;String&gt;</code>，而转换过后的函数返回值类型会变成“Any?”类型。</li>\n<li>当挂起函数经过反编译以后，它会变成<strong>由switch和label组成的状态机结构</strong>。</li>\n<li>为了便于研究，课程里提供了大致等价的协程状态机代码：其中，when 表达式实现了协程状态机，而continuation.label 则代表了当前状态机的具体状态，continuation.label 改变一次，就代表了挂起函数被调用了一次；</li>\n<li>在一个挂起函数被调用的时候，它的返回值可能是具体的结果，也可能会是 <code>CoroutineSingletons.COROUTINE_SUSPENDED</code>，这时候就代表了这个函数被挂起了。</li>\n</ul><p>另外在这节课里，我们还进行了一次反思和实战，通过研究协程基础层当中的“suspend inline val coroutineContext”这个顶层变量，我们发现了挂起函数与协程上下文之间的紧密联系。并且，我们还灵活运用了这节课学到的知识，进一步改进了KtHttp，让它可以直接支持挂起函数。</p><p>你在自己的工作场景当中，其实也可以通过这样思考与实战的方式，来进一步强化所学和所得，甚至可以把输入转化成输出，把知识真正沉淀成你自己的东西。</p><h2>思考题</h2><p>我们都知道挂起函数是Kotlin协程里才有的概念，请问，Java代码中可以调用Kotlin的挂起函数吗？比如，下面这个函数，我们可以在Java当中调用吗？</p><pre><code class="language-plain">object SuspendFromJavaExample {\n    // 在Java当中如何调用这个方法？\n    suspend fun getUserInfo(id: Long):String {\n        delay(1000L)\n        return "Kotlin"\n    }\n}\n</code></pre>',
        article_title: "27 | 图解挂起函数：原来你就是个状态机？",
      },
      {
        title: "加餐五 | 深入理解协程基础元素",
        id: 497868,
        content:
          '<p>你好，我是朱涛。</p><p>在上一讲当中，我们深入研究了Kotlin挂起函数的原理，实际更多的是在了解协程的“基础层”。而接下来，我们将会开始研究协程启动的原理，探索协程的“中间层”。</p><p>在<a href="https://time.geekbang.org/column/article/495862">第26讲</a>里，我曾提到过，Kotlin的协程框架其实就是协程基础元素组合出来的框架。如果我们想要弄懂Kotlin协程，首先就要将它的“基础层”理解透彻。</p><p>所以今天，我还是决定来一次加餐，带你系统深入地认识一下Kotlin协程当中的基础元素。等你对协程的基础层有了深入认识以后，下节课研究协程启动原理就会轻松一些了。</p><h2>协程基础元素</h2><p>通过第26讲我们现在已经知道，Kotlin协程的基础元素大致有这些：Continuation、SafeContinuation、CoroutineContext、CombinedContext、CancellationException、intrinsics。</p><p><img src="https://static001.geekbang.org/resource/image/c6/ae/c65bbb36321c7683ea6d17155d2ee2ae.jpg?wh=2000x1125" alt=""></p><p>其中的CoroutineContext、CancellationException我都已经介绍过了，另外的CombinedContext，其实就是CoroutineContext的一个实现类，而SafeContinuation则是Continuation的实现类。</p><!-- [[[read_end]]] --><p>所以，在整个协程基础元素当中，我们最需要关心的，其实就是<strong>Continuation和intrinsics</strong>。</p><p>在intrinsics里，有一个重要的高阶函数suspendCoroutineUninterceptedOrReturn{}，我们后面会讲到它。至于Continuation，虽然我们在前面已经介绍过它是什么，但还没有系统了解过它的用法，所以接下来，我们就先系统了解一下Continuation的两种用法。</p><h2>Continuation到底该怎么用？</h2><p>实际上，在<a href="https://time.geekbang.org/column/article/488985">第18讲</a>里，我们就已经学过Continuation的其中一种用法了：</p><pre><code>// 代码段1\n\nsuspend fun &lt;T : Any&gt; KtCall&lt;T&gt;.await(): T =\n    suspendCancellableCoroutine { continuation -&gt;\n        val call = call(object : Callback&lt;T&gt; {\n            override fun onSuccess(data: T) {\n                // 注意这里\n                continuation.resume(data)\n            }\n\n\n            override fun onFail(throwable: Throwable) {\n                // 注意这里\n                continuation.resumeWithException(throwable)\n            }\n        })\n\n        continuation.invokeOnCancellation {\n            println(&quot;Call cancelled!&quot;)\n            call.cancel()\n        }\n    }\n</code></pre><p>当我们想要实现挂起函数的时候，可以使用suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，在它们的Lambda当中，我们可以使用它暴露出来的continuation对象，把程序的执行结果或异常传到外部去。</p><p><strong>这种方式，往往是用于实现挂起函数内部逻辑的。</strong></p><p>比如说，我们可以用suspendCoroutine{}写一个更加简单的例子：</p><pre><code>// 代码段2\n\nfun main() = runBlocking {\n    val result = getLengthSuspend(&quot;Kotlin&quot;)\n    println(result)\n}\n\nsuspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt;\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        continuation.resume(text.length)\n    }\n}\n\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>以上代码里，我们是使用suspendCoroutine{}实现了挂起函数，然后在它的内部，我们使用continuation.resume()的方式，传出了挂起函数的返回值。</p><p>可能你会觉得奇怪，为什么以continuation.resume()这样异步的方式传出结果以后，挂起函数就能接收到结果呢？其实，当我们把main()函数当中的调用逻辑改一下，这一切就会清晰明了。</p><pre><code>// 代码段3\n\n// 变化在这里\nfun main()  {\n    val func = ::getLengthSuspend as (String, Continuation&lt;Int&gt;) -&gt; Any?\n\n    func(&quot;Kotlin&quot;, object: Continuation&lt;Int&gt;{\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result&lt;Int&gt;) {\n            println(result.getOrNull())\n        }\n    })\n\n    // 防止程序提前结束\n    Thread.sleep(2000L)\n}\n\nsuspend fun getLengthSuspend(text: String): Int = suspendCoroutine { continuation-&gt;\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        continuation.resume(text.length)\n    }\n}\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>可以看到，在这段代码里，我们借助上节课的知识，把getLengthSuspend()这个函数强转成了带有Continuation的函数类型，然后通过匿名内部类的方式，创建了一个Continuation对象传了进去。最终，程序的执行结果和代码段2是一致的。</p><p>你还记得我在<a href="https://time.geekbang.org/column/article/487085">第15讲</a>提到过的观点吗？</p><blockquote>\n<p>挂起函数的本质，就是Callback!</p>\n</blockquote><p>那么现在，就让我们把Continuation改为Callback，看看代码会变成什么样子。</p><pre><code>// 代码段4\n\n// 变化在这里\nfun main()  {\n    func(&quot;Kotlin&quot;, object: Callback&lt;Int&gt;{\n        override fun resume(result: Int) {\n            println(result)\n        }\n    })\n\n    // 防止程序提前结束\n    Thread.sleep(2000L)\n}\n\nfun func(text: String, callback: Callback&lt;Int&gt;) {\n    thread {\n        // 模拟耗时\n        Thread.sleep(1000L)\n        callback.resume(text.length)\n    }\n}\n\ninterface Callback&lt;T&gt; {\n    fun resume(value: T)\n}\n\n/*\n输出结果：\n等待1秒\n6\n*/\n</code></pre><p>可见，当我们把Continuation改成Callback以后，整个代码就变成了我们曾经最熟悉的异步回调代码了。调用方，可以使用匿名内部类创建Callback用于接收异步结果；异步函数内部，使用callback.resume()将结果传出去。</p><p>综上所述，Kotlin协程当中的Continuation，作用其实就相当于Callback，它既可以用于<strong>实现挂起函数</strong>，往挂起函数的外部传递结果；也可以用于<strong>调用挂起函数</strong>，我们可以创建Continuation的匿名内部类，来接收挂起函数传递出来的结果。</p><p>所以在这里，我们也就可以轻松回答上节课的思考题了：</p><blockquote>\n<p>我们都知道挂起函数是Kotlin协程里才有的概念，请问，Java代码中可以调用Kotlin的挂起函数吗？比如，下面这个函数，我们可以在Java当中调用吗？</p>\n</blockquote><pre><code>// 代码段5\n\n// 需要在Java中调用的Kotlin挂起函数\nobject SuspendFromJavaExample {\n    // 在Java当中如何调用这个方法？\n    suspend fun getUserInfo(id: Long):String {\n        delay(1000L)\n        return &quot;Kotlin&quot;\n    }\n}\n</code></pre><p>答案当然是肯定的，Java当中调用挂起函数的方式，其实跟前面的代码段3是一样的：</p><pre><code>// 代码段6\n\npublic static void main(String[] args) throws InterruptedException {\n    SuspendFromJavaExample.INSTANCE.getUserInfo(100L, new Continuation&lt;String&gt;() {\n        @NotNull\n        @Override\n        public CoroutineContext getContext() {\n            return EmptyCoroutineContext.INSTANCE;\n        }\n\n        @Override\n        public void resumeWith(@NotNull Object o) {\n            System.out.println(o+&quot;&quot;);\n        }\n    });\n\n    // 防止程序提前结束\n    Thread.sleep(2000L);\n}\n\n/*\n输出结果\nKotlin\n*/\n</code></pre><p>在上面的代码中，我们只是把代码段3的思想应用到了Java代码中而已，唯一需要<strong>注意</strong>的，就是：在Java当中访问Kotlin的object单例，是需要加上INSTANCE后缀的。这一点，我们在<a href="https://time.geekbang.org/column/article/475058">第5讲</a>当中就已经了解过。</p><p>看到这里，可以发现，我们在实现挂起函数逻辑的时候，总是离不开<strong>suspendCoroutine{}、suspendCancellableCoroutine{}</strong>。其实，这两个高阶函数也是Kotlin协程的基础元素，让我们来进一步认识这两个高阶函数。</p><h2>suspendCoroutineUninterceptedOrReturn</h2><p>实际上，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数的实现原理是类似的，所以这里我们就主要解释下suspendCoroutine{}。</p><p>如果你去看suspendCoroutine{}的源代码，会发现它其实也在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中。</p><pre><code>// 代码段7\n\npublic interface Continuation&lt;in T&gt; {\n    public val context: CoroutineContext    \n    public fun resumeWith(result: Result&lt;T&gt;)\n}\n\npublic suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T {\n\n    // 注意这里\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation&lt;T&gt; -&gt;\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n</code></pre><p>在上面的代码中，我们第一眼就能看到一个名字特别长的高阶函数suspendCoroutineUninterceptedOrReturn{}。它其实就是实现suspendCoroutine{}的关键。除了它之外，其他部分的代码都很好理解：</p><ul>\n<li>SafeContinuation(c.intercepted())这行代码的作用，就是把原本的Continuation包裹一遍。</li>\n<li>block(safe)这行代码，其实就是在调用Lambda当中的逻辑。</li>\n<li>safe.getOrThrow()，就是在取出block(safe)的运行结果，我们在上节课也提到过，Continuation当中是可以存储result的。这个Result可能是正确的结果，也可能是异常。</li>\n</ul><p>下面我们重点来看看suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用。如果你去看它的源代码，那你看到的大概率会是这样的：</p><pre><code>// 代码段8\n\npublic suspend inline fun &lt;T&gt; suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation&lt;T&gt;) -&gt; Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;)\n}\n</code></pre><p>大部分人看到这样的代码可能都会觉得奇怪：<strong>为什么这个高阶函数的源代码会是抛出异常呢？</strong></p><p>在前面的加餐二“表达式思维”里，我其实有做过说明，如果你还有印象的话，应该就能理解这样的代码也是符合函数返回值的规范的。不过，如果它总是抛异常的话，我们用suspendCoroutine{}写代码的时候，为什么不会产生崩溃呢？这个异常信息里的提示内容又是什么意思？</p><blockquote>\n<p>“Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic.”</p>\n</blockquote><p>实际上，理解这句话的关键在于“intrinsic”这个单词，它有“固有”“本质”的意思，不过在上面这句话的语境下，这里的intrinsic其实是指编译器领域的一个术语，我们可以把它理解为“内建”。因此，上面我们看到的异常提示信息的意思就是：suspendCoroutineUninterceptedOrReturn是一个编译器内建函数，<strong>它是由Kotlin编译器来实现的</strong>。</p><p>为了不偏离这节课的主题，这里我们就不去深究Kotlin编译器当中的逻辑了，感兴趣的话你可以自行研究这个<a href="https://github.com/JetBrains/kotlin/blob/1.6.0/compiler/backend/src/org/jetbrains/kotlin/codegen/coroutines/coroutineCodegenUtil.kt">链接</a>。接下来，我们可以换一个角度，写一些Demo代码，通过运行调试来看看这个内建函数的功能和作用。</p><p>让我们先来看看suspendCoroutineUninterceptedOrReturn这个高阶函数的参数，它会接收一个Lambda，类型是<code>(Continuation&lt;T&gt;) -&gt; Any?</code>，经过上节课的学习，你是否觉得这个类型有些眼熟呢？这里的“Any?”类型，其实就能代表当前这个挂起函数是否真正挂起。</p><p>因此，我们可以写出下面这样的代码：</p><pre><code>// 代码段9\n\nfun main() = runBlocking {\n    val result = testNoSuspendCoroutine()\n    println(result)\n}\n\nprivate suspend fun testNoSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; {\n        continuation -&gt;\n    return@suspendCoroutineUninterceptedOrReturn &quot;Hello!&quot;\n}\n\n/*\n输出结果：\nHello!\n*/\n</code></pre><p>在这段代码中，我们直接使用suspendCoroutineUninterceptedOrReturn实现了挂起函数，并且，在它的Lambda当中，我们并没有调用continuation.resume()，而是直接返回了结果“Hello!”。根据程序的运行结果，我们可以看到，在挂起函数的外部确实也可以接收到这个结果。</p><p>那么这时候，如果我们把上面的代码反编译一下，会看到类似这样的代码：</p><pre><code>    // 代码段10\n\n    private static final Object testNoSuspendCoroutine(Continuation $completion) {\n      int var2 = false;\n      if (&quot;Hello!&quot; == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {\n         DebugProbesKt.probeCoroutineSuspended($completion);\n      }\n    \n      return &quot;Hello!&quot;;\n    }\n</code></pre><p>所以，从反编译的结果来看，testNoSuspendCoroutine()这个函数其实就是一个<strong>伪挂起函数</strong>，它的内部并不会真正挂起。这样，当我们从外部调用这个函数的时候，这个函数会立即返回结果“Hello!”。</p><p>而这时候，我们可以再写一个真正的挂起函数：</p><pre><code>// 代码段11\n\nfun main() = runBlocking {\n    val result = testSuspendCoroutine()\n    println(result)\n}\n\nprivate suspend fun testSuspendCoroutine() = suspendCoroutineUninterceptedOrReturn&lt;String&gt; {\n    continuation -&gt;\n    thread {\n        Thread.sleep(1000L)\n        continuation.resume(&quot;Hello!&quot;)\n\n\n    }\n    return@suspendCoroutineUninterceptedOrReturn kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n}\n\n/*\n输出结果：\n等待1秒\nHello!\n*/\n</code></pre><p>这一次，我们并没有使用return返回结果，而是使用了continuation.resume()。通过程序运行结果，我们可以看到挂起函数的外部也能接收到这个结果。然后我们也再来反编译一下，看看它对应的Java代码：</p><pre><code>// 代码段12\n\nprivate static final Object testSuspendCoroutine(Continuation $completion) {\n    int var2 = false;\n    // 1\n    ThreadsKt.thread$default(false, false, (ClassLoader)null, (String)null, 0, (Function0)(new CoroutineBasicElementsKt$testSuspendCoroutine$2$1($completion)), 31, (Object)null);\n    // 2\n    Object var10000 = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n    if (var10000 == IntrinsicsKt.getCOROUTINE_SUSPENDED()) {\n     DebugProbesKt.probeCoroutineSuspended($completion);\n    }\n    // 3\n    return var10000;\n}\n\nfinal class CoroutineBasicElementsKt$testSuspendCoroutine$2$1 extends Lambda implements Function0 {\n\n   final Continuation $it;\n\n   public Object invoke() {\n      this.invoke();\n      return Unit.INSTANCE;\n   }\n\n   public final void invoke() {\n      // 4\n      Thread.sleep(1000L);\n      Continuation var1 = this.$it;\n      String var2 = &quot;Hello!&quot;;\n      Companion var3 = Result.Companion;\n      var1.resumeWith(Result.constructor-impl(var2));\n   }\n\n   CoroutineBasicElementsKt$testSuspendCoroutine$2$1(Continuation var1) {\n      super(0);\n      this.$it = var1;\n   }\n}\n</code></pre><p>以上代码中一共有4个注释，我们一个个看：</p><ul>\n<li>注释1、4，创建了一个新的线程，执行了thread{}当中的代码。</li>\n<li>注释2，将var10000赋值为COROUTINE_SUSPENDED这个挂起标志位。</li>\n<li>注释3，返回挂起标志位，代表testSuspendCoroutine()这个函数会真正挂起。</li>\n</ul><p>所以，这两个例子其实也从侧面证明了我们在上节课当中的结论：</p><blockquote>\n<p>由于 suspend 修饰的函数，既可能返回 CoroutineSingletons.COROUTINE_SUSPENDED，也可能返回实际结果，甚至可能返回 null，为了适配所有的可能性，CPS转换后的函数返回值类型就只能是Any?了。</p>\n</blockquote><p>那么现在，我们也就可以总结出<strong>suspendCoroutineUninterceptedOrReturn{}这个高阶函数的作用</strong>了：它可以将挂起函数当中的Continuation以参数的形式暴露出来，在它的Lambda当中，我们可以直接返回结果，这时候它就是一个“伪挂起函数”；或者，我们也可以返回COROUTINE_SUSPENDED这个挂起标志位，然后使用continuation.resume()传递结果。</p><p>相应的，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，只是对它的一种封装而已。</p><h2>小结</h2><p>这节课，我们学习了Kotlin协程当中与挂起函数密切相关的两个基础元素，Continuation、suspendCoroutine{}。</p><p>Continuation是整个协程当中最重要的基础元素，我们可以将其看做是一个Callback。它主要有两个使用场景，一种是在实现挂起函数的时候，用于传递挂起函数的执行结果；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于接收挂起函数的执行结果。借助这种思路，我们也完全可以在Java当中调用挂起函数。</p><p>当我们想要实现挂起函数的时候，我们往往需要使用suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数。它们两个都是对suspendCoroutineUninterceptedOrReturn{}的封装，这个高阶函数的作用其实就是暴露挂起函数的Continuation对象。在它的Lambda当中，我们既可以直接返回执行结果，也可以返回COROUTINE_SUSPENDED这个挂起标志位，然后使用continuation.resume()传递结果。</p><h2>思考题</h2><p>你觉得，suspendCoroutine{}、suspendCancellableCoroutine{}这两个高阶函数，它对比suspendCoroutineUninterceptedOrReturn{}的优势在哪里？Kotlin官方为什么要进行这样的封装呢？</p><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "加餐五 | 深入理解协程基础元素",
      },
      {
        title: "28 | launch的背后到底发生了什么？",
        id: 499826,
        content:
          '<p>你好，我是朱涛。</p><p>在前面的课程里，我们一直在研究如何使用Kotlin协程，比如，如何启动协程，如何使用挂起函数，如何使用Channel、Flow等API。但到目前为止，我们只知道该怎么用协程，对它内部的运行机制并没有深究。</p><p>现在我们都知道，launch、async可以创建、启动新的协程，但我们只能通过调试参数，通过log看到协程。比如我们可以回过头来看下<a href="https://time.geekbang.org/column/article/485632">第13讲</a>当中的代码：</p><pre><code class="language-plain">// 代码段1\n\n// 代码中一共启动了两个协程\nfun main() = runBlocking {\n    println(Thread.currentThread().name)\n\n    launch {\n        println(Thread.currentThread().name)\n        delay(100L)\n    }\n\n    Thread.sleep(1000L)\n}\n\n/*\n输出结果：\nmain @coroutine#1\nmain @coroutine#2\n*/\n</code></pre><p>现在回过头来看，这段代码无疑是非常简单的，runBlocking{} 启动了第一个协程，launch{} 启动了第二个协程。可是，有一个问题，我们一直都没有找到答案：<strong>协程到底是如何创建的？它对应的源代码，到底在哪个类？具体在哪一行？</strong></p><p>我们常说Java线程的源代码是Thread.java，这样说虽然不一定准确，但我们起码能看到几个暴露出来的方法。那么，在Kotlin协程当中，有没有类似Coroutine.kt的类呢？对于这些问题，我们唯有去阅读Kotlin协程的源码、去分析launch的启动流程，才能找到答案。</p><!-- [[[read_end]]] --><p>这节课，我就将从<a href="https://time.geekbang.org/column/article/495862">第26讲</a>当中提到的createCoroutine{}、startCoroutine{} 这两个函数开始说起，在认识了这两个协程基础元素以后，我们就会进入协程的“中间层”，开始分析launch的源代码。我相信，学完这节课以后，你一定会对Kotlin协程有一个更加透彻的认识。</p><h2>协程启动的基础API</h2><p>在第26讲里，我给你留了一个思考题，在<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt">Continuation.kt</a>这个文件当中，还有两个重要的扩展函数：</p><pre><code class="language-plain">// 代码段2\n\npublic fun &lt;T&gt; (suspend () -&gt; T).createCoroutine(\n    completion: Continuation&lt;T&gt;\n): Continuation&lt;Unit&gt; =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(\n    completion: Continuation&lt;T&gt;\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n</code></pre><p>其实，createCoroutine{}、startCoroutine{}这两个函数，就是Kotlin协程当中最基础的两个创建协程的API。</p><p>我们在<a href="https://time.geekbang.org/column/article/486305">第14讲</a>里曾经提到过，启动协程有三种常见的方式：launch、runBlocking、async。它们其实属于协程中间层提供的API，而它们的底层都在某种程度上调用了“基础层”的协程API。</p><p>那么，这是不是就意味着：<strong>我们使用协程的基础层API，也可以创建协程呢？</strong></p><p>答案当然是肯定的。我们可以来分析一下代码段2当中的函数签名。</p><p>createCoroutine{}、startCoroutine{}，它们都是扩展函数，其扩展接收者类型是一个函数类型：<code>suspend () -&gt; T</code>，代表了“无参数，返回值为T的挂起函数或者Lambda”。而对于函数本身，它们两个都接收一个 <code>Continuation&lt;T&gt;</code> 类型的参数，其中一个函数，还会返回一个 <code>Continuation&lt;Unit&gt;</code> 类型的返回值。</p><p>也许你对于“给函数类型增加扩展”这样的行为会感到不太适应。不过，在Kotlin当中，<strong>函数就是一等公民</strong>，普通的类型可以有扩展，那么，函数类型自然也可以有扩展。因此，我们完全可以写出像下面这样的代码：</p><pre><code class="language-plain">// 代码段3\n\nfun main() {\n    testStartCoroutine()\n    Thread.sleep(2000L)\n}\n\nval block = suspend {\n    println("Hello!")\n    delay(1000L)\n    println("World!")\n    "Result"\n}\n\nprivate fun testStartCoroutine() {\n\n    val continuation = object : Continuation&lt;String&gt; {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result&lt;String&gt;) {\n            println("Result is: ${result.getOrNull()}")\n        }\n    }\n\n    block.startCoroutine(continuation)\n}\n\n/*\n输出结果\nHello!\nWorld!\nResult is: Result\n*/\n</code></pre><p>在这段代码中，我们定义了一个Lambda表达式block，它的类型就是 <code>suspend () -&gt; T</code>。这样一来，我们就可以用block.startCoroutine()来启动协程了。这里，我们还创建了一个匿名内部类对象continuation，作为startCoroutine()的参数。</p><p>在<a href="https://time.geekbang.org/column/article/497868">加餐</a>里，我们提到过Continuation主要有两种用法，一种是在实现挂起函数的时候，用于<strong>传递挂起函数的执行结果</strong>；另一种是在调用挂起函数的时候，以匿名内部类的方式，用于<strong>接收挂起函数的执行结果</strong>。而代码段3中Continuation的作用，则明显属于后者。</p><p>从代码段3的执行结果中，我们可以看出来，startCoroutine()的作用其实就是创建一个新的协程，并且执行block当中的逻辑，等协程执行完毕以后，将结果返回给Continuation对象。而这个逻辑，我们使用 <strong>createCoroutine()</strong> 这个方法其实也可以实现。</p><pre><code class="language-plain">代码段4\n\nprivate fun testCreateCoroutine() {\n\n    val continuation = object : Continuation&lt;String&gt; {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result&lt;String&gt;) {\n            println("Result is: ${result.getOrNull()}")\n        }\n    }\n\n    val coroutine = block.createCoroutine(continuation)\n\n    coroutine.resume(Unit)\n}\n\n/*\n输出结果\nHello!\nWorld!\nResult is: Result\n*/\n</code></pre><p>根据以上代码，我们可以看到，createCoroutine()的作用其实就是创建一个协程，并暂时先不启动它。等我们想要启动它的时候，直接调用resume()即可。如果我们再进一步分析代码段2当中的源代码，会发现createCoroutine()、startCoroutine()的源代码差别也并不大，只是前者没有调用resume()，而后者调用了resume()。</p><p>换句话说，startCoroutine()之所以可以创建并同时启动协程的原因就在于，它在源码中直接调用了resume(Unit)，所以，我们在代码段3当中就不需要自己调用resume()方法了。</p><p>那么下面，我们就以startCoroutine()为例，来研究下它的实现原理。我们把代码段3反编译成Java，看看它会变成什么样子：</p><pre><code class="language-java">// 代码段5\n\npublic final class LaunchUnderTheHoodKt {\n    // 1\n    public static final void main() {\n        testStartCoroutine();\n        Thread.sleep(2000L);\n    }\n\n    // 2\n    private static final Function1&lt;Continuation&lt;? super String&gt;, Object&gt; block = new LaunchUnderTheHoodKt$block$1(null);\n\n    // 3\n    public static final Function1&lt;Continuation&lt;? super String&gt;, Object&gt; getBlock() {\n        return block;\n    }\n    // 4\n    static final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super String&gt;, Object&gt; {\n        int label;\n\n        LaunchUnderTheHoodKt$block$1(Continuation $completion) {\n          super(1, $completion);\n        }\n\n        @Nullable\n        public final Object invokeSuspend(@NotNull Object $result) {\n          Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n          switch (this.label) {\n            case 0:\n              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n              System.out\n                .println("Hello!");\n              this.label = 1;\n              if (DelayKt.delay(1000L, (Continuation)this) == object)\n                return object; \n              DelayKt.delay(1000L, (Continuation)this);\n              System.out\n                .println("World!");\n              return "Result";\n            case 1:\n              ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n              System.out.println("World!");\n              return "Result";\n          } \n          throw new IllegalStateException("call to \'resume\' before \'invoke\' with coroutine");\n        }\n\n        @NotNull\n        public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;? super LaunchUnderTheHoodKt$block$1&gt; $completion) {\n          return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$block$1($completion);\n        }\n\n        @Nullable\n        public final Object invoke(@Nullable Continuation&lt;?&gt; p1) {\n          return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE);\n        }\n    }\n\n    // 5\n    private static final void testStartCoroutine() {\n        LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 continuation = new LaunchUnderTheHoodKt$testStartCoroutine$continuation$1();\n        ContinuationKt.startCoroutine(block, continuation);\n    }\n\n    // 6\n    public static final class LaunchUnderTheHoodKt$testStartCoroutine$continuation$1 implements Continuation&lt;String&gt; {\n        @NotNull\n        public CoroutineContext getContext() {\n          return (CoroutineContext)EmptyCoroutineContext.INSTANCE;\n        }\n\n        public void resumeWith(@NotNull Object result) {\n          System.out.println(Intrinsics.stringPlus("Result is: ", Result.isFailure-impl(result) ? null : result));\n        }\n    }\n}\n\n\ninternal abstract class SuspendLambda(\n    public override val arity: Int,\n    completion: Continuation&lt;Any?&gt;?\n) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction {}\n</code></pre><p>上面的反编译代码中，一共有6个注释，我们一个个来看：</p><ul>\n<li>注释1，是我们的main()函数。由于它本身只是一个普通的函数，因此反编译之后，逻辑并没有什么变化。</li>\n<li>注释2、3，它们是Kotlin为block变量生成的静态变量以及方法。</li>\n<li>注释4，<code>LaunchUnderTheHoodKt$block$1</code>，其实就是block具体的实现类。这个类继承自SuspendLambda，而SuspendLambda是ContinuationImpl的子类，因此它也间接实现了Continuation接口。其中的invokeSuspend()，也就是我们在上节课分析过的<strong>协程状态机逻辑</strong>。除此之外，它还有一个create()方法，我们在后面会来分析它。</li>\n<li>注释5，它对应了testStartCoroutine()这个方法，原本的 <code>block.startCoroutine(continuation)</code> 变成了“<code>ContinuationKt.startCoroutine(block, continuation)</code>”，这其实就体现出了扩展函数的原理。</li>\n<li>注释6，其实就是continuation变量对应的匿名内部类。</li>\n</ul><p>那么接下来，我们就可以对照着反编译代码，来分析整个代码的执行流程了。</p><p>首先，main()函数会调用testStartCoroutine()函数，接着，就会调用startCoroutine()方法。</p><pre><code class="language-plain">// 代码段6\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(\n    completion: Continuation&lt;T&gt;\n) {\n//        注意这里\n//           ↓\ncreateCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n</code></pre><p>从代码段6里，我们可以看到，在startCoroutine()当中，首先会调用createCoroutineUnintercepted()方法。如果我们直接去看它的源代码，会发现它只存在一个声明，并没有具体实现：</p><pre><code class="language-plain">// 代码段7\n\n//    注意这里\n//       ↓\npublic expect fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted(\n    completion: Continuation&lt;T&gt;\n): Continuation&lt;Unit&gt;\n</code></pre><p>上面代码中的expect，我们可以把它理解为一种<strong>声明</strong>，由于Kotlin是面向多个平台的，具体的实现，就需要在特定的平台实现。所以在这里，我们就需要打开Kotlin的源代码，找到JVM平台对应的实现：</p><pre><code class="language-plain">// 代码段8\n\n//    1，注意这里\n//       ↓\npublic actual fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted(\n    completion: Continuation&lt;T&gt;\n): Continuation&lt;Unit&gt; {\n    val probeCompletion = probeCoroutineCreated(completion)\n    //             2，注意这里\n    //               ↓\n    return if (this is BaseContinuationImpl)\n        create(probeCompletion)\n    else\n        createCoroutineFromSuspendFunction(probeCompletion) {\n            (this as Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)\n        }\n}\n</code></pre><p>请留意这里的注释1，这个actual，代表了createCoroutineUnintercepted()在JVM平台的实现。</p><p>另外，我们可以看到，createCoroutineUnintercepted()仍然还是一个扩展函数，注释2处的this，其实就代表了前面代码段3当中的block变量。我们结合代码段5反编译出来的 <code>LaunchUnderTheHoodKt$block$1</code>，可以知道block其实就是SuspendLambda的子类，而SuspendLambda则是ContinuationImpl的子类。</p><p>因此，注释2处的 <code>(this is BaseContinuationImpl)</code> 条件一定是为 <strong>true</strong> 的。这时候，它就会调用 <code>create(probeCompletion)</code>。</p><p>然后，如果你去查看create()的源代码，会看到这样的代码：</p><pre><code class="language-plain">// 代码段9\n\npublic open fun create(completion: Continuation&lt;*&gt;): Continuation&lt;Unit&gt; {\n    throw UnsupportedOperationException("create(Continuation) has not been overridden")\n}\n</code></pre><p>可以看到，在默认情况下，这个create()方法是会抛出异常的，它的提示信息是：create()方法没有被重写！潜台词就是，create()方法应该被重写！如果不被重写，就会抛出异常。</p><p>那么，<strong>create()方法是在哪里被重写的呢？</strong>答案其实就在代码段5的“<code>LaunchUnderTheHoodKt$block$1</code>”这个block的实现类当中。</p><pre><code class="language-java">// 代码段10\n\nstatic final class LaunchUnderTheHoodKt$block$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super String&gt;, Object&gt; {\n    int label;\n\n    LaunchUnderTheHoodKt$block$1(Continuation $completion) {\n      super(1, $completion);\n    }\n\n    @Nullable\n    public final Object invokeSuspend(@NotNull Object $result) {\n      Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n      switch (this.label) {\n        case 0:\n          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n          System.out\n            .println("Hello!");\n          this.label = 1;\n          if (DelayKt.delay(1000L, (Continuation)this) == object)\n            return object; \n          DelayKt.delay(1000L, (Continuation)this);\n          System.out\n            .println("World!");\n          return "Result";\n        case 1:\n          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n          System.out.println("World!");\n          return "Result";\n      } \n      throw new IllegalStateException("call to \'resume\' before \'invoke\' with coroutine");\n    }\n\n    // 1，注意这里\n    public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;? super LaunchUnderTheHoodKt$block$1&gt; $completion) {\n      return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$block$1($completion);\n    }\n\n    @Nullable\n    public final Object invoke(@Nullable Continuation&lt;?&gt; p1) {\n      return ((LaunchUnderTheHoodKt$block$1)create(p1)).invokeSuspend(Unit.INSTANCE);\n    }\n}\n</code></pre><p>这里，你可以留意下代码里的注释1，这个其实就是重写之后的create()方法。换句话说，代码段8当中的 <code>create(probeCompletion)</code>，最终会调用代码段10的create()方法，它最终会返回“<code>LaunchUnderTheHoodKt$block$1</code>”这个block实现类，对应的Continuation对象。</p><p><strong>这行代码，其实就对应着协程被创建的时刻。</strong></p><p>好，到这里，协程创建的逻辑就分析完了，我们再回到startCoroutine()的源码，看看它后续的逻辑。</p><pre><code class="language-plain">// 代码段11\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(\n    completion: Continuation&lt;T&gt;\n) {\n//                                           注意这里\n//                                             ↓\ncreateCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n</code></pre><p>类似的，intercepted()这个方法的源代码，我们也需要去Kotlin的源代码当中找到对应的JVM实现。</p><pre><code class="language-plain">// 代码段12\n\npublic actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =\n    (this as? ContinuationImpl)?.intercepted() ?: this\n</code></pre><p>它的逻辑很简单，只是将Continuation强转成了ContinuationImpl，调用了它的intercepted()。这里有个细节，由于this的类型是“<code>LaunchUnderTheHoodKt$block$1</code>”，它是ContinuationImpl的子类，所以这个类型转换一定可以成功。</p><p>接下来，我们看看ContinuationImpl的源代码。</p><pre><code class="language-plain">// 代码段13\n\ninternal abstract class ContinuationImpl(\n    completion: Continuation&lt;Any?&gt;?,\n    private val _context: CoroutineContext?\n) : BaseContinuationImpl(completion) {\n\n    @Transient\n    private var intercepted: Continuation&lt;Any?&gt;? = null\n\n    public fun intercepted(): Continuation&lt;Any?&gt; =\n        intercepted\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted = it }\n}\n</code></pre><p>这里其实就是通过ContinuationInterceptor，对Continuation进行拦截，从而将程序的执行逻辑派发到特定的线程之上，这部分的逻辑我们在下一讲会再展开。</p><p>让我们回到startCoroutine()的源码，看看它的最后一步 <strong>resume(Unit)</strong>。</p><pre><code class="language-plain">// 代码段14\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutine(\n    completion: Continuation&lt;T&gt;\n) {\n//                                                   注意这里\n//                                                      ↓\ncreateCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n</code></pre><p>这里的 <code>resume(Unit)</code>，作用其实就相当于启动了协程。</p><p>好，现在我们已经弄清楚了startCoroutine()这个协程的基础API是如何启动协程的了。接下来，我们来看看中间层的launch{} 函数是如何启动协程的。</p><h2>launch是如何启动协程的？</h2><p>在研究launch的源代码之前，我们先来写一个简单的Demo：</p><pre><code class="language-plain">// 代码段15\n\nfun main() {\n    testLaunch()\n    Thread.sleep(2000L)\n}\n\nprivate fun testLaunch() {\n    val scope = CoroutineScope(Job())\n    scope.launch {\n        println("Hello!")\n        delay(1000L)\n        println("World!")\n    }\n}\n\n/*\n输出结果：\nHello!\nWorld!\n*/\n</code></pre><p>然后，我们还是通过反编译，来看看它对应的Java代码长什么样：</p><pre><code class="language-java">// 代码段16\n\npublic final class LaunchUnderTheHoodKt {\n  public static final void main() {\n    testLaunch();\n    Thread.sleep(2000L);\n  }\n\n  private static final void testLaunch() {\n    CoroutineScope scope = CoroutineScopeKt.CoroutineScope((CoroutineContext)JobKt.Job$default(null, 1, null));\n    BuildersKt.launch$default(scope, null, null, new LaunchUnderTheHoodKt$testLaunch$1(null), 3, null);\n  }\n\n  static final class LaunchUnderTheHoodKt$testLaunch$1 extends SuspendLambda implements Function2&lt;CoroutineScope, Continuation&lt;? super Unit&gt;, Object&gt; {\n    int label;\n\n    LaunchUnderTheHoodKt$testLaunch$1(Continuation $completion) {\n      super(2, $completion);\n    }\n\n    @Nullable\n    public final Object invokeSuspend(@NotNull Object $result) {\n      Object object = IntrinsicsKt.getCOROUTINE_SUSPENDED();\n      switch (this.label) {\n        case 0:\n          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n          System.out\n            .println("Hello!");\n          this.label = 1;\n          if (DelayKt.delay(1000L, (Continuation)this) == object)\n            return object; \n          DelayKt.delay(1000L, (Continuation)this);\n          System.out\n            .println("World!");\n          return Unit.INSTANCE;\n        case 1:\n          ResultKt.throwOnFailure(SYNTHETIC_LOCAL_VARIABLE_1);\n          System.out.println("World!");\n          return Unit.INSTANCE;\n      } \n      throw new IllegalStateException("call to \'resume\' before \'invoke\' with coroutine");\n    }\n\n    @NotNull\n    public final Continuation&lt;Unit&gt; create(@Nullable Object value, @NotNull Continuation&lt;? super LaunchUnderTheHoodKt$testLaunch$1&gt; $completion) {\n      return (Continuation&lt;Unit&gt;)new LaunchUnderTheHoodKt$testLaunch$1($completion);\n    }\n\n    @Nullable\n    public final Object invoke(@NotNull CoroutineScope p1, @Nullable Continuation&lt;?&gt; p2) {\n      return ((LaunchUnderTheHoodKt$testLaunch$1)create(p1, p2)).invokeSuspend(Unit.INSTANCE);\n    }\n  }\n}\n</code></pre><p>有了前面的经验，上面的代码对我们来说就很简单了。唯一需要注意的是“<code>LaunchUnderTheHoodKt$testLaunch$1</code>”这个类，它其实对应的就是我们launch当中的Lambda。</p><p>为了让它们之间的对应关系更加明显，我们可以换一种写法：</p><pre><code class="language-plain">// 代码段17\n\nprivate fun testLaunch() {\n    val scope = CoroutineScope(Job())\n    val block: suspend CoroutineScope.() -&gt; Unit = {\n        println("Hello!")\n        delay(1000L)\n        println("World!")\n    }\n    scope.launch(block = block)\n}\n</code></pre><p>这段代码中的block，其实就对应着“<code>LaunchUnderTheHoodKt$testLaunch$1</code>”这个类。这里的block，<strong>本质上仍然是一个Continuation</strong>。</p><p>好，接下来，我们来看看launch{} 的源代码。</p><pre><code class="language-plain">public fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {\n    // 1\n    val newContext = newCoroutineContext(context)\n    // 2\n    val coroutine = if (start.isLazy)\n        LazyStandaloneCoroutine(newContext, block) else\n        StandaloneCoroutine(newContext, active = true)\n    // 3\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n</code></pre><p>上面的代码一共有三个注释，我们也来分析一下：</p><ul>\n<li>注释1，launch会根据传入的CoroutineContext创建出新的Context。</li>\n<li>注释2，launch会根据传入的启动模式来创建对应的协程对象。这里有两种，一种是标准的，一种是懒加载的。</li>\n<li>注释3，尝试启动协程。</li>\n</ul><p>我们跟进coroutine.start()这个方法，会进入AbstractCoroutine这个抽象类：</p><pre><code class="language-plain">public abstract class AbstractCoroutine&lt;in T&gt;(\n    parentContext: CoroutineContext,\n    initParentJob: Boolean,\n    active: Boolean\n) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope {\n\n    // 省略\n\n    public fun &lt;R&gt; start(start: CoroutineStart, receiver: R, block: suspend R.() -&gt; T) {\n        start(block, receiver, this)\n    }\n}\n</code></pre><p>到这里，我们其实就能看到，Java当中有Thread.java对应线程的逻辑，而Kotlin协程当中，也有AbstractCoroutine.kt这个类对应协程的抽象逻辑。AbstractCoroutine有一个start()方法，专门用于启动协程。</p><p>我们继续跟进 <code>start(block, receiver, this)</code>，就会进入CoroutineStart.invoke()。</p><pre><code class="language-plain">public enum class CoroutineStart {\n    public operator fun &lt;T&gt; invoke(block: suspend () -&gt; T, completion: Continuation&lt;T&gt;): Unit =\n        when (this) {\n            DEFAULT -&gt; block.startCoroutineCancellable(completion)\n            ATOMIC -&gt; block.startCoroutine(completion)\n            UNDISPATCHED -&gt; block.startCoroutineUndispatched(completion)\n            LAZY -&gt; Unit // will start lazily\n        }\n}\n</code></pre><p>在这个invoke()方法当中，它会根据launch传入的启动模式，以不同的方式启动协程。当我们的启动模式是ATOMIC的时候，就会调用 <code>block.startCoroutine(completion)</code>。<strong>而这个，其实就是我们在课程最开始研究过的startCoroutine()这个协程基础API。</strong></p><p>而另外两个方法，<code>startCoroutineUndispatched(completion)</code> 和 <code>startCoroutineCancellable(completion)</code>，我们从名字上也能判断出，它们只是在startCoroutine()的基础上增加了一些额外的功能而已。前者代表启动协程以后就不会被分发，后者代表启动以后可以响应取消。</p><p>然后，对于代码段15的launch逻辑而言，由于我们没有传入特定的启动模式，因此，这里会<strong>执行默认的模式</strong>，也就是调用“s<code>tartCoroutineCancellable(completion)</code>”这个方法。</p><pre><code class="language-plain">public fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    // 1\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\npublic actual fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted(\n    completion: Continuation&lt;T&gt;\n): Continuation&lt;Unit&gt; {\n    val probeCompletion = probeCoroutineCreated(completion)\n\n    return if (this is BaseContinuationImpl)\n        // 2\n        create(probeCompletion)\n    else\n        createCoroutineFromSuspendFunction(probeCompletion) {\n            (this as Function1&lt;Continuation&lt;T&gt;, Any?&gt;).invoke(it)\n        }\n}\n</code></pre><p>那么，通过查看startCoroutineCancellable()的源代码，我们能发现，它最终还是会调用我们之前分析过的 <strong>createCoroutineUnintercepted()</strong>，而在它的内部，仍然会像我们之前分析过的，去调用 <strong>create(probeCompletion)</strong>，然后最终会调用代码段16当中“<code>LaunchUnderTheHoodKt$testLaunch$1</code>”的 <strong>create()</strong> 方法。</p><p>至此，launch启动协程的整个过程，我们就已经分析完了。其实，launch这个API，只是对协程的基础元素startCoroutine()等方法进行了一些封装而已。</p><p>看完这么多的代码和文字，相信你可能已经有一些感觉了，不过可能对整个流程还是有些模糊。这里我做了一个视频，描述了launch的执行流程。</p><p><video poster="https://media001.geekbang.org/d73d6006c2ce4a209b3cba2b6c5ebafe/snapshots/fcfe8c9744f24d839fba5ae3a0f0df11-00002.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/579f8748-17fcbea5357-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/b530ae502d4c45d890ca9980b8015d92/ef1ed378d5c641eabb79638108d93169-41692a60cf345f0654e492ba41cca21a-sd.m3u8" type="application/x-mpegURL"></video></p><h2>小结</h2><p>createCoroutine{}、startCoroutine{}，它们是Kotlin提供的两个底层API，前者是用来创建协程的，后者是用来创建并同时启动协程的。</p><p>通过反编译，我们发现，startCoroutine{} 最终会调用createCoroutineUnintercepted()这个函数，而它在JVM平台的实现，就是调用Lambda对应的实现类“<code>LaunchUnderTheHoodKt$block$1</code>”当中的create()方法。</p><p>另外，Kotlin协程框架在<strong>中间层</strong>实现了launch、async之类的协程构建器（Builder），你要知道，它们只是对协程底层API进行了更好的封装而已。它们除了拥有启动协程的基础能力，还支持传入CoroutineContext、CoroutineStart等参数，前者可以帮我们实现结构化并发，后者可以支持更灵活的启动模式。</p><h2>思考题</h2><p>在代码段3当中，我们使用的是 <code>suspend {}</code> 启动的协程，它的类型是 <code>suspend () -&gt; String</code>。那么，我们是否可以使用挂起函数启动协程呢？就像下面这样：</p><pre><code class="language-plain">private suspend fun func(): String {\n    println("Hello!")\n    delay(1000L)\n    println("World!")\n    return "Result"\n}\n\nprivate fun testStartCoroutineForSuspend() {\n    val block = ::func\n\n    val continuation = object : Continuation&lt;String&gt; {\n        override val context: CoroutineContext\n            get() = EmptyCoroutineContext\n\n        override fun resumeWith(result: Result&lt;String&gt;) {\n            println("Result is: ${result.getOrNull()}")\n        }\n    }\n\n    block.startCoroutine(continuation)\n}\n</code></pre><p>如果使用这种方式启动协程，它的整体执行流程和代码段3会有什么不一样吗？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "28 | launch的背后到底发生了什么？",
      },
      {
        title: "29 | Dispatchers是如何工作的？",
        id: 500420,
        content:
          '<p>你好，我是朱涛。今天，我们来分析Kotlin协程当中的Dispatchers。</p><p>上节课里，我们分析了launch的源代码，从中我们知道，Kotlin的launch会调用startCoroutineCancellable()，接着又会调用createCoroutineUnintercepted()，最终会调用编译器帮我们生成SuspendLambda实现类当中的create()方法。这样，协程就创建出来了。不过，协程是创建出来了，可它是如何运行的呢？</p><p>另外我们也都知道，协程无法脱离线程运行，Kotlin当中所有的协程，最终都是运行在线程之上的。<strong>那么，协程创建出来以后，它又是如何跟线程产生关联的？</strong>这节课，我们将进一步分析launch的启动流程，去发掘上节课我们忽略掉的代码分支。</p><p>我相信，经过这节课的学习，你会对协程与线程之间的关系有一个更加透彻的认识。</p><h2>Dispatchers</h2><p>在上节课里我们学习过，launch{}本质上是调用了startCoroutineCancellable()当中的createCoroutineUnintercepted()方法创建了协程。</p><pre><code class="language-plain">// 代码段1\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    //                                        注意这里\n    //                                           ↓\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n</code></pre><!-- [[[read_end]]] --><p>那么下面，我们就接着上节课的流程，继续分析createCoroutineUnintercepted(completion)之后的 <strong>intercepted()方法</strong>。</p><p>不过，在正式分析intercepted()之前，我们还需要弄清楚Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext之间的关系。</p><pre><code class="language-plain">// 代码段2\n\npublic actual object Dispatchers {\n\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n\n    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher\n\n    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined\n\n    public val IO: CoroutineDispatcher = DefaultIoScheduler\n\n    public fun shutdown() {    }\n}\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}\n\npublic interface ContinuationInterceptor : CoroutineContext.Element {}\n\npublic interface Element : CoroutineContext {}\n</code></pre><p>在<a href="https://time.geekbang.org/column/article/488571">第17讲</a>当中，我们曾经分析过它们之间的继承关系。Dispatchers是一个单例对象，它当中的Default、Main、Unconfined、IO，类型都是CoroutineDispatcher，而它本身就是CoroutineContext。所以，它们之间的关系就可以用下面这个图来描述。</p><p><img src="https://static001.geekbang.org/resource/image/2c/d1/2cf4c3c45b6f6838e5fyy16a4fce02d1.jpg?wh=2000x1125" alt=""></p><p>让我们结合这张图，来看看下面这段代码：</p><pre><code class="language-plain">// 代码段3\n\nfun main() {\n    testLaunch()\n    Thread.sleep(2000L)\n}\n\nprivate fun testLaunch() {\n    val scope = CoroutineScope(Job())\n    scope.launch{\n        logX("Hello!")\n        delay(1000L)\n        logX("World!")\n    }\n}\n\n/**\n * 控制台输出带协程信息的log\n */\nfun logX(any: Any?) {\n    println(\n        """\n================================\n$any\nThread:${Thread.currentThread().name}\n================================""".trimIndent()\n    )\n}\n\n/*\n输出结果\n================================\nHello!\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nWorld!\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n*/\n</code></pre><p>在这段代码中，我们没有为launch()传入任何CoroutineContext参数，但通过执行结果，我们发现协程代码居然执行在DefaultDispatcher，并没有运行在main线程之上。这是为什么呢？</p><p>我们可以回过头来分析下launch的源代码，去看看上节课中我们刻意忽略的地方。</p><pre><code class="language-plain">// 代码段4\n\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {\n    // 1\n    val newContext = newCoroutineContext(context)\n    val coroutine = if (start.isLazy)\n        LazyStandaloneCoroutine(newContext, block) else\n        StandaloneCoroutine(newContext, active = true)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n</code></pre><p>首先，请留意launch的第一个参数，context，它的默认值是EmptyCoroutineContext。在第17讲里，我曾提到过，CoroutineContext就相当于Map，而EmptyCoroutineContext则相当于一个空的Map。所以，我们可以认为，这里的EmptyCoroutineContext传了也相当于没有传，它的目的只是为了让context参数不为空而已。<strong>这其实也体现出了Kotlin的空安全思维，Kotlin官方用EmptyCoroutineContext替代了null。</strong></p><p>接着，请留意上面代码的注释1，这行代码会调用newCoroutineContext(context)，将传入的context参数重新包装一下，然后返回。让我们看看它具体的逻辑：</p><pre><code class="language-plain">// 代码段5\n\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    // 1\n    val combined = coroutineContext.foldCopiesForChildCoroutine() + context\n    // 2\n    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined\n    // 3\n    return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null)\n        debug + Dispatchers.Default else debug\n}\n</code></pre><p>这段代码一共有三个注释，我们来分析一下：</p><ul>\n<li>注释1，由于newCoroutineContext()是CoroutineScope的扩展函数，因此，我们可以直接访问CoroutineScope的coroutineContext对象，它其实就是CoroutineScope对应的上下文。foldCopiesForChildCoroutine()的作用，其实就是将CoroutineScope当中的所有上下文元素都拷贝出来，然后跟传入的context参数进行合并。<strong>这行代码，可以让子协程继承父协程的上下文元素。</strong></li>\n<li>注释2，它的作用是在调试模式下，为我们的协程对象增加唯一的ID。我们在代码段3的输出结果中看到的“@coroutine#1”，其中的数字“1”就是在这个阶段生成的。</li>\n<li>注释3，如果合并过后的combined当中没有CoroutineDispatcher，那么，就会默认使用Dispatchers.Default。</li>\n</ul><p>看到这里，你也许会有一个疑问，为什么协程默认的线程池是Dispatchers.Default，而不是Main呢？答案其实也很简单，因为Kotlin协程是支持多平台的，<strong>Main线程只在UI编程平台才有可用</strong>。因此，当我们的协程没有指定Dispatcher的时候，就只能使用Dispatchers.Default了。毕竟，协程是无法脱离线程执行的。</p><p>那么现在，代码段3当中的协程执行在Dispatchers.Default的原因也就找到了：由于我们定义的scope没有指定Dispatcher，同时launch的参数也没有传入Dispatcher，最终在newCoroutineContext()的时候，会被默认指定为Default线程池。</p><p>好，有了前面的基础以后，接下来，我们就可以开始intercepted()的逻辑了。</p><h2>CoroutineDispatcher拦截器</h2><p>让我们回到课程开头提到过的startCoroutineCancellable()方法的源代码，其中的createCoroutineUnintercepted()方法，我们在上节课已经分析过了，它的返回值类型就是\u0010Continuation。而<strong>intercepted()方法，其实就是Continuation的扩展函数</strong>。</p><pre><code class="language-plain">// 代码段6\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    //                                        注意这里\n    //                                           ↓\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\n\npublic actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =\n    (this as? ContinuationImpl)?.intercepted() ?: this\n\ninternal abstract class ContinuationImpl(\n    completion: Continuation&lt;Any?&gt;?,\n    private val _context: CoroutineContext?\n) : BaseContinuationImpl(completion) {\n    constructor(completion: Continuation&lt;Any?&gt;?) : this(completion, completion?.context)\n\n    @Transient\n    private var intercepted: Continuation&lt;Any?&gt;? = null\n\n    // 1\n    public fun intercepted(): Continuation&lt;Any?&gt; =\n        intercepted\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted = it }\n}\n</code></pre><p>从上面的代码中，我们可以看到，startCoroutineCancellable()当中的intercepted()最终会调用BaseContinuationImpl的intercepted()方法。</p><p>这里，请你留意代码中我标记出的注释，intercepted()方法首先会判断它的成员变量 <strong>intercepted是否为空</strong>，如果为空，就会调用context[ContinuationInterceptor]，获取上下文当中的Dispatcher对象。以代码段3当中的逻辑为例，这时候的Dispatcher肯定是Default线程池。</p><p>然后，如果我们继续跟进interceptContinuation(this)方法的话，会发现程序最终会调用CoroutineDispatcher的interceptContinuation()方法。</p><pre><code class="language-plain">// 代码段7\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n\n    // 1\n    public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =\n        DispatchedContinuation(this, continuation)\n}\n</code></pre><p>同样留意下这里的注释1，interceptContinuation()直接返回了一个DispatchedContinuation对象，并且将this、continuation作为参数传了进去。这里的this，其实就是Dispatchers.Default。</p><p>所以，如果我们把startCoroutineCancellable()改写一下，它实际上会变成下面这样：</p><pre><code class="language-plain">// 代码段8\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\n// 等价\n//  ↓\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    // 1\n    val continuation = createCoroutineUnintercepted(completion)\n    // 2\n    val dispatchedContinuation = continuation.intercepted()\n    // 3\n    dispatchedContinuation.resumeCancellableWith(Result.success(Unit))\n}\n</code></pre><p>在上面的代码中，注释1，2我们都已经分析完了，现在只剩下注释3了。这里的resumeCancellableWith()，其实就是真正将协程任务分发到线程上的逻辑。让我们继续跟进分析源代码：</p><pre><code class="language-plain">// 代码段9\n\ninternal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    inline fun resumeCancellableWith(\n        result: Result&lt;T&gt;,\n        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?\n    ) {\n        // 省略，留到后面分析\n    }\n\n}\n</code></pre><p>也就是，DispatchedContinuation是实现了Continuation接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性continuation。通过之前代码段7的分析，我们知道它的成员属性 <strong>dispatcher对应的就是Dispatcher.Default</strong>，而成员属性 <strong>continuation对应的则是launch当中传入的SuspendLambda实现类</strong>。</p><p>另外，DispatchedContinuation还继承自DispatchedTask，我们来看看DispatchedTask到底是什么。</p><pre><code class="language-plain">internal abstract class DispatchedTask&lt;in T&gt;(\n    @JvmField public var resumeMode: Int\n) : SchedulerTask() {\n\n}\n\ninternal actual typealias SchedulerTask = Task\n\ninternal abstract class Task(\n    @JvmField var submissionTime: Long,\n    @JvmField var taskContext: TaskContext\n) : Runnable {\n    constructor() : this(0, NonBlockingContext)\n    inline val mode: Int get() = taskContext.taskMode // TASK_XXX\n}\n</code></pre><p>可以看到，DispatchedContinuation继承自DispatchedTask，而它则是SchedulerTask的子类，SchedulerTask是Task的类型别名，而Task实现了Runnable接口。因此，<strong>DispatchedContinuation不仅是一个Continuation，同时还是一个Runnable。</strong></p><p>那么，既然它是Runnable，也就意味着它可以被分发到Java的线程当中去执行了。所以接下来，我们就来看看resumeCancellableWith()当中具体的逻辑：</p><pre><code class="language-plain">// 代码段9\n\ninternal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    inline fun resumeCancellableWith(\n        result: Result&lt;T&gt;,\n        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?\n    ) {\n        val state = result.toState(onCancellation)\n        // 1\n        if (dispatcher.isDispatchNeeded(context)) {\n            _state = state\n            resumeMode = MODE_CANCELLABLE\n            // 2\n            dispatcher.dispatch(context, this)\n        } else {\n            // 3\n            executeUnconfined(state, MODE_CANCELLABLE) {\n                if (!resumeCancelled(state)) {\n                    resumeUndispatchedWith(result)\n                }\n            }\n        }\n    }\n\n}\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    // 默认是true\n    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true\n\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n}\n\ninternal object Unconfined : CoroutineDispatcher() {\n    // 只有Unconfined会重写成false\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false\n}\n</code></pre><p>这段代码里也有三个注释，我们来分析一下：</p><ul>\n<li>注释1，dispatcher.isDispatchNeeded()，通过查看CoroutineDispatcher的源代码，我们发现它的返回值始终都是true。在它的子类当中，只有Dispatchers.Unconfined会将其重写成false。这也就意味着，除了Unconfined以外，其他的Dispatcher都会返回true。对于我们代码段3当中的代码而言，我们的Dispatcher是默认的Default，所以，代码将会进入注释2对应的分支。</li>\n<li>注释2，dispatcher.dispatch(context, this)，这里其实就相当于将代码的执行流程分发到Default线程池。dispatch()的第二个参数要求是Runnable，这里我们传入的是this，这是因为DispatchedContinuation本身就间接实现了Runnable接口。</li>\n<li>注释3，executeUnconfined{}，它其实就对应着Dispather是Unconfined的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。</li>\n</ul><p>接下来，让我们继续沿着注释2进行分析，这里的dispatcher.dispatch()其实就相当于调用了Dispatchers.Default.dispatch()。让我们看看它的逻辑：</p><pre><code class="language-plain">public actual object Dispatchers {\n\n    @JvmStatic\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n}\n\ninternal object DefaultScheduler : SchedulerCoroutineDispatcher(\n    CORE_POOL_SIZE, MAX_POOL_SIZE,\n    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n) {}\n</code></pre><p>那么，从上面的代码中，我们可以看到，<strong>Dispatchers.Default本质上是一个单例对象DefaultScheduler</strong>，它是SchedulerCoroutineDispatcher的子类。<br>\n我们也来看看SchedulerCoroutineDispatcher的源代码：</p><pre><code class="language-plain">internal open class SchedulerCoroutineDispatcher(\n    private val corePoolSize: Int = CORE_POOL_SIZE,\n    private val maxPoolSize: Int = MAX_POOL_SIZE,\n    private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    private val schedulerName: String = "CoroutineScheduler",\n) : ExecutorCoroutineDispatcher() {\n\n    private var coroutineScheduler = createScheduler()\n\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)\n}\n</code></pre><p>根据以上代码，我们可以看到Dispatchers.Default.dispatch()最终会调用SchedulerCoroutineDispatcher的dispatch()方法，而它实际上调用的是coroutineScheduler.dispatch()。</p><p>这里，我们同样再来看看CoroutineScheduler的源代码：</p><pre><code class="language-plain">internal class CoroutineScheduler(\n    @JvmField val corePoolSize: Int,\n    @JvmField val maxPoolSize: Int,\n    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME\n) : Executor, Closeable {\n\n    override fun execute(command: Runnable) = dispatch(command)\n\n    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {\n        trackTask() \n        // 1\n        val task = createTask(block, taskContext)\n        // 2\n        val currentWorker = currentWorker()\n        // 3\n        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)\n        if (notAdded != null) {\n            if (!addToGlobalQueue(notAdded)) {\n\n                throw RejectedExecutionException("$schedulerName was terminated")\n            }\n        }\n        val skipUnpark = tailDispatch &amp;&amp; currentWorker != null\n\n        if (task.mode == TASK_NON_BLOCKING) {\n            if (skipUnpark) return\n            signalCpuWork()\n        } else {\n\n            signalBlockingWork(skipUnpark = skipUnpark)\n        }\n    }\n\n    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }\n\n    // 内部类 Worker\n    internal inner class Worker private constructor() : Thread() {\n    }\n}\n</code></pre><p>你发现了吗？CoroutineScheduler其实是Java并发包下的Executor的子类，它的execute()方法也被转发到了dispatch()。</p><p>上面的代码里也有三个注释，我们分别来看看：</p><ul>\n<li>注释1，将传入的Runnable类型的block（也就是DispatchedContinuation），包装成Task。</li>\n<li>注释2，currentWorker()，拿到当前执行的线程。这里的Worker其实是一个内部类，它本质上仍然是Java的Thread。</li>\n<li>注释3，currentWorker.submitToLocalQueue()，将当前的Task添加到Worker线程的本地队列，等待执行。</li>\n</ul><p>那么接下来，我们就来分析下Worker是如何执行Task的。</p><pre><code class="language-plain">internal inner class Worker private constructor() : Thread() {\n\n    override fun run() = runWorker()\n\n    @JvmField\n    var mayHaveLocalTasks = false\n\n    private fun runWorker() {\n        var rescanned = false\n        while (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) {\n            // 1\n            val task = findTask(mayHaveLocalTasks)\n\n            if (task != null) {\n                rescanned = false\n                minDelayUntilStealableTaskNs = 0L\n                // 2\n                executeTask(task)\n                continue\n            } else {\n                mayHaveLocalTasks = false\n            }\n\n            if (minDelayUntilStealableTaskNs != 0L) {\n                if (!rescanned) {\n                    rescanned = true\n                } else {\n                    rescanned = false\n                    tryReleaseCpu(WorkerState.PARKING)\n                    interrupted()\n                    LockSupport.parkNanos(minDelayUntilStealableTaskNs)\n                    minDelayUntilStealableTaskNs = 0L\n                }\n                continue\n            }\n\n            tryPark()\n        }\n        tryReleaseCpu(WorkerState.TERMINATED)\n    }\n}\n</code></pre><p>实际上，Worker会重写Thread的run()方法，然后把执行流程交给runWorker()，以上代码里有两个关键的地方，我也用注释标记了。</p><ul>\n<li>注释1，在while循环当中，会一直尝试从Worker的本地队列取Task出来，如果存在需要执行的Task，就会进入下一步。</li>\n<li>注释2，executeTask(task)，其实就是执行对应的Task。</li>\n</ul><p>而接下来的逻辑，就是<strong>最关键的部分</strong>了：</p><pre><code class="language-plain">internal inner class Worker private constructor() : Thread() {\n    private fun executeTask(task: Task) {\n        val taskMode = task.mode\n        idleReset(taskMode)\n        beforeTask(taskMode)\n        // 1\n        runSafely(task)\n        afterTask(taskMode)\n    }\n}\n\nfun runSafely(task: Task) {\n    try {\n        // 2\n        task.run()\n    } catch (e: Throwable) {\n        val thread = Thread.currentThread()\n        thread.uncaughtExceptionHandler.uncaughtException(thread, e)\n    } finally {\n        unTrackTask()\n    }\n}\n\ninternal abstract class Task(\n    @JvmField var submissionTime: Long,\n    @JvmField var taskContext: TaskContext\n) : Runnable {\n    constructor() : this(0, NonBlockingContext)\n    inline val mode: Int get() = taskContext.taskMode // TASK_XXX\n}\n</code></pre><p>在Worker的executeTask()方法当中，会调用runSafely()方法，而在这个方法当中，最终会调用task.run()。前面我们就提到过 <strong>Task本质上就是Runnable，而Runnable.run()其实就代表了我们的协程任务真正执行了！</strong></p><p>那么，task.run()具体执行的代码是什么呢？其实它是执行的 <strong>DispatchedTask.run()</strong>。这里的DispatchedTask实际上是DispatchedContinuation的父类。</p><pre><code class="language-plain">internal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    public final override fun run() {\n\n        val taskContext = this.taskContext\n        var fatalException: Throwable? = null\n        try {\n            val delegate = delegate as DispatchedContinuation&lt;T&gt;\n            val continuation = delegate.continuation\n            withContinuationContext(continuation, delegate.countOrElement) {\n                val context = continuation.context\n                val state = takeState() \n                val exception = getExceptionalResult(state)\n\n                val job = if (exception == null &amp;&amp; resumeMode.isCancellableMode) context[Job] else null\n                if (job != null &amp;&amp; !job.isActive) {\n                    // 1\n                    val cause = job.getCancellationException()\n                    cancelCompletedResult(state, cause)\n                    continuation.resumeWithStackTrace(cause)\n                } else {\n                    if (exception != null) {\n                        // 2\n                        continuation.resumeWithException(exception)\n                    } else {\n                        // 3\n                        continuation.resume(getSuccessfulResult(state))\n                    }\n                }\n            }\n        } catch (e: Throwable) {\n\n            fatalException = e\n        } finally {\n            val result = runCatching { taskContext.afterTask() }\n            handleFatalException(fatalException, result.exceptionOrNull())\n        }\n    }\n}\n</code></pre><p>上面的代码有三个关键的注释，我们一起来分析：</p><ul>\n<li>注释1，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用continuation.resumeWithStackTrace(cause)将具体的原因传出去。</li>\n<li>注释2，判断协程是否发生了异常，如果已经发生了异常，则需要调用continuation.resumeWithException(exception)将异常传递出去。</li>\n<li>注释3，如果一切正常，则会调用continuation.resume(getSuccessfulResult(state))，这时候，协程才会正式启动，并且执行launch当中传入的Lambda表达式。</li>\n</ul><p>最后，按照惯例，我还是制作了一个视频，来向你展示整个Dispather的代码执行流程。</p><p><video poster="https://media001.geekbang.org/60e32fba628c47b299b6d8e7a80f8379/snapshots/ee285063538d488da66a8986948e5e10-00005.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2310ea02-17fd4a64006-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/67b93afae3c942789649155c1fb4bb34/846224bcab894329a030dbe0ef087544-af4fd499cd27e74109eba82f17247037-sd.m3u8" type="application/x-mpegURL"></video></p><h2>小结</h2><p>这节课，我们围绕着launch，着重分析了它的Dispatchers执行流程。Dispatchers是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤：</p><ul>\n<li>第一步，createCoroutineUnintercepted(completion)创建了协程的Continuation实例，紧接着就会调用它的intercepted()方法，将其封装成DispatchedContinuation对象。</li>\n<li>第二步，DispatchedContinuation会持有CoroutineDispatcher、以及前面创建的Continuation对象。课程中的CoroutineDispatcher实际上就是Default线程池。</li>\n<li>第三步，执行DispatchedContinuation的resumeCancellableWith()方法，这时候，就会执行dispatcher.dispatch()，这就会将协程的Continuation封装成Task添加到Worker的本地任务队列，等待执行。这里的Worker本质上就是Java的Thread。<strong>在这一步，协程就已经完成了线程的切换</strong>。</li>\n<li>第四步，Worker的run()方法会调用runWork()，它会从本地的任务队列当中取出Task，并且调用task.run()。而它实际上调用的是DispatchedContinuation的run()方法，在这里，会调用continuation.resume()，它将执行原本launch当中生成的SuspendLambda子类。<strong>这时候，launch协程体当中的代码，就在线程上执行了</strong>。</li>\n</ul><h2>思考题</h2><p>经过这节课的学习以后，请问你是否对协程的本质有了更深入的认识？请讲讲你的心得体会吧！</p>',
        article_title: "29 | Dispatchers是如何工作的？",
      },
      {
        title: "30 | CoroutineScope是如何管理协程的？",
        id: 501702,
        content:
          '<p>你好，我是朱涛。</p><p>通过前面课程的学习，我们知道CoroutineScope是实现协程结构化并发的关键。使用CoroutineScope，我们可以批量管理同一个作用域下面所有的协程。那么，今天这节课，我们就来研究一下CoroutineScope是如何管理协程的。</p><h2>CoroutineScope VS 结构化并发</h2><p>在前面的课程中，我们学习过CoroutineScope的用法。由于launch、async被定义成了CoroutineScope的扩展函数，这就意味着：在调用launch之前，我们必须先获取CoroutineScope。</p><pre><code class="language-plain">// 代码段1\n\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {}\n\npublic fun &lt;T&gt; CoroutineScope.async(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; T\n): Deferred&lt;T&gt; {}\n\nprivate fun testScope() {\n    val scope = CoroutineScope(Job())\n    scope.launch{\n        // 省略\n    }\n}\n</code></pre><!-- [[[read_end]]] --><p>不过，很多初学者可能不知道，协程早期的API并不是这么设计的，最初的launch、async只是普通的顶层函数，我们不需要scope就可以直接创建协程，就像这样：</p><pre><code class="language-plain">// 代码段2\n\nprivate fun testScope() {\n    // 早期协程API的写法\n    launch{\n        // 省略\n    }\n}\n</code></pre><p>很明显，代码段2的写法要比代码段1的简单很多，那么Kotlin官方为什么要舍近求远，专门设计一个更加复杂的API呢？这一切，都是因为<strong>结构化并发</strong>。</p><p>让我们来看一段代码：</p><pre><code class="language-plain">// 代码段3\n\nprivate fun testScope() {\n    val scope = CoroutineScope(Job())\n    scope.launch{\n        launch {\n            delay(1000000L)\n            logX("Inner")\n        }\n        logX("Hello!")\n        delay(1000000L)\n        logX("World!")  // 不会执行\n    }\n\n    scope.launch{\n        launch {\n            delay(1000000L)\n            logX("Inner！！！")\n        }\n        logX("Hello！！!")\n        delay(1000000L)\n        logX("World1!！！")  // 不会执行\n    }\n    Thread.sleep(500L)\n    scope.cancel()\n}\n</code></pre><p>上面这段代码很简单，我们使用scope创建了两个顶层的协程，接着，在协程的内部我们使用launch又创建了一个子协程。最后，我们在协程的外部等待了500毫秒，并且调用了scope.cancel()。这样一来，我们前面创建的4个协程就全部都取消了。</p><p><img src="https://static001.geekbang.org/resource/image/7b/80/7b40c302yy14d01d07787dc857a5cf80.jpg?wh=2000x1125" alt=""></p><p>通过前面<a href="https://time.geekbang.org/column/article/488571">第17讲</a>的学习，我们知道上面的代码其实可以用这样的关系图来表示。父协程是属于Scope的，子协程是属于父协程的，因此，只要调用了scope.cancel()，这4个协程都会被取消。</p><p>想象一下，如果我们将上面的代码用协程最初的API改写的话，这一切就完全不一样了：</p><pre><code class="language-plain">// 代码段4\n\n// 使用协程最初的API，只是伪代码\nprivate fun testScopeJob() {\n    val job = Job()\n    launch(job){\n        launch {\n            delay(1000000L)\n            logX("Inner")\n        }\n        logX("Hello!")\n        delay(1000000L)\n        logX("World!")  // 不会执行\n    }\n\n    launch(job){\n        launch {\n            delay(1000000L)\n            logX("Inner！！！")\n        }\n        logX("Hello！！!")\n        delay(1000000L)\n        logX("World1!！！")  // 不会执行\n    }\n    Thread.sleep(500L)\n    job.cancel()\n}\n</code></pre><p>在上面的代码中，为了实现结构化并发，我们不得不创建一个Job对象，然后将其传入launch当中作为参数。</p><p>你能感受到其中的差别吗？如果使用原始的协程API，结构化并发是需要开发者自觉往launch当中传job参数才能实现，它是<strong>可选</strong>的，开发者也可能疏忽大意，忘记传参数。而launch成为CoroutineScope的扩展函数以后，这一切就成为<strong>必须</strong>的了，我们开发者不可能忘记。</p><p>而且，通过对比代码段3和4以后，我们也可以发现：<strong>CoroutineScope管理协程的能力，其实也是源自于Job。</strong></p><p>那么，CoroutineScope与Job到底是如何实现结构化并发的呢？接下来，让我们从源码中寻找答案吧！</p><h2>父子关系在哪里建立的？</h2><p>在分析源码之前，我们先来写一个简单的Demo。接下来，我们就以这个Demo为例，来研究一下CoroutineScope是如何通过Job来管理协程的。</p><pre><code class="language-plain">// 代码段5\n\nprivate fun testScope() {\n    // 1\n    val scope = CoroutineScope(Job())\n    scope.launch{\n        launch {\n            delay(1000000L)\n            logX("Inner")  // 不会执行\n        }\n        logX("Hello!")\n        delay(1000000L)\n        logX("World!")  // 不会执行\n    }\n\n    Thread.sleep(500L)\n    // 2\n    scope.cancel()\n}\n\npublic interface CoroutineScope {\n    public val coroutineContext: CoroutineContext\n}\n\npublic interface Job : CoroutineContext.Element {}\n</code></pre><p>以上代码的逻辑很简单，我们先来看看注释1对应的地方。我们都知道，CoroutineScope是一个接口，那么我们<strong>为什么可以调用它的构造函数，来创建CoroutineScope对象呢？</strong>不应该使用object关键字创建匿名内部类吗？</p><p>其实，代码段5当中调用CoroutineScope()并不是构造函数，而是一个顶层函数：</p><pre><code class="language-plain">// 代码段6\n\n// 顶层函数\npublic fun CoroutineScope(context: CoroutineContext): CoroutineScope =\n    // 1\n    ContextScope(if (context[Job] != null) context else context + Job())\n\n// 顶层函数\npublic fun Job(parent: Job? = null): CompletableJob = JobImpl(parent)\n</code></pre><p>在<a href="https://time.geekbang.org/column/article/472154">第1讲</a>当中，我曾提到过，Kotlin当中的函数名称，在大部分情况下都是遵循“<a href="https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰命名法</a>”的，而在一些特殊情况下则不遵循这种命名法。上面的顶层函数CoroutineScope()，其实就属于特殊的情况，因为它虽然是一个普通的顶层函数，但它发挥的作用却是“构造函数”。类似的用法，还有Job()这个顶层函数。</p><p>因此，在Kotlin当中，当顶层函数作为构造函数使用的时候，<strong>它的首字母是要大写的</strong>。</p><p>让我们回到代码段6，看看其中注释1的地方。这行代码的意思是，当我们创建CoroutineScope的时候，如果传入的Context是包含Job的，那就直接用；如果是不包含Job的，就会创建一个新的Job。这就意味着，<strong>每一个CoroutineScope对象，它的Context当中必定存在一个Job对象。</strong>而代码段5当中的CoroutineScope(Job())，改成CoroutineScope()也是完全没问题的。</p><p>接下来，我们再来看看launch的源代码：</p><pre><code class="language-plain">// 代码段7\n\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {\n    // 1\n    val newContext = newCoroutineContext(context)\n    // 2\n    val coroutine = if (start.isLazy)\n        LazyStandaloneCoroutine(newContext, block) else\n        StandaloneCoroutine(newContext, active = true)\n    // 3\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n</code></pre><p>在前面两节课里，我们已经分析过注释1和注释3当中的逻辑了，这节课呢，我们来分析注释2处的逻辑。</p><pre><code class="language-plain">// 代码段8\n\nprivate open class StandaloneCoroutine(\n    parentContext: CoroutineContext,\n    active: Boolean\n) : AbstractCoroutine&lt;Unit&gt;(parentContext, initParentJob = true, active = active) {\n    override fun handleJobException(exception: Throwable): Boolean {\n        handleCoroutineException(context, exception)\n        return true\n    }\n}\n\nprivate class LazyStandaloneCoroutine(\n    parentContext: CoroutineContext,\n    block: suspend CoroutineScope.() -&gt; Unit\n) : StandaloneCoroutine(parentContext, active = false) {\n    private val continuation = block.createCoroutineUnintercepted(this, this)\n\n    override fun onStart() {\n        continuation.startCoroutineCancellable(this)\n    }\n}\n</code></pre><p>可以看到，StandaloneCoroutine是AbstractCoroutine的子类，而在<a href="https://time.geekbang.org/column/article/499826">第28讲</a>当中，我们就已经遇到过AbstractCoroutine，它其实就是代表了<strong>协程的抽象类</strong>。另外这里有一个initParentJob参数，它是true，代表了协程创建了以后，需要初始化协程的父子关系。而LazyStandaloneCoroutine则是StandaloneCoroutine的子类，它的active参数是false，代表了以懒加载的方式创建协程。</p><p>接下来，我们就看看它们的父类AbstractCoroutine：</p><pre><code class="language-plain">// 代码段9\n\npublic abstract class AbstractCoroutine&lt;in T&gt;(\n    parentContext: CoroutineContext,\n    initParentJob: Boolean,\n    active: Boolean\n) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope {\n\n    init {\n        if (initParentJob) initParentJob(parentContext[Job])\n    }\n}\n</code></pre><p>可以看到，<strong>AbstractCoroutine其实是JobSupport的子类</strong>，在它的init{} 代码块当中，会根据initParentJob参数，判断是否需要初始化协程的父子关系。这个参数我们在代码段8当中已经分析过了，它一定是true，所以这里的initParentJob()方法一定会执行，而它的参数parentContext[Job]取出来的Job，其实就是我们在Scope当中的Job。</p><p>另外，这里的initParentJob()方法，是它的父类JobSupport当中的方法，我们来看看：</p><pre><code class="language-plain">// 代码段10\n\npublic open class JobSupport constructor(active: Boolean) : Job, ChildJob, ParentJob, SelectClause0 {\n    final override val key: CoroutineContext.Key&lt;*&gt; get() = Job\n\n    protected fun initParentJob(parent: Job?) {\n        assert { parentHandle == null }\n        // 1\n        if (parent == null) {\n            parentHandle = NonDisposableHandle\n            return\n        }\n        // 2\n        parent.start()\n        @Suppress("DEPRECATION")\n        // 3\n        val handle = parent.attachChild(this)\n        parentHandle = handle\n\n        if (isCompleted) {\n            handle.dispose()\n            parentHandle = NonDisposableHandle \n        }\n    }\n}\n\n// Job源码\npublic interface Job : CoroutineContext.Element {\n    public val children: Sequence&lt;Job&gt;   \n    public fun attachChild(child: ChildJob): ChildHandle\n}\n</code></pre><p>上面的代码一共有三个地方需要注意，我们来分析一下：</p><ul>\n<li>注释1，判断传入的parent是否为空，如果parent为空，说明当前的协程不存在父Job，这时候就谈不上创建协程父子关系了。不过，如果按照代码段5的逻辑来分析的话，此处的parent则是scope当中的Job，因此，代码会继续执行到注释2。</li>\n<li>注释2，这里是确保parent对应的Job启动了。</li>\n<li>注释3，parent.attachChild(this)，这个方法我们在<a href="https://time.geekbang.org/column/article/487930">第16讲</a>当中提到过，它会将当前的Job，添加为parent的子Job。<strong>这里其实就是建立协程父子关系的关键代码。</strong></li>\n</ul><p>所以，我们可以将协程的结构当作一颗<strong>N叉树</strong>。每一个协程，都对应着一个Job的对象，而每一个Job可以有一个父Job，也可以有多个子Job。</p><p><img src="https://static001.geekbang.org/resource/image/30/9a/308decb3a0d5c89d2082673d00f33f9a.jpg?wh=2000x1013" alt=""></p><p>这样，当我们知道协程的父子关系是如何建立的了以后，父协程如何取消子协程也就很容易理解了。</p><h2>协程是如何“结构化取消”的？</h2><p>其实，协程的结构化取消，本质上是<strong>事件的传递</strong>，它跟我们平时生活中的场景都是类似的：</p><p><img src="https://static001.geekbang.org/resource/image/0b/da/0b95644933e584dcdf0e8a24696394da.jpg?wh=2000x986" alt=""></p><p>就比如，当我们在学校、公司内部，有消息或任务需要传递的时候，总是遵循这样的规则：处理好分内的事情，剩下的部分交给上级和下级。协程的结构化取消，也是通过这样的事件消息模型来实现的。</p><p>甚至，如果让我们来实现协程API的话，都能想象到它的代码该怎么写：</p><pre><code class="language-plain">// 代码段11\n\nfun Job.cancelJob() {\n    // 通知子Job\n    children.forEach {\n        cancelJob()\n    }\n    // 通知父Job\n    notifyParentCancel()\n}\n</code></pre><p>当然，以上只是简化后的伪代码，真实的协程代码一定比这个复杂很多，但只要你能理解这一点，我们后面的分析就很简单了。让我们接着代码段5当中的注释2，继续分析scope.cancel()后续的流程。</p><pre><code class="language-plain">// 代码段12\n\npublic fun CoroutineScope.cancel(cause: CancellationException? = null) {\n    val job = coroutineContext[Job] ?: error("Scope cannot be cancelled because it does not have a job: $this")\n    job.cancel(cause)\n}\n</code></pre><p>可以看到，CoroutineScope的cancel()方法，本质上是调用了它当中的Job.cancel()。而这个方法的具体实现在JobSupport当中：</p><pre><code class="language-plain">// 代码段13\n\npublic override fun cancel(cause: CancellationException?) {\n    cancelInternal(cause ?: defaultCancellationException())\n}\n\npublic open fun cancelInternal(cause: Throwable) {\n    cancelImpl(cause)\n}\n\ninternal fun cancelImpl(cause: Any?): Boolean {\n    var finalState: Any? = COMPLETING_ALREADY\n    if (onCancelComplete) {\n        // 1\n        finalState = cancelMakeCompleting(cause)\n        if (finalState === COMPLETING_WAITING_CHILDREN) return true\n    }\n    if (finalState === COMPLETING_ALREADY) {\n        // 2\n        finalState = makeCancelling(cause)\n    }\n    return when {\n        finalState === COMPLETING_ALREADY -&gt; true\n        finalState === COMPLETING_WAITING_CHILDREN -&gt; true\n        finalState === TOO_LATE_TO_CANCEL -&gt; false\n        else -&gt; {\n            afterCompletion(finalState)\n            true\n        }\n    }\n}\n</code></pre><p>可见，job.cancel()最终会调用JobSupport的 <strong>cancelImpl()方法</strong>。其中有两个注释，代表了两个分支，它的判断依据是onCancelComplete这个Boolean类型的成员属性。这个其实就代表了当前的Job，是否有协程体需要执行。</p><p>另外，由于CoroutineScope当中的Job是我们手动创建的，并不需要执行任何协程代码，所以，它会是 <strong>true</strong>。也就是说，这里会执行注释1对应的代码。</p><p>让我们继续分析cancelMakeCompleting()方法：</p><pre><code class="language-plain">// 代码段14\n\nprivate fun cancelMakeCompleting(cause: Any?): Any? {\n    loopOnState { state -&gt;\n        // 省略部分\n        val finalState = tryMakeCompleting(state, proposedUpdate)\n        if (finalState !== COMPLETING_RETRY) return finalState\n    }\n}\n\nprivate fun tryMakeCompleting(state: Any?, proposedUpdate: Any?): Any? {\n    if (state !is Incomplete)\n        return COMPLETING_ALREADY\n\n        // 省略部分\n        return COMPLETING_RETRY\n    }\n\n    return tryMakeCompletingSlowPath(state, proposedUpdate)\n}\n\nprivate fun tryMakeCompletingSlowPath(state: Incomplete, proposedUpdate: Any?): Any? {\n    // 省略部分\n    notifyRootCause?.let { notifyCancelling(list, it) }\n\n    return finalizeFinishingState(finishing, proposedUpdate)\n}\n</code></pre><p>从上面的代码中，我们可以看到cancelMakeCompleting()会调用tryMakeCompleting()方法，最终则会调用tryMakeCompletingSlowPath()当中的notifyCancelling()方法。所以，<strong>它才是最关键的代码。</strong></p><pre><code class="language-plain">// 代码段15\n\nprivate fun notifyCancelling(list: NodeList, cause: Throwable) {\n\n    onCancelling(cause)\n    // 1，通知子Job\n    notifyHandlers&lt;JobCancellingNode&gt;(list, cause)\n    // 2，通知父Job\n    cancelParent(cause)\n}\n</code></pre><p>可以看到，上面代码段15和我们前面写的代码段11当中的伪代码的逻辑是一致的。我们再分别来看看它们具体的逻辑：</p><pre><code class="language-plain">// 代码段16\n\nprivate inline fun &lt;reified T: JobNode&gt; notifyHandlers(list: NodeList, cause: Throwable?) {\n    var exception: Throwable? = null\n    list.forEach&lt;T&gt; { node -&gt;\n        try {\n            node.invoke(cause)\n        } catch (ex: Throwable) {\n            exception?.apply { addSuppressedThrowable(ex) } ?: run {\n                exception =  CompletionHandlerException("Exception in completion handler $node for $this", ex)\n            }\n        }\n    }\n    exception?.let { handleOnCompletionException(it) }\n}\n</code></pre><p>代码段16当中的逻辑，就是遍历当前Job的子Job，并将取消的cause传递过去，这里的invoke()最终会调用ChildHandleNode的invoke()方法：</p><pre><code class="language-plain">internal class ChildHandleNode(\n    @JvmField val childJob: ChildJob\n) : JobCancellingNode(), ChildHandle {\n    override val parent: Job get() = job\n    override fun invoke(cause: Throwable?) = childJob.parentCancelled(job)\n    override fun childCancelled(cause: Throwable): Boolean = job.childCancelled(cause)\n}\n\npublic final override fun parentCancelled(parentJob: ParentJob) {\n    cancelImpl(parentJob)\n}\n</code></pre><p>然后，从以上代码中我们可以看到，ChildHandleNode的invoke()方法会调用parentCancelled()方法，而它最终会调用cancelImpl()方法。其实，这个就是代码段13当中的cancelImpl()方法，也就是Job取消的入口函数。这实际上就相当于在做<strong>递归调用</strong>。</p><p>接下来，我们看看代码段15当中的注释2，通知父Job的流程：</p><pre><code class="language-plain">private fun cancelParent(cause: Throwable): Boolean {\n    if (isScopedCoroutine) return true\n\n    val isCancellation = cause is CancellationException\n    val parent = parentHandle\n\n    if (parent === null || parent === NonDisposableHandle) {\n        return isCancellation\n    }\n    // 1\n    return parent.childCancelled(cause) || isCancellation\n}\n</code></pre><p>请留意上面代码段的注释1，这个函数的返回值是有意义的，返回true代表父协程处理了异常，而返回false，代表父协程没有处理异常。这种类似<strong>责任链的设计模式</strong>，在很多领域都有应用，比如Android的事件分发机制、OkHttp的拦截器，等等。</p><pre><code class="language-plain">public open fun childCancelled(cause: Throwable): Boolean {\n    if (cause is CancellationException) return true\n    return cancelImpl(cause) &amp;&amp; handlesException\n}\n</code></pre><p>那么，当异常是CancellationException的时候，协程是会进行特殊处理的。一般来说，父协程会忽略子协程的取消异常，这一点我们在<a href="https://time.geekbang.org/column/article/493666">第23讲</a>当中也提到过。而如果是其他的异常，那么父协程就会响应子协程的取消了。这个时候，我们的代码又会继续递归调用代码段13当中的cancelImpl()方法了。</p><p>至此，协程的“结构化取消”部分的逻辑，我们也分析完了。让我们通过视频来看看它们整体的执行流程。</p><p><video poster="https://media001.geekbang.org/41d544c386e34b73afab957695a6e30b/snapshots/c7cc627f133445baaea087b1bd782502-00004.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/11ed8a28-17fe08521f6-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/86dc2d503bae4837b12bd14164638672/ea00e3feab4c45daaba366aeb5954b76-e25bfe7f85baccb92a23fd106eeaeea9-sd.m3u8" type="application/x-mpegURL"></video></p><h2>小结</h2><p>今天的内容到这里就结束了，我们来总结和回顾一下这节课里涉及到的知识点：</p><ul>\n<li>每次创建CoroutineScope的时候，它的内部会确保CoroutineContext当中一定存在Job元素，而CoroutineScope就是通过这个Job对象来管理协程的。</li>\n<li>在我们通过launch、async创建协程的时候，会同时创建AbstractCoroutine的子类，在它的initParentJob()方法当中，会建立协程的父子关系。每个协程都会对应一个Job，而每个Job都会有一个父Job，多个子Job。最终它们会形成一个N叉树的结构。</li>\n<li>由于协程是一个N叉树的结构，因此协程的取消事件以及异常传播，也会按照这个结构进行传递。每个Job取消的时候，都会通知自己的子Job和父Job，最终以递归的形式传递给每一个协程。另外，协程在向上取消父Job的时候，还利用了责任链模式，确保取消事件可以一步步传播到最顶层的协程。这里还有一个细节就是，默认情况下，父协程都会忽略子协程的CancellationException。</li>\n</ul><p>到这里，我们其实就可以进一步总结出协程的<strong>结构化取消的规律</strong>了。</p><p>对于CancellationException引起的取消，它只会向下传播，取消子协程；对于其他的异常引起的取消，它既向上传播，也向下传播，最终会导致所有协程都被取消。</p><p><img src="https://static001.geekbang.org/resource/image/04/35/04a978310f722996c38bd09a00fdae35.gif?wh=1080x608" alt="图片"></p><h2>思考题</h2><p>在第23讲当中，我们学习过SupervisorJob，它可以起到隔离异常传播的作用，下面是它的源代码，请问你能借助这节课学的知识点来分析下它的原理吗？</p><pre><code class="language-plain">public fun SupervisorJob(parent: Job? = null) : CompletableJob = \n    SupervisorJobImpl(parent)\n\nprivate class SupervisorJobImpl(parent: Job?) : JobImpl(parent) {\n    override fun childCancelled(cause: Throwable): Boolean = false\n}\n</code></pre>',
        article_title: "30 | CoroutineScope是如何管理协程的？",
      },
      {
        title: "31 | 图解Channel：如何理解它的CSP通信模型？",
        id: 502085,
        content:
          '<p>你好，我是朱涛。今天我们来分析Channel的源码。</p><p>Kotlin的Channel是一个非常重要的组件，在它出现之前，协程之间很难进行通信，有了它以后，协程之间的通信就轻而易举了。在<a href="https://time.geekbang.org/column/article/493069">第22讲</a>当中，我们甚至还借助Channel实现的Actor做到了并发安全。</p><p>那么总的来说，Channel是热的，同时它还是一个<strong>线程安全的数据管道</strong>。而由于Channel具有线程安全的特性，因此，它最常见的用法，就是建立CSP通信模型（Communicating Sequential Processes）。</p><p>不过你可能会觉得，CSP太抽象了不好理解，但其实，这个通信模型我们在第22讲里就接触过了。当时我们虽然是通过Actor来实现的，但却是把它当作CSP在用，它们两者的差异其实很小。</p><p><video poster="https://media001.geekbang.org/e2f6d9ef4c8e4a67b051a16e64808084/snapshots/a465772fb3354c83bf29a2e6c50a1ca6-00004.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/54981571-17f69fc57d6-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/97b00e96eb0d465c9ca8552b52f6d725/5cfcdb560f644b90b9fd41d335f023b4-dead5a81ab78def2dfeefb98f2c92342-sd.m3u8" type="application/x-mpegURL"></video></p><p>关于<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP的理论</a>，它的精确定义其实比较复杂，不过它的核心理念用一句话就可以概括：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>（Don’t communicate by sharing memory; share memory by communicating）。</p><p>可是，我们为什么可以通过Channel实现CSP通信模型呢？这背后的技术细节，则需要我们通过源码来发掘了。</p><!-- [[[read_end]]] --><h2>Channel背后的数据结构</h2><p>为了研究Channel的源代码，我们仍然是以一个简单的Demo为例，来跟踪它的代码执行流程。</p><pre><code class="language-plain">// 代码段1\n\nfun main()  {\n    val scope = CoroutineScope(Job() + mySingleDispatcher)\n    // 1，创建管道\n    val channel = Channel&lt;Int&gt;()\n\n    scope.launch {\n        // 2，在一个单独的协程当中发送管道消息\n        repeat(3)  {\n            channel.send(it)\n            println("Send: $it")\n        }\n\n        channel.close()\n    }\n\n    scope.launch {\n        // 3，在一个单独的协程当中接收管道消息\n        repeat(3) {\n            val result = channel.receive()\n            println("Receive ${result}")\n        }\n    }\n\n    println("end")\n    Thread.sleep(2000000L)\n}\n\n/*\n输出结果：\nend\nReceive 0\nSend: 0\nSend: 1\nReceive 1\nReceive 2\nSend: 2\n*/\n</code></pre><p>以上代码主要分为三个部分，分别是：Channel创建、发送数据、接收数据。</p><p>我们先来分析注释1处的Channel创建逻辑。我们都知道Channel其实是一个接口，它是通过组合SendChannel、ReceiveChannel得来的。而注释1处调用的Channel()，其实是一个普通的顶层函数，只是<strong>它发挥的作用是构造函数，因此它的首字母是大写的</strong>，这跟我们上节课分析的CoroutineScope、Job也是类似的。</p><pre><code class="language-plain">// 代码段2\n\npublic interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {\n\npublic fun &lt;E&gt; Channel(\n    capacity: Int = RENDEZVOUS,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    onUndeliveredElement: ((E) -&gt; Unit)? = null\n): Channel&lt;E&gt; =\n    when (capacity) {\n        RENDEZVOUS -&gt; {\n            if (onBufferOverflow == BufferOverflow.SUSPEND)\n                RendezvousChannel(onUndeliveredElement) \n            else\n                ArrayChannel(1, onBufferOverflow, onUndeliveredElement) \n        }\n        CONFLATED -&gt; {\n            ConflatedChannel(onUndeliveredElement)\n        }\n        UNLIMITED -&gt; LinkedListChannel(onUndeliveredElement) \n        BUFFERED -&gt; ArrayChannel( \n            if (onBufferOverflow == BufferOverflow.SUSPEND) CHANNEL_DEFAULT_CAPACITY else 1,\n            onBufferOverflow, onUndeliveredElement\n        )\n        else -&gt; {\n            if (capacity == 1 &amp;&amp; onBufferOverflow == BufferOverflow.DROP_OLDEST)\n                ConflatedChannel(onUndeliveredElement) \n            else\n                ArrayChannel(capacity, onBufferOverflow, onUndeliveredElement)\n        }\n    }\n</code></pre><p>然后，从上面的代码里，我们可以看到，<strong>Channel()方法的核心逻辑就是一个when表达式</strong>，它根据传入的参数，会创建不同类型的Channel实例，包括了：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel。而这些实现类都有一个共同的父类：<strong>AbstractChannel</strong>。</p><pre><code class="language-plain">// 代码段3\n\ninternal abstract class AbstractSendChannel&lt;E&gt;(\n    @JvmField protected val onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?\n) : SendChannel&lt;E&gt; {\n\n    protected val queue = LockFreeLinkedListHead()\n\n    // 省略\n\n    internal abstract class AbstractChannel&lt;E&gt;(\n    onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?\n) : AbstractSendChannel&lt;E&gt;(onUndeliveredElement), Channel&lt;E&gt; {}\n}\n</code></pre><p>可以看到，AbstractChannel其实是AbstractSendChannel的内部类，同时它也是AbstractSendChannel的子类。而Channel当中的核心逻辑，都是依靠AbstractSendChannel当中的 <strong>LockFreeLinkedListHead</strong> 实现的。我们接着来看下它的源代码：</p><pre><code class="language-plain">// 代码段4\n\npublic actual open class LockFreeLinkedListHead : LockFreeLinkedListNode() {\n    public actual val isEmpty: Boolean get() = next === this\n}\n\npublic actual open class LockFreeLinkedListNode {\n    // 1\n    private val _next = atomic&lt;Any&gt;(this)\n    private val _prev = atomic(this)\n    private val _removedRef = atomic&lt;Removed?&gt;(null)\n}\n</code></pre><p>可见，LockFreeLinkedListHead其实继承自 <strong>LockFreeLinkedListNode</strong>，而LockFreeLinkedListNode则是实现Channel核心功能的关键数据结构。整个数据结构的核心思想，来自于2004年的一篇论文：<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.4693&rep=rep1&type=pdf">《Lock-Free and Practical Doubly Linked List-Based Deques Using Single-Word Compare-and-Swap》</a>。如果你对其中的原理感兴趣，可以去看看这篇论文。这里，为了不偏离主题，我们只分析它的核心思想。</p><p>LockFreeLinkedListNode，我们可以将其区分开来看待，即LockFree和LinkedList。</p><p>第一个部分：<strong>LockFree</strong>，它是通过<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2">CAS</a>（Compare And Swap）的思想来实现的，比如JDK提供的java.util.concurrent.atomic。这一点，我们从上面注释1的atomic也可以看出来。</p><p>第二个部分：<strong>LinkedList</strong>，这说明LockFreeLinkedList本质上还是一个<strong>链表</strong>。简单来说，它其实是一个循环双向链表，而LockFreeLinkedListHead其实是一个<strong>哨兵节点</strong>，如果你熟悉链表这个数据结构，也可以将其看作是链表当中的<a href="https://stackoverflow.com/questions/37324972/what-is-a-dummy-head">虚拟头结点</a>，这个节点本身不会用于存储任何数据，它的next指针会指向整个链表的<strong>头节点</strong>，而它的prev指针会指向整个链表的<strong>尾节点</strong>。</p><p>为了方便你理解，我画了一张图描述这个链表的结构：</p><p><img src="https://static001.geekbang.org/resource/image/b0/ef/b040356bb5e6e6eab4b4fb4bcdbb74ef.jpg?wh=2000x713" alt=""></p><p>请看图片左边的部分，<strong>当链表为空的时候</strong>，LockFreeLinkedListHead的next指针和prev指针，都是指向自身的。这也就意味着，这个Head节点是不会存储数据，同时，也是不会被删除的。</p><p>然后再看图片右边的部分，<strong>当链表有2个元素的时候</strong>，这时LockFreeLinkedListHead节点的next指针才是第一个节点，而Head的prev指针则是指向尾结点。</p><p>实际上，寻常的循环双向链表是可以在首尾添加元素的，同时也支持“正向遍历、逆向遍历”的。但Channel内部的这个数据结构只能在末尾添加，而它遍历的顺序则是从队首开始的。这样的设计，就让它的行为在变成了先进先出<strong>单向队列</strong>的同时，还实现了队尾添加操作，只需要O(1)的时间复杂度。</p><p><img src="https://static001.geekbang.org/resource/image/47/c4/479f6fcb5cf2a9eb2f56951546eefdc4.jpg?wh=2000x683" alt=""></p><p>可以说，正是因为LockFreeLinkedList这个数据结构，我们才能使用Channel实现CSP通信模型。</p><p>好，在弄清楚LockFreeLinkedList这个数据结构以后，Channel后续的源码分析就很简单了。让我们来分别分析一下Channel的send()、receive()的流程。</p><h2>发送和接收的流程</h2><p>我们回过头来看代码段1当中的逻辑，我们分别启动了两个协程，在这两个协程中，我们分别发送了三次数据，也接收了三次数据。程序首先会执行send()，由于Channel在默认情况下容量是0，所以，send()首先会被挂起。让我们来看看这部分的逻辑：</p><pre><code class="language-plain">// 代码段5\n\npublic final override suspend fun send(element: E) {\n    // 1\n    if (offerInternal(element) === OFFER_SUCCESS) return\n    // 2\n    return sendSuspend(element)\n}\n\nprotected open fun offerInternal(element: E): Any {\n    while (true) {\n        // 3\n        val receive = takeFirstReceiveOrPeekClosed() ?: return OFFER_FAILE\n        // 省略\n    }\n}\n\nprivate suspend fun sendSuspend(element: E): Unit = suspendCancellableCoroutineReusable sc@ { cont -&gt;\n    loop@ while (true) {\n        if (isFullImpl) {\n            // 4\n            val send = if (onUndeliveredElement == null)\n                SendElement(element, cont) else\n                SendElementWithUndeliveredHandler(element, cont, onUndeliveredElement)\n            val enqueueResult = enqueueSend(send)\n            when {\n                enqueueResult == null -&gt; {\n                    // 5\n                    cont.removeOnCancellation(send)\n                    return@sc\n                }\n                enqueueResult is Closed&lt;*&gt; -&gt; {\n                }\n                enqueueResult === ENQUEUE_FAILED -&gt; {} \n                enqueueResult is Receive&lt;*&gt; -&gt; {} \n                else -&gt; error("enqueueSend returned $enqueueResult")\n            }\n        }\n        // 省略\n    }\n}\n</code></pre><p>上面的挂起函数send()分为两个部分：</p><ul>\n<li>注释1，尝试向Channel发送数据，如果这时候Channel已经有了消费者，那么if就会为true，send()方法就会return。不过，按照代码段1的逻辑，首次调用send()的时候，Channel还不存在消费者，因此在注释3处，尝试从LockFreeLinkedList取出消费者是不可能的。所以，程序会继续执行注释2处的逻辑。</li>\n<li>注释2，会调用挂起函数sendSuspend()，它是由高阶函数suspendCancellableCoroutineReusable{} 实现的。我们看它的名字就能知道，它跟suspendCancellableCoroutine{} 是类似的（如果你有些忘了，可以回过头去看看<a href="https://time.geekbang.org/column/article/497868">加餐五</a>）。另外，请留意下这个方法的注释4，它会将发送的元素封装成SendElement对象，然后调用enqueueSend()方法，将其添加到LockFreeLinkedList这个队列的末尾。如果enqueueSend()执行成功了，就会执行注释5，注册一个回调，用于将SendElement从队列中移除掉。</li>\n</ul><p>如果你足够细心的话，你会发现这整个流程并没有涉及到resume的调用，因此，这也意味着sendSuspend()会一直被挂起，而这就意味着send()会一直被挂起！那么，问题来了，<strong>send()会在什么时候被恢复</strong>？</p><p>答案当然是：<strong>receive()被调用的时候</strong>！</p><pre><code class="language-plain">// 代码段6\n\npublic final override suspend fun receive(): E {\n    // 1\n    val result = pollInternal()\n\n    @Suppress("UNCHECKED_CAST")\n    if (result !== POLL_FAILED &amp;&amp; result !is Closed&lt;*&gt;) return result as E\n    // 2\n    return receiveSuspend(RECEIVE_THROWS_ON_CLOSE)\n}\n\nprotected open fun pollInternal(): Any? {\n    while (true) {\n        // 3\n        val send = takeFirstSendOrPeekClosed() ?: return POLL_FAILED\n        val token = send.tryResumeSend(null)\n        if (token != null) {\n            assert { token === RESUME_TOKEN }\n            //4\n            send.completeResumeSend()\n            return send.pollResult\n        }\n\n        send.undeliveredElement()\n    }\n}\n\n// CancellableContinuationImpl\nprivate fun dispatchResume(mode: Int) {\n    if (tryResume()) return \n    // 5\n    dispatch(mode)\n}\n\ninternal fun &lt;T&gt; DispatchedTask&lt;T&gt;.dispatch(mode: Int) {\n    // 省略\n    if (!undispatched &amp;&amp; delegate is DispatchedContinuation&lt;*&gt; &amp;&amp; mode.isCancellableMode == resumeMode.isCancellableMode) {\n\n        val dispatcher = delegate.dispatcher\n        val context = delegate.context\n        if (dispatcher.isDispatchNeeded(context)) {\n            // 6\n            dispatcher.dispatch(context, this)\n        } else {\n            resumeUnconfined()\n        }\n    } else {\n        // 省略\n    }\n}\n</code></pre><p>可以看到，挂起函数receive()的逻辑，跟代码段5当中的send()是类似的。</p><ul>\n<li>注释1，尝试从LockFree队列当中找出是否有正在被挂起的<strong>发送方</strong>。具体的逻辑在注释3处，它会从队首开始遍历，寻找Send节点。</li>\n<li>接着上面的代码段1的案例分析，此时我们一定是可以从队列中找到一个Send节点的，因此程序会继续执行注释4处的代码。</li>\n<li>注释4，completeResumeSend()，它最终会调用注释5处的dispatch(mode)，而dispatch(mode)其实就是DispatchedTask的dispatch()，是不是觉得很熟悉？这个DispatchedTask其实就是我们在<a href="https://time.geekbang.org/column/article/500420">第29讲</a>当中分析过的DispatchedTask，这里的dispatch()就是协程体当中的代码在线程执行的时机。最终，它会执行在Java的Executor之上。至此，我们之前被挂起的send()方法，其实就算是恢复了。</li>\n</ul><p>另外，你可以再留意上面的注释2，当LockFree队列当中没有正在挂起的发送方时，它会执行receiveSuspend()，而receiveSuspend()也同样会被挂起：</p><pre><code class="language-plain">private suspend fun &lt;R&gt; receiveSuspend(receiveMode: Int): R = suspendCancellableCoroutineReusable sc@ { cont -&gt;\n    val receive = if (onUndeliveredElement == null)\n        ReceiveElement(cont as CancellableContinuation&lt;Any?&gt;, receiveMode) else\n        ReceiveElementWithUndeliveredHandler(cont as CancellableContinuation&lt;Any?&gt;, receiveMode, onUndeliveredElement)\n    while (true) {\n        if (enqueueReceive(receive)) {\n            removeReceiveOnCancel(cont, receive)\n            return@sc\n        }\n\n        val result = pollInternal()\n        if (result is Closed&lt;*&gt;) {\n            receive.resumeReceiveClosed(result)\n            return@sc\n        }\n        if (result !== POLL_FAILED) {\n            cont.resume(receive.resumeValue(result as E), receive.resumeOnCancellationFun(result as E))\n            return@sc\n        }\n    }\n}\n</code></pre><p>所以，这里的逻辑其实跟之前的sendSuspend()是类似的。首先，它会封装一个ReceiveElement对象，并且将其添加到LockFree队列的末尾，如果添加成功的话，这个receiveSuspend就会继续挂起，这就意味着receive()也会被挂起。而receive()被恢复的时机，其实就对应了代码段5当中注释1的代码：offerInternal(element)。</p><p>至此，Channel的发送和接收流程，我们就都已经分析完了。按照惯例，我们还是通过一个视频来回顾代码的整体执行流程：</p><p><video poster="https://media001.geekbang.org/5e802d680a944610923fa5aef8ec195e/snapshots/c0a015f2fc92490487ca71ef5869d1ff-00004.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4dc6e14-17fe818d116-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/238c705ce5ae4e178b2016740f5e7c2d/cffb3c5afd144013b0ddb3c33bc91d24-f86120202e2c15a5f41d05f11e710bf6-sd.m3u8" type="application/x-mpegURL"></video></p><h2>小结</h2><p>通过这节课，我们知道，Channel其实是一个线程安全的管道。它最常见的用法，就是实现CSP通信模型。它的核心理念是：<strong>不要共享内存来通信；而是要用通信来共享内存</strong>。而Channel之所以可以用来实现CSP通信模型，主要还是因为它底层用到的数据结构：LockFreeLinkedList。</p><p>LockFreeLinkedList虽然是一个循环双向链表，但在Channel的源码中，它会被当做<strong>先进先出</strong>的单向队列，它只在队列末尾插入节点，而遍历则只正向遍历。</p><p>还有Channel的send()，它会分为两种情况，一种是当前的LockFree队列当中已经有被挂起的<strong>接收方</strong>，这时候，send()会恢复Receive节点的执行，并且将数据发送给对方。第二种情况是：当前队列当中没有被挂起的接收方，这时候send()就会被挂起，而被发送的数据会被封装成SendElement对象插入到队列的末尾，等待被下次的receive()恢复执行。</p><p>而Channel的receive()，也是分为两种情况，一种是当前的LockFree队列当中已经存在被挂起的<strong>发送方</strong>，这时候receive()会恢复Send节点的执行，并且取出Send节点当中带过来的数据。第二种情况是：当前队列没有被挂起的发送方，这时候receive()就会被挂起，同时它也会被封装成一个ReceiveElement对象插入到队列的末尾，等待被下次的send()恢复执行。</p><p>其实，Kotlin推崇CSP模型进行并发的原因还有很多，比如门槛低、可读性高、扩展性好，还有一点是会被很多人提到的：不容易发生死锁。</p><p>不过，这里需要特别注意的是，CSP场景下的并发模型，并非不可能发生死锁，在一些特殊场景下，它也是可能发生死锁的，比如：通信死锁（Communication Deadlock）。因此，CSP也并不是解决所有并发问题的万能解药，我们还是要具体问题具体分析。</p><h2>思考题</h2><p>在课程的开头，我们分析了Channel一共有四种实现方式：RendezvousChannel、ArrayChannel、ConflatedChannel、LinkedListChannel，请问你能结合今天学习的知识，分析LinkedListChannel的原理吗？</p><pre><code class="language-plain">internal open class LinkedListChannel&lt;E&gt;(onUndeliveredElement: OnUndeliveredElement&lt;E&gt;?) : AbstractChannel&lt;E&gt;(onUndeliveredElement) {\n    protected final override val isBufferAlwaysEmpty: Boolean get() = true\n    protected final override val isBufferEmpty: Boolean get() = true\n    protected final override val isBufferAlwaysFull: Boolean get() = false\n    protected final override val isBufferFull: Boolean get() = false\n\n    protected override fun offerInternal(element: E): Any {\n        while (true) {\n            val result = super.offerInternal(element)\n            when {\n                result === OFFER_SUCCESS -&gt; return OFFER_SUCCESS\n                result === OFFER_FAILED -&gt; { // try to buffer\n                    when (val sendResult = sendBuffered(element)) {\n                        null -&gt; return OFFER_SUCCESS\n                        is Closed&lt;*&gt; -&gt; return sendResult\n                    }\n                    // otherwise there was receiver in queue, retry super.offerInternal\n                }\n                result is Closed&lt;*&gt; -&gt; return result\n                else -&gt; error("Invalid offerInternal result $result")\n            }\n        }\n    }\n\n    protected override fun offerSelectInternal(element: E, select: SelectInstance&lt;*&gt;): Any {\n        while (true) {\n            val result = if (hasReceiveOrClosed)\n                super.offerSelectInternal(element, select) else\n                (select.performAtomicTrySelect(describeSendBuffered(element)) ?: OFFER_SUCCESS)\n            when {\n                result === ALREADY_SELECTED -&gt; return ALREADY_SELECTED\n                result === OFFER_SUCCESS -&gt; return OFFER_SUCCESS\n                result === OFFER_FAILED -&gt; {} // retry\n                result === RETRY_ATOMIC -&gt; {} // retry\n                result is Closed&lt;*&gt; -&gt; return result\n                else -&gt; error("Invalid result $result")\n            }\n        }\n    }\n}\n</code></pre>',
        article_title: "31 | 图解Channel：如何理解它的CSP通信模型？",
      },
      {
        title: "32 | 图解Flow：原来你是只纸老虎？",
        id: 503629,
        content:
          '<p>你好，我是朱涛。今天我们来研究Flow的源代码。</p><p>经过前面的学习，我们已经知道了，Channel和Flow都是数据流，Channel是“热”的，Flow则是“冷”的。这里的冷，代表着Flow不仅是“冷淡”的，而且还是“懒惰”的。</p><p>除了“冷”这个特性以外，Flow从API的角度分类，主要分为：构造器、中间操作符、终止操作符。今天这节课，我们将会从这几个角度来分析Flow的源码，来看看它的这几类API是如何实现的。</p><p>经过这节课的学习，你会发现：虽然Flow的功能看起来非常高大上，然而它的原理却非常的简单，是一只名副其实的“纸老虎”。</p><h2>Flow为什么是冷的？</h2><p>在正式开始研究Flow源代码之前，我们首先需要确定研究的对象。这里，我写了一段Demo代码，接下来我们就以这个Demo为例，来分析Flow的整个执行流程：</p><pre><code class="language-plain">// 代码段1\n\nfun main() {\n    val scope = CoroutineScope(Job())\n    scope.launch {\n        testFlow()\n    }\n\n    Thread.sleep(1000L)\n\n    logX("end")\n}\n\nprivate suspend fun testFlow() {\n    // 1\n    flow {\n        emit(1)\n        emit(2)\n        emit(3)\n        emit(4)\n        emit(5)\n    }.collect {      // 2\n            logX(it)\n        }\n}\n\n/**\n * 控制台输出带协程信息的log\n */\nfun logX(any: Any?) {\n    println(\n        """\n================================\n$any\nThread:${Thread.currentThread().name}\n================================""".trimIndent()\n    )\n}\n\n/*\n输出结果\n================================\n1\nThread:DefaultDispatcher-worker-1\n================================\n================================\n2\nThread:DefaultDispatcher-worker-1\n================================\n================================\n3\nThread:DefaultDispatcher-worker-1\n================================\n================================\n4\nThread:DefaultDispatcher-worker-1\n================================\n================================\n5\nThread:DefaultDispatcher-worker-1\n================================\n================================\nend\nThread:main\n================================\n*/\n</code></pre><!-- [[[read_end]]] --><p>这段代码很简单，我们创建了一个CoroutineScope，接着使用它创建了一个新的协程，在协程当中，我们使用flow{} 这个高阶函数创建了Flow对象，接着使用了collect{} 这个终止操作符。<br>\n我们利用<a href="https://time.geekbang.org/column/article/491632">第20讲</a>当中学过的内容，很容易就能想象出类似这样的一个思维模型。</p><p><img src="https://static001.geekbang.org/resource/image/e3/4f/e3c3bd48f715e6d26yye3bd60096fd4f.jpg?wh=2000x940" alt=""></p><p>那么下面，我们就先来看看注释1处，分析一下Flow是怎么创建出来的。</p><pre><code class="language-plain">// 代码段2\n\npublic fun &lt;T&gt; flow(block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; =\n     SafeFlow(block)\n\npublic interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>可以看到，flow{} 是一个高阶函数，它接收的参数类型是函数类型<code>FlowCollector&lt;T&gt;.() -&gt; Unit</code>，这个类型代表了：它是FlowCollector的扩展或成员方法，没有参数，也没有返回值。flow()的返回值类型是<code>Flow&lt;T&gt;</code>，而它实际返回的类型是SafeFlow，让我们来看看它的源码定义。</p><pre><code class="language-plain">// 代码段3\n\nprivate class SafeFlow&lt;T&gt;(private val block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit) : AbstractFlow&lt;T&gt;() {\n    // 1\n    override suspend fun collectSafely(collector: FlowCollector&lt;T&gt;) {\n        collector.block()\n    }\n}\n\npublic abstract class AbstractFlow&lt;T&gt; : Flow&lt;T&gt;, CancellableFlow&lt;T&gt; {\n    // 省略\n}\n\ninternal interface CancellableFlow&lt;out T&gt; : Flow&lt;T&gt;\n</code></pre><p>从上面的代码我们可以看到，SafeFlow其实是AbstractFlow的子类，而AbstractFlow则实现了Flow这个接口，所以SafeFlow算是间接实现了Flow接口。而AbstractFlow是协程当中所有Flow的抽象类，所以，它当中应该会有许多Flow通用的逻辑。</p><p>那么接下来，我们就来看看AbstractFlow当中的逻辑：</p><pre><code class="language-plain">// 代码段4\n\npublic abstract class AbstractFlow&lt;T&gt; : Flow&lt;T&gt;, CancellableFlow&lt;T&gt; {\n\n    // 1\n    public final override suspend fun collect(collector: FlowCollector&lt;T&gt;) {\n        // 2\n        val safeCollector = SafeCollector(collector, coroutineContext)\n        try {\n            // 3\n            collectSafely(safeCollector)\n        } finally {\n            safeCollector.releaseIntercepted()\n        }\n    }\n\n    public abstract suspend fun collectSafely(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>请留意上面代码的注释1，看到这个挂起函数collect()，你是不是觉得很熟悉呢？它其实就是终止操作符collect对应的调用处。这个collect()的逻辑其实也很简单，我都用注释标记出来了，我们来看看：</p><ul>\n<li>注释2，collect()的参数类型是FlowCollector，这里只是将其重新封装了一遍，变成了SafeColletor对象。从它的名称，我们也大概可以猜出来，它肯定是会对collect当中的逻辑做一些安全检查的，SafeCollector的源码我们留到后面分析，我们接着看注释3。</li>\n<li>注释3，collectSafely()，这里其实就是调用了它的抽象方法，而它的具体实现就在代码段3里SafeFlow的collectSafely()方法，而它的逻辑也很简单，它直接调用了collector.block()，这其实就相当于触发了flow{} 当中的Lambda逻辑。换句话说，collector.block()就相当于调用了代码段1当中的5次emit()方法。</li>\n</ul><p>那么，代码分析到这里，我们其实就已经可以看出来Flow为什么是冷的了。我们都知道Channel之所以是热的，是因为它不管有没有接收方，发送方都会工作。而FLow之所以是冷的，是因为Flow的构造器，真的就只会构造一个SafeFlow对象，完全不会触发执行它内部的Lambda表达式的逻辑，<strong>只有当collect()被调用之后，flow{} 当中的Lambda逻辑才会真正被触发执行</strong>。</p><p>好，现在我们已经知道collect()是如何触发Flow执行的了，接下来，我们来看看Flow是如何将上游的数据传递给下游的。</p><h2>FlowCollector：上游与下游之间的桥梁</h2><p>经过之前的分析，我们知道flow{} 这个高阶函数会创建一个Flow对象，它具体的类型是SafeFlow，它其实间接实现了Flow接口，因此我们可以直接调用collect()这个终止操作符，从而拿到flow{} 的Lambda当中emit（发射）出来的数据。</p><p>上面整个流程分析下来，给我们的感觉是这样的：<strong>下游的collect()会触发上游的Lambda执行，上游的Lambda当中的emit()会把数据传递给下游</strong>。</p><p>那么，Flow到底是如何做到的呢？这其中的关键，还是collect()传入的参数类型：FlowCollector。</p><pre><code class="language-plain">// 代码段5\n\npublic fun interface FlowCollector&lt;in T&gt; {\n    public suspend fun emit(value: T)\n}\n\npublic interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n</code></pre><p>当我们在下游调用collect{} 的时候，其实是在调用Flow接口的collect方法，而我们之所以可以写出花括号的形式，是因为Lambda简写，这一点我们在<a href="https://time.geekbang.org/column/article/476637">第7讲</a>当中有提到过。那么，为了让它们的关系更加清晰地暴露出来，我们可以换一种写法，来实现代码段1当中的逻辑。</p><pre><code class="language-plain">// 代码段6\n\nprivate suspend fun testFlow() {\n\n    flow {\n        // 1\n        emit(1)\n        emit(2)\n        emit(3)\n        emit(4)\n        emit(5)\n    }\n        // 变化在这里\n        .collect(object : FlowCollector&lt;Int&gt;{ \n            // 2\n            override suspend fun emit(value: Int) {\n                logX(value)\n            }\n        })\n}\n</code></pre><p>这里代码段6和前面代码段1的逻辑其实是等价的，唯一的变化在于，这里我们使用了匿名内部类的方式，直接传入了FlowCollector，在这个匿名内部类的emit()方法，其实就充当着Flow的下游接收其中的数据流。</p><p>所以，要分析“上游与下游是如何连接的”这个问题，我们只需要看注释2处的emit()是如何被调用的即可。</p><p>那么，经过前面代码段4的分析，我们从它注释2处的代码就可以知道，collect()方法传入的FlowCollector参数，其实是被传入SafeCollector当中，被封装了起来。所以接下来，我们只要分析SafeCollector当中的逻辑就行。</p><pre><code class="language-plain">// 代码段7\n\ninternal actual class SafeCollector&lt;T&gt; actual constructor(\n    // 1\n    @JvmField internal actual val collector: FlowCollector&lt;T&gt;,\n    @JvmField internal actual val collectContext: CoroutineContext\n) : FlowCollector&lt;T&gt;, ContinuationImpl(NoOpContinuation, EmptyCoroutineContext), CoroutineStackFrame {\n\n    internal actual val collectContextSize = collectContext.fold(0) { count, _ -&gt; count + 1 }\n    private var lastEmissionContext: CoroutineContext? = null\n    private var completion: Continuation&lt;Unit&gt;? = null\n\n    // ContinuationImpl\n    override val context: CoroutineContext\n        get() = completion?.context ?: EmptyCoroutineContext\n\n    // 2\n    override suspend fun emit(value: T) {\n        return suspendCoroutineUninterceptedOrReturn sc@{ uCont -&gt;\n            try {\n                // 3\n                emit(uCont, value)\n            } catch (e: Throwable) {\n                lastEmissionContext = DownstreamExceptionElement(e)\n                throw e\n            }\n        }\n    }\n\n    private fun emit(uCont: Continuation&lt;Unit&gt;, value: T): Any? {\n        val currentContext = uCont.context\n        currentContext.ensureActive()\n\n        // 4\n        val previousContext = lastEmissionContext\n        if (previousContext !== currentContext) {\n            checkContext(currentContext, previousContext, value)\n        }\n        completion = uCont\n        // 5\n        return emitFun(collector as FlowCollector&lt;Any?&gt;, value, this as Continuation&lt;Unit&gt;)\n    }\n\n}\n\n// 6\nprivate val emitFun =\n    FlowCollector&lt;Any?&gt;::emit as Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;\n\npublic interface Function3&lt;in P1, in P2, in P3, out R&gt; : Function&lt;R&gt; {\n    public operator fun invoke(p1: P1, p2: P2, p3: P3): R\n}\n</code></pre><p>在这段SafeCollector的源码中，一共有6个地方需要我们注意，让我们来看看。</p><p>注释1，collector，它是SafeCollector的参数，通过分析代码段4的注释2处，我们可以知道，它其实就对应着代码段6里，注释1处的匿名内部类FlowCollector。之后我们需要特别留意这个collector，看看它的emit()是在哪里被调用的，因为这就意味着代码段6当中的注释2被调用。我们可以将其看作<strong>下游的emit()</strong>。</p><p>注释2，emit()，通过之前代码段4的分析，我们知道，这个emit()方法，其实就是代码段6里调用的emit()。也就是说，Flow上游发送的数据，最终会传递到这个emit()方法当中来。我们可以将其看作<strong>上游的emit()</strong>。</p><p>注释3，emit(uCont, value)，这里的suspendCoroutineUninterceptedOrReturn这个高阶函数，是把挂起函数的Continuation暴露了出来，并且将其作为参数传递给了另一个emit()方法。你需要注意的是，这行代码被try-catch包裹了，而且把其中的异常捕获以后，会被重新包装成DownstreamExceptionElement，意思就是“下游的异常”，这从侧面也能说明，这个方法即将执行下游的代码。</p><p>这里还有一个细节就是，DownstreamExceptionElement会被存储在lastEmissionContext当中，它的作用是：在下游发送异常以后，可以让上游感知到。</p><p>注释4，这里会对当前的协程上下文与之前的协程上下文做对比检查，如果它们两者不一致，就会在checkContext()当中做进一步的判断和提示。我们第20讲思考题的答案就藏在这里，为了不偏离主线，这个部分的逻辑我们暂时先放着，等我们分析完Flow的整体流程以后再来看。</p><p>注释5，<code>emitFun(collector as FlowCollector&lt;Any?&gt;, value, this as Continuation&lt;Unit&gt;)</code>，这里其实就是在调用下游的emit()，也就是代码段6当中的注释2对应的emit()方法。那么，这里的emitFun()是什么呢？我们可以在注释6处找到它的定义：<code>FlowCollector&lt;Any?&gt;::emit</code>，这是函数引用的语法，代表了它就是FlowCollector的emit()方法，它的类型是<code>Function3&lt;FlowCollector&lt;Any?&gt;, Any?, Continuation&lt;Unit&gt;, Any?&gt;</code>。</p><p>乍一看，你也许会觉得这个类型有点难以理解，其实，这个知识点我们在<a href="https://time.geekbang.org/column/article/477295">第8讲</a>当中就已经介绍过，我们平时写的函数类型<code>() -&gt; Unit</code>其实就对应了Function0，也就是：没有参数的函数类型。所以，这里的Function3其实就代表了三个参数的函数类型。因此，注释5处，其实就代表了下游的emit()方法被调用了，对应的value也是这时候传进去的。</p><p>至此，上游传递数据给下游的整个流程，我们也分析完毕了，FlowCollector其实就相当于上游与下游之间的桥梁，它起到了连接上游、下游的作用。</p><p>回过头去看前面分析过的代码，你会发现，Flow的核心原理其实只牵涉到那么几十行代码，而它的核心接口也只有Flow、FlowCollector而已。为了方便你理解，这里我做了一个视频，描述Flow的整体调用流程。</p><p><video poster="https://media001.geekbang.org/ee3f3922229043989ff5360153d32bb3/snapshots/18583a3c35934300ba8168a9cdf3bffe-00003.jpg" preload="none" controls=""><source src="https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/1cde05a-17ffa4bfd9b-0000-0000-01d-dbacd.mp4" type="video/mp4"><source src=" https://media001.geekbang.org/b5538bc05f124a169a9f327652c34ede/9d938a35259248e8a7d07883f4b8fd3d-9df58af0511489d2a6a939c5941037dd-sd.m3u8" type="application/x-mpegURL"></video></p><p>所以，对比挂起函数的原理，不得不说，Flow真的只是一只看起来吓人的“纸老虎”。</p><h2>思考与推演</h2><p>接下来，我们基于前面的结论来进行一些思考，来尝试推演和理解一下Flow的其他功能细节，比如：中间操作符的原理、不允许使用withContext{} 的原因。</p><h3>推演：中间操作符</h3><p>请你想象一个问题：在已知Flow上游、下游传递数据的原理以后，如果让你来设计Flow的中间操作符，你会怎么设计？</p><p>要回答这个问题，其实我们只需要回想一下Flow的思维模型，让我们来更新一下代码段1对应的思维模型，将Flow的源码执行流程也融入进去：</p><p><img src="https://static001.geekbang.org/resource/image/98/ac/9828f4c4f874ddf4b7d1c45a5f5ab5ac.jpg?wh=2000x980" alt=""></p><p>flow{} 这个高阶函数，代表了上游，它会创建一个Flow对象，提供给下游调用Flow的collect方法。在前面的代码段2当中，我们曾经分析过，flow{} 实际上返回的是SafeFlow对象，在这个SafeFlow当中，会有一个SafeCollector对象。而整个Flow的调用过程，其实就是三个步骤：</p><ul>\n<li>第一步，上游的flow{} 创建SafeFlow的对象，下游调用Flow的collect()方法，触发flow{} 的Lambda对应的代码执行，也就是其中emit()被执行。</li>\n<li>第二步，上游调用的emit()，其实就是SafeCollector的emit()，这时候，就相当于上游将数据传递给SafeCollector。</li>\n<li>第三步，SafeCollector调用emitFun()，这里的emitFun()其实就对应了下游的emit()方法（如果你忘了，可以回过头看看代码段6的注释2）。</li>\n</ul><p>通过以上分析，我们能发现，Flow的源码执行流程，也非常符合我们之前构想出来的思维模型。那么，对于它的中间操作符，我们是不是只需要加一个“中转站”就可以了呢？答案是肯定的。</p><p>如果让你来设计Flow的中间操作符，我相信你大概率会设计出类似下面这样的结构：</p><p><img src="https://static001.geekbang.org/resource/image/13/eb/13acf7e1dbffdc22226f59f432658deb.jpg?wh=2000x1125" alt=""></p><p>可以看到，当Flow当中出现中间操作符的时候，上游和下游之间就会多出一个个的中转站。对于每一个“中转站”来说，它都会有上游和下游，它都会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>那么，接下来，让我们来分析一下Flow中间操作符的源代码，看看Kotlin官方的设计是否符合我们的猜想：</p><pre><code class="language-plain">// 代码段8\n\n// 1\ninline fun &lt;T&gt; Flow&lt;T&gt;.filter(\n    crossinline predicate: suspend (T) -&gt; Boolean\n): Flow&lt;T&gt; = transform { value -&gt;\n    // 8\n    if (predicate(value)) return@transform emit(value)\n}\n\n// 2\ninternal inline fun &lt;T, R&gt; Flow&lt;T&gt;.unsafeTransform(\n    crossinline transform: suspend FlowCollector&lt;R&gt;.(value: T) -&gt; Unit\n): Flow&lt;R&gt; = unsafeFlow { \n    // 6\n    collect { value -&gt;\n        // 7\n        return@collect transform(value)\n    }\n}\n\n// 3\ninternal inline fun &lt;T&gt; unsafeFlow(\n    crossinline block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit\n): Flow&lt;T&gt; {\n    // 4\n    return object : Flow&lt;T&gt; {\n        // 5\n        override suspend fun collect(collector: FlowCollector&lt;T&gt;) {\n            collector.block()\n        }\n    }\n}\n</code></pre><p>上面的代码看起来有点复杂，让我们来一步步来分析：</p><ul>\n<li>注释1、2、3，请留意这几个方法的签名，它们的返回值类型都是Flow，这意味着，Flow.filter{} 的返回值类型仍然是Flow。我们站在整体的角度来分析的话，会发现：这只是一个Flow被封装的过程。我们都知道，flow{} 创建的是SafeFlow对象，当我们接着调用filter{} 之后，根据注释4处的逻辑，我们发现它会变成一个普通的Flow匿名内部类对象。</li>\n<li>注释5，对于<code>flow{}.filter{}.collect{}</code>这样的代码，最终的collect{} 调用的代码，其实就是注释5对应的collect()方法。我们看看它的方法体collector.block()，这其实就代表了注释6、7会执行。</li>\n<li>注释6，collect{}，这里是在调用上游Flow的collect{}，触发上游的Lambda执行了，也就是<code>flow{}.filter{}.collect{}</code>里的flow{} 当中的Lambda，然后注释7就会被执行。</li>\n<li>注释7，transform(value)，在前面代码段7的分析中，我们知道，这里transform(value)当中的value，其实就是上游传递下来的数据，让我们来看看transform{} 当中具体的逻辑，也就是注释8。</li>\n<li>注释8，<code>if (predicate(value))</code>，这其实就是我们filter的条件，只有符合这个条件的情况下，我们才会继续向下游传递数据，而传递的方式，就是调用emit()，这里的emit()其实就代表了下游会接收到数据了。</li>\n</ul><p>可见，filter{} 的核心思想，完全符合我们前面思维模型推演的结果。接下来，我们来看看map{}、onEach{} 之类的源码：</p><pre><code class="language-plain">// 代码段9\n\npublic inline fun &lt;T, R&gt; Flow&lt;T&gt;.map(crossinline transform: suspend (value: T) -&gt; R): Flow&lt;R&gt; = transform { value -&gt;\n    return@transform emit(transform(value))\n}\n\npublic fun &lt;T&gt; Flow&lt;T&gt;.onEach(action: suspend (T) -&gt; Unit): Flow&lt;T&gt; = transform { value -&gt;\n    action(value)\n    return@transform emit(value)\n}\n</code></pre><p>当我们理解了filter以后，你会发现，map、和onEach之类的操作符就变得很简单了。前者就是在调用下游emit()的时候做了一次数据转换，而后者则是在每次向下游传递数据的时候，同时调用一下传入的Lambda表达式action()。</p><h3>思考：上下文保护</h3><p>在第20讲当中，我留过一个思考题：</p><blockquote>\n<p>课程里我曾提到过，Flow当中直接使用withContext{} 是很容易出现问题的，下面代码是其中的一种。请问你能解释其中的缘由吗？Kotlin官方为什么要这么设计？</p>\n</blockquote><pre><code class="language-plain">// 代码段10\n\nfun main() = runBlocking {\n    flow {\n        withContext(Dispatchers.IO) {\n            emit(1)\n        }\n    }.map { it * 2 }\n        .collect()\n}\n\n/*\n输出结果：\n\nException in thread "main" java.lang.IllegalStateException: Flow invariant is violated:\n        Flow was collected in [BlockingCoroutine{Active}@6e58a46, BlockingEventLoop@2cbfb24],\n        but emission happened in [DispatchedCoroutine{Active}@500da3c0, Dispatchers.IO].\n        Please refer to \'flow\' documentation or use \'flowOn\' instead\n*/\n</code></pre><p>其实，课程进行到这里，我们就已经可以很简单地回答这个问题了。</p><p>在<a href="https://time.geekbang.org/column/article/494526">第24讲</a>当中，我们曾经给Flow的三种API进行过分类：Flow构建器、Flow中间操作符，它们两个是不需要协程作用域的，只有Flow终止操作符需要协程作用域。</p><p><img src="https://static001.geekbang.org/resource/image/b9/b7/b98d651e66309f67f16843e5d00a80b7.jpg?wh=2000x1125" alt=""></p><p>通过前面Flow的源码分析流程，我们其实就会发现，在默认情况下，Flow下游的“协程上下文”最终会成为上游的执行环境，也会变成中间操作符的执行环境。也正是这个原因，才让Flow可以天然支持协程的“结构化并发”的特性，比如说结构化取消。</p><pre><code class="language-plain">// 代码段11\n\nprivate fun testFlow2() {\n    val scope = CoroutineScope(Job())\n    scope.launch {\n        flow {\n            logX("上游")\n            repeat(100) {\n                emit(it)\n            }\n        }.filter {\n            logX("中间")\n            it &gt; 2\n        }\n            .map { it * 2 }\n            .onCompletion {\n                logX(it)\n            }\n            .collect {\n                logX(it)\n                delay(1000L)\n            }\n    }\n\n    Thread.sleep(2000L)\n\n    scope.cancel()\n    logX("结束")\n}\n\n/*\n输出结果：\n================================\n上游\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n6\nThread:DefaultDispatcher-worker-1\n================================\n================================\n中间\nThread:DefaultDispatcher-worker-1\n================================\n================================\n8\nThread:DefaultDispatcher-worker-1\n================================\n================================\n结束\nThread:main\n================================\n================================\nkotlinx.coroutines.JobCancellationException: Job was cancelled; job=JobImpl{Cancelling}@407d87d0\nThread:DefaultDispatcher-worker-1\n================================\n*/\n</code></pre><p>从上面的执行结果可以看到，虽然我们的上游要尝试emit()100个数据，但是由于外部的scope在2000毫秒后会取消，所以整个Flow都会响应取消。</p><p>那么反之，如果Kotlin官方允许开发者在flow{} 当中，调用withContext{} 改变协程上下文的话，<strong>Flow上游与下游的协程上下文就会不一致，它们整体的结构也会被破坏，从而导致“结构化并发”的特性也被破坏</strong>。</p><p>Flow源码中对于上下文的检测，我们称之为上下文保护（Context Preservation），它对应的检测时机在代码段7的注释4处，具体的逻辑如下：</p><pre><code class="language-plain">// 代码段12\n\nprivate fun emit(uCont: Continuation&lt;Unit&gt;, value: T): Any? {\n    // 省略\n    // This check is triggered once per flow on happy path.\n    val previousContext = lastEmissionContext\n    if (previousContext !== currentContext) {\n        checkContext(currentContext, previousContext, value)\n    }\n}\n\nprivate fun checkContext(\n    currentContext: CoroutineContext,\n    previousContext: CoroutineContext?,\n    value: T\n) {\n    if (previousContext is DownstreamExceptionElement) {\n        exceptionTransparencyViolated(previousContext, value)\n    }\n    checkContext(currentContext)\n    lastEmissionContext = currentContext\n}\n\ninternal fun SafeCollector&lt;*&gt;.checkContext(currentContext: CoroutineContext) {\n    val result = currentContext.fold(0) fold@{ count, element -&gt;\n        val key = element.key\n        val collectElement = collectContext[key]\n        if (key !== Job) {\n            return@fold if (element !== collectElement) Int.MIN_VALUE\n            else count + 1\n        }\n\n        val collectJob = collectElement as Job?\n        val emissionParentJob = (element as Job).transitiveCoroutineParent(collectJob)\n\n        if (emissionParentJob !== collectJob) {\n            error(\n                "Flow invariant is violated:\\n" +\n                        "\\t\\tEmission from another coroutine is detected.\\n" +\n                        "\\t\\tChild of $emissionParentJob, expected child of $collectJob.\\n" +\n                        "\\t\\tFlowCollector is not thread-safe and concurrent emissions are prohibited.\\n" +\n                        "\\t\\tTo mitigate this restriction please use \'channelFlow\' builder instead of \'flow\'"\n            )\n        }\n\n\n        if (collectJob == null) count else count + 1\n    }\n\n    // 判断上游、下游的Context\n    if (result != collectContextSize) {\n        error(\n            "Flow invariant is violated:\\n" +\n                    "\\t\\tFlow was collected in $collectContext,\\n" +\n                    "\\t\\tbut emission happened in $currentContext.\\n" +\n                    "\\t\\tPlease refer to \'flow\' documentation or use \'flowOn\' instead"\n        )\n    }\n}\n</code></pre><p>所以，总的来说，Flow不允许直接使用withContext{} 的原因，是为了“结构化并发”，它并不是不允许切换线程，而是不允许随意破坏协程的上下文。Kotlin提供的操作符flowOn{}，官方已经帮我们处理好了上下文的问题，所以我们可以放心地切线程。</p><h2>小结</h2><p>这节课，我们是通过分析Flow的源码，理解了它的几类API是如何实现的。我们知道，Flow是冷数据流，可以分为上游Flow构造器、中间操作符、下游FlowCollector。那么可以说，<strong>理解了Flow、FlowCollector这两个接口，其实就理解了Flow的原理。</strong></p><p>上游Flow构造器，它实际返回的对象是SafeFlow，在SafeFlow当中有一个SafeCollector，它会接收上游的数据，并且将数据传递给下游的FlowCollector。</p><p>下游FlowCollector，在下游调用collect()的时候，实际上是调用的Flow的collect()方法，这就会触发上游的Lambda被执行。在collect()调用的时候，它会创建一个FlowCollector的匿名内部类对象，专门用于接收来自上游的数据。</p><p>中间操作符，它在整个Flow的调用流程当中，既会充当上游，也会充当下游。它会被下游触发执行，它也会触发自己的上游；同时，它会接收来自上游的数据，也会传递给自己的下游。</p><p>上下文保护，由于Flow的上游与中间操作符并不需要协程作用域，因此，它们都是共用的Flow下游的协程上下文。也正是因为Flow的这种设计，让Flow天然支持结构化并发。为此，Kotlin官方也限制了我们开发者不能随意在上游与中转站阶段，改变Flow的上下文。</p><p>其实，课程进行到这里，你会发现，Flow的原理之所以看起来很简单，完全是因为它站在了“挂起函数”“高阶函数”这两个巨人的肩膀上！如果没有它们作为基础，Flow的API设计一定会更加复杂。</p><h2>思考题</h2><p>前面我提到过，“理解了Flow、FlowCollector这两个接口，就理解了Flow的原理。”那么，你能概括出Flow、FlowCollector这两个抽象的接口之间的内在联系吗？</p><pre><code class="language-plain">public interface Flow&lt;out T&gt; {\n    public suspend fun collect(collector: FlowCollector&lt;T&gt;)\n}\n\npublic fun interface FlowCollector&lt;in T&gt; {\n    public suspend fun emit(value: T)\n}\n</code></pre>',
        article_title: "32 | 图解Flow：原来你是只纸老虎？",
      },
    ],
  },
  {
    chapterTitle: "Android项目篇",
    children: [
      {
        title: "33 | Java Android开发者还会有未来吗？",
        id: 504379,
        content:
          '<p>你好，我是朱涛。在过去的几十讲里，我们把Kotlin的基础语法和核心难点协程，都全面学习了一遍，从原理到实战，从协程的核心挂起函数、launch等，到探究它们的源码定义，可以说我们已经基本掌握了Kotlin的核心知识点与特性，你也应该可以在工作中使用Kotlin来解决实际问题了。如果你发现自己对这些知识的掌握还有不少漏洞，也别着急，可以再回头复习一下相应部分的内容，或者在留言区提问，我会给你解答。</p><p>那么，从这节课起，我会带你来看看Kotlin在实践场景中，应用得最普遍、最广泛的领域，<strong>Android</strong>。我们一起来学习下如何结合所学的Kotlin知识，来高效开发Android应用。</p><p>今天这节课，我们先来聊聊Kotlin和Android的关系，让你对Android的现状与未来的发展方向有一个清晰的认识。</p><p>虽然Kotlin是面向多个平台的（如JVM、Native、JS等），不过我们在讨论Kotlin的同时，难免也会讨论下Android。甚至，很多开发者都是因为Android才开始接触Kotlin的。</p><p>说起Kotlin与Android，就不得不提它俩对应的公司JetBrains和Google。早在2013年之前，这两家公司就有过合作。最开始的时候，Android开发者的开发工具还是Eclipse，Google是在JetBrains的IntelliJ的基础上，进行改造以后，才有了后来的Android Studio。</p><!-- [[[read_end]]] --><p>而Eclipse与Android Studio之间的开发体验，可以说是天壤之别。这一点，在Kotlin与Java的对比上其实也是类似的。Android开发者不学Kotlin坚持使用Java，就好比是不使用Android Studio坚持使用Eclipse一样。</p><p>那么，对于Android开发者来说，Kotlin对比Java的优势，可以说是全方位的，具体我们可以从下面几个维度来看。</p><h2>语言的优势</h2><p>在前面的课程当中，我曾经说过，Kotlin与Java并没有绝对的好坏，但不可否认的是：<strong>在Android平台上，Kotlin对比Java是有绝对优势的。</strong></p><p>经过前面课程的学习，我想你对Kotlin的语法特性已经有了充分的认识，不论是它简洁的语法，还是灵活的扩展特性，还是它的空安全特性，或者是强大的协程框架，都可以为我们Android开发者带来更好的体验。</p><p>另外，由于Kotlin同时也是基于JVM的，它与Java的100%互操作性，也让我们开发者可以灵活地集成到现有的工程中去。</p><p>根据Android官方的一组<a href="https://developer.android.com/kotlin/build-better-apps#:~:text=Kotlin%2520is%2520already%2520used%2520by,Android%2520apps%2520contain%2520Kotlin%2520code.">统计数据</a>，已经有超过60%的Android个人开发者在使用Kotlin；而在排名前1000的Android应用中，也已经有超过80%的比例在使用Kotlin进行开发。可见，头部互联网公司的Android团队都在积极在做技术转型，Kotlin也正在成为大厂Android研发的基本要求。</p><p>而随着Kotlin在Android当中普及率的提升，整个开发者社区产出的内容也渐渐以Kotlin为主，不论是Android官方的文档，还是其他技术社区的博客，其中的代码片段都在使用Kotlin。我们以Google官方在GitHub开源的<a href="https://github.com/android/architecture-components-samples">Sample</a>为例，其中大部分的代码都已经变成了Kotlin。试想一下，作为一个Android开发者，如果看不懂Kotlin代码，我们又该如何跟进最新的技术呢？</p><h2>开源库</h2><p>作为Android开发者，我们总是难免会用到一些优秀的开源库，近几年，GitHub上也涌现了许多纯Kotlin开发的开源库，比如说<a href="https://github.com/InsertKoinIO/koin">Kotlin依赖注入框架Koin</a>、<a href="https://github.com/coil-kt/coil">Kotlin实现的图片加载框架coil</a>，等等。其实，不仅是新的开源库会用Kotlin，许多著名的Java开源库也在使用Kotlin重写，比如著名的<a href="https://github.com/square/okhttp">网络请求框架OkHttp</a>、<a href="https://github.com/square/leakcanary">内存泄漏检测框架LeakCanary</a>、<a href="https://github.com/square/picasso">图片加载框架Picasso</a>等。大量开源库拥抱Kotlin，这本身其实就说明了Kotlin自身的语言优势。</p><p><img src="https://static001.geekbang.org/resource/image/db/ce/db2b8998684f9bc89f44de57a71116ce.png?wh=1920x1164" alt="图片"></p><p>所以，如果我们Android开发者看不懂Kotlin代码，这些用Kotlin编写的开源库，我们用起来肯定会有点儿心虚，因为看不懂它们的源代码。</p><p>当然，如果仅仅是GitHub上面的第三方开源库在选择Kotlin，我们也还是可以选择不用它。但如果是Android官方的呢？实际上，连Android官方团队都开始使用Kotlin写<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/packages/SystemUI/src/com/android/systemui/media/">Android系统的源代码</a>（AOSP），还有Jetpack库（比如<a href="https://github.com/androidx/androidx/tree/androidx-main/paging/paging-common/src/main/kotlin/androidx/paging">Paging</a>、<a href="https://github.com/androidx/androidx/tree/androidx-main/lifecycle/lifecycle-viewmodel/src/main/java/androidx/lifecycle">ViewModel</a>）等等。可以说，Kotlin在Android当中的地位已经远远超过了Java，而且，随着时间的推移，两者的差距会越来越大。</p><p><img src="https://static001.geekbang.org/resource/image/2f/7a/2f50c2584cce6c8ddyy1f36feed04e7a.png?wh=1920x1360" alt="图片"></p><h2>Jetpack Compose</h2><p>在2021年7月，Android官方团队正式发布了全新的UI编程框架Jetpack Compose。它是由纯Kotlin实现的，想要使用它，我们就必须懂Kotlin。</p><p>对于传统的Android开发来说，开发者必须先用XML编写UI布局，类似这样：</p><pre><code class="language-plain">&lt;?xml version="1.0" encoding="utf-8"?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    tools:context=".MainActivity"&gt;\n\n    &lt;TextView\n        android:id="@+id/text"\n        android:layout_width="wrap_content"\n        android:layout_height="wrap_content"\n        android:text="Hello World!"\n        app:layout_constraintBottom_toBottomOf="parent"\n        app:layout_constraintLeft_toLeftOf="parent"\n        app:layout_constraintRight_toRightOf="parent"\n        app:layout_constraintTop_toTopOf="parent" /&gt;\n\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre><p>这个XML，其实就是一个最简单的UI布局，父布局ConstraintLayout里面有一个TextView。在XML当中，我们使用一个个的UI控件节点，来描述控件间的嵌套关系，最终组成一个UI的树。接着，开发者就需要在Java或Kotlin当中编写对应的业务逻辑。</p><pre><code class="language-plain">class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val textView = findViewById&lt;TextView&gt;(R.id.text)\n        textView.setOnClickListener {\n            // do something\n        }\n    }\n}\n</code></pre><p>这样的代码模式其实有一个特别明显的缺陷，那就是<strong>代码之间的依赖跨越了两个不同的语言模块</strong>：XML模块、Kotlin模块。</p><p><img src="https://static001.geekbang.org/resource/image/33/58/33bfe3be69b354e713976efa5a82cc58.jpg?wh=2000x853" alt=""></p><p>对于这样跨越模块的依赖，两者之间的耦合是非常严重的，维护起来非常费力，XML发生改变了，Kotlin当中也要发生对应的改变。虽然Android官方也曾推出过DataBinding之类的工具，帮助我们在XML当中编写简单的数据绑定逻辑，但这种方式并不能从根本上解决问题，因为 <strong>DataBinding只能减少两个模块之间的耦合，并不能消灭</strong>。</p><p>而Jetpack Compose，就为Android开发提供了另一种可能性：UI和逻辑都用Kotlin编写。</p><pre><code class="language-plain">// 不需要 xml\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text("Hello world!")\n        }\n    }\n}\n</code></pre><p>在上面的代码中，我们直接使用Text()的方法创建了一个TextView，然后传入了setContent{}这个高阶函数当中。这样，我们整个Android的代码就写完了，根本不需要编写XML，也不需要findViewById、DataBinding之类的操作了。</p><p><img src="https://static001.geekbang.org/resource/image/fb/7d/fb265dcabc32b1e9f8a064980a22c27d.jpg?wh=2000x859" alt=""></p><p>很明显，Jetpack Compose这样的代码模式，就属于内聚模式。由于我们可以使用Kotlin编写UI布局，所以，我们可以同时使用Kotlin完成View相关的逻辑，比如状态管理、布局测量、触摸反馈、动画，等等。要知道，在从前XML的时代，View相关的这些逻辑都是割裂开的，耦合也非常严重。</p><p>总的来说，使用Compose可以大大简化我们Android的开发，也可以提升开发者的效率。在Compose当中，大量使用了Kotlin的高级特性，比如扩展、委托，甚至协程；同时它大量借鉴了函数式编程的思想，在Compose当中推崇“不变性”“无副作用”，为此，Compose也为开发者提供了一系列的<a href="https://developer.android.com/jetpack/compose/side-effects">Effect Handlers</a>。</p><p>总之，如果你是一名热爱Kotlin的Android工程师，那么你一定会对Jetpack Compose一见钟情。</p><p>当然，这里我为了让课程简单易懂，特地举了最简单的例子，如果你对Jetpack Compose感兴趣，也可以去看看<a href="https://developer.android.com/courses/pathways/compose">Android官方的Compose教程</a>。</p><h2>小结</h2><p>好，到这里，我们这节课的内容就差不多结束了。这节课我们主要从三个角度分析了Kotlin对Android开发的重要性。</p><ul>\n<li><strong>语言的优势</strong>，Kotlin因为其简洁的语法，以及灵活的语法特性，还有强大的协程框架，让它建立起了对比Java的语言优势，从而也让越来越多的开发者愿意使用它。业界的文档、博客也渐渐以Kotlin为主流。</li>\n<li><strong>开源库</strong>，不仅第三方的开源库，就连Android官方团队也在使用Kotlin编写源代码。</li>\n<li><strong>Jetpack Compose</strong>，它是Android团队推出的全新UI框架，可以大大简化Android开发，也可以提升开发效率。它是纯Kotlin开发的，我们开发者如果要使用它的话，也必须使用Kotlin。</li>\n</ul><p>好，现在，让我们来回答这节课的标题的问题：<strong>Java Android开发者还会有未来吗？</strong>我认为单纯的Android应用开发者，如果不掌握好Kotlin，一定是会渐渐被淘汰的。</p><p>当然，经过前面一系列课程的学习，我相信你已经对Kotlin的各个方面都有了透彻的认识。这节课的目的，我是想告诉你，如果你是Android开发者，请一定不要怀疑自己学习Kotlin这个决定到底正不正确；同时也不要犹豫，一定要在实际工作中用起来。</p><p>在接下来的两节课当中，我会用一些简单的案例，来向你展示Kotlin在Android开发当中的实际应用。</p><h2>思考题</h2><p>作为Android开发者，你最喜欢Kotlin的哪个语言特性？为什么？</p><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>',
        article_title: "33 | Java Android开发者还会有未来吗？",
      },
      {
        title: "34 | Kotlin与Jetpack简直是天生一对！",
        id: 505790,
        content:
          '<p>你好，我是朱涛。今天，我们来聊聊Android的Jetpack。</p><p>在我看来，Kotlin和Jetpack，它们两个简直就是天生一对。作为Android开发者，如果只用Kotlin不用Jetpack，我们其实很难在Android平台充分发挥Kotlin的语言优势。而如果我们只用Jetpack而不用Kotlin，那么，我们将只能用到Jetpack的小部分功能。毕竟，Jetpack当中有很多API和库，是专门为Kotlin提供的。</p><p>经过前面课程内容的学习，相信现在你已经对Kotlin十分熟悉了，那么，接下来就让我们来看看Jetpack吧！这节课里，我会为你介绍Jetpack核心库的基本概念、简单用法，以及它跟Kotlin之间的关系，从而也为我们下节课的实战项目打下基础。</p><h2>Jetpack简介</h2><p>Jetpack，它有“喷气式背包”的意思。对于我们开发者来说，它其实就是Google官方为我们提供的一套开发套件，专门用来帮助Android开发者提升开发效率、提升应用稳定性的。</p><p><a href="https://android-developers.googleblog.com/2019/05/whats-new-with-android-jetpack.html"><img src="https://static001.geekbang.org/resource/image/ba/c2/ba1e45560e1e6510591d75ee6ee862c2.jpg?wh=600x600" alt=""></a></p><p>Android Jetpack，最初的宣传图标，就是“穿着喷气式背包的Android机器人”。大概意思就是：有了Jetpack，Android就能“起飞了”。这当然只是一种夸张的比喻，不过，从我实际的开发体验来说，Jetpack确实可以给Android开发者带来极大的好处，尤其是当Jetpack与Kotlin结合到一起的情况下。</p><!-- [[[read_end]]] --><p>我们先来了解下KTX。</p><h2>KTX</h2><p>KTX是Jetpack当中最特殊的一类库，它是由Kotlin编写的，同时也仅为Kotlin开发者服务，使用Java语言的Android开发者是用不了的。KTX，它的作用其实是对当前Android生态当中的API进行额外补充。它依托Kotlin的扩展能力，为Android原有API增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</p><p>如果我们想要使用KTX的核心功能，我们需要单独进行依赖：</p><pre><code class="language-groovy">// 代码段1\n\ndependencies {\n    implementation "androidx.core:core-ktx:1.7.0"\n}\n</code></pre><p>让我们来看一个关于SharedPreference的简单例子，如果我们使用Java，我们大概率是需要写一堆模板代码的，类似这样：</p><pre><code class="language-java">// 代码段2\n\nSharedPreferences sharedPreferences= getSharedPreferences("data",Context.MODE_PRIVATE);\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putString(SP_KEY_RESPONSE, response);\n\neditor.commit();\neditor.apply();\n</code></pre><p>不过，如果我们有了KTX，那么代码就会变得极其简单：</p><pre><code class="language-plain">// 代码段3\n\npreference.edit { putBoolean("key", value) }\n</code></pre><p>上面的这个edit()方法，其实是一个高阶函数，它是由KTX提供的，如果你去看它的源代码，会发现，它其实就是一个扩展出来的高阶函数：</p><pre><code class="language-plain">// 代码段4\n\ninline fun SharedPreferences.edit(\n        commit: Boolean = false,\n        action: SharedPreferences.Editor.() -&gt; Unit\n) {\n    val editor = edit()\n    action(editor)\n    if (commit) {\n        editor.commit()\n    } else {\n        editor.apply()\n    }\n}\n</code></pre><p>可以看到，KTX其实就是将一些常见的模板代码封装了起来，然后以扩展函数的形式提供给开发者。虽然它自身的原理很简单，但是却可以大大提升开发者的效率。</p><p>KTX除了能够扩展Android SDK的API以外，它还可以扩展Jetpack当中其他的库，比如说LiveData、Room等等。接下来，我们就来看看Jetpack当中比较核心的库：Lifecycle。</p><h2>Lifecycle</h2><p>Lifecycle，其实就是Android的生命周期组件。在整个Jetpack组件当中的地位非常特殊，是必学的组件。举个例子，其他的组件比如WorkManager，如果我们实际工作中用不上，那么我们不去学它是不会有什么问题的。Lifecycle不一样，只要我们是做Android开发的，我们就绕不开Lifecycle。Activity里面有Lifecycle；Fragment里面也有；LiveData里面也有；</p><p>ViewModel底层也用到了Lifecycle；使用协程也离不开Lifecycle。</p><p>那么，Lifecycle到底是什么呢？我们平时提到生命周期，往往都是说的Activity、Fragment，而它们两者之间却有一个很大的问题，<strong>生命周期函数不一致</strong>。</p><p>Activity的生命周期我们肯定心里有数，不过Fragment生命周期函数比Activity多了几个：onCreateView、onViewCreated、onViewStateRestore、onDestoryView。最重要的是，Fragment生命周期、回调函数、Fragment内部View的生命周期，它们三者之间还有很复杂的对应关系。换句话说，Fragment的生命周期函数要比Activity复杂一些。</p><p>加之，Activity和Fragment结合的情况下，它们的生命周期行为在不同版本的Android系统上行为可能还会不一致。这在某些边界条件下，还会引发一些难以排查的bug，进一步增加我们Android程序员的维护成本。</p><p>在计算机世界里，大部分问题都可以通过增加一个抽象层来解决。Android团队的做法就是推出了Lifecycle这个架构组件，用它来统一Activity、Fragment的生命周期行为。</p><p><img src="https://static001.geekbang.org/resource/image/f0/a1/f03yy1b87813c58f5591aab720e432a1.jpg?wh=2000x904" alt=""></p><p>有了LifeCycle以后，我们开发者就可以面向Lifecycle编程。比如说，我们希望实现一个通用的地理位置监听的Manager，就可以这样来做：</p><pre><code class="language-plain">// 代码段5\n\n// 不关心调用方是Activity还是Fragment\nclass LocationManager(\n    private val context: Context,\n    private val callback: (Location) -&gt; Unit\n): DefaultLifecycleObserver {\n\n    override fun onStart(owner: LifecycleOwner) {\n        start()\n    }\n\n    override fun onStop(owner: LifecycleOwner) {\n        stop()\n    }\n\n    private fun start() {\n        // 使用高德之类的 SDK 请求地理位置\n    }\n\n    private fun stop() {\n        // 停止\n    }\n}\n\nclass LifecycleExampleActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_life_cycle_example)\n\n        val locationManager = LocationManager(this) {\n            // 展示地理位置信息\n        }\n        lifecycle.addObserver(locationManager)\n    }\n}\n</code></pre><p>上面代码的LocationManager只需要实现DefaultLifecycleObserver这个接口即可，外部是在Activity还是在Fragment当中使用，根本不必关心。</p><h3>Lifecycle与协程</h3><p>通过前面课程的学习，我们知道，协程其实也是有生命周期的。也就是说，Android和Kotlin协程都是有生命周期的。这就意味着，当我们在Android当中使用协程的时候，就要格外小心。</p><p>作为Android开发者，你一定知道内存泄漏的概念：当内存变量的生命周期大于Android生命周期的时候，我们就认为内存发生泄漏了。类似的，当协程的生命周期大于Android生命周期的时候，<strong>协程也就发生泄漏了</strong>。</p><p>这一点，Android官方早就帮我们考虑到了。Lifecycle还可以跟我们前面提到的KTX结合到一起，进一步为Kotlin协程提供支持。</p><p><img src="https://static001.geekbang.org/resource/image/ba/5c/ba1d19579cd0e6e6a8e4e004732c705c.png?wh=884x456" alt="图片"></p><p>在Activity、Fragment当中，KTX还提供了对应的lifecycleScope，它本质上就是一个：与生命周期绑定的协程作用域。</p><pre><code class="language-plain">// 代码段6\n\n// 1\npublic val LifecycleOwner.lifecycleScope: LifecycleCoroutineScope\n    // 2\n    get() = lifecycle.coroutineScope\n\npublic abstract class LifecycleCoroutineScope internal constructor() : CoroutineScope {\n    internal abstract val lifecycle: Lifecycle\n\n    public fun launchWhenCreated(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenCreated(block)\n    }\n\n    public fun launchWhenStarted(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenStarted(block)\n    }\n\n    public fun launchWhenResumed(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenResumed(block)\n    }\n}\n</code></pre><p>在Android当中，Activity和Fragment都会实现LifecycleOwner这个接口，代表它们都是拥有生命周期的组件。注释1处，这里使用了Kotlin的扩展属性，为LifecycleOwner扩展了lifecycleScope。它的类型是LifecycleCoroutineScope，而它其实就是CoroutineScope的实现类。</p><p>lifecycleScope这个属性的具体实现，其实是通过注释2处的自定义getter()实现的，也就是：Lifecycle.coroutineScope。</p><pre><code class="language-plain">// 代码段7\n\npublic val Lifecycle.coroutineScope: LifecycleCoroutineScope\n    get() {\n        while (true) {\n            // 1\n            val existing = mInternalScopeRef.get() as LifecycleCoroutineScopeImpl?\n            if (existing != null) {\n                return existing\n            }\n            // 2\n            val newScope = LifecycleCoroutineScopeImpl(\n                this,\n                SupervisorJob() + Dispatchers.Main.immediate\n            )\n            //3\n            if (mInternalScopeRef.compareAndSet(null, newScope)) {\n                newScope.register()\n                return newScope\n            }\n        }\n    }\n</code></pre><p>可以看到，Lifecycle.coroutineScope仍然是一个扩展属性。它的逻辑其实也很简单，主要是分为了三个步骤：</p><ul>\n<li>第一步，检查是否存在缓存的CoroutineScope，如果存在，那就直接返回即可。</li>\n<li>第二步，如果不存在缓存，那就创建一个新的协程作用域。在创建的作用域的时候，用到了两个我们熟悉的概念：SupervisorJob、Dispatchers.Main，它们都是协程上下文的元素，<strong>前者是用来隔离协程异常传播的，后者是指定协程执行线程的</strong>。</li>\n<li>第三步，更新缓存，并且调用register()绑定scope与Lifecycle的关系，最后返回。</li>\n</ul><p>接下来，我们打破砂锅问到底，看看register()的具体逻辑是什么：</p><pre><code class="language-plain">// 代码段8\n\ninternal class LifecycleCoroutineScopeImpl(\n    override val lifecycle: Lifecycle,\n    override val coroutineContext: CoroutineContext\n    // 2\n) : LifecycleCoroutineScope(), LifecycleEventObserver {\n    init {\n        if (lifecycle.currentState == Lifecycle.State.DESTROYED) {\n            coroutineContext.cancel()\n        }\n    }\n\n    // 1\n    fun register() {\n        launch(Dispatchers.Main.immediate) {\n            if (lifecycle.currentState &gt;= Lifecycle.State.INITIALIZED) {\n                lifecycle.addObserver(this@LifecycleCoroutineScopeImpl)\n            } else {\n                coroutineContext.cancel()\n            }\n        }\n    }\n\n    // 3\n    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {\n        if (lifecycle.currentState &lt;= Lifecycle.State.DESTROYED) {\n            lifecycle.removeObserver(this)\n            coroutineContext.cancel()\n        }\n    }\n}\n\npublic interface LifecycleEventObserver extends LifecycleObserver {\n    void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);\n}\n</code></pre><p>上面的代码一共有三个注释，我们一个个来看：</p><ul>\n<li>注释1，register()，可以看到，它的逻辑其实很简单，主要就是调用了addObserver()，将自身作为观察者传了进去。之所以可以这么做，还是因为注释2处的LifecycleEventObserver。</li>\n<li>注释2，LifecycleEventObserver，它其实就是一个SAM接口，每当LifeCycleOwner的生命周期发生变化的时候，这个onStateChanged()方法就会被调用。而这个方法的具体实现则在注释3处。</li>\n<li>注释3，这里的逻辑也很简单，当LifeCycleOwner对应的Activity、Fragment被销毁以后，就会调用removeObserver(this)移除观察者，最后，就是最关键的coroutineContext.cancel()，取消整个作用域里所有的协程任务。</li>\n</ul><p>这样一来，就能保证LifeCycle与协程的生命周期完全一致了，也就不会出现协程泄漏的问题了。</p><h2>小结</h2><p>这节课，我们主要了解了Android当中的Jetpack，它是Android官方提供给开发者的一个开发套件，可以帮助我们开发者提升开发效率。Jetpack当中其实有<a href="https://developer.android.com/jetpack">几十个库</a>，在这节课里，我们是着重讲解了其中的KTX与LifeCycle。</p><ul>\n<li>KTX，主要是依托Kotlin的扩展能力，为Android原有API增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</li>\n<li>Lifecycle，其实就是Android的生命周期组件。它统一封装了Activity、Fragment等Android生命周期的组件。让我们开发者可以只关注LifeCycle的生命周期，而不用在意其他细节。</li>\n<li>KTX还为LifeCycle增加了协程支持，也就是lifecycleScope。在它的底层，这个协程作用域和宿主的生命周期进行了绑定。当宿主被销毁以后，它可以确保lifecycleScope当中的协程任务，也跟着被取消。</li>\n</ul><p>所以，对于Android开发者来说，Kotlin和Jetpack是一个“你中有我，我中有你”的关系，我们把它们称为“天生一对”一点儿也不为过。</p><h2>思考题</h2><p>在Android中使用协程的时候，除了lifecycleScope以外，我们还经常会使用ViewModel的viewModelScope。你能结合前面协程篇、源码篇的知识点，分析出viewModelScope的实现原理吗？</p><pre><code class="language-plain">class MyViewModel : ViewModel() {\n    private val _persons: MutableLiveData&lt;List&lt;Person&gt;&gt; = MutableLiveData()\n    val persons: LiveData&lt;List&lt;Person&gt;&gt; = _persons\n\n    fun loadPersons() {\n        viewModelScope.launch {\n            delay(500L)\n            _persons.value = listOf(Person("Tom"), Person("Jack"))\n        }\n    }\n}\n\n// 扩展属性\npublic val ViewModel.viewModelScope: CoroutineScope\n    get() {\n        val scope: CoroutineScope? = this.getTag(JOB_KEY)\n        if (scope != null) {\n            return scope\n        }\n        return setTagIfAbsent(\n            JOB_KEY,\n            // 实现类\n            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)\n        )\n    }\n\n// 实现了Closeable的CoroutineScope\ninternal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {\n    override val coroutineContext: CoroutineContext = context\n\n    override fun close() {\n        // 取消\n        coroutineContext.cancel()\n    }\n}\n\npublic abstract class ViewModel {\n\n    @Nullable\n    private final Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();\n    private volatile boolean mCleared = false;\n\n\n    @SuppressWarnings("WeakerAccess")\n    protected void onCleared() {\n    }\n\n    @MainThread\n    final void clear() {\n        mCleared = true;\n\n        if (mBagOfTags != null) {\n            synchronized (mBagOfTags) {\n                for (Object value : mBagOfTags.values()) {\n                    // 调用scope的close()\n                    closeWithRuntimeException(value);\n                }\n            }\n        }\n        onCleared();\n    }\n\n    // scope暂存起来\n    @SuppressWarnings("unchecked")\n    &lt;T&gt; T setTagIfAbsent(String key, T newValue) {\n        T previous;\n        synchronized (mBagOfTags) {\n            previous = (T) mBagOfTags.get(key);\n            if (previous == null) {\n                mBagOfTags.put(key, newValue);\n            }\n        }\n        T result = previous == null ? newValue : previous;\n        if (mCleared) {\n\n            closeWithRuntimeException(result);\n        }\n        return result;\n    }\n\n    private static void closeWithRuntimeException(Object obj) {\n        if (obj instanceof Closeable) {\n            try {\n                ((Closeable) obj).close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n</code></pre>',
        article_title: "34 | Kotlin与Jetpack简直是天生一对！",
      },
      {
        title: "35 | 用Kotlin写一个GitHub Trending App",
        id: 506682,
        content:
          '<p>你好，我是朱涛。</p><p>这节课，我们一起来用Kotlin和Jetpack写一个简单的Android应用。为了便于理解，这个应用的功能会尽量简单，即使你对Android不是特别熟悉，跟着课程的引导，你也能轻松完成。</p><h2>准备工作</h2><p>在之前的课程中，我们的实战项目都是基于JVM的，并没有涉及过Android相关的配置。因此，如果你的电脑没有Android开发的环境的话，那么可能需要做一些额外的配置。当然，在你已有Java环境的前提下，想要配置Android开发环境并不麻烦，你可以去搜索一些相关的<a href="https://www.google.com/search?q=Android+%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">Android开发环境配置</a>的教程。</p><p>那么，要进行Android开发，我们可以使用IntelliJ，也可以使用Android Studio，后者针对Android开发做了很多定制化，也是免费的，这里我也建议你去下载Android Studio。</p><p>当配置好所有的环境以后，我们就可以像创建Kotlin工程一样，来创建一个新的Android工程了。</p><p><img src="https://static001.geekbang.org/resource/image/f9/00/f9f6b73c7a09bac3ae5b3e15ff997000.gif?wh=900x650" alt="图片"></p><p>然后，当你创建好工程以后，就可以尝试运行代码了，这时候你大概率会看到一个Hello World的初始界面。</p><p>接下来，我们就正式进入开发吧。</p><h2>MVVM架构</h2><p>Android应用的架构，在过去的这些年里一直都在变化。最开始的Android其实没有什么明确的架构，大家习惯于把所有代码都往Activity里放，直到后来才开始有了MVC、MVP以及MVVM。</p><!-- [[[read_end]]] --><p>那么，站在现在这个时间节点上，当前Android中比较主流、比较受Google推崇的，是MVVM架构。这节课，我们就以 <strong>MVVM架构</strong>为基础，并且也尝试<strong>结合Clean架构</strong>来进行一些实践。</p><p>关于MVVM架构，它其实就是代表了Model — View — ViewModel，如果将其对应到Android当中来的话，它们之间大概会是这样的关系：</p><p><img src="https://static001.geekbang.org/resource/image/41/04/416e9447d2cfbe726154c25b6317f404.png?wh=771x232" alt="图片"></p><p>MVVM其实是一种广泛存在的架构模式，在Android当中也有类似的实现。ViewModel会连接View和Model，View和Model之间是隔离开的。而View和ViewModel之间，也往往会存在数据绑定，这里的数据绑定可以是一个组件（如Android的DataBinding），也可以是由代码来完成绑定。</p><p>而相比MVVM架构，Clean架构则是一种更加抽象的思维模式了。它将整个架构大致分为三层，由外到内分别是：表现层、领域层、数据层。它们之间的依赖关系也是由外到内的。</p><p><img src="https://static001.geekbang.org/resource/image/ae/0a/ae182ae3b475ff0289ce3653db6ec70a.png?wh=1656x1216" alt="图片"></p><p>不过 <strong>Clean架构只是一种思想</strong>，当我们尝试在Android中落地应用的时候，其实并不一定会完全按照这里的架构图来设计，目前比较常见的架构是下面这样的：</p><p><img src="https://static001.geekbang.org/resource/image/5a/b2/5aa98ff8962f90dd47b479fee303dcb2.png?wh=928x687" alt="图片"></p><p>可以看到，上面这个架构，融入了MVVM与Clean两个架构的特点，让我们从下往上看：</p><ul>\n<li><strong>实体层</strong>，这里其实就是我们平时定义的一些Bean的实体类，用Kotlin的数据类即可。</li>\n<li><strong>数据层</strong>，这里一般会有两个概念，分别是DataSource与Repository，前者代表数据源，后者代表数据仓库。数据源一般会区分本地数据源和远程数据源，而数据仓库则会统筹它们两者。</li>\n<li><strong>领域层</strong>，这里一般会是一些相对具体一些的业务逻辑。</li>\n<li><strong>表现层</strong>，这里则是接近UI展示的上层逻辑了。</li>\n</ul><p>好，架构分析完了，接下来我们看看代码该怎么写，我们还是按照架构的分层，从下往上来实现。</p><h3>实体层</h3><p>首先，我们要定义一个密封类，来统一不同情况下的数据形式。</p><pre><code class="language-plain">sealed class ResultX&lt;out R: Any&gt; {\n\n    data class Success&lt;out T: Any&gt;(val data: T) : ResultX&lt;T&gt;()\n    data class Error(val exception: Exception) : ResultX&lt;Nothing&gt;()\n    object Loading : ResultX&lt;Nothing&gt;()\n\n    override fun toString(): String {\n        return when (this) {\n            is Success&lt;*&gt; -&gt; "Success[data=$data]"\n            is Error -&gt; "Error[exception=$exception]"\n            Loading -&gt; "Loading"\n        }\n    }\n}\n</code></pre><p>这里，我们利用密封类和泛型，将数据的成功、失败、加载中都统一了起来。类似这样的做法，我们在课程的<a href="https://time.geekbang.org/column/article/473349">第2讲</a>里也已经提到过了。</p><p>然后，由于我们是要实现一个GitHub Trending的应用，所以这里我们只需要找一个开源的API，通过分析它的JSON结构，然后定义出具体的Data Class就行了。这一步，我们其实在<a href="https://time.geekbang.org/column/article/481787">第12讲</a>当中就已经完成了。</p><pre><code class="language-plain">data class RepoList(\n    var count: Int?,\n    var items: List&lt;Repo&gt;?,\n    var msg: String?\n)\n\ndata class Repo(\n    var added_stars: String?,\n    var avatars: List&lt;String&gt;?,\n    var desc: String?,\n    var forks: String?,\n    var lang: String?,\n    var repo: String?,\n    var repo_link: String?,\n    var stars: String?\n)\n</code></pre><p>不过，在之前的课程当中，我提到过以这种方式定义的数据类，其实还存在2个问题。</p><ul>\n<li>问题1：不符合“不变性思维”，成员属性全部都是var定义的。</li>\n<li>问题2：不符合“空安全思维”，所有的类型都是可为空的。</li>\n</ul><p>那么针对这两个问题，我们像下面这样做，其实很容易就能搞定：</p><pre><code class="language-plain">data class RepoList(\n    val count: Int = 0,\n    val items: List&lt;Repo&gt; = listOf(),\n    val msg: String = "数据为空"\n)\n\ndata class Repo(\n    val added_stars: String = "",\n    val avatars: List&lt;String&gt; = listOf(),\n    val desc: String = "",\n    val forks: String = "",\n    val lang: String = "",\n    val repo: String = "",\n    val repo_link: String = "",\n    val stars: String = ""\n)\n</code></pre><p>在这段代码中，我们是把var都替换成了val，把所有的可空类型都改成了不可空类型，同时也为属性都提供了默认值。</p><p>当然，仅仅只是改变底层的实体类的定义还远远不够，具体遇到的问题，我们会在后面分析。下面我们接着来看数据层。</p><h3>数据层</h3><p>在数据层当中，最关键的就是RepoDataSource和Repository。那么首先，我们就要定义它们对应的接口。你可以参考这里的实现：</p><pre><code class="language-plain">interface RepoDataSource {\n    suspend fun getRepos(): ResultX&lt;RepoList&gt;\n}\n\ninterface IRepository {\n    suspend fun getRepoList(): ResultX&lt;RepoList&gt;\n}\n</code></pre><p>接下来，就是它们对应的实现类了，我们先来看看数据源怎么处理。</p><p>由于我们需要请求网络，所以这里我们自然就会想到OkHttp和Retrofit了。虽然我们也可以使用自己写的KtHttp，但它毕竟只是用于学习和研究目的而编写的，并不适合真的拿来用。</p><pre><code class="language-plain">object RetrofitClient {\n\n    private const val TAG = "OkHttp"\n    private const val BASE_URL = "https://baseUrl.com/"\n    private const val TIME_OUT = 10\n\n    val moshi: Moshi by lazy {\n        Moshi.Builder()\n            .add(KotlinJsonAdapterFactory())\n            .build()\n    }\n\n    val service by lazy { getService(RepoService::class.java, BASE_URL) }\n\n    private val client: OkHttpClient by lazy {\n        val builder = OkHttpClient.Builder()\n        builder.connectTimeout(TIME_OUT.toLong(), TimeUnit.SECONDS)\n        builder.build()\n    }\n\n    private fun &lt;S&gt; getService(\n        serviceClass: Class&lt;S&gt;,\n        baseUrl: String,\n        client: OkHttpClient = this.client\n    ): S {\n        return Retrofit.Builder()\n            .client(client)\n            .addConverterFactory(MoshiConverterFactory.create(moshi))\n            .baseUrl(baseUrl)\n            .build().create(serviceClass)\n    }\n}\n\ninterface RepoService {\n    @GET("repo")\n    suspend fun repos(@Query("lang") lang: String = "Kotlin", @Query("since") since: String = "weekly"): RepoList\n}\n</code></pre><p>其实，当我们自己手写了KtHttp的源码以后，Retrofit用起来就会非常顺手。这里我们是定义了一个单例RetrofitClient用来请求API，还有RepoService来代表具体的请求参数规则。</p><p>那么有了Retrofit以后，我们要处理数据源也就很容易了。</p><pre><code class="language-plain">object RemoteRepoDataSource : RepoDataSource {\n    const val TAG = "RemoteRepoDataSource"\n    override suspend fun getRepos(): ResultX&lt;RepoList&gt; =\n        withContext(Dispatchers.IO) {\n            try {\n                Success(RetrofitClient.service.repos())\n            } catch (e: Exception) {\n                Log.e(TAG, e.message, e)\n                Error(e)\n            }\n        }\n}\n</code></pre><p>在这里，我们定义了一个RemoteRepoDataSource，它实现了RepoDataSource这个数据源的接口。而它具体的实现方法，是使用withContext{} 将API请求分发到了IO线程池，然后根据实际的运行结果，将数据封装成对应的ResultX的子类型。</p><p>接着就是数据仓库了，它一般是用于统筹缓存数据、远程数据的，这里为了不引入过多的复杂度，我们简单来实现：</p><pre><code class="language-plain">class MainRepository(\n    private val dataSource: RepoDataSource = RemoteRepoDataSource,\n    private val localDataSource: RepoDataSource? = null\n) : IRepository {\n    override suspend fun getRepoList(): ResultX&lt;RepoList&gt; {\n        // 暂不处理缓存逻辑\n        return dataSource.getRepos()\n    }\n}\n</code></pre><p>你可以看到，它其实就是数据源的一层封装而已。</p><p>好，至此，我们的数据层就已经完成了。</p><h3>领域层</h3><p>所谓领域层，其实就像是业务逻辑的一个小单元，这里的小单元，我们可以将其称为UseCase。</p><pre><code class="language-plain">class GetRepoListUseCase(private val repository: IRepository = MainRepository()) {\n    suspend operator fun invoke(): ResultX&lt;RepoList&gt; {\n        return repository.getRepoList()\n    }\n}\n</code></pre><p>在当前的案例中，我们只有一个业务场景，也就是获取GitHub仓库的列表，所以这个UseCase的逻辑也很简单。不过你要知道，在实际的工作场景中，UseCase是可以承载复杂的业务逻辑的。</p><p>接下来，我们往上看一下表现层。</p><h3>表现层</h3><p>到了表现层这里，我们其实就已经非常接近UI了，具体来说，这里主要涉及到ViewModel还有Activity、Fragment。我们先来看看ViewModel。</p><pre><code class="language-plain">class MainViewModel(\n    val getRepoListUseCase: GetRepoListUseCase = GetRepoListUseCase()\n) : ViewModel() {\n    val repos: LiveData&lt;RepoList&gt;\n        get() = _repos\n    private val _repos = MutableLiveData&lt;RepoList&gt;()\n\n    fun loadRepos() {\n        viewModelScope.launch {\n            val result = getRepoListUseCase()\n            when (result) {\n                is ResultX.Success -&gt; {\n                    _repos.value = result.data\n                }\n                is ResultX.Error -&gt; {\n                    _repos.value = RepoList()\n                }\n                ResultX.Loading -&gt; {\n                    // 展示Loading\n                }\n            }\n        }\n    }\n}\n</code></pre><p>可以看到，我们在ViewModel当中定义了一组LiveData，并且针对它的读写做了限制，这一点，我们在讲<a href="https://time.geekbang.org/column/article/484631">不变性思维</a>的时候提到过。</p><p>在loadRepos()这个方法中，我们用到了viewModelScope.launch {} 来启动协程。经过上节课的学习，我们知道以这种方式启动的协程是不会发生泄漏的，其中的协程任务会随着Activity的销毁而取消。</p><p>OK，最后，就是Activity当中的逻辑了。</p><pre><code class="language-plain">class MainActivity : AppCompatActivity() {\n    // 1\n    private val viewModel: MainViewModel by viewModels()\n    // 2\n    private lateinit var binding: ActivityMainBinding\n\n    private lateinit var adapter: RepoAdapter\n    private val layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        viewModel.loadRepos()\n        observeData()\n    }\n\n    private fun observeData() {\n        // 3\n        viewModel.repos.observe(this) {\n            display(it)\n        }\n    }\n\n    private fun display(repoList: RepoList) {\n        adapter = RepoAdapter(repoList)\n        binding.recycler.layoutManager = layoutManager\n        binding.recycler.adapter = adapter\n    }\n}\n</code></pre><p>上面Activity的逻辑也很简单，其中有几个注释，我们一起来看看：</p><ul>\n<li>注释1，这里我们使用了委托的语法，将ViewModel的创建交给了"by viewModels()"。它其实是Activity的一个扩展函数，是由KTX实现的。</li>\n<li>注释2，ActivityMainBinding，这里我们使用了Jetpack当中的ViewBinding，这样我们就不用写烦人的findViewById()了。</li>\n<li>注释3，viewModel.repos.observe{}，这里我们完成了ViewModel当中LiveData的数据监听，当我们的网络请求有结果以后，它就会立刻被回调。</li>\n</ul><p>另外，以上代码中还涉及到了一些RecyclerView相关的适配器逻辑，也非常简单：</p><pre><code class="language-plain">class RepoAdapter(private val repoList: RepoList): RecyclerView.Adapter&lt;RepoHolder&gt;() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RepoHolder {\n        return RepoHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_repo, parent, false))\n    }\n\n    override fun onBindViewHolder(holder: RepoHolder, position: Int) {\n        holder.text.text = repoList.items.getOrNull(position)?.repo\n    }\n\n    override fun getItemCount(): Int = repoList.count\n}\n\nclass RepoHolder(itemView: View): RecyclerView.ViewHolder(itemView) {\n    val text : TextView = itemView.findViewById(R.id.text)\n}\n</code></pre><p>也就是，为了让RecyclerView正确展示数据，我们需要实现一些方法，以上这些都是一些模板代码。</p><p>最后，在运行代码之前，我们还需要给App增加一个网络权限。</p><pre><code class="language-plain">&lt;uses-permission android:name="android.permission.INTERNET" /&gt;\n</code></pre><p>这个时候，如果你在模拟器或者真机上运行的话，就会看到类似这样的一个效果：</p><p><img src="https://static001.geekbang.org/resource/image/9d/0b/9d1b8168691b7b59a0dbf30cecbbbd0b.gif?wh=271x576" alt=""></p><p>那么，到这里，我们的代码是不是就写完了呢？其实并没有。</p><h2>空安全</h2><p>因为，我们还有一个问题没有解决：<strong>如果服务端返回的JSON字段是null的话，我们的程序仍然会出错。</strong>具体来说，我们可以用这个单元测试来模拟。</p><pre><code class="language-plain">@Test\nfun test() {\n    //                  强行返回null\n    //                      ↓\n    val json = """{"repo": null, "repo_link": "https://github.com/JetBrains/kotlin", "desc": "The Kotlin Programming Language.", "lang": "Kotlin", "stars": "40,907", "forks": "5,067", "added_stars": "98 stars this week", "avatars": ["https://avatars.githubusercontent.com/u/292714?s=40&amp;v=4", "https://avatars.githubusercontent.com/u/1127631?s=40&amp;v=4", "https://avatars.githubusercontent.com/u/908958?s=40&amp;v=4", "https://avatars.githubusercontent.com/u/3007027?s=40&amp;v=4", "https://avatars.githubusercontent.com/u/888318?s=40&amp;v=4"]}"""\n    val repo = RetrofitClient.moshi.adapter(Repo::class.java).fromJson(json)\n    println(repo?.repo)\n}\n\n/*\n报错：\nNon-null value \'repo\' was null at $.repo at com.squareup.moshi.internal.Util\n*/\n</code></pre><p><img src="https://static001.geekbang.org/resource/image/30/36/30b3bbf89b59c957801b1f75454a3236.gif?wh=1200x850" alt="图片"></p><p>其实，当我们利用<a href="https://time.geekbang.org/column/article/484921">空安全思维</a>，将Repo中所有的成员都定义成“非空类型”以后，当API不返回某个字段的时候，程序是可以自动填充默认值的。但是，当API强行在接口当中返回null的时候，我们的程序还是会崩溃。</p><p>为了解决这个问题，我们需要为JSON解析框架Moshi，配置一个额外的规则：</p><pre><code class="language-plain">object NullStringAdapter {\n    @FromJson\n    fun fromJson(reader: JsonReader): String {\n        if (reader.peek() != JsonReader.Token.NULL) {\n            return reader.nextString()\n        }\n        reader.nextNull&lt;Unit&gt;()\n        return ""\n    }\n\n    @ToJson\n    fun toJson(writer: JsonWriter, value: String?) {\n        writer.value(value)\n    }\n}\n</code></pre><p>这个Adapter，其实就是在服务端返回null的时候，我们做一层兼容，将其替换成默认值。它的用法也很简单：</p><pre><code class="language-plain">object RetrofitClient {\n\n    // 省略\n\n    val moshi: Moshi by lazy {\n        Moshi.Builder()\n            .add(NullStringAdapter) // 变化在这里\n            .add(KotlinJsonAdapterFactory())\n            .build()\n    }\n\n}\n</code></pre><p>这样，当我们把这个Adapter配置到Moshi当中以后，单元测试就可以正常通过了。</p><p><img src="https://static001.geekbang.org/resource/image/19/88/197d46d4fe35edf1babbd0a9b15ff388.gif?wh=1198x822" alt="图片"></p><h2>小结</h2><p>好，这节课的内容到这里就差不多结束了。让我们来做一个简单的总结。</p><ul>\n<li>MVVM，是一种常见的架构模式，在Android当中，一般会借助ViewModel、LiveData之类的组件来实现。在实战当中，我们还可以将其跟Clean架构的思想相结合，将整体应用的架构分为四层：实体层、数据层、领域层、表现层。</li>\n<li>实体层，在大部分架构设计当中，实体层会和数据层进行融合，不过在这节课当中，我们将其单独抽了出来，放在了整个架构的最底层，通过密封类、数据类来实现的。</li>\n<li>数据层，这里有两个概念，分别是“数据源”和“数据仓库”。数据源一般会分为缓存数据与远程数据，数据仓库则负责统筹多种数据源。</li>\n<li>领域层，这里会涉及到业务逻辑的最小单元，我们一般将其称为UseCase。</li>\n<li>表现层，这里会涉及到数据与UI交互的逻辑。ViewModel当中会封装UseCase，并且持有数据和View进行交互。</li>\n<li>最后，我们还根据实际情况，对JSON解析库Moshi，做了额外配置，让它可以对服务端返回null的时候，仍然保持兼容，不会出现空指针异常。</li>\n</ul><p>那么，如果你本身对Android、MVVM、Clean架构都不是很熟悉，也许在学习这节课的过程中会有点不太适应。这时候，你可以去GitHub下载本课程对应的Demo，来实际运行和调试，以加深印象，链接在<a href="https://github.com/chaxiu/GitHubTrending.git">这里</a>。</p><h2>思考题</h2><p>这节课，我们融合MVVM和Clean完成了一种混合架构，请问这种架构有什么样的优点和缺点呢？</p>',
        article_title: "35 | 用Kotlin写一个GitHub Trending App",
      },
    ],
  },
  {
    chapterTitle: "结束语",
    children: [
      {
        title: "结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！",
        id: 507617,
        content:
          '<p>你好，我是朱涛。</p><p>咱们课程到这里就算正式更新完了，在讲结束语之前呢，我还给你准备了一份结课测试题，这套试卷共有5道单选题和5道多选题，满分100，核心考点都出自前面讲到的所有重要知识，希望可以帮助你进行一场自测。</p><p>除此之外呢，我也很想知道你对这门课的建议，所以我也给你准备了一份<a href="https://jinshuju.net/f/tp2QfX">问卷</a>。欢迎你在问卷里聊一聊你的想法，也许就有机会获得礼物哦。</p><p>好了，话不多说，请你来做一做这套结课测试题吧！</p><p><a href="http://time.geekbang.org/quiz/intro?act_id=3429&exam_id=8955"><img src="https://static001.geekbang.org/resource/image/28/a4/28d1be62669b4f3cc01c36466bf811a4.png?wh=1142*201" alt=""></a></p><!-- [[[read_end]]] -->',
        article_title: "结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！",
      },
      {
        title: "结束语 | 不忘初心",
        id: 508768,
        content:
          '<p>你好，我是朱涛。</p><p>不知不觉，课程就已经更新到50讲了。当我提笔开始写这篇结束语的时候，心情竟有些失落与不舍。这里我想先感谢你的支持与陪伴，也请你不要把结束语当做课程的终点，以后，我还是会偶尔回来加餐，分享更多Kotlin相关的经验。我希望，这门课可以陪着你，一起见证你的成长。所以，要记得，常回来看看。</p><p>今天，我们就不聊技术了。我想分享3个小故事，都是发生在我自己身上的，真实的故事。</p><p>第一个故事，是我大学时期的“黑历史”。刚进大学的时候，我曾经认为自己比身边的同学要“聪明”。当身边的同学都在努力学习的时候，我懈怠了，我自认为可以凭借自己的“聪明”打败那些平庸的人。但是，经过一系列事件：期末考试成绩一般、ACM竞赛失败，我渐渐认清了一个现实：我只是个普通人，我的天资很平庸。</p><p>说实话，认识到自己的平庸，并且接受这个事实，真的不是个容易的事情。不过，这种思维带来的影响也是巨大的。因为，我再也不会用所谓的“聪明”，来给自己的懒惰找借口了；我再也不会去千方百计地找捷径，幻想着一蹴而就、一飞冲天了。为了学好一门技术，我会脚踏实地去写代码、做项目、写博客。我开始相信：<strong>慢就是快，技术成长没有捷径</strong>。</p><p>这番话可能会让有些同学感到失望，但技术成长确实是没有捷径的，我们能做的，就是踏踏实实地写代码，认认真真地去总结，然后才可能达到我们想要达成的目标。</p><!-- [[[read_end]]] --><p>第二个故事，是关于<strong>机遇和努力</strong>。人们常说，机遇比努力重要。这句话虽然是对的，但却容易让人误入歧途。因为，机遇是可遇不可求的，我们唯一能做的，就只有努力。</p><p>我庆幸自己很早就认识到了自己的平庸，并且，也一直在努力。在2017年，Kotlin、Jetpack等新技术刚出现，大部分开发者还在抱怨、吐槽的时候，我已经在积极探索，并且通过写博客、写教程来帮助他人了。渐渐地，越来越多的技术大会邀请我，Google、Kotlin的员工也找到了我，让我去申请GDE（谷歌开发者专家）。这也让我有了跟世界顶级开发者交流的机会。随着视野的开阔，我也越发清晰地认识到了自己的平庸，也越发努力了。<a href="https://github.com/elizarov">Roman Elizarov</a>、<a href="https://github.com/JakeWharton">Jake Wharton</a>这样的程序员才算是天才，他们尚且如此努力，我又有什么理由不努力呢？</p><p>所以，我一直告诉我自己：<strong>在机遇来临之前，我只能努力。</strong>所以，你也不要觉得，自己一直以来的努力没有用，你只是需要多一点时间，多一点耐心，让量变成为质变。</p><p>第三个故事，是关于<strong>理想和兴趣</strong>。小时候，我的理想就是当一个发明家，像爱迪生那样，发明电灯泡，帮助其他的人。不过，到了高考选专业的时候，我却没有找到“发明家”这个专业。最终，我阴差阳错地选了通信工程专业，在大一学习C语言的时候，我对计算机产生了浓厚的兴趣。最后，我就变成了一个程序员。</p><p>不过，后来我发现，我的兴趣正好可以帮我实现儿时的理想。因为：<strong>程序员也可以当发明家，帮助身边的人</strong>。大学的时候，我会做一些小游戏，自娱自乐。我记得很久之前有次春运的时候，我还写了个小软件，帮村里外出打工的叔叔阿姨抢火车票。</p><p>工作以后也一样。比如，我们课程里的“<a href="https://time.geekbang.org/column/article/477295">词频统计程序</a>”，其实就是来自于我业余时间写的一个英语阅读的软件，它可以辅助我在阅读计算机专业书籍的同时，帮我积累更多词汇。比如，2020年疫情初期，我写了个简单的脚本，来监测京东、天猫的口罩库存，提醒身边的朋友去抢。再比如，前段时间，发生了很多悲剧新闻：儿童被拐卖、妇女被虐待、老人跌倒没人扶。看完这些新闻以后，我就花了几个通宵的时间，做了一个保护弱势群体的App。</p><p>虽然这些小东西都很粗糙，从商业的角度看连雏形都算不上，它们也无法给我带来任何金钱上的收益，但我却乐在其中。所以，我也会告诉我自己<strong>：不忘初心，方得始终</strong>。</p><p>其实，我也常常会想，虽然我们每个人的起点各不相同，但终点都是殊途同归的。我们唯一能做的，就是享受其中的过程，去追求来自内心的那份宁静和快乐。与其活在世俗的教条当中让自己难受，还不如跟随自己的内心，去做一些开心的事情。</p><p>所以，如果你有什么理想、兴趣爱好，那就勇敢地去追求、去尝试吧！<strong>因为，它值得</strong>！</p><p>好了，最后我想说的是，课程结束并非终点，我们还可以在留言区互动交流，也祝你享受成长，学有所成。另外，我还给你准备了一份毕业问卷，希望你能花两三分钟填写一下，非常期待能听到你对这门课的反馈。</p><p><a href="https://jinshuju.net/f/tp2QfX"><img src="https://static001.geekbang.org/resource/image/47/a0/4716250ccbb661d61d72f99f95efc2a0.jpg?wh=1142x801" alt=""></a></p><p>我是朱涛，感谢你一直以来的学习和陪伴，我们再会。</p>',
        article_title: "结束语 | 不忘初心",
      },
    ],
  },
];
